(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
/*!
 * nano-assign v1.0.0
 * (c) 2017-present egoist <0x142857@gmail.com>
 * Released under the MIT License.
 */
'use strict';

var index = function(obj) {
  var arguments$1 = arguments;

  for (var i = 1; i < arguments.length; i++) {
    // eslint-disable-next-line guard-for-in, prefer-rest-params
    for (var p in arguments[i]) { obj[p] = arguments$1[i][p]; }
  }
  return obj
};

module.exports = index;

},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
(function (process,setImmediate){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                var rejection = err || new Error("" + err);

                rejection.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + rejection.message);

                deferred.reject(rejection);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":3,"timers":10}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],8:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":6,"./encode":7}],9:[function(require,module,exports){
(function (process,global){
/*
* Copyright 2015 SpinalCom - www.spinalcom.com
*
* This file is part of SpinalCore.
*
* Please read all of the following terms and conditions of the Free Software
* license Agreement ("Agreement") carefully.
*
* This Agreement is a legally binding contract between the Licensee (as defined
* below) and SpinalCom that sets forth the terms and conditions that govern
* your use of the Program. By installing and/or using the Program, you agree to
* abide by all the terms and conditions stated or referenced herein.
*
* If you do not agree to abide by these terms and conditions, do not
* demonstrate your acceptance and do not install or use the Program.
*
* You should have received a copy of the license along with this file. If not,
* see <http://resources.spinalcom.com/licenses.pdf>.
*/

// Generated by CoffeeScript 1.12.7
var _index_current_popup, add_class, get_left, get_top, new_alert_msg, new_dom_element, rem_class, root, spinal_new_popup, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

url = require('url');

root = typeof _root_obj === "undefined" ? global : window;

root.spinalCore = (function() {
  function spinalCore() {}

  spinalCore._def = {};

  spinalCore.connect = function(options) {
    var auth;
    if (typeof options === 'string') {
      options = url.parse(options);
    }
    if (options.path.slice(-1)[0] !== "/") {
      options.path += "/";
    }
    FileSystem._home_dir = options.path;
    FileSystem._url = options.hostname;
    FileSystem._port = options.port;
    if (options.auth !== null) {
      auth = options.auth.split(":");
      FileSystem._userid = auth[0];
      if (auth.length > 1) {
        FileSystem._password = auth[1];
      }
    } else {
      FileSystem._userid = 644;
      FileSystem._password = "";
    }
    return new FileSystem;
  };

  spinalCore.store = function(fs, model, path, callback_success, callback_error) {
    var file_name, lst;
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model could not be stored. You can pass a callback to handle this error.");
      };
    }
    lst = path.split("/");
    file_name = lst.pop();
    if (lst[0] === "") {
      lst.splice(0, 1);
    }
    path = lst.join("/");
    return fs.load_or_make_dir(FileSystem._home_dir + path, function(dir, err) {
      var file;
      if (err) {
        return callback_error();
      } else {
        file = dir.detect(function(x) {
          return x.name.get() === file_name;
        });
        if (file != null) {
          dir.remove(file);
        }
        dir.add_file(file_name, model, {
          model_type: "Model"
        });
        return callback_success();
      }
    });
  };

  spinalCore.register_models = function(modelList) {
    var key, len, m, q, results, results1, value;
    if (modelList && modelList instanceof Function) {
      modelList = [modelList];
    }
    if (modelList instanceof Array) {
      results = [];
      for (q = 0, len = modelList.length; q < len; q++) {
        m = modelList[q];
        results.push(spinalCore._def[m.name] = m);
      }
      return results;
    } else {
      results1 = [];
      for (key in modelList) {
        value = modelList[key];
        results1.push(spinalCore._def[key] = value);
      }
      return results1;
    }
  };

  spinalCore.load = function(fs, path, callback_success, callback_error) {
    var file_name, lst;
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model could not be loaded. You can pass a callback to handle this error.");
      };
    }
    lst = path.split("/");
    file_name = lst.pop();
    if (lst[0] === "") {
      lst.splice(0, 1);
    }
    path = lst.join("/");
    return fs.load_or_make_dir(FileSystem._home_dir + path, function(current_dir, err) {
      var file;
      if (err) {
        return callback_error();
      } else {
        file = current_dir.detect(function(x) {
          return x.name.get() === file_name;
        });
        if (file != null) {
          return file.load(function(data, err) {
            if (err) {
              return callback_error();
            } else {
              return callback_success(data, err);
            }
          });
        } else {
          return callback_error();
        }
      }
    });
  };

  spinalCore.load_type = function(fs, type, callback_success, callback_error) {
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model of this type could not be loaded. " + "You can pass a callback to handle this error.");
      };
    }
    return fs.load_type(type, function(data, err) {
      if (err) {
        return callback_error();
      } else {
        return callback_success(data, err);
      }
    });
  };

  spinalCore.load_right = function(fs, ptr, callback_success, callback_error) {
    if (typeof callback_error === "undefined") {
      callback_error = function() {
        return console.log("Model Right could not be loaded." + " You can pass a callback to handle this error.");
      };
    }
    return fs.load_right(ptr, function(data, err) {
      if (err) {
        return callback_error();
      } else {
        return callback_success(data, err);
      }
    });
  };

  spinalCore.share_model = function(fs, ptr, file_name, right_flag, targetName) {
    return fs.share_model(ptr, file_name, right_flag, targetName);
  };

  spinalCore.right_flag = {
    AD: 1,
    WR: 2,
    RD: 4
  };

  spinalCore.extend = function(child, parent) {
    var child_name, ctor, key, value;
    for (key in parent) {
      value = parent[key];
      child[key] = value;
    }
    ctor = function() {
      this.constructor = child;
    };
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    child.super = function () {
            var args = [];
           	for (var i=1; i < arguments.length; i++)
                args[i-1] = arguments[i];
            child.__super__.constructor.apply(arguments[0], args);
        };
    root = typeof global !== "undefined" && global !== null ? global : window;
    child_name = /^function\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
    return root[child_name] = child;
  };

  return spinalCore;

})();

module.exports = spinalCore;

root = typeof _root_obj === "undefined" ? global : window;

root.ModelProcessManager = (function() {
  function ModelProcessManager() {}

  ModelProcessManager._counter = 0;

  ModelProcessManager._modlist = {};

  ModelProcessManager._n_processes = {};

  ModelProcessManager._cur_mid = 0;

  ModelProcessManager._cur_process_id = 0;

  ModelProcessManager._timeout = void 0;

  ModelProcessManager._force_m = false;

  ModelProcessManager._synchro = void 0;

  ModelProcessManager.new_from_state = function(str) {
    var l, len, lst, map, mid, q, s;
    map = {};
    lst = str.split("\n");
    mid = lst.shift();
    for (q = 0, len = lst.length; q < len; q++) {
      l = lst[q];
      if (!l.length) {
        continue;
      }
      s = l.split(" ");
      map[s[0]] = {
        type: s[1],
        data: s[2],
        buff: void 0
      };
    }
    eval("var __new__ = new " + map[mid].type + ";");
    __new__._set_state(map[mid].data, map);
    return __new__;
  };

  ModelProcessManager.load = function(filename, func) {
    if (!ModelProcessManager.synchronizer) {
      ModelProcessManager._synchro = new Synchronizer;
    }
    return ModelProcessManager._synchro.load(filename, func);
  };

  ModelProcessManager.conv = function(v) {
    if (v instanceof Model) {
      return v;
    }
    if (v instanceof Array) {
      return new Lst(v);
    }
    if (typeof v === "string") {
      return new Str(v);
    }
    if (typeof v === "number") {
      return new Val(v);
    }
    if (typeof v === "boolean") {
      return new Bool(v);
    }
    if (v instanceof Object) {
      return new Model(v);
    }
    return new Obj(v);
  };

  ModelProcessManager.get_object_class = function(obj) {
    var arr;
    if (obj && obj.constructor && obj.constructor.name) {
      return obj.constructor.name;
    }
    if (obj && obj.constructor && obj.constructor.toString) {
      arr = obj.constructor.toString().match(/function\s*(\w+)/);
      if (!arr) {
        arr = obj.constructor.toString().match(/class\s*(\w+)/);
      }
      if (arr && arr.length === 2) {
        return arr[1];
      }
    }
  };

  ModelProcessManager._get_attribute_names = function(m) {
    var key, results, val;
    if (m instanceof Model) {
      return m._attribute_names;
    } else {
      results = [];
      for (key in m) {
        val = m[key];
        results.push(key);
      }
      return results;
    }
  };

  ModelProcessManager._new_model_from_state = function(mid, map) {
    var info;
    info = map[mid];
    eval("info.buff = new " + info.type + ";");
    info.buff._set_state(info.data, map);
    return info.buff;
  };

  ModelProcessManager._need_sync_processes = function() {
    if (ModelProcessManager._timeout == null) {
      return ModelProcessManager._timeout = setTimeout(ModelProcessManager._sync_processes, 1);
    }
  };

  ModelProcessManager._sync_processes = function() {
    var id, len, model, process, processes, q, ref, ref1, ref2;
    processes = {};
    ref = ModelProcessManager._modlist;
    for (id in ref) {
      model = ref[id];
      ref1 = model._processes;
      for (q = 0, len = ref1.length; q < len; q++) {
        process = ref1[q];
        processes[process.process_id] = {
          value: process,
          force: false
        };
      }
    }
    ref2 = ModelProcessManager._n_processes;
    for (id in ref2) {
      process = ref2[id];
      processes[id] = {
        value: process,
        force: true
      };
    }
    ModelProcessManager._timeout = void 0;
    ModelProcessManager._modlist = {};
    ModelProcessManager._n_processes = {};
    ModelProcessManager._counter += 2;
    for (id in processes) {
      process = processes[id];
      ModelProcessManager._force_m = process.force;
      process.value.onchange();
    }
    return ModelProcessManager._force_m = false;
  };

  return ModelProcessManager;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.SpinalUserManager = (function() {
  function SpinalUserManager() {}

  SpinalUserManager.get_user_id = function(options, user_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_user_id?u=' + user_name + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_user_id', response);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_user_id', status);
    });
  };

  SpinalUserManager.get_admin_id = function(options, admin_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_admin_id?u=' + admin_name + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_admin_id', response);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_admin_id', status);
    });
  };

  SpinalUserManager.new_account = function(options, user_name, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_new_account?e=' + user_name + '&p=' + password + '&cp=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_new_account', status);
    });
  };

  SpinalUserManager.change_password = function(options, user_id, password, new_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_user_password?e=' + user_id + '&op=' + password + '&np=' + new_password + '&cp=' + new_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_user_password', status);
    });
  };

  SpinalUserManager.delete_account = function(options, user_id, password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_delete_account?e=' + user_name + '&i=' + user_id + '&p=' + password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_delete_account', status);
    });
  };

  SpinalUserManager.change_password_by_admin = function(options, username, password, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_user_password_by_admin?u=' + username + '&np=' + password + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_user_password_by_admin', status);
    });
  };

  SpinalUserManager.delete_account_by_admin = function(options, username, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_delete_account_by_admin?u=' + username + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_delete_account_by_admin', status);
    });
  };

  SpinalUserManager.change_account_rights_by_admin = function(options, username, right, admin_id, admin_password, success_callback, error_callback) {
    var get_cmd;
    if (error_callback == null) {
      error_callback = null;
    }
    get_cmd = '/get_change_account_rights_by_admin?u=' + username + '&ri=' + right + '&a=' + admin_id + '&ap=' + admin_password;
    return this.send_xhr(options, get_cmd, function(response) {
      if (parseInt(response) === -1) {
        return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
      } else {
        return success_callback(response);
      }
    }, function(status) {
      return SpinalUserManager._if_error(error_callback, 'get_change_account_rights_by_admin', status);
    });
  };

  SpinalUserManager.send_xhr = function(options, get_cmd, success_callback, error_callback) {
    var path, xhr_object;
    path = "";
    if (typeof options === 'string') {
      options = url.parse(options);
    }
    FileSystem._url = options.hostname;
    FileSystem._port = options.port;
    if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
      if (FileSystem._port) {
        path = "http://" + FileSystem._url + ":" + FileSystem._port + get_cmd;
      } else {
        path = "http://" + FileSystem._url + get_cmd;
      }
    } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
      path = get_cmd;
    }
    xhr_object = FileSystem._my_xml_http_request();
    xhr_object.open('GET', path, true);
    xhr_object.onreadystatechange = function() {
      if (this.readyState === 4 && this.status === 200) {
        return success_callback(this.responseText);
      } else if (this.readyState === 4) {
        return error_callback(this.status);
      }
    };
    return xhr_object.send();
  };

  SpinalUserManager._if_error = function(error_callback, fun, response) {
    if (error_callback !== null) {
      return error_callback(response);
    } else {
      return console.log('Error on ' + fun + ' and the error_callback was not set.');
    }
  };

  return SpinalUserManager;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Model = (function() {
  function Model(attr) {
    this._attribute_names = [];
    this.model_id = ModelProcessManager._cur_mid;
    ModelProcessManager._cur_mid += 1;
    this._processes = [];
    this._parents = [];
    this._date_last_modification = ModelProcessManager._counter + 2;
    if (attr != null) {
      this._set(attr);
    }
  }

  Model.prototype.destructor = function() {};

  Model.prototype.has_been_modified = function() {
    return this._date_last_modification > ModelProcessManager._counter - 2 || ModelProcessManager._force_m;
  };

  Model.prototype.has_been_directly_modified = function() {
    return this._date_last_modification > ModelProcessManager._counter - 1 || ModelProcessManager._force_m;
  };

  Model.prototype.bind = function(f, onchange_construction) {
    if (onchange_construction == null) {
      onchange_construction = true;
    }
    if (f instanceof Process) {
      this._processes.push(f);
      f._models.push(this);
      if (onchange_construction) {
        ModelProcessManager._n_processes[f.process_id] = f;
        return ModelProcessManager._need_sync_processes();
      }
    } else {
      return new BindProcess(this, onchange_construction, f);
    }
  };

  Model.prototype.unbind = function(f) {
    var len, q, ref, results, v;
    if (f instanceof Process) {
      this._processes.splice(this._processes.indexOf(f), 1);
      return f._models.splice(f._models.indexOf(this), 1);
    } else {
      ref = this._processes;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        v = ref[q];
        if (v instanceof BindProcess && v.f === f) {
          results.push(this.unbind(v));
        }
      }
      return results;
    }
  };

  Model.prototype.get = function() {
    var len, name, q, ref, res;
    res = {};
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      name = ref[q];
      res[name] = this[name].get();
    }
    return res;
  };

  Model.prototype.set = function(value) {
    if (this._set(value)) {
      this._signal_change();
      return true;
    }
    return false;
  };

  Model.prototype.set_state = function(str) {
    var l, len, lst, map, mid, q, s;
    map = {};
    lst = str.split("\n");
    mid = lst.shift();
    for (q = 0, len = lst.length; q < len; q++) {
      l = lst[q];
      if (!l.length) {
        continue;
      }
      s = l.split(" ");
      map[s[0]] = {
        type: s[1],
        data: s[2],
        buff: void 0
      };
    }
    map[mid].buff = this;
    return this._set_state(map[mid].data, map);
  };

  Model.prototype.get_state = function(date) {
    var fmm, id, obj, res;
    if (date == null) {
      date = -1;
    }
    fmm = {};
    this._get_flat_model_map(fmm, date);
    res = this.model_id.toString();
    if (this._date_last_modification > date) {
      for (id in fmm) {
        obj = fmm[id];
        res += "\n" + obj.model_id + " " + ModelProcessManager.get_object_class(obj) + " " + obj._get_state();
      }
    }
    return res;
  };

  Model.prototype.add_attr = function(n, p, signal_change) {
    var key, results, val;
    if (signal_change == null) {
      signal_change = true;
    }
    if (p != null) {
      if (typeof p === "function") {
        return this[n] = p;
      } else {
        if (this[n] != null) {
          console.error(("attribute " + n + " already exists in ") + ("" + (ModelProcessManager.get_object_class(this))));
        }
        p = ModelProcessManager.conv(p);
        if (indexOf.call(p._parents, this) < 0) {
          p._parents.push(this);
        }
        this._attribute_names.push(n);
        this[n] = p;
        if (signal_change) {
          return this._signal_change();
        }
      }
    } else {
      results = [];
      for (key in n) {
        val = n[key];
        if (val != null) {
          results.push(this.add_attr(key, val, signal_change));
        }
      }
      return results;
    }
  };

  Model.prototype.rem_attr = function(name, signal_change) {
    var c, i;
    if (signal_change == null) {
      signal_change = true;
    }
    c = this[name];
    if (c) {
      i = c._parents.indexOf(this);
      if (i >= 0) {
        c._parents.splice(i, 1);
        if (c._parents.length === 0) {
          c.destructor();
        }
      }
      delete this[name];
      i = this._attribute_names.indexOf(name);
      if (i >= 0) {
        this._attribute_names.splice(i, 1);
      }
      if (signal_change) {
        return this._signal_change();
      }
    }
  };

  Model.prototype.mod_attr = function(n, p) {
    if (this[n] !== p) {
      this.rem_attr(n);
      return this.add_attr(n, p);
    }
  };

  Model.prototype.set_attr = function(o) {
    var k, len, q, r, results, to_rem, v;
    for (k in o) {
      v = o[k];
      this.mod_attr(k, v);
    }
    to_rem = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        k = ref[q];
        if (o[k] == null) {
          results.push(k);
        }
      }
      return results;
    }).call(this);
    results = [];
    for (q = 0, len = to_rem.length; q < len; q++) {
      r = to_rem[q];
      results.push(this.rem_attr(r));
    }
    return results;
  };

  Model.prototype.size = function(for_display) {
    if (for_display == null) {
      for_display = false;
    }
    return [];
  };

  Model.prototype.dim = function(for_display) {
    if (for_display == null) {
      for_display = false;
    }
    return this.size(for_display).length;
  };

  Model.prototype.equals = function(m) {
    var key, len, len1, q, ref, ref1, u, val, y;
    if (this === m) {
      return true;
    }
    if (m._attribute_names != null) {
      u = {};
      ref = m._attribute_names;
      for (q = 0, len = ref.length; q < len; q++) {
        key = ref[q];
        val = m[key];
        if (this[key] == null) {
          return false;
        }
        if (!this[key].equals(val)) {
          return false;
        }
        u[key] = true;
      }
      ref1 = this._attribute_names;
      for (y = 0, len1 = ref1.length; y < len1; y++) {
        key = ref1[y];
        if (u[key] == null) {
          return false;
        }
      }
    }
    return false;
  };

  Model.prototype.get_parents_that_check = function(func_to_check) {
    var res, visited;
    res = [];
    visited = {};
    this._get_parents_that_check_rec(res, visited, func_to_check);
    return res;
  };

  Model.prototype.deep_copy = function() {
    var key, len, o, q, ref;
    o = {};
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      key = ref[q];
      o[key] = this[key].deep_copy();
    }
    eval("var __new__ = new " + (ModelProcessManager.get_object_class(this)) + ";");
    __new__.set_attr(o);
    return __new__;
  };

  Model.prototype.real_change = function() {
    var a, len, q, ref;
    if (this.has_been_directly_modified() && !this._attribute_names.length) {
      return true;
    }
    ref = this._attribute_names;
    for (q = 0, len = ref.length; q < len; q++) {
      a = ref[q];
      if (typeof this.cosmetic_attribute === "function" ? this.cosmetic_attribute(a) : void 0) {
        continue;
      }
      if (this[a].real_change()) {
        return true;
      }
    }
    return false;
  };

  Model.prototype.cosmetic_attribute = function(name) {
    return false;
  };

  Model.prototype._get_state = function() {
    var name, str;
    str = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        name = ref[q];
        results.push(name + ":" + this[name].model_id);
      }
      return results;
    }).call(this);
    return str.join(",");
  };

  Model.prototype._get_fs_data = function(out) {
    var name, obj, str;
    FileSystem.set_server_id_if_necessary(out, this);
    str = (function() {
      var len, q, ref, results;
      ref = this._attribute_names;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        name = ref[q];
        obj = this[name];
        FileSystem.set_server_id_if_necessary(out, obj);
        results.push(name + ":" + obj._server_id);
      }
      return results;
    }).call(this);
    return out.mod += "C " + this._server_id + " " + (str.join(",")) + " ";
  };

  Model.prototype._set = function(value) {
    var change, key, len, len1, q, ref, ref1, used, val, y;
    change = false;
    used = {};
    ref = ModelProcessManager._get_attribute_names(value);
    for (q = 0, len = ref.length; q < len; q++) {
      key = ref[q];
      used[key] = true;
    }
    ref1 = (function() {
      var len1, ref1, results, z;
      ref1 = this._attribute_names;
      results = [];
      for (z = 0, len1 = ref1.length; z < len1; z++) {
        key = ref1[z];
        if (!used[key]) {
          results.push(key);
        }
      }
      return results;
    }).call(this);
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      key = ref1[y];
      change = true;
      this.rem_attr(key, false);
    }
    for (key in value) {
      val = value[key];
      if (val != null) {
        if (this[key] != null) {
          if (this[key].constructor === val.constructor) {
            change |= this[key].set(val);
          } else {
            change = true;
            this.mod_attr(key, val, false);
          }
        } else {
          this.add_attr(key, val, false);
        }
      }
    }
    return change;
  };

  Model.prototype._signal_change = function(change_level) {
    var len, p, q, ref;
    if (change_level == null) {
      change_level = 2;
    }
    if (change_level === 2 && (this._server_id != null)) {
      FileSystem.signal_change(this);
    }
    ModelProcessManager._modlist[this.model_id] = this;
    if (this._date_last_modification <= ModelProcessManager._counter) {
      this._date_last_modification = ModelProcessManager._counter + change_level;
      ref = this._parents;
      for (q = 0, len = ref.length; q < len; q++) {
        p = ref[q];
        p._signal_change(1);
      }
    }
    return ModelProcessManager._need_sync_processes();
  };

  Model.prototype._set_state = function(str, map) {
    var attr, inr, k_id, len, len1, q, ref, ref1, results, spl, u, y;
    u = {};
    if (str.length) {
      ref = str.split(",");
      for (q = 0, len = ref.length; q < len; q++) {
        spl = ref[q];
        inr = spl.split(":");
        attr = inr[0];
        k_id = inr[1];
        u[attr] = true;
        if (map[k_id].buff != null) {
          if (this[attr] == null) {
            this.add_attr(attr, map[k_id].buff);
          } else if (map[k_id].buff !== this[attr]) {
            this.mod_attr(attr, map[k_id].buff);
          }
        } else if (this[attr] == null) {
          this.add_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
        } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
          this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
        }
      }
    }
    ref1 = this._attribute_names;
    results = [];
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      attr = ref1[y];
      if (!u[attr]) {
        results.push(this.rem_attr(attr));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Model.prototype._get_parents_that_check_rec = function(res, visited, func_to_check) {
    var len, p, q, ref, results;
    if (visited[this.model_id] == null) {
      visited[this.model_id] = true;
      if (func_to_check(this)) {
        return res.push(this);
      } else {
        ref = this._parents;
        results = [];
        for (q = 0, len = ref.length; q < len; q++) {
          p = ref[q];
          results.push(p._get_parents_that_check_rec(res, visited, func_to_check));
        }
        return results;
      }
    }
  };

  Model.prototype._set_state_if_same_type = function(mid, map) {
    var dat;
    dat = map[mid];
    if (ModelProcessManager.get_object_class(this) === dat.type) {
      dat.buff = this;
      this._set_state(dat.data, map);
      return true;
    }
    return false;
  };

  Model.prototype._get_flat_model_map = function(map, date) {
    var len, name, obj, q, ref, results;
    map[this.model_id] = this;
    ref = this._attribute_names;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      name = ref[q];
      obj = this[name];
      if (map[obj.model_id] == null) {
        if (obj._date_last_modification > date) {
          results.push(obj._get_flat_model_map(map, date));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return Model;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Obj = (function(superClass) {
  extend(Obj, superClass);

  function Obj(data) {
    Obj.__super__.constructor.call(this);
    if (data != null) {
      this._set(data);
    }
  }

  Obj.prototype.toString = function() {
    var ref;
    return (ref = this._data) != null ? ref.toString() : void 0;
  };

  Obj.prototype.equals = function(obj) {
    if (obj instanceof Obj) {
      return this._data === obj._data;
    }
    return this._data === obj;
  };

  Obj.prototype.get = function() {
    return this._data;
  };

  Obj.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (this.toString()) + " ";
  };

  Obj.prototype._set = function(value) {
    if (this._data !== value) {
      this._data = value;
      return true;
    }
    return false;
  };

  Obj.prototype._get_state = function() {
    return this._data;
  };

  Obj.prototype._set_state = function(str, map) {
    return this.set(str);
  };

  return Obj;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Choice = (function(superClass) {
  extend(Choice, superClass);

  function Choice(data, initial_list) {
    if (initial_list == null) {
      initial_list = [];
    }
    Choice.__super__.constructor.call(this);
    this.add_attr({
      num: 0,
      lst: initial_list
    });
    if (data != null) {
      this.num.set(data);
    }
  }

  Choice.prototype.filter = function(obj) {
    return true;
  };

  Choice.prototype.item = function() {
    return this._nlst()[this.num.get()];
  };

  Choice.prototype.get = function() {
    var ref;
    return (ref = this.item()) != null ? ref.get() : void 0;
  };

  Choice.prototype.toString = function() {
    var ref;
    return (ref = this.item()) != null ? ref.toString() : void 0;
  };

  Choice.prototype.equals = function(a) {
    if (a instanceof Choice) {
      return Choice.__super__.equals.call(this, a);
    } else {
      return this._nlst()[this.num.get()].equals(a);
    }
  };

  Choice.prototype._set = function(value) {
    var i, j, len, q, ref;
    ref = this._nlst();
    for (j = q = 0, len = ref.length; q < len; j = ++q) {
      i = ref[j];
      if (i.equals(value)) {
        return this.num.set(j);
      }
    }
    return this.num.set(value);
  };

  Choice.prototype._nlst = function() {
    var l, len, q, ref, results;
    ref = this.lst;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      l = ref[q];
      if (this.filter(l)) {
        results.push(l);
      }
    }
    return results;
  };

  return Choice;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Bool = (function(superClass) {
  extend(Bool, superClass);

  function Bool(data) {
    Bool.__super__.constructor.call(this);
    this._data = false;
    if (data != null) {
      this._set(data);
    }
  }

  Bool.prototype.toggle = function() {
    return this.set(!this._data);
  };

  Bool.prototype.toBoolean = function() {
    return this._data;
  };

  Bool.prototype.deep_copy = function() {
    return new Bool(this._data);
  };

  Bool.prototype._set = function(value) {
    var n;
    if (n instanceof Model) {
      n = value.toBoolean();
    } else if (value === "false") {
      n = false;
    } else if (value === "true") {
      n = true;
    } else {
      n = Boolean(value);
    }
    if (this._data !== n) {
      this._data = n;
      return true;
    }
    return false;
  };

  Bool.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (1 * Boolean(this._data)) + " ";
  };

  return Bool;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.ConstOrNotModel = (function(superClass) {
  extend(ConstOrNotModel, superClass);

  function ConstOrNotModel(bool, model, check_disabled) {
    if (check_disabled == null) {
      check_disabled = true;
    }
    ConstOrNotModel.__super__.constructor.call(this);
    this.add_attr({
      bool: bool,
      model: model,
      check_disabled: check_disabled
    });
  }

  ConstOrNotModel.prototype.get = function() {
    var ref;
    return (ref = this.model) != null ? ref.get() : void 0;
  };

  ConstOrNotModel.prototype.set = function(value) {
    var ref;
    return (ref = this.model) != null ? ref.set(value) : void 0;
  };

  ConstOrNotModel.prototype.toString = function() {
    var ref;
    return (ref = this.model) != null ? ref.toString() : void 0;
  };

  return ConstOrNotModel;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.ConstrainedVal = (function(superClass) {
  extend(ConstrainedVal, superClass);

  function ConstrainedVal(value, params) {
    if (params == null) {
      params = {};
    }
    ConstrainedVal.__super__.constructor.call(this);
    this.add_attr({
      val: value || 0,
      _min: params.min != null ? params.min : 0,
      _max: params.max != null ? params.max : 100
    });
    this.add_attr({
      _div: params.div != null ? params.div : this._max - this._min
    });
  }

  ConstrainedVal.prototype.get = function() {
    return this.val.get();
  };

  ConstrainedVal.prototype.ratio = function() {
    return (this.val.get() - this._min.get()) / this.delta();
  };

  ConstrainedVal.prototype.delta = function() {
    return this._max.get() - this._min.get();
  };

  ConstrainedVal.prototype.set_params = function(params) {
    this._min.set(params.min != null ? params.min : 0);
    this._max.set(params.max != null ? params.max : 100);
    return this._div.set(params.div != null ? params.div : this._max - this._min);
  };

  ConstrainedVal.prototype._set = function(value) {
    var res;
    if (value instanceof ConstrainedVal) {
      return this.val._set(value.get());
    }
    res = this.val.set(value);
    this._check_val();
    return res;
  };

  ConstrainedVal.prototype._check_val = function() {
    var d, m, n, r, s, v;
    v = this.val.get();
    m = this._min.get();
    n = this._max.get();
    d = this._div.get();
    if (v < m) {
      this.val.set(m);
    }
    if (v > n) {
      this.val.set(n);
    }
    if (d) {
      s = (n - m) / d;
      r = m + Math.round((this.val.get() - m) / s) * s;
      return this.val.set(r);
    }
  };

  return ConstrainedVal;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Lst = (function(superClass) {
  extend(Lst, superClass);

  function Lst(data) {
    var d, i, q, ref, s;
    Lst.__super__.constructor.call(this);
    this.length = 0;
    s = this.static_length();
    if (s >= 0) {
      d = this.default_value();
      for (i = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
        this.push(d, true);
      }
    }
    if (data != null) {
      this._set(data);
    }
  }

  Lst.prototype.static_length = function() {
    return -1;
  };

  Lst.prototype.default_value = function() {
    return 0;
  };

  Lst.prototype.base_type = function() {
    return void 0;
  };

  Lst.prototype.get = function() {
    var i, len, q, ref, results;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      results.push(i.get());
    }
    return results;
  };

  Lst.prototype.size = function() {
    return [length];
  };

  Lst.prototype.toString = function() {
    var l, x;
    if (this.length) {
      l = (function() {
        var len, q, ref, results;
        ref = this;
        results = [];
        for (q = 0, len = ref.length; q < len; q++) {
          x = ref[q];
          results.push(x.toString());
        }
        return results;
      }).call(this);
      return l.join();
    } else {
      return "";
    }
  };

  Lst.prototype.equals = function(lst) {
    var i, q, ref;
    if (this.length !== lst.length) {
      return false;
    }
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (!this[i].equals(lst[i])) {
        return false;
      }
    }
    return true;
  };

  Lst.prototype.push = function(value, force) {
    var b;
    if (force == null) {
      force = false;
    }
    if (this._static_size_check(force)) {
      return;
    }
    b = this.base_type();
    if (b != null) {
      if (!(value instanceof b)) {
        value = new b(value);
      }
    } else {
      value = ModelProcessManager.conv(value);
    }
    if (indexOf.call(value._parents, this) < 0) {
      value._parents.push(this);
    }
    this[this.length] = value;
    this.length += 1;
    return this._signal_change();
  };

  Lst.prototype.pop = function() {
    var old;
    if (this._static_size_check(false)) {
      return;
    }
    if (this.length <= 0) {
      return;
    }
    this.length -= 1;
    old = this[this.length];
    this.rem_attr(this.length);
    return old;
  };

  Lst.prototype.clear = function() {
    var results;
    results = [];
    while (this.length) {
      results.push(this.pop());
    }
    return results;
  };

  Lst.prototype.unshift = function(element) {
    var b, i, q, ref;
    if (this._static_size_check(false)) {
      return;
    }
    b = this.base_type();
    if (b != null) {
      if (!(element instanceof b)) {
        element = new b(element);
      }
    } else {
      element = ModelProcessManager.conv(element);
    }
    if (indexOf.call(element._parents, this) < 0) {
      element._parents.push(this);
    }
    if (this.length) {
      for (i = q = ref = this.length - 1; ref <= 0 ? q <= 0 : q >= 0; i = ref <= 0 ? ++q : --q) {
        this[i + 1] = this[i];
      }
    }
    this[0] = element;
    this.length += 1;
    this._signal_change();
    return this.length;
  };

  Lst.prototype.shift = function() {
    var r;
    r = this[0];
    this.splice(0, 1);
    return r;
  };

  Lst.prototype.remove = function(item) {
    var i;
    i = this.indexOf(item);
    if (i >= 0) {
      return this.splice(i, 1);
    }
  };

  Lst.prototype.remove_ref = function(item) {
    var i;
    i = this.indexOf_ref(item);
    if (i >= 0) {
      return this.splice(i, 1);
    }
  };

  Lst.prototype.filter = function(f) {
    var i, len, q, ref, results;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        results.push(i);
      }
    }
    return results;
  };

  Lst.prototype.detect = function(f) {
    var i, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        return i;
      }
    }
    return void 0;
  };

  Lst.prototype.sorted = function(fun_sort) {
    var it, len, new_array, q, ref;
    new_array = new Array;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      it = ref[q];
      new_array.push(it);
    }
    new_array.sort(fun_sort);
    return new_array;
  };

  Lst.prototype.has = function(f) {
    var i, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      if (f(i)) {
        return true;
      }
    }
    return false;
  };

  Lst.prototype.indexOf = function(v) {
    var i, q, ref;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (this[i].equals(v)) {
        return i;
      }
    }
    return -1;
  };

  Lst.prototype.indexOf_ref = function(v) {
    var i, q, ref;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      if (this[i] === v) {
        return i;
      }
    }
    return -1;
  };

  Lst.prototype.contains = function(v) {
    return this.indexOf(v) >= 0;
  };

  Lst.prototype.contains_ref = function(v) {
    return this.indexOf_ref(v) >= 0;
  };

  Lst.prototype.toggle = function(v) {
    var i;
    i = this.indexOf(v);
    if (i >= 0) {
      this.splice(i);
      return false;
    } else {
      this.push(v);
      return true;
    }
  };

  Lst.prototype.toggle_ref = function(v) {
    var i;
    i = this.indexOf_ref(v);
    if (i >= 0) {
      this.splice(i);
      return false;
    } else {
      this.push(v);
      return true;
    }
  };

  Lst.prototype.slice = function(begin, end) {
    var i, q, ref, ref1, tab;
    if (end == null) {
      end = this.length;
    }
    if (begin < 0) {
      begin = 0;
    }
    if (end > this.length) {
      end = this.length;
    }
    tab = new Lst;
    for (i = q = ref = begin, ref1 = end; ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
      tab.push(this[i].get());
    }
    return tab;
  };

  Lst.prototype.concat = function(new_tab, force) {
    var el, len, q;
    if (force == null) {
      force = false;
    }
    if (this._static_size_check(force)) {
      return;
    }
    if (new_tab.length) {
      for (q = 0, len = new_tab.length; q < len; q++) {
        el = new_tab[q];
        this.push(el);
      }
      return this;
    }
  };

  Lst.prototype.splice = function(index, n) {
    var i, q, ref, ref1, ref2, ref3, ref4, ref5, y, z;
    if (n == null) {
      n = 1;
    }
    if (this._static_size_check(false)) {
      return;
    }
    for (i = q = ref = index, ref1 = Math.min(index + n, this.length); ref <= ref1 ? q < ref1 : q > ref1; i = ref <= ref1 ? ++q : --q) {
      this.rem_attr(i);
    }
    for (i = y = ref2 = index, ref3 = this.length - n; ref2 <= ref3 ? y < ref3 : y > ref3; i = ref2 <= ref3 ? ++y : --y) {
      this[i] = this[i + n];
    }
    for (i = z = ref4 = this.length - n, ref5 = this.length; ref4 <= ref5 ? z < ref5 : z > ref5; i = ref4 <= ref5 ? ++z : --z) {
      delete this[i];
    }
    this.length -= n;
    return this._signal_change();
  };

  Lst.prototype.insert = function(index, list) {
    var i, l, len, len1, o, q, results, y;
    if (list.length) {
      l = Math.max(this.length - index, 0);
      o = (function() {
        var q, ref, results;
        results = [];
        for (i = q = 0, ref = l; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          results.push(this.pop());
        }
        return results;
      }).call(this);
      o.reverse();
      for (q = 0, len = list.length; q < len; q++) {
        l = list[q];
        this.push(l);
      }
      results = [];
      for (y = 0, len1 = o.length; y < len1; y++) {
        l = o[y];
        results.push(this.push(l));
      }
      return results;
    }
  };

  Lst.prototype.set_or_push = function(index, val) {
    if (index < this.length) {
      return this.mod_attr(index, val);
    } else if (index === this.length) {
      return this.push(val);
    }
  };

  Lst.prototype.trim = function(size) {
    var results;
    results = [];
    while (this.length > size) {
      results.push(this.pop());
    }
    return results;
  };

  Lst.prototype.join = function(sep) {
    return this.get().join(sep);
  };

  Lst.prototype.deep_copy = function() {
    var i, q, ref, res;
    res = new Lst;
    for (i = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
      res.push(this[i].deep_copy());
    }
    return res;
  };

  Lst.prototype.back = function() {
    return this[this.length - 1];
  };

  Lst.prototype.real_change = function() {
    var a, len, q, ref;
    if (this.has_been_directly_modified()) {
      return true;
    }
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      a = ref[q];
      if (a.real_change()) {
        return true;
      }
    }
    return false;
  };

  Lst.prototype._set = function(value) {
    var change, p, q, ref, s;
    change = this.length !== value.length;
    s = this.static_length();
    if (s >= 0 && change) {
      console.error("resizing a static array (type " + ((ModelProcessManager.get_object_class(this)) + ") is forbidden"));
    }
    for (p = q = 0, ref = value.length; 0 <= ref ? q < ref : q > ref; p = 0 <= ref ? ++q : --q) {
      if (p < this.length) {
        change |= this[p].set(value[p]);
      } else if (s < 0) {
        this.push(value[p]);
      }
    }
    if (s < 0) {
      while (this.length > value.length) {
        this.pop();
      }
      this.length = value.length;
    }
    return change;
  };

  Lst.prototype._get_flat_model_map = function(map, date) {
    var len, obj, q, ref, results;
    map[this.model_id] = this;
    ref = this;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      obj = ref[q];
      if (map[obj.model_id] == null) {
        if (obj._date_last_modification > date) {
          results.push(obj._get_flat_model_map(map, date));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Lst.prototype._get_fs_data = function(out) {
    var obj, str;
    FileSystem.set_server_id_if_necessary(out, this);
    str = (function() {
      var len, q, ref, results;
      ref = this;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        obj = ref[q];
        FileSystem.set_server_id_if_necessary(out, obj);
        results.push(obj._server_id);
      }
      return results;
    }).call(this);
    return out.mod += "C " + this._server_id + " " + (str.join(",")) + " ";
  };

  Lst.prototype._get_state = function() {
    var obj, str;
    str = (function() {
      var len, q, ref, results;
      ref = this;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        obj = ref[q];
        results.push(obj.model_id);
      }
      return results;
    }).call(this);
    return str.join(",");
  };

  Lst.prototype._set_state = function(str, map) {
    var attr, k_id, l_id, q, ref, ref1, ref2, results, y;
    l_id = str.split(",").filter(function(x) {
      return x.length;
    });
    while (this.length > l_id.length) {
      this.pop();
    }
    for (attr = q = 0, ref = this.length; 0 <= ref ? q < ref : q > ref; attr = 0 <= ref ? ++q : --q) {
      k_id = l_id[attr];
      if (map[k_id].buff != null) {
        if (map[k_id].buff !== this[attr]) {
          this.mod_attr(attr, map[k_id].buff);
        }
      } else if (!this[attr]._set_state_if_same_type(k_id, map)) {
        this.mod_attr(attr, ModelProcessManager._new_model_from_state(k_id, map));
      }
    }
    results = [];
    for (attr = y = ref1 = this.length, ref2 = l_id.length; ref1 <= ref2 ? y < ref2 : y > ref2; attr = ref1 <= ref2 ? ++y : --y) {
      k_id = l_id[attr];
      if (map[k_id].buff != null) {
        results.push(this.push(map[k_id].buff));
      } else {
        results.push(this.push(ModelProcessManager._new_model_from_state(k_id, map)));
      }
    }
    return results;
  };

  Lst.prototype._static_size_check = function(force) {
    if (this.static_length() >= 0 && !force) {
      console.error("resizing a static array (type " + ((ModelProcessManager.get_object_class(this)) + ") is forbidden"));
      return true;
    }
    return false;
  };

  return Lst;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Val = (function(superClass) {
  extend(Val, superClass);

  function Val(data) {
    Val.__super__.constructor.call(this);
    this._data = 0;
    if (data != null) {
      this._set(data);
    }
  }

  Val.prototype.toggle = function() {
    return this.set(!this._data);
  };

  Val.prototype.toBoolean = function() {
    return Boolean(this._data);
  };

  Val.prototype.deep_copy = function() {
    return new Val(this._data);
  };

  Val.prototype.add = function(v) {
    if (v) {
      this._data += v;
      return this._signal_change();
    }
  };

  Val.prototype._set = function(value) {
    var n;
    if (typeof value === "string") {
      if (value.slice(0, 2) === "0x") {
        n = parseInt(value, 16);
      } else {
        n = parseFloat(value);
        if (isNaN(n)) {
          n = parseInt(value);
        }
        if (isNaN(n)) {
          console.log("Don't know how to transform " + value + " to a Val");
        }
      }
    } else if (typeof value === "boolean") {
      n = 1 * value;
    } else if (value instanceof Val) {
      n = value._data;
    } else {
      n = value;
    }
    if (this._data !== n) {
      this._data = n;
      return true;
    }
    return false;
  };

  return Val;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.Vec = (function(superClass) {
  extend(Vec, superClass);

  function Vec(data) {
    Vec.__super__.constructor.call(this, data);
  }

  Vec.prototype.base_type = function() {
    return Val;
  };

  Vec.prototype._underlying_fs_type = function() {
    return "Lst";
  };

  return Vec;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.Str = (function(superClass) {
  extend(Str, superClass);

  function Str(data) {
    Str.__super__.constructor.call(this);
    this._data = "";
    this.length = 0;
    if (data != null) {
      this._set(data);
    }
  }

  Str.prototype.toggle = function(str, space) {
    var i, l;
    if (space == null) {
      space = " ";
    }
    l = this._data.split(space);
    i = l.indexOf(str);
    if (i < 0) {
      l.push(str);
    } else {
      l.splice(i, 1);
    }
    return this.set(l.join(" "));
  };

  Str.prototype.contains = function(str) {
    return this._data.indexOf(str) >= 0;
  };

  Str.prototype.equals = function(str) {
    return this._data === str.toString();
  };

  Str.prototype.ends_with = function(str) {
    var l;
    l = this._data.match(str + "$");
    return (l != null ? l.length : void 0) && l[0] === str;
  };

  Str.prototype.deep_copy = function() {
    return new Str(this._data + "");
  };

  Str.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (encodeURI(this._data)) + " ";
  };

  Str.prototype._set = function(value) {
    var n;
    if (value == null) {
      return this._set("");
    }
    n = value.toString();
    if (this._data !== n) {
      this._data = n;
      this.length = this._data.length;
      return true;
    }
    return false;
  };

  Str.prototype._get_state = function() {
    return encodeURI(this._data);
  };

  Str.prototype._set_state = function(str, map) {
    return this.set(decodeURIComponent(str));
  };

  return Str;

})(Obj);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray = (function(superClass) {
  extend(TypedArray, superClass);

  function TypedArray(size, data) {
    var B;
    TypedArray.__super__.constructor.call(this);
    if (size == null) {
      size = [];
    }
    if (!size.length) {
      size = [size];
    }
    this._size = size;
    if (data == null) {
      B = this.base_type();
      data = new B(this.nb_items());
    }
    this._data = data;
  }

  TypedArray.prototype.base_type = function() {};

  TypedArray.prototype.dim = function() {
    return this._size.length;
  };

  TypedArray.prototype.size = function(d) {
    if (d != null) {
      return this._size[d];
    } else {
      return this._size;
    }
  };

  TypedArray.prototype.set_val = function(index, value) {
    index = this._get_index(index);
    if (this._data[index] !== value) {
      this._data[index] = value;
      return this._signal_change();
    }
  };

  TypedArray.prototype.nb_items = function() {
    var i, len, q, ref, tot;
    tot = this._size[0] || 0;
    ref = this._size.slice(1);
    for (q = 0, len = ref.length; q < len; q++) {
      i = ref[q];
      tot *= i;
    }
    return tot;
  };

  TypedArray.prototype.toString = function() {
    var i, j, l, len, m, o, q, ref, ref1, res, s, v, y;
    m = 1;
    res = "";
    l = (function() {
      var len, q, ref, results;
      ref = this._size;
      results = [];
      for (q = 0, len = ref.length; q < len; q++) {
        s = ref[q];
        o = m;
        m *= s;
        results.push(o);
      }
      return results;
    }).call(this);
    ref = this._data;
    for (i = q = 0, len = ref.length; q < len; i = ++q) {
      v = ref[i];
      res += v;
      for (j = y = ref1 = l.length - 1; ref1 <= 0 ? y <= 0 : y >= 0; j = ref1 <= 0 ? ++y : --y) {
        if (i % l[j] === l[j] - 1) {
          res += [" ", "\n", "\n\n"][j];
          break;
        }
      }
    }
    return res;
  };

  TypedArray.prototype.equals = function(obj) {
    var i, len, q, ref, v;
    if (obj instanceof TypedArray) {
      if (this._size.length !== obj._size.length) {
        return false;
      }
      ref = this._size;
      for (i = q = 0, len = ref.length; q < len; i = ++q) {
        v = ref[i];
        if (v !== obj._size[i]) {
          return false;
        }
      }
      return this._data === obj._data;
    }
    return this._data === obj;
  };

  TypedArray.prototype.get = function(index) {
    if (index != null) {
      return this._data[this._get_index(index)];
    } else {
      return this._data;
    }
  };

  TypedArray.prototype.resize = function(new_size) {
    var B, len, n, q, s, tot;
    tot = 1;
    for (q = 0, len = new_size.length; q < len; q++) {
      s = new_size[q];
      tot *= s;
    }
    B = this.base_type();
    n = new B(tot);
    n.set(this._data);
    this._data = n;
    this._size = new_size;
    return this._signal_change();
  };

  TypedArray.prototype._set = function(str) {
    var B;
    if (typeof str === "string") {
      this._set_state(str, {});
      return true;
    }
    if (this._data !== str || this._size.length !== 1 || this._size[0] !== str.length) {
      B = this.base_type();
      this._data = new B(str);
      this._size = [str.length];
      return true;
    }
    return false;
  };

  TypedArray.prototype._get_index = function(index) {
    var i, m, o, q, ref;
    if (index.length) {
      o = 0;
      m = 1;
      for (i = q = 0, ref = index.length; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
        o += m * index[i];
        m *= this._size[i];
      }
      return o;
    }
    return index;
  };

  TypedArray.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    return out.mod += "C " + this._server_id + " " + (this._get_state()) + " ";
  };

  TypedArray.prototype._get_state = function() {
    var d, len, len1, q, ref, ref1, res, s, y;
    res = "";
    res += this._size.length;
    ref = this._size;
    for (q = 0, len = ref.length; q < len; q++) {
      s = ref[q];
      res += "," + s;
    }
    ref1 = this._data;
    for (y = 0, len1 = ref1.length; y < len1; y++) {
      d = ref1[y];
      res += "," + d;
    }
    return res;
  };

  TypedArray.prototype._set_state = function(str, map) {
    var B, l, n, q, ref, results, s, v;
    l = str.split(",");
    s = parseInt(l[0]);
    this._size = (function() {
      var q, ref, results;
      results = [];
      for (v = q = 0, ref = s; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
        results.push(parseInt(l[v + 1]));
      }
      return results;
    })();
    B = this.base_type();
    n = this.nb_items();
    this._data = new B(n);
    results = [];
    for (v = q = 0, ref = n; 0 <= ref ? q < ref : q > ref; v = 0 <= ref ? ++q : --q) {
      results.push(this._data[v] = parseFloat(l[s + 1 + v]));
    }
    return results;
  };

  return TypedArray;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Float32 = (function(superClass) {
  extend(TypedArray_Float32, superClass);

  function TypedArray_Float32(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Float32.__super__.constructor.call(this, size, data);
  }

  TypedArray_Float32.prototype.base_type = function() {
    return Float32Array;
  };

  TypedArray_Float32.prototype.deep_copy = function() {
    return new TypedArray_Float32(this._size, this._data);
  };

  return TypedArray_Float32;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Float64 = (function(superClass) {
  extend(TypedArray_Float64, superClass);

  function TypedArray_Float64(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Float64.__super__.constructor.call(this, size, data);
  }

  TypedArray_Float64.prototype.base_type = function() {
    return Float64Array;
  };

  TypedArray_Float64.prototype.deep_copy = function() {
    return new TypedArray_Float64(this._size, this._data);
  };

  return TypedArray_Float64;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.TypedArray_Int32 = (function(superClass) {
  extend(TypedArray_Int32, superClass);

  function TypedArray_Int32(size, data) {
    if (size == null) {
      size = [];
    }
    TypedArray_Int32.__super__.constructor.call(this, size, data);
  }

  TypedArray_Int32.prototype.base_type = function() {
    return Int32Array;
  };

  TypedArray_Int32.prototype.deep_copy = function() {
    return new TypedArray_Int32(this._size, this._data);
  };

  return TypedArray_Int32;

})(TypedArray);

root = typeof _root_obj === "undefined" ? global : window;

root.User = (function(superClass) {
  extend(User, superClass);

  function User() {
    User.__super__.constructor.call(this);
  }

  return User;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.FileSystem = (function() {
  var XMLHttpRequest_node;

  FileSystem.popup = 0;

  FileSystem.debug = false;

  FileSystem._cur_tmp_server_id = 0;

  FileSystem._sig_server = true;

  FileSystem._disp = false;

  FileSystem._userid = "644";

  FileSystem._timeout_reconnect = 30000;

  if (typeof document !== "undefined") {
    FileSystem.is_cordova = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
  } else {
    FileSystem.is_cordova = false;
  }

  if (typeof global !== 'undefined') {
    XMLHttpRequest_node = require('xhr2');
    FileSystem._XMLHttpRequest = XMLHttpRequest_node;
  }

  FileSystem._objects_to_send = {};

  FileSystem._timer_send = void 0;

  FileSystem._timer_chan = void 0;

  FileSystem._nb_callbacks = 0;

  FileSystem._callbacks = {};

  FileSystem._type_callbacks = [];

  FileSystem._nb_insts = 0;

  FileSystem._insts = {};

  FileSystem._files_to_upload = {};

  FileSystem._ptr_to_update = {};

  FileSystem._tmp_objects = {};

  FileSystem._objects = {};

  FileSystem._url = "127.0.0.1";

  FileSystem._port = "8888";

  FileSystem.url_com = "/sceen/_";

  FileSystem.url_upload = "/sceen/upload";

  if (typeof global !== 'undefined') {
    FileSystem.CONNECTOR_TYPE = "Node";
  } else {
    FileSystem.CONNECTOR_TYPE = "Browser";
  }

  function FileSystem() {
    this._data_to_send = "";
    this._session_num = -2;
    this._num_inst = FileSystem._nb_insts++;
    this.make_channel_error_timer = 0;
    FileSystem._insts[this._num_inst] = this;
    if (FileSystem._userid != null) {
      this.send("U " + FileSystem._userid + " " + FileSystem._password + " ");
    }
    this.send("S " + this._num_inst + " ");
  }

  FileSystem.prototype.load = function(path, callback) {
    FileSystem._send_chan();
    this.send("L " + FileSystem._nb_callbacks + " " + (encodeURI(path)) + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.load_type = function(type, callback) {
    FileSystem._send_chan();
    this.send("R 0 " + type + " ");
    return FileSystem._type_callbacks.push([type, callback]);
  };

  FileSystem.prototype.load_or_make_dir = function(dir, callback) {
    return this.load(dir, (function(_this) {
      return function(res, err) {
        var lst, nir, oir, v;
        if (err) {
          if (dir === "/") {
            return callback(0, err);
          } else {
            lst = (function() {
              var len, q, ref, results;
              ref = dir.split('/');
              results = [];
              for (q = 0, len = ref.length; q < len; q++) {
                v = ref[q];
                if (v.length) {
                  results.push(v);
                }
              }
              return results;
            })();
            nir = lst.pop();
            oir = "/" + lst.join("/");
            return _this.load_or_make_dir(oir, function(n_res, n_err) {
              var n_dir;
              if (n_err) {
                return callback(0, n_err);
              } else {
                n_dir = new Directory;
                n_res.add_file(nir, n_dir);
                return callback(n_dir, n_err);
              }
            });
          }
        } else {
          return callback(res, err);
        }
      };
    })(this));
  };

  FileSystem.prototype.load_ptr = function(ptr, callback) {
    FileSystem._send_chan();
    this.send("l " + FileSystem._nb_callbacks + " " + ptr + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.load_right = function(ptr, callback) {
    FileSystem._send_chan();
    this.send("r " + ptr + " " + FileSystem._nb_callbacks + " ");
    FileSystem._callbacks[FileSystem._nb_callbacks] = callback;
    return FileSystem._nb_callbacks++;
  };

  FileSystem.prototype.share_model = function(ptr, file_name, share_type, targetName) {
    FileSystem._send_chan();
    return this.send("h " + ptr._server_id + " " + share_type + " " + (encodeURI(targetName)) + " " + (encodeURI(file_name)) + " ");
  };

  FileSystem.prototype.send = function(data) {
    this._data_to_send += data;
    if (FileSystem._timer_send == null) {
      return FileSystem._timer_send = setTimeout(FileSystem._timeout_send_func, 1);
    }
  };

  FileSystem.prototype.make_channel = function() {
    var path, xhr_object;
    path = "";
    if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
      if (FileSystem._port) {
        path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + ("?s=" + this._session_num);
      } else {
        path = "http://" + FileSystem._url + FileSystem.url_com + ("?s=" + this._session_num);
      }
    } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
      path = FileSystem.url_com + ("?s=" + this._session_num);
    }
    xhr_object = FileSystem._my_xml_http_request();
    xhr_object.open('GET', path, true);
    xhr_object.onreadystatechange = function() {
      var _fs, _w;
      if (this.readyState === 4 && this.status === 200) {
        _fs = FileSystem.get_inst();
        if (_fs.make_channel_error_timer !== 0) {
          _fs.onConnectionError(0);
        }
        _fs.make_channel_error_timer = 0;
        if (FileSystem._disp) {
          console.log("chan ->", this.responseText);
        }
        _w = function(sid, obj) {
          var _obj, c, len, mod_R, q, ref, results;
          _obj = FileSystem._create_model_by_name(obj);
          if ((sid != null) && (_obj != null)) {
            _obj._server_id = sid;
            FileSystem._objects[sid] = _obj;
            ref = FileSystem._type_callbacks;
            results = [];
            for (q = 0, len = ref.length; q < len; q++) {
              c = ref[q];
              mod_R = root[c[0]] || spinalCore._def[c[0]];
              if (_obj instanceof mod_R) {
                results.push(c[1](_obj));
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        };
        FileSystem._sig_server = false;
        eval(this.responseText);
        return FileSystem._sig_server = true;
      } else if (this.readyState === 4 && this.status === 0) {
        console.error("Disconnected from the server with request : " + path + ".");
        _fs = FileSystem.get_inst();
        if (_fs.make_channel_error_timer === 0) {
          console.log("Trying to reconnect.");
          _fs.make_channel_error_timer = new Date();
          setTimeout(_fs.make_channel.bind(_fs), 1000);
          return _fs.onConnectionError(1);
        } else if (((new Date()) - _fs.make_channel_error_timer) < FileSystem._timeout_reconnect) {
          return setTimeout(_fs.make_channel.bind(_fs), 1000);
        } else {
          return _fs.onConnectionError(2);
        }
      } else if (this.readyState === 4 && this.status === 500) {
        return FileSystem.get_inst().onConnectionError(3);
      }
    };
    return xhr_object.send();
  };

  FileSystem.prototype.onConnectionError = function(error_code) {
    var msg;
    msg = "";
    if (error_code === 0) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        FileSystem.popup.hide();
      } else {
        console.log("Reconnected to the server.");
      }
    } else if (error_code === 1) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        msg = "Disconnected from the server, trying to reconnect...";
      } else {
        console.error("Disconnected from the server, trying to reconnect...");
      }
    } else if (error_code === 2 || error_code === 3 || error_code === 4) {
      if (FileSystem.CONNECTOR_TYPE === "Browser" || FileSystem.is_cordova) {
        msg = "Disconnected from the server, please refresh the window.";
      } else if (FileSystem.CONNECTOR_TYPE === "Node") {
        console.error("Disconnected from the server.");
        process.exit();
      } else {
        console.error("Disconnected from the server.");
      }
    }
    if (msg !== "") {
      if (FileSystem.popup === 0) {
        FileSystem.popup = new new_alert_msg({
          parent: document.getElementsByTagName("BODY")[0],
          msg: msg,
          btn: [
            {
              txt: 'reload page',
              click: window.location.reload.bind(window.location),
              backgroundColor: '#ff5b57'
            }, {
              txt: 'close',
              backgroundColor: '#348fe2',
              click: function() {
                return FileSystem.popup.hide();
              }
            }
          ]
        });
      } else {
        FileSystem.popup.show();
      }
      if (error_code === 2 || error_code === 3 || error_code === 4) {
        FileSystem.popup.show_btn();
      } else {
        FileSystem.popup.hide_btn();
      }
      return FileSystem.popup.setMsg(msg);
    }
  };

  FileSystem.get_inst = function() {
    var i, k, ref;
    ref = FileSystem._insts;
    for (k in ref) {
      i = ref[k];
      return i;
    }
    return new FileSystem;
  };

  FileSystem.set_server_id_if_necessary = function(out, obj) {
    var ncl;
    if (obj._server_id == null) {
      obj._server_id = FileSystem._get_new_tmp_server_id();
      FileSystem._tmp_objects[obj._server_id] = obj;
      ncl = ModelProcessManager.get_object_class(obj);
      if (obj._underlying_fs_type != null) {
        out.mod += "T " + obj._server_id + " " + ncl + " ";
        ncl = obj._underlying_fs_type();
      }
      out.cre += "N " + obj._server_id + " " + ncl + " ";
      return obj._get_fs_data(out);
    }
  };

  FileSystem.signal_change = function(m) {
    if (FileSystem._sig_server) {
      FileSystem._objects_to_send[m.model_id] = m;
      if (FileSystem._timer_chan != null) {
        clearTimeout(FileSystem._timer_chan);
      }
      return FileSystem._timer_chan = setTimeout(FileSystem._timeout_chan_func, 250);
    }
  };

  FileSystem._tmp_id_to_real = function(tmp_id, res) {
    var fs, path, ptr, tmp, xhr_object;
    tmp = FileSystem._tmp_objects[tmp_id];
    if (tmp == null) {
      console.log(tmp_id);
    }
    FileSystem._objects[res] = tmp;
    tmp._server_id = res;
    delete FileSystem._tmp_objects[tmp_id];
    ptr = FileSystem._ptr_to_update[tmp_id];
    if (ptr != null) {
      delete FileSystem._ptr_to_update[tmp_id];
      ptr.data.value = res;
    }
    if ((FileSystem._files_to_upload[tmp_id] != null) && (tmp.file != null)) {
      delete FileSystem._files_to_upload[tmp_id];
      fs = FileSystem.get_inst();
      path = "";
      if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
        if (FileSystem._port) {
          path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
        } else {
          path = "http://" + FileSystem._url + FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
        }
      } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
        path = FileSystem.url_com + ("?s=" + fs._session_num + "&p=" + tmp._server_id);
      }
      xhr_object = FileSystem._my_xml_http_request();
      xhr_object.open('PUT', path, true);
      xhr_object.onreadystatechange = function() {
        var _w;
        if (this.readyState === 4 && this.status === 200) {
          _w = function(sid, obj) {
            var _obj;
            _obj = FileSystem._create_model_by_name(obj);
            if ((sid != null) && (_obj != null)) {
              _obj._server_id = sid;
              return FileSystem._objects[sid] = _obj;
            }
          };
          return eval(this.responseText);
        }
      };
      xhr_object.send(tmp.file);
      delete tmp.file;
    }
    return FileSystem.signal_change(FileSystem._objects[res]);
  };

  FileSystem._create_model_by_name = function(name) {
    if (typeof name !== "string") {
      return name;
    }
    if (typeof spinalCore._def[name] !== 'undefined') {
      return new spinalCore._def[name]();
    }
    if (typeof root[name] === 'undefined') {
      if (FileSystem.debug === true) {
        console.warn("Got Model type \"" + name + "\" from hub but no registered.");
      }
      root[name] = new Function("return function " + name + " (){" + name + ".super(this);}")();
      FileSystem.extend(root[name], Model);
    }
    return new root[name]();
  };

  FileSystem.extend = function(child, parent) {
    var child_name, ctor, key, value;
    for (key in parent) {
      value = parent[key];
      child[key] = value;
    }
    ctor = function() {
      this.constructor = child;
    };
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
    child.__super__ = parent.prototype;
    child.super = function () {
            var args = [];
           	for (var i=1; i < arguments.length; i++)
                args[i-1] = arguments[i];
            child.__super__.constructor.apply(arguments[0], args);
        };
    root = typeof global !== "undefined" && global !== null ? global : window;
    child_name = /^function\s+([\w\$]+)\s*\(/.exec(child.toString())[1];
    return root[child_name] = child;
  };

  FileSystem._get_new_tmp_server_id = function() {
    FileSystem._cur_tmp_server_id++;
    if (FileSystem._cur_tmp_server_id % 4 === 0) {
      FileSystem._cur_tmp_server_id++;
    }
    return FileSystem._cur_tmp_server_id;
  };

  FileSystem._send_chan = function() {
    var f, k, out, ref, results;
    out = FileSystem._get_chan_data();
    ref = FileSystem._insts;
    results = [];
    for (k in ref) {
      f = ref[k];
      results.push(f.send(out));
    }
    return results;
  };

  FileSystem._timeout_chan_func = function() {
    FileSystem._send_chan();
    return delete FileSystem._timer_chan;
  };

  FileSystem._get_chan_data = function() {
    var model, n, out, ref;
    out = {
      cre: "",
      mod: ""
    };
    ref = FileSystem._objects_to_send;
    for (n in ref) {
      model = ref[n];
      model._get_fs_data(out);
    }
    FileSystem._objects_to_send = {};
    return out.cre + out.mod;
  };

  FileSystem._timeout_send_func = function() {
    var f, k, out, path, ref, ref1, xhr_object;
    out = FileSystem._get_chan_data();
    ref = FileSystem._insts;
    for (k in ref) {
      f = ref[k];
      f._data_to_send += out;
    }
    ref1 = FileSystem._insts;
    for (k in ref1) {
      f = ref1[k];
      if (!f._data_to_send.length) {
        continue;
      }
      if (f._session_num === -1) {
        continue;
      }
      if (f._session_num === -2) {
        f._session_num = -1;
      } else {
        f._data_to_send = ("s " + f._session_num + " ") + f._data_to_send;
      }
      path = "";
      if (FileSystem.CONNECTOR_TYPE === "Node" || FileSystem.is_cordova) {
        if (FileSystem._port) {
          path = "http://" + FileSystem._url + ":" + FileSystem._port + FileSystem.url_com;
        } else {
          path = "http://" + FileSystem._url + FileSystem.url_com;
        }
      } else if (FileSystem.CONNECTOR_TYPE === "Browser") {
        path = FileSystem.url_com;
      }
      xhr_object = FileSystem._my_xml_http_request();
      xhr_object.open('POST', path, true);
      xhr_object.onreadystatechange = function() {
        var _c, _w, c, len, q, results;
        if (this.readyState === 4 && this.status === 200) {
          if (FileSystem._disp) {
            console.log("resp ->", this.responseText);
          }
          _c = [];
          _w = function(sid, obj) {
            var _obj, c, len, mod_R, q, ref2, results;
            _obj = FileSystem._create_model_by_name(obj);
            if ((sid != null) && (_obj != null)) {
              _obj._server_id = sid;
              FileSystem._objects[sid] = _obj;
              ref2 = FileSystem._type_callbacks;
              results = [];
              for (q = 0, len = ref2.length; q < len; q++) {
                c = ref2[q];
                mod_R = root[c[0]] || spinalCore._def[c[0]];
                if (_obj instanceof mod_R) {
                  results.push(c[1](_obj));
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
          };
          FileSystem._sig_server = false;
          eval(this.responseText);
          FileSystem._sig_server = true;
          results = [];
          for (q = 0, len = _c.length; q < len; q++) {
            c = _c[q];
            results.push(FileSystem._callbacks[c[0]](FileSystem._objects[c[1]], c[2]));
          }
          return results;
        } else if (this.readyState === 4 && (this.status === 0 || this.status === 500)) {
          return FileSystem.get_inst().onConnectionError(4);
        }
      };
      if (FileSystem._disp) {
        console.log("sent ->", f._data_to_send + "E ");
      }
      xhr_object.setRequestHeader('Content-Type', 'text/plain');
      xhr_object.send(f._data_to_send + "E ");
      f._data_to_send = "";
    }
    FileSystem._objects_to_send = {};
    return delete FileSystem._timer_send;
  };

  FileSystem._my_xml_http_request = function() {
    if (FileSystem.CONNECTOR_TYPE === "Browser") {
      if (window.XMLHttpRequest) {
        return new XMLHttpRequest;
      }
      if (window.ActiveXObject) {
        return new ActiveXObject('Microsoft.XMLHTTP');
      }
      return alert('Your browser does not seem to support XMLHTTPRequest objects...');
    } else if (FileSystem.CONNECTOR_TYPE === "Node") {
      return new FileSystem._XMLHttpRequest();
    } else {
      return console.log("you must define CONNECTOR_TYPE");
    }
  };

  return FileSystem;

})();

root = typeof _root_obj === "undefined" ? global : window;

root.Directory = (function(superClass) {
  extend(Directory, superClass);

  function Directory() {
    Directory.__super__.constructor.call(this);
  }

  Directory.prototype.base_type = function() {
    return File;
  };

  Directory.prototype.find = function(name) {
    var f, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      f = ref[q];
      if (f.name.equals(name)) {
        return f;
      }
    }
    return void 0;
  };

  Directory.prototype.load = function(name, callback) {
    var f;
    f = this.find(name);
    if (f) {
      return f.load(callback);
    } else {
      return callback(void 0, "file does not exist");
    }
  };

  Directory.prototype.has = function(name) {
    var f, len, q, ref;
    ref = this;
    for (q = 0, len = ref.length; q < len; q++) {
      f = ref[q];
      if (f.name.equals(name)) {
        return true;
      }
    }
    return false;
  };

  Directory.prototype.add_file = function(name, obj, params) {
    var o, res;
    if (params == null) {
      params = {};
    }
    o = this.find(name);
    if (o != null) {
      return o;
    }
    res = new File(name, obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.add_tiff_file = function(name, obj, tiff_obj, params) {
    var o, res;
    if (params == null) {
      params = {};
    }
    o = this.find(name);
    if (o != null) {
      return o;
    }
    res = new TiffFile(name, obj, tiff_obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.force_add_file = function(name, obj, params) {
    var name_file, num, o, res;
    if (params == null) {
      params = {};
    }
    num = 0;
    name_file = name;
    o = this.find(name_file);
    if (o != null) {
      while (true) {
        name_file = name + "_" + num;
        o = this.find(name_file);
        if (o != null) {
          num += 1;
        } else {
          break;
        }
      }
    }
    res = new File(name_file, obj, params);
    this.push(res);
    return res;
  };

  Directory.prototype.get_file_info = function(info) {
    return info.icon = "folder";
  };

  return Directory;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.File = (function(superClass) {
  extend(File, superClass);

  function File(name, ptr_or_model, info) {
    var cp_info, key, val;
    if (name == null) {
      name = "";
    }
    if (ptr_or_model == null) {
      ptr_or_model = 0;
    }
    if (info == null) {
      info = {};
    }
    File.__super__.constructor.call(this);
    cp_info = {};
    for (key in info) {
      val = info[key];
      cp_info[key] = val;
    }
    if (ptr_or_model instanceof Model) {
      if (cp_info.model_type == null) {
        cp_info.model_type = ModelProcessManager.get_object_class(ptr_or_model);
      }
      if (typeof ptr_or_model.get_file_info === "function") {
        ptr_or_model.get_file_info(cp_info);
      }
    }
    this.add_attr({
      name: name,
      admins: new Lst,
      users: new Lst,
      _created_at: new Date(),
      _ptr: new Ptr(ptr_or_model),
      _info: cp_info
    });
  }

  File.prototype.load = function(callback) {
    return this._ptr.load(callback);
  };

  return File;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Path = (function(superClass) {
  extend(Path, superClass);

  function Path(file1) {
    var size;
    this.file = file1;
    Path.__super__.constructor.call(this);
    size = this.file != null ? this.file.fileSize != null ? this.file.fileSize : this.file.size : 0;
    this.add_attr({
      remaining: size,
      to_upload: size
    });
  }

  Path.prototype.get_file_info = function(info) {
    info.remaining = this.remaining;
    return info.to_upload = this.to_upload;
  };

  Path.prototype._get_fs_data = function(out) {
    Path.__super__._get_fs_data.call(this, out);
    if ((this.file != null) && this._server_id & 3) {
      return FileSystem._files_to_upload[this._server_id] = this;
    }
  };

  return Path;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.Ptr = (function(superClass) {
  extend(Ptr, superClass);

  function Ptr(model) {
    Ptr.__super__.constructor.call(this);
    this.data = {};
    this._set(model);
  }

  Ptr.prototype.load = function(callback) {
    var ref;
    if (this.data.model != null) {
      return callback(this.data.model, false);
    } else {
      return (ref = FileSystem.get_inst()) != null ? ref.load_ptr(this.data.value, callback) : void 0;
    }
  };

  Ptr.prototype._get_fs_data = function(out) {
    FileSystem.set_server_id_if_necessary(out, this);
    if (this.data.model != null) {
      FileSystem.set_server_id_if_necessary(out, this.data.model);
      out.mod += "C " + this._server_id + " " + this.data.model._server_id + " ";
      this.data.value = this.data.model._server_id;
      if (this.data.model._server_id & 3) {
        return FileSystem._ptr_to_update[this.data.model._server_id] = this;
      }
    } else {
      return out.mod += "C " + this._server_id + " " + this.data.value + " ";
    }
  };

  Ptr.prototype._set = function(model) {
    var res;
    if (typeof model === "number") {
      res = this.data.value !== model;
      this.data = {
        value: model
      };
      return res;
    }
    if (model instanceof Model) {
      res = this.data.value !== model._server_id;
      this.data = {
        model: model,
        value: model._server_id
      };
      return res;
    }
    return false;
  };

  Ptr.prototype._get_state = function() {
    return this._data;
  };

  Ptr.prototype._set_state = function(str, map) {
    return this.set(str);
  };

  return Ptr;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.RightsItem = (function(superClass) {
  extend(RightsItem, superClass);

  function RightsItem() {
    RightsItem.__super__.constructor.call(this);
  }

  return RightsItem;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.SessionModel = (function(superClass) {
  extend(SessionModel, superClass);

  function SessionModel() {
    SessionModel.__super__.constructor.call(this);
  }

  return SessionModel;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.TiffFile = (function(superClass) {
  extend(TiffFile, superClass);

  function TiffFile(name, ptr_or_model, ptr_tiff, info) {
    if (name == null) {
      name = "";
    }
    if (ptr_or_model == null) {
      ptr_or_model = 0;
    }
    if (ptr_tiff == null) {
      ptr_tiff = 0;
    }
    if (info == null) {
      info = {};
    }
    TiffFile.__super__.constructor.call(this, name, ptr_or_model, info);
    this.add_attr({
      _ptr_tiff: new Ptr(ptr_tiff),
      _has_been_converted: 0
    });
  }

  TiffFile.prototype.load_tiff = function(callback) {
    return this._ptr_tiff.load(callback);
  };

  return TiffFile;

})(File);

root = typeof _root_obj === "undefined" ? global : window;

root.UserRight = (function(superClass) {
  extend(UserRight, superClass);

  function UserRight() {
    UserRight.__super__.constructor.call(this);
  }

  UserRight.prototype.set = function() {
    return console.log("Set a UserRight is not allowed.");
  };

  return UserRight;

})(Model);

root = typeof _root_obj === "undefined" ? global : window;

root.RightSetList = (function(superClass) {
  extend(RightSetList, superClass);

  function RightSetList() {
    RightSetList.__super__.constructor.call(this);
  }

  return RightSetList;

})(Lst);

root = typeof _root_obj === "undefined" ? global : window;

root.Process = (function() {
  function Process(m, onchange_construction) {
    var i, len, q;
    if (onchange_construction == null) {
      onchange_construction = true;
    }
    this.process_id = ModelProcessManager._cur_process_id;
    ModelProcessManager._cur_process_id += 1;
    this._models = [];
    if (m instanceof Model) {
      m.bind(this, onchange_construction);
    } else if (m.length != null) {
      for (q = 0, len = m.length; q < len; q++) {
        i = m[q];
        i.bind(this, onchange_construction);
      }
    } else if (m != null) {
      console.error("Process constructor doesn't know what to do with", m);
    }
  }

  Process.prototype.destructor = function() {
    var i, len, m, q, ref, results;
    ref = this._models;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      m = ref[q];
      i = m._processes.indexOf(this);
      if (i >= 0) {
        results.push(m._processes.splice(i, 1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Process.prototype.onchange = function() {};

  return Process;

})();

root.bind = function(m, f) {
  var i, len, q, results;
  if (m instanceof Model) {
    return m.bind(f);
  } else {
    results = [];
    for (q = 0, len = m.length; q < len; q++) {
      i = m[q];
      results.push(i.bind(f));
    }
    return results;
  }
};

root = typeof _root_obj === "undefined" ? global : window;

root.BindProcess = (function(superClass) {
  extend(BindProcess, superClass);

  function BindProcess(model, onchange_construction, f1) {
    this.f = f1;
    BindProcess.__super__.constructor.call(this, model, onchange_construction);
  }

  BindProcess.prototype.onchange = function() {
    return this.f();
  };

  return BindProcess;

})(Process);

new_dom_element = function(params, nodeName) {
  var k, n, name, v, val;
  if (params == null) {
    params = {};
  }
  if (nodeName == null) {
    nodeName = "div";
  }
  n = document.createElement(params.nodeName || nodeName);
  for (name in params) {
    val = params[name];
    switch (name) {
      case "parentNode":
        val.appendChild(n);
        break;
      case "nodeName":
        void 0;
        break;
      case "style":
        for (k in val) {
          v = val[k];
          n.style[k] = v;
        }
        break;
      case "txt":
        n.innerHTML = val;
        break;
      default:
        n[name] = val;
    }
  }
  return n;
};

add_class = function(obj, src) {
  var old, p_1;
  if (typeof src === "string") {
    return add_class(obj, src.split(" "));
  }
  old = (obj.className || "").split(" ");
  p_1 = src.filter(function(x) {
    return indexOf.call(old, x) < 0;
  });
  return obj.className = (old.concat(p_1)).filter(function(x) {
    return x;
  }).join(" ");
};

rem_class = function(obj, src) {
  var old;
  if (typeof src === "string") {
    return rem_class(obj, src.split(" "));
  }
  old = (obj.className || "").split(" ");
  return obj.className = (old.filter(function(x) {
    return indexOf.call(src, x) < 0;
  })).join(" ");
};

get_left = function(l) {
  if (l.offsetParent != null) {
    return l.offsetLeft + get_left(l.offsetParent);
  } else {
    return l.offsetLeft;
  }
};

get_top = function(l) {
  if (l.offsetParent != null) {
    return l.offsetTop + get_top(l.offsetParent);
  } else {
    return l.offsetTop;
  }
};

new_alert_msg = (function() {
  function new_alert_msg(params1) {
    this.params = params1 != null ? params1 : {};
    this.create_footer = bind(this.create_footer, this);
    this.rotatating = true;
    this.deg = 40;
    this.in_rotation = false;
    this.background = new_dom_element({
      nodeName: 'div',
      style: {
        position: 'fixed',
        height: '100%',
        width: '100%',
        top: 0,
        left: 0,
        backgroundColor: 'rgba(36, 42, 48, 0.38)',
        zIndex: 100000,
        textAlign: 'center'
      },
      onclick: function(evt) {
        if (evt.target !== this.background) {
          return;
        }
        if (this.params.onclose != null) {
          this.params.onClose();
        }
        this.hide();
        if (typeof evt.stopPropagation === "function") {
          evt.stopPropagation();
        }
        if (typeof evt.preventDefault === "function") {
          evt.preventDefault();
        }
        if (typeof evt.stopImmediatePropagation === "function") {
          evt.stopImmediatePropagation();
        }
        return false;
      }
    });
    if (this.params.parent != null) {
      this.params.parent.appendChild(this.background);
    }
    this.popup = new_dom_element({
      nodeName: 'div',
      style: {
        marginTop: '30px',
        display: 'inline-block',
        width: '80%',
        backgroundColor: '#FFF',
        zIndex: 100001,
        borderRadius: '30px'
      }
    });
    this.background.appendChild(this.popup);
    this.create_content();
    this.create_footer();
  }

  new_alert_msg.prototype.create_header = function() {
    this.header = new_dom_element({
      style: {
        width: '100%',
        backgroundColor: "#1a2229",
        color: '#fff'
      }
    });
    this.popup.appendChild(this.header);
    this.title = new_dom_element({
      nodeName: 'span'
    });
    if (this.params.title != null) {
      this.title.innerHTML = this.params.title;
    }
    this.title_close = new_dom_element({
      nodeName: 'span',
      innerHTML: 'x',
      style: {
        display: 'block',
        float: 'right',
        position: 'relative',
        right: '10px',
        cursor: 'pointer'
      },
      onclick: (function(_this) {
        return function(evt) {
          if (evt.target !== _this.title_close) {
            return;
          }
          if (_this.params.onclose != null) {
            _this.params.onClose();
          }
          _this.hide();
          if (typeof evt.stopPropagation === "function") {
            evt.stopPropagation();
          }
          if (typeof evt.preventDefault === "function") {
            evt.preventDefault();
          }
          if (typeof evt.stopImmediatePropagation === "function") {
            evt.stopImmediatePropagation();
          }
          return false;
        };
      })(this)
    });
    this.header.appendChild(this.title);
    return this.header.appendChild(this.title_close);
  };

  new_alert_msg.prototype.create_content = function() {
    this.content = new_dom_element({
      style: {
        width: '100%',
        color: '#000',
        position: 'relative',
        padding: '15px',
        fontSize: 'xx-large'
      }
    });
    this.popup.appendChild(this.content);
    this.img = new_dom_element({
      nodeName: 'img',
      src: "data:image/gif;base64,R0lGODlhyADIAPYPAP7+/tjY2Pz8/Pr6+vj4+OTk5Pb29vLy8uDg4PT09MjIyOjo6OLi4sbGxubm5tbW1pKSkurq6t7e3ry8vNDQ0MrKytzc3PDw8NTU1MDAwNra2u7u7sLCwuzs7M7Ozr6+vtLS0oaGhpCQkMzMzMTExLKysrCwsKioqJycnJiYmKCgoJSUlKSkpKKiopaWlqysrKqqqra2tpqamp6enqampq6urrS0tLi4uLq6uoqKioyMjHx8fISEhICAgH5+foiIiI6OjnJycnZ2dnBwcHp6eoKCgnR0dGZmZnh4eP///2xsbGpqagAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/wtYTVAgRGF0YVhNUEU/eDQ5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8eHBhY2tldCBlbmQ9InIiPz4AIfkEBQUADwAsAAAAAMgAyAAAB/+ASYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+/wADChxIsKDBgwgTKswFoKHDhxAjSpxIsaLFixgxgsvIseNDARciRLggwKPJjBtPqpyYwEKAlwEsJFhJE2LKmjQFuIT50kJJnDRvAj15gSfPC0NXCk3aMYJRmB2YnlwqFaPTpwEiVPVIdaWBDRsINMWateMAsGKHdjU5oABPrRn/rz6Fa5WngwFA15rdeTQuWboWixq1kDboN5wOsPqsixUwxQF87eLUyzHyW8ZzMQ+efLimZZgaClOUa9SxRAIayFrg7A0x2QAFLpK+bNEtWQesu+FE/XpmxdkwTUM88Dp0bm5AF7yW8HMi8JfCHQqQ8Do61841B6Qmu+H334obXlvAe3zb0PBkNTSP+LzsRMivu+fFXlMAgtcLRn+fmJgsgqSUeURceqI91F50CbwWgG/ztZaUbVgx4Nx+EAnAwGu4AUjfbtthdYBEB0okGFYakKfWhji1FwBz7FEoHXUuNqgbU/CRFRVEIeIo3noyIjeRAAds8GFH6JFoYkM5OsQb/1lIcTSAAwhEwONDaxEAY0xNYmQhhjo2BlF/ETrJAAcTlNnAkBGtdSVMDDBo0YBkGWCgiwm+JudFAnRQQZl8TtDAlAB01QGGR1IE5lMSOjSiUVkCcOFtGB0AQp+USiBRV2s+pcGNFS2JFYM6PbVYQ3UaaRFqH1BK6Z9poghAh8uhOSF3DxkQmQV3NlTkU/K95wAJqqqawZRd3acgm7lGFCpWjQIAkkgkQbQoT5b+uMEIwQarALGuTqugBgsACoC3AajXkQCwwiTrQwlgkG22BXDrYESDHsuTBhsACuFLGqwbabqxRTSABBm8G+yoNrnakAGP2vuSBP4KACYDBXJEQP/DDvAocQMGq+pBs1Qq3BBImR5bQMUCGFDoSQMkMOUFHnRMKQnhVhSgsxGk+62UW0k0QAAy9/mBBCu3Ou+ph9qbaM/SYRt0mRi4abPIEiXQsL29Ms3A0xNUkPVFN1e4wWdYZcg0ABQEzUG81x3tZM4mn91Q2gZ/UOJUVCOt4NdbSWAwBf5yFHZFBxg7mLhMEUCmqgpwqtLgFQkw9r1SMx0BpRwwgLjgeb8tgQUFJCs3ABt4wEEDxvVo3uisVwV567CD3XnstFv0eu0nCUBAArz37vvvvhNwZEoGFKCzw/yejLtDEcCQQwjQRy/99NTnAANcGxlwPPL3Vtx6BEBQL/7/+NLrgNtG+3JPVsC1w0D+++OfIMBG26sPGu4CPA///tHnMMBG9rMX7gjAvwJC73+HqV8ANTBA/Rnwff5DXwBfw77YCcB9D3zfCRDYGk9NECbjWR74Mjg+IGQsJW1R4LE0UICiwW4BziNh/05wl0ChSAA4zKEOd6jD5UlEAAMIohCHSMQiCvEnt/Nh7ZKoxNgxsYmte6KyImABDbQpdgyzgAR4pjpt4ERysOpX6w4QxnyVx4s0SUDJYrK5oSzLKAgIXEekSID0GYVvVdnVU5T3uNlNUYUV7JkdjaKBCLjQdn58yOTsZTamDVJUZpxjIgGQAMPZC2R55N4VOee2xyTt/1hLk9vVGOm9S3VOAHBDXiFhh0oV3ouLU+uktMiGoYq17JBOMsCU6qg+C0SLInphmPriqKyJlfIiwnxJIx2iRvUxQHQhkyUAVKSYSEJklGL0yAXStcyRbcCVPHFcNGcEET1+awEuJJe5OIIuZv1oAeB8CSaLhbxnUuSNRlnXs0bCI3KtCHEXq6cpZelKCWByTrRyiK14QhhFVicwayTkQMn5kIjyqwNt1I6dpPMZhJVKU8d0SAcU+B+jUVSktcTIJ9n0EH82apSSuciT4jNRH0WkZJu8yEefkqwkUVJBlZtIMqkFqCpdyZcdsaRRlulTAKz0JZrjyAX4IoFSUiZIB/9oYzmLU6CmajShUhUS4qT4I1oGQJzTjBEA6qUYXOJNmitREYu6lJmbPpQpZI2IBxkFIrUCAE4gxeskL/LIAIQSoXWNCExh0k3DwNUkO70XNJHkVwAYQEFyfOtJVzId/OjHSxNRjn+0ipLBUsScIDxkUz9SPzxq1qY5aa13QDsR1PbEraV9LEdEixUEbG61H7GodSSpW4zslSeZpSxtJwJYQoY0t5s1yVNhI5vKPqSwjW1bdD1Cy9TNNrEUOW5PzpgNnNByuMyzLmI3U5O8OlUxpAWussiWXeJudy9POWiLlgseUeFWdsXFyEwvyhH59pWx/wXwfU1CALAkWLngvUh8g8OioQCfzcBRNK1UMMw699bEpU30cE46StqziTiNt5os7U5Mk7NAq8RyW4iMZ0zjGtv4xjjOsY53zOMe+/jHQA6ykIdM5CIb+chITrKSl8zkJjv5yVCOspSnTOUqW/nKWM6ylrfM5S57+ctgDrOYx0zmMpv5zGhOc0ACAQAh+QQFBQANACw8ADIAXABlAAAH/4ANgoOEhYaHiIYSiYyNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SRBaWEi6iRqqULh62rsrOXsaK2tIm4uby9vr/AwcLDxMWcr8bJysvMzc6ru8/SmwIHGwcA05oCGxIB3xIE2pYACQzf6AHRhcjF7YwEDunzG8TrlAIRGvPzEtm89y4JuOCN3zwN/yCdYhRwVLlzBvkxSDjO0IAFESNeoFhREDcLGflpiMAR1EJLJ98JAnCgYMh0BcR1JESgwMt+2GYOyrfv5jcNG0pWBADRZ4AFA3QW2mA0AIMEmRo2ODnK5k0LG5UesppxpIBPVHsxzeggqdZEAlymQwD1bKMDPf+/WQiaS+onAwUsSIhg1q3fv4ADNxhAoLDhw4gPD/g6c0MGGDQiS55MuTKMDPXGbXhRubPnyS86jMvwubTnD+Mgm14tGQbjZwNYy46sbcCJ2athjMZtOsPrZ5t5ew5d0fFt4ZEvi575G5/g59ArLgqLSkOKHTxKbGgeHUSQIeCHEPlwwJfdTBd2hF//A4RM6DjWyx8ig0FfwAJkzJcvpMb2TVJR90l++823Awdt/cVBgfvp8MB7pkgiICgEQMDgfjMUcJ9SCZggxIX82fAfQxLyIkAB+oG4Xg8KJFjKhAoxMgAIIai4HgQScLcJjJkISEAGRNgIXhA26NgRNzB8J6SIApPw2MB5AzKwgpA6GFlKLFDC4wEPKhKxITSKdJIADh8ymMOX7MRITD4tKDnfBNEJMoAEIswXAoSpdKJSJHtWQoACPYQXgpOBJeDBBxQkYOUkWfoywGJxRuoMoWpuJemlmGaq6aaZUsrpL41SEuqVqPQ56jFgFnMqJZ5+6uqrsMbqyKpn0RpKIAAh+QQFBQAXACw/ADgAWQBZAAAH/4AXgoOEhYaHiImKhw6Ljo+QkZKTlIiNlZiZmpucnZ6foKGio6SlpqeoqaqrrK2umJevsrO0tba3uLm6u7y9vr6xuMG/xMWrDMbJnMPKzYjImdAXzJXSztfYzdTZttug3ty64OHk5ead1ufq6+y/AAID8fLz9PMCAM4JDwoN/f7/AANWCJAgWYIKARMq/FfhgLEHCyMqfIDPHT+JGP1VKCYgo8d+AogJuPgxYoWQ7iCWjPjA2MGVChtWJKaPJMwKDw6gNIZPgM+fQIMKDTmzndGjtdKhKlAjxQwSDpFesABBhFURKUYYOHpAxtWvLCwMaFfhq1kRJRbsLAfAxFmzK7g4RD01jhOAEm/PyqBAwByFvG9pIBgLqS4hpaMGwAD8NkaEtdcMcFjB2KyLBgeKZjIcCkAEvJW/znjQ1xTiSKcFCZDQIvRXGJxRk9o2IoXrqw00OwNwYELV2y0fpe724vaJcwMCzAidAnI4AgpsA2bhXBDn2KgAbIjx++wIowIKnDjbwhR2QucRDXiA4qqKCFIFEQgwQkPp+Kqr49+farik1OnxJ+CABBZo4DcHJohfgHQpOAqDvwQCACH5BAUFABEALDcAMgBhAGYAAAf/gBGCg4SFhoeIhQaFFouJj5CRkpOUlZaXmJmam5ydlh2eoaKioKOmp4ilqKuGqpqulQWskBansJW1s5S5r7q+nre4v4S8o8G7w7rHycyJy83QhM/RnNOpj9bR2ZXbhhfUqN3gvseO48ni56zp6uGf7YPFvYXsoezfnfXwggj5lP2ULsirhMAcpASUjumDBFBdw3+zFm4yeGjgJonVkGHC6EnWI4vORlF89HCfyZOT0nEshPCRx0wvQ8VE+WjksJX7cNJMVvIRvlk/JdnMJFDSTFRHd57TiSjpIKbX1LUEB1LpsKDRqs5yarWr169gw2oCIKCs2bNozwIQm4hAAQ0B/+LKnUu3roYCBNgSIgC3rt+/cjXk1RuhAODDf7l27Yu4cVwNa9kCcEw5bmSxABhXBgyZsOHNhwtcFssX9F8Lgwm71Qz6LoHRhAHInk27tu3ZhHPr3t2sVoGhqzooiIHjgQHYvCU5KGGiuYkYGga00yqKQAzn2D84aAf1UADs4E0owJr8kILw4EtgOG6qaCTFoSqgD3/DgnRPwKlZmI8+wwIBnMBXiICeCMABf+hVQF5KSg2AAXMIYmeDcZZQNyAi+U0iQAcIHODNeRFihwMC9zFkyVRNZSIAAijs4CIMIzkwQYjYcdABcqcQCIkAFPjg4o8tlDjIABpcR2NzDyCyIP84F/Tw45MeAGiIASBASCMDm8BnIT2HjPDkkzksCcAFDRyZAY7AJIJVMfJw8OWTOEh5iAAF4BBiDOoMxOabP/aw3SMDBGADgh+soqMkA7jAp4snpJaIAR5YCZ4GlWQ4iKVPRSWIBIu6SKkkHRwI3gRCJrJlJgoRIgAMnbqAaQQr2tncBEsOghCKktR6SKrSOLmoAnJGMsBbBQyAJienCsLrIAJ80GkIG2ByLDPLXqpDpzGUGla1g4DQqQ+HUuMUt4IM0OKiLTi6raaFMNDpDhgQRq4gApjQKQS4Uosqu4VcwEOnHAQLzzPz0uvmoiF0pwy/hRAgQqcmCHxOvlzuCslqA++G29FFDBciQAudniCxUgUT4oCPfObQG8cW72jDojmMvDKoHXsTAp81yMxKsq3UbEgFb+awgc6saJxpy8Li8CQNHRDti65IV4xoASSQUKxeJc85gNMk+1ze16bwDLYiYo9NyAUdKJxJIAAh+QQFBQAMACw6ADIAWABmAAAH/4AMgoOEhYaHiIIJhouJjo+QkZKTlJWWl5iZmpuSEZyfoJmeoaSlgqOmpqiiqa2cq66WC6mwsbaRtbe6iLm7voO9v77BwrrExbbHyK7Ky7SJs87Ph43Sqta/zdig2sDbmLXd35Pi4+DW1Y8H5LzY0ePv5oTpt+WX9vKx+In0+aHx/pbtW6cLYEBO/UrtO8jwX8NQCR9KRLZwYiuCFjNq3Mixo8ePIEOKHEmypMmTKFOqXMmypUuLES9awBDAwQCVF0Do1IkhgoCTAx7sHBrgwk+SC4YqBSEhAYCREpYuLXAzZFSpSh/4rBRTIFapAQ487QhAw1epCAyMbRdQQIGzS/8xLKjaquukAwv6GbgKd+eDDkcxYVRlQ4YMFB/oCgJwIUDfoRrsFiuLwrDlG4EHAYiA4fFOB+YSqLBMWsNaQgPeegbRwZeACxlevOAwmEEA0qRPxExgwXOAV5EEBAhypPgRIxYIgcBNuoIjxo7hYjjt6gJx48WNVCvA3LKK1o4ELOj8NQB1QQY3ccCOncQgASa6G04MaQCCr7kkK5pUg73xGoQsIJ9hBUQCQAJmKWVeKwC94F9xLxTywYA1ECAJABsIpVMABgiyTm2lOPhghIQcMMOAGFDyWgRG/SKifyRqNsKALID4CADn2fIiezEOQsAJAyqQmT87YtfjIBYMOEO6RboUadyRgxQm3w2K5eMkhLxUJp8EDF15BJSDZDDgCx0G5CWYHrYwIAgHnZkIAMvJ18IFZj74pSMDvDAgB8vYSIibjiAwIApMtgKoIzcM+EGO1hyaSAdaMkcDkXaiWUgD8p3A6CbpTeIoPyx0lwGlI0pyG240iGVlpZIIoECkE6i6aqmtcgbCVnXSOsmQpPoHoEkZ2OmeSRcY4Z8Rfn4UlLHGGaEBSgIY0MEHsmVgFI7YZqvtttx2y20gACH5BAUFACIALDcAMgBaAGYAAAf/gCKCg4SFhoeIhQaGi4mOj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipmA6qra6vsLGys7S1trehG6K6tby2vridrMGojcTHyJUHyczNv5bAqsvOtNGPxo8J1JTDqNOQ3ZnWotjbxOOE37XqkOyS5Y/umPKp4eaa6KTa9aX0s/D3qgXkZC8XqnyHAEZCyMzfQGQMO0UUte+hxUcTL2rcyLGjx48gQ4ocSbKkyZMoU6pcybIlKYUvC1iQEEFAygMaAugMoCHjRQEWdgpFcADAK5/ihCoNUIDAyAJLlWqIwAnpKahRlVqwOgimrA1ZoyKoyJFB2KhNPUbIeVboVJun/7xKAmBgwwBDBLC23WnhQieyoABc8DChMAa4hBJI2CuUgdxZDgpLnkDhkIANbBkH6CCCqykCHyZLLihIwILMex2SOuDhwwcK5QqIlkzCKSICZhkjkKTakS8ADCCEGB4CQgFCCGZLtmA00YHFbTW4SiCc+HAItjsrL/xBNYAOqJfuTkRaEwXr1kEQqrB9wuFIDsLmeyyIvqAM6IlnILSh/QTOkRiAwFISIDaKPR/kN9wHhACAQXsV3MVbUDpJkJ0I2gAGCVIJKjiBIqFtV0BzkQBwwAa9jdJhfh8WIkF7HFzozIrotUjIACS0J90x8tBonY2ELOBfirb4SByQgwhA2K12FBjIjJHDITnIAf5RRQ2UIUgpCAAPtKeAjKV4JgKWWgpCQAbtIUDiV46Q6Uhy23FgnyxuJiJAA+0FsOYrGhZSZyIRDNnMn4gAQEF7GAyqYJbtwKioh5AAEMB2JJhSniSEJkIAB8o9sKc3mC5apiGyiSbnoyxOosFkIMwpUSWZxsMAAn5dKSolRn2aDJYMluTBopWVdEB11kHg6kMSEFvccScRcMEIhXnQ5ymBAAAh+QQFBQANACxGAHYAOgAiAAAH/4ANgoOEhAIbAQsEAIyNjo+QjAMGAoWWl5gHM0OcKwyRoI8GBQGlDgCYqZYDLpyuRhShoQcapbYFqKq6Cq69SAmykAK1trYHuqoJPb29I6IaFBQWA48HxcUSAsGgAiXMvRyOETU05TQ1HY6I17YR25ELRt+uFo0E5OblNdSMBuy2Gha9azRAxTxOIvgBsJAvnwRHDP6ZGtgowMEhQTQ4AtHQHAhH/iQGADZwQI6LLAQyotCxXCxHDkQi0PaOw0UkpxyxbPmSILF/G95d2HHxhsKVLWn0bNRB5LRgAmpc5HEB0s6OSxtJEOlOVgF5Bz3Q1Jk0KyNrEgOGGiDjogsDkeyuNjTLiJREXKBAXAzyMG5ZUCElknxE4MfFEyofyc1Hl9ECmWMZCfhwcUdXvzxDDRMZVB2Rix8iK/4bat2/p5JPXPxxQNZicxR0bZV4GUGQix9dkw6VQKRaASguykiMGes2u/9OESA6zwiCba9dbiPw81o9Aj4O7oO+W1YEiRYEEGAxz0dV7pm3CbCQHMCABdmZKRANKrrSgaZtoRawIDinIDfQV193wXxniwNHuYcABxxc9o59jYFCwAYbEOeIAALqlh5FHFIEYYcgvqNBUvWEaCJg+ORTg4UnniiAAyme42CLNLrXWzQawFVjIAAh+QQFBQAVACw3ADIAYABmAAAH/4AVgoOEhYaHiImCEoqNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlppeMp5CpqomsrbCxla+mtLKHtre6u7y9jgi+vh2gw8GExcbJysvMzc7P0NGiudKJyNXYvtSeB9nA2aLXgt+726Hk5ZbisgyN5uDw8Z/rrQjdiu2X+Z378v7G9P4JFPhuoMFkAT0lbHUv3cGHFQqG6gexosWLGDNq3Mixo8ePIPmFHOmIIsmTKFPWqmDSVMuUC8/hUiko5iabNEdJTLYz56eXPuP1THQAQYcBxoZKajgogQ0RUF8s0PdrmYAXULOu0ADyQdavLgw8BFqBAIqvXwMUGuAAAYIIAv8OAmiA9isFQgdGNNjbYARTfxtW1M1aYNAAvXz3joj7T8DTwSJOMK6wIHHiCK1wTkIAWQSEfgws8yXrCV0hckpZdL6BdBAC0XtNe2Ilu1C3v44odHYh7jXs2gpFJTgLWcHkcbAbAJfGobMK3L5FL4cWQTDkAAAMRbc83ZkAE51rEDi0PTFw0rwkdIZQmHzy7ohww2rReUJr7e/BAfDQOcWGROXxBZ8yB6TQ2QiKBBgbOBN01oJYAOaXYDIOQNDZOwoq14h8ujw2WAn3IZLhgMEMYOBgK0zVyIiYKIXJAMTVxcFxIkpoiYuWADDADYOhwOFpNkYjQAcxZvVAdr8EOQlFjpls4CEECiCZ5G/wCOAABRT8FwmL8QAgJSRcdhQmR5XBhplHh4m22EcAXICYYj9iJAABbSHgwABe5qnnnnz26eefegYCACH5BAUFAAsALDUAMgBiAGYAAAf/gAuCg4SFhoeIiYQWio2Oj5CRkpOUlZaXmJmam4YdnJ+gm56hpKWdpqiHo5irqaGMoa2TsK6QtJaytbqVuZK3u7+cvZHBu6TDxsmKyMqcErjN0Y7M0tHUiRfVpdfaxtzdut/grr3Z496T4sCip+eP5pnq8O7CphfFpQmRw+qYz/SF5kn7Vw0fNEUEtxGzp6tAI3wCBQ2LuItiJYsAM1oLJUGfIoeXQH4S6QijRnInU6qUZpJTy1T3Vhp6KTNezZuOPBbEqYymK4OpSPIcSrSo0aNIkypdyrSp06dQG0adGpSq1atKBWgVgBVbiRw8ZljgakxoNAIkeOxYu8MHBrJY/wU8EMG27g+dVAU4aFG37w4SVw/Y8OG3bwuqAxT8KOyXxTkLPh8J0LCCceEKtSJvEhCBhuXCKJ4muNHjc18fMQik7DdgxGLTdVsUgLsAgIEIB2hrA0pIAIIUsOuKeKCaEIEKJpKT0FzIrKGEmgjECM6WBwm8gxok317CeSPmmwY0oL7WRAfdghBsXx9jwCbwiCIKIEA3+AwE7g8NuLF+vVABF0TQQUTwRVeaaUCAYIAiD/S3XkIGWBDAhAFYUNw0310yABCfFfFBbookYIOD260igIQUTsibLgJ8YBkMEaBnyAgkJscBIRekmGKBoBDAYV8pWPhIBDWaUEIrHehIYf8/l0BXiAM/7pDDCAtK9kGRI9CWpJIBMAlJTII4acgADzRAnCQSFBnDAYVsqaQ8k/AICQH81RhAJ1x2eRQAGBSJw4WDuKmjl+dcUEKRzgmaIqHjKFBkA/m1mecw3rnjQJFHIqLokpVg18wAV9ZIgYwLbDoho9pooKangU5KlAExFKkBAImYqidPAFBQ5AeA4sklNWJqY2iRDjRiKzWsVgMAcjUqMI2rOAkQK4klvHQsJiuSUqeDGDxy7SXZgiIAjQ7e0Kum0OI0moMIQPJtSYaEGwoACTBr5J3upouhO/d0JMm7XQGMlcBX5cilnESdqKS8TUWYogVVdjUIAANc0MEQgAIAoPHGHHfs8ccgh7xxIAAh+QQFBQAUACwwADUAZwBjAAAH/4AUgoOEhYaHiImCEYqNjo+QkZKTg4yUl5iUBpmElpObnKGNnpmkoqeooaaprK2Pq66xspWztbawhaC2u5K4vKe6rL6/tQiYw8TJr8rMl8jN0J3RxMHL09eIz9iQ1Zza28nftOCzq+Lkrabd6L/n7IgHkbjumcbvvOuT9vfOjfu79PhNCyiwoEF+BCEhiNconyOHnCCykhiLoquEByNm3Mixo8eNGDV9/MVwpMmTKFOqXMmylYABBAzInEmzpk0DBAYIYCnAgAYgS44IHUq0qNElIv6hHKBBidGnUIkqYaASJ5CoWKFCGFA1aNavQ5VYNGgArFmhYwsS8HoWq5KdKf8HiGibFcJKAQic0n06xEFVQQUg6N17RAkEvymrDTBw4ILjx5AjXzhwwADclpgza6YAQFDnzZQSNKDRwkaBz6AdDQDRQoZrGSgQoE6NCAGM17hZpG3Z4Qbu3zJAYNsdykCDGcB/36BNSMADFsmB42AOuEb05AFoA7gw4XpyG7QJjEDuHfcMBVwRhgpAo7zyVQMOEJg9ckEJ97hfIEg/CC+I/xYQp88sA1SAAn6utQBCNwBY8N+DIFzwkQAYIAgbBxIe0gGED2JwWUYADPACgjYgdohzHD6YoSEhESKgIgOQ5x0MFhCgiAMpPthBQ5C0GMlt16ngQQL05YJBjv8l4BHwAB5Eh8IHGzgCAAJIgqBBkQcNACRuJhTAnyIHVAlCSRTM84tSinSw5QkB2PgIAAFUKZs0h/joCJp3YrBfL1ViUI2ZPD1Q5QL0AbpSAVUG8OEi2bBkgJgr0smiSOwAIEGVFizKaJ0rXSCmkpyGOgmZ2MBZ5WmNinpSBH26qaqkJg1wJJLDGGoSokgG8OWkrxqCJzmPVhlpr5smQmou11CJJAKaFmLrkrPmSNGzh7zIC4o5ojpKqiNNmeMDu3Lr7EkAGCAoh1Faw+tJBCj73wLyiLvtPeVG0IGr6o4bCSjWskMtdeOsC/DABBcsUAR2ihIIACH5BAUFAA8ALDAAMgBnAGYAAAf/gA+Cg4SFhoeIiYMJhoyKj5CRkpOUlZaXmJmam5ydnp+goaKjpIUEpZCnqKulDqyvsLGys7S1trWqt7q7mLm8v5ESwMOCG6LGxIjIvMvJzs8PvpqO0NXJ0qIH1tvc3ZXNkuCe2ITa2wyy6JPimgzU3obqhMK88ormgvaX5IPshvSl3vECCE+Rv0H4YumblBBSQ0kCFS089BBTxYIYEx2sRRARA36pJrYDec8SSU4Ro2VMtpHSyZWfRB5q2YkmoZSebD5wtYqnQ5hACRHwOZOVzqBIrR1NKpGp06dQZwEQMKCq1atYs1oVAMApgAEFTuQIQbas2bNoc5wgWottJgEF/3SgnUvXrI4ISQkMOFG3L90TAtqCGjDWr+GyOV5yG3C4MdkBSQk7NqyDqQC+k/vCSMoAwAIgmekC6ZBXUAQYhUOH0AGDdNCPhggkmE27tm3aBhRH3c27IICuvU0GIJHBw9JOMm0JQJBhgnPneG0dDwUgQoPn2DlADn4IwAEK2MNPQGD0ke5OBAJ8EB+eAvdCDDiwFw9i2HRJADpUmM++QHlJyWGSAAj8sefBM25hMoAG6xUYngaB8SaAAyQ42N4BwN20HVAAbLCfhc8pEEGEhDgQwImwYRLgAx2BIoAGID6XAQLkMHDijRpcVFIhCaLCQIzOBWBAhoRccOORGniiY/8lSwoiwHUgGkeiIRYceaSODzWJyHkrCtBggSQ4MKUhEVh5ZEvnPaKlJE8W+IEEJy1o5o0GUILTLBLwh0ECRCJi4pwBrPjAmjlJAiV2I2wwJiIJAHpinZXcWclCLSZywKFhLpoIAo722A4lCVWqiAARMDAiJRs4qkGa6zB5XyZVAurae2Q6Kup7BGjgKKGZsApLAY52hlwint7SKKAaQEorIQJI4OgCyxqSKqAWbBjtAy86+ipSCziKgKac3PpLrrvissufcxbQZ7SxmrkqKr7CAkC7VkZ3bYlzWgDusgPQeyKvm2y7ygDoajDrvYcQsMEG1sKiSrwIRxwxwBJHLGkFxcUQEwgAIfkEBQUADQAsMAAyAGcAZQAAB/+ADYKDhIWGh4iJiRKKjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaaVBaePjKqrrYkLh6yvtLWas7YNuLmGu7y/wMHCw8TFxsfIwrHJzM3Oz5EX0NOdAgMDlL7UjQIHHjgeCc7Spgw8Q+g+CgTbitqOCefo80AW2O2cOPP7Q0EtEQJMkXO0rNSAEPz4CbkhbtQ7XgOEJEzIwwO7TQ8zDcwkQMfEiSsYBET0bqMjk7kUfJwY5MSGkYVQqipYLUaQlQmJfLiIL5IACRBwJvwB4h6iVJeQNqCZtFICBUWE8pNRAGZPRwI22JAoFZ2RGg2vPhpQQEXXeRB4EmOqiUAAj2f/OYidlICDj64orIZS2kimp6w1jAjNO5fSAAYycE4obIkAiB8TfRw4lZHXgQw79hnBwJjjhhIhfMioDIpv59OoU7fSO4k14wgfTtCYTbu27dsnMmwAZhpTBBi3gwuvDWM3YwEfhisXniFX70yyl0unDcPo3OnYZ3cWED27chgAOmfwvlxu4VQbgJMP/sJvzwsc1K+nAYOD+2m9rRHYz7+///4DhKfagAQWaKBPEUigQQFhqfIcMBtoEMCEAWgw2YGKJCABhRxK4BqGBBTA4YgBGIfhIAJEICGJHD44IAAbbMjiiC7SQhomCSAwI4v3dUbWjizWyIuQCK4IJIUaRCDgxIsXyHgkhQWolcyNhxjAwJMcInDAkocQqYiXowAQAZYUWvBSl5ugBCYnMJJZ4QLWtdJjNI4AoCOWBRjAZSFUEoLSnKYAYOSOElyw5yW49HkSm06yqEEHH1bii6KqdLDjAlIepZExADQ6IQMJHHriIAQ4WaiolLAFiaqVNHkJAAdscGFqgHpC6ai4clJrrms24mKvuQYr7LDEFmtsJsAe+8utnzBbirOdqArtJqy+4suuoEzrSbLKduvtt6dgO6C2BZL7SSAAIfkEBQUAGgAsMAA4AGcAWQAAB/+AGoKDhIWGh4iJiouLDoyPkJGSk5SVloiOl5qbnJ2en6ChoqOkpaanqKmqq6ytrq+wsauZsrW2t7i5uru8hgICvbEJASMBBMGtESoizCgYA8ipBMvM1ScFwNGlFdXdIhAxFwC5tKYCLd7eLgrH2qACLunpMwHQ7p408vIv5feXD/rkQZhwYBw5UQAaBJSXYoS/TQ5eLEzXwkI2RAw0ZRTUz9LGSQQezJjozUQEgw8nATjQIB5JZisytEs5SUCEGC+rwbCnq+OmAQjy5aRA8xIBCjJelkBJyiesAxlWTFxaVJOABSUWOqz60wILeSgScO1kYETSaiskjPW0koQKGSXSnJb6uLau3bu5xv3ay7ev318amNoVcOCBggaIEytezFjBgwO15Ko8UIGx5cuKK4i9+wCz58sPBKuSTEnA4c+oE1e4OFZA6teIWY89DdtzhbsAOtf2HMBuxgSVd1uuYACvhmG0hVcIUHwtXUEABAyYTr26deqAjWvfzr27qOepwHsfT768+Wikz6svlJ6QeFvt18uKL3/Re0j3aebXRL9+r/3+BShgJfH1N+CBjVhiIIIMNujgegDil8iCD1Zo4YUYZugKhRp2yB2HpoDoISci8hIIACH5BAUFABAALDAAMgBnAGYAAAf/gBCCg4SFhoeIiYMGhRaMipCRkpOUlZaXmJmam5ydnpgdn6KjggIDAp6hpKuRAwgcHAUDnaqstoUCHS07vDs3s5u1lgW3lLk/vb0jnMKWFsWSAjDJvSEHwdDFAsjUvDGomc3O2ZDc3T4LmuKVz+SI0t29LeCX6+6eBfG9D+H3rAMm9O0QQQCUP1YdeAjkYDCRvYOQBHAQyONCvUwWISJKIEKgCXqTHmrU9ECgD2KV7D0aeYnALn0ogIVkSaqAD4EYUtIcNSCGQB0rI4k8NPQTAEwbQgj8AFKRuKLQABAoEECWMQUCe0CFsNXfhQkmwt5A0DSRgRUCYZQlSglBpQvt/ywNABu2LoetAQTukEDIXtdKbjMFqEvYRIkRCSIROCEwhcxJgW1BpVu4ro0Ajw856CEwLiLPtDzZqFx5QoG1ggbcENigUT9yAD6QJk1iw9FDF3Lo88BWVFBIkRUhmE26BIXfpTzE45F4J6bBxCvH0JAZwgAV1HxgQJ3KUlcAHThEL+3AkIFpvFSczoRSVPtKrnCML6wgI6EDDC5wp4Rco4EHo80XVgkYVOfcIH8pcsEIAtq134GeCBCBeA2Cxop9kvTnyQAS3CBgBdm8RxMABmBQwngKHJggJxcoEJ0G2axIjgOUEXZDQdlYeOAAFsRAWAnljYQhTf9NcIMCMm4iIv+ETDbp5JNQagLAlFRWaeWVVEYppQEFaBDAl2CGKeaYGhSAI0tLamKAl2O26SaYGpyppSQAUPXmnW2mSY6emQDAJp6AfqnBbXNGAkCgiH5JaKGK+JkooDAyKomdj77Jp6SCEEPAn5WKaYGBmBoyQJedwmlVqIekCYAArLbq6qutQrAoqrTWauutuELyTAEa3nJprqIkmSOwksVI7LGIwDUphBYMOUqvQrbFyq+FUKuRtTMhy1UnOiaiJ7QQdStJcJI0562SyGJ7ibqfOKttiLp6pxG5xTw0pGfiGiJsoRZ6Bm6o7O6077+CECyIX4QYHAm9muTLDCJdMayIw5AkZu53JO46BPFbF91DcV8bv6tTbyJnq2/JhuiJcKrnHruyJRfj+rLMr52M8sFOhXwzJDOLHLPNQG80Z8CF9LwzyUVv8nExS+ucdMNQLm00rU0HDbIkzlZdDNE4I81zoRlr7PXRViNIds5jn6220mtXYoDWa1/Qwb6jBAIAIfkEBQUACgAsNgAxAFoAZwAAB/+ACoKDhIWGh4iGAhcfLy8fHQYCiZSVlpeYlgFBR51HRgEDmaOkpZgXnJ6dQhemrq+uGaqqHLC2t5Uvs541uL6Vk6Mwu529v8eDAgsUIBHBlyfER8bIvgAXNzLaKBXPldHE1NW21zTa5zIBmOC74uOwH+jnLAnQ0u7vpgDm8toN9uHy3eLXb0YHS+xm4RM4CkC8ftpuILzHEFYEFBC1IfhGsaIrARwyyoAhKlFCVQs9YjrQQiQISid5qXxFQWSLeohiFpvpysALkbVydjy0gCclCSJRRBAa8BBOo4gGZMtYgmk7qKYizBBp4ZDOaVhLCWgg8gQBQ19TJlp6CwAAUgf/WIj08JZQWkNs8y2KsMGbJQwiVbSyO1SlgQAgEj/oUNcSgRoiPxQa1lSlAMSJM2tI0JgSgqRFB+kiZoJnhMyoEyMoSWnABJElnnGQ9u9SaFgAMKfOjGGBX0MdVIgsMChBKlVCnt7KiwgAht27A1zoXEhABZEYCFk4fkSIhd8CdUNHbUF5oQQnMmo4T6LGCw4XwJMyX2nD+PEFWBPKDbGFAYa3ZbLAfdBhEAF1Cggw1TkzSIBgWArklYAGBEY3XSEEfICRDDcw90qAxwiwwQMVpibBf+dFQJ8pKyIzgAPPlZhZAfJBSAoABiAgo2YP2qgAiJUAcACFO3roowItAtMBxIklSnDkLwMU0OSTRrqCowQEVvkkLIuIl9kDNW75igARxJjZYGJW82IAD0iQZJpwxinnnHTWaeedeOap55589unnn4AGKuighBZq6KGUvInooow26uijHikK6aNa/lnpMZJOqummnGYV6KW+gPpnpvkA+SippEaICHOpxgmilh6a6iesjdLKqK2L4oqorofyaqivhQJLqLCDEiuosZ+uWquytzIrp6yYIFsJtEdKa6mzloiaprWzYturt52Gy2irvWpbTSAAIfkEBQUAIwAsNwAxAFoAZwAAB/+AI4KDhIWGh4iGBx4THx4HBImSk5SVlpUIIiGbIRAIl6ChopcGmpybEAmjq6yrFKenIK2ztJMfsJwZtbuSACO+lxO4m7q8xoQXEggHoMLDxce8BhQT1RMawcMh0NG0BhzW1gWWzrjc3awAGOHWGZGU5bDn6Kvg7NUawJLxp/P0ovbufVA1iV+uf7PW3atGQR8ig8QQtjqw0FqEgtr8Sbz0oOKEBgL2ZdzIykAGj58SQdwmaQPJRAAkeHSncuQolxsJKPD4wCGhlRpHOHg5KYLHCRce2jRkgOgkAdQqeghpCKjTVRQ9Xqy6lBCzq5MCeGwwgOszsKNMepRg1hzYAxv/DvjsxcDjh6Y/u1L62oqAhACALSS1NGBnRQwOrXbDWSgm4McBEOCl1OEo4xG3zr7sALnzUEoCFC6sQOjVMFmVPrfa8LczZA0d5hY68MEjYwKmTkGYvFGDa9cS+CKygJJQgdydCsg2dPmQcEkIfv8uwLsQgYDsVAuaVpsCwUHPLVWfdED6bw0LqBoqsDBD2X/aLXE271rDBvWl7y341xyUAQb0AffdIAOI5sEFy4ESnzEHtBbgYwW8Q8gAFxCQICkSCRCBbw8CpsFWaFHS3yEEONDhYwyEKMmCkyQQ3YkjHhMjIuNZsoEFHY6jole0bBigjjsaQ0AB9M3Ii5HdAODism8WBMkfjo9pMKBTSPISgQQWUOfkllx26eWXYIYp5phklmnmmWimqeaabLbp5ptwxinnnKvUSOeXVd6pYp6z8KmnRH5yGSghdoY46J+IolloooyiE56MZj46iqQkhUepU5dOcihWbC4qEYvdZGrMjJ4OUmoop4YJKiWrhiKqKJv26WqsjdYaqq245qorIbT+2euuwAYr7LBgtoqWsbdu9CuxrCzL7LO1vgrtmanq6SwrgQAAIfkEBQUADQAsSAAxADoAIgAAB/+ADYKDhIWGgwAGGhQUGgkDAIeSk5SVhBE1NJo0NREClqChkwSZm5o1BKKqqxampharsaAUrpsUspWRqh61mreqAp+HiRsbBLqgvL2/oQ4fHxIDhQMFAdYBEciVyrXMlQIlQUPjKAvCAxbX1xeh3K7ekwIk4/RDPg7SDurXFsLbvTTgSdqwox49FgQEpNtnLUIygAINDYBhkF6PVAsZakj1b5klCUYqjvORSh9DawUsuTMVkZCBFCLHqfhEQMNJawk6dtsWc4iRlA0ALLgZQILOd5QO8OhZw98Amzc3UFppa9KAGz13sCO0gagGf4ao+prkAElPDoYEICC6YJLYgJLsCNDomYNjoQNe7RZ621KDuJgBJAGodpOBtkF8DxmA0HOGtLhQTx44lLiQAAU9hbSdBCACUQlgBVXmWqRnidASMzLsEBbiNBs9feS01PWmhseIXRMqIKSnglBqiTrYq1sQARU9geitlIBoAAOEaHkcFKBnEFiiAJg8iQBZq15GBQ0A0pMF7lA1iUIfVMoUKuqZHa7qTFTqIEzu5Qv60PMGalAK3TQZIQRYwIgFBmiDmUhFrCcLXhr9N0kCZlXkAS6CDLaPBgOqQkFv9chwniwCbFfAcqIg4MI4QbAwG4aDCGDAiLEQEIEFG0hoSCAAIfkEBQUAEgAsNwAxAFoAWgAAB/+AEoKDhIWGh4iGAwsICA4EAomSk5SVlpUHIw2bDSMXAJehoqOWA5qcmyMDpKytrAuoqBGutLWTCLGcDLa8vYK4uQ27oQCgvseDwLnDlh0eIw6RyL7KscyUJBAi2yUb073VqNeJACDb5yIoHdLfruG6mCno5zcDxu2s75vjhwIf8+dmrMLXSp8wSg5WANyGYiBBUgb5FSJgYuG2GA8LBjsoKYBFEStmZTyE4NZGiYMSqPiYYWSiDpIiJhJQ4aOMAxlhQjz5Up5FEC7z8Tw0AMdHFg6DhpJ5qMBHESWVjmI6EcZHG+ykXqI6CMCDjyt0al06lNCBGR8b3BtriasEASTmPqIwwEvsN7cRFFrEwHZqWQkDbHw8kVQrzrYbowpi8BFCAXdKI2wU+fbExxtZSXVQ/FDAKVSqkn1McaEW54yZQB8W5OGjgrV9RQmI0GhB4a8LZxCI/c2Az3kBeLfToPecicyC7BJEsBrZghr06ArHN2BDgebTsyNSrr279+/gw4tP/pD7Q+zj06tfz769+/fw48ufT7++/fv48+vfz7+///8ABtifedQIWAmBviBo4IIMNujgg7Ghp9RpEFZo4YUYBqjgfopRyGEhOElY34YZlmjiib6IeBeDJC7YIookgaciLTOOEggAIfkEBQUADgAsNwAxAFwAZwAAB/+ADoKDhIWGh4iGAhcRERcCAImSk5SVlpcGFgGbARYGl6ChoqECmpybFgKjq6ytF6enF62ztJUdsJwdtbu8hBG4m7q9w7S/wMKWBxoayMS2l8a4zZIAGCUm2BUJkc680bDTiRLY5CY3B92EC63fp+GHBjHl5B6q6cXAAe+GIPPkOPdqtctFacM1fyZw2AvIamCwSQMUIMQ2ghvDVQ71TSow0UQJWRfFTcq4TxCBCR0xWAwpiqSkAB1jfGKJMV/JA/ImWqDZ0CYiAR46ZljIM5TLQx06mohQtOaxQwM4dKzQ1Km0Qww6lkBXtaXPQgZwpOw66ighDB1vECDrAKQls4L/LtjoiACUARAcMKxtClfAiI4ciEoyUOHHjsNA1u1KcOnW00ERtJYkRECDi8OYd4jYK0kxr1fA3DqQOnEEJQELaGReHdiBBJqmTqWC3NEG40SLcPRYvVrEAF6TCWWSPVOQho4BBo/IwZs3D873RMft4Egwgok4fh8iYEFG8+YuCCzaJX3VgJzzChwSEOHF9+8jtLM1VOAgOQWKDmTg8Z63j+ytSHCbMxc0QM4I0DlAAAgi9McbCgUIFtd8gwiQQAcGrCQAAyo4uJoOIMiHSHBkGVCCDx5i1sMHxVEoigAppIgZDB1I2Et5xDQg4w4uSGCjJThW1UKKP8TnYi1D9tcD+Q4DHjlLBv3RsMCPszRZ1AEhNAeBBlQ6OYoAGKCIWQgKJOhlLQJIoEIIIsQQ5JloCtAlnHTWaeedeOap55589unnn4AGKuighBZq6KGIJqroopO8xuijkNbyZp2T+llppN2QyKemmNJiZVGOGnqppHmOWomp6XRQHqoXVVoSq5IEB2unoHgW0KybjhhSqILwyoutDuwzDbCsiOarIIx9OgmrwoICK669NPuotITiSO2i1yqarSXKBnTsM0hBui2i4x5a7iDfHtntIOciK2i7hMI7qLxsEQsKvYnY26ol+ELLFr7BzgcrwH8S7KfBotKq8MKIXNABp90EAgA7",
      style: {
        height: '35px',
        marginRight: '20px'
      }
    });
    this._loop_spinner_();
    this.content.appendChild(this.img);
    this.msg = new_dom_element({
      nodeName: 'span'
    });
    return this.content.appendChild(this.msg);
  };

  new_alert_msg.prototype._loop_spinner_ = function() {
    if (this.in_rotation === true) {
      return;
    }
    this.in_rotation = true;
    this.deg = (this.deg + 360) + 1;
    this.img.style.WebkitTransitionDuration = '2.2s';
    this.img.style.webkitTransform = "rotate(" + this.deg + "deg)";
    this.img.style.transitionTimingFunction = 'linear';
    if (this.rotatating === true) {
      return setTimeout(function() {
        this.in_rotation = false;
        return this._loop_spinner_();
      }, 2000);
    } else {
      return this.in_rotation = false;
    }
  };

  new_alert_msg.prototype.create_footer = function() {
    var b, btn, d, len, q, ref, results;
    this.footer = new_dom_element({
      style: {
        width: '100%',
        color: '#000',
        position: 'relative',
        padding: '15px',
        height: '100px'
      }
    });
    this.popup.appendChild(this.footer);
    ref = this.params.btn;
    results = [];
    for (q = 0, len = ref.length; q < len; q++) {
      btn = ref[q];
      d = new_dom_element({
        style: {
          width: (100 / this.params.btn.length) + "%",
          paddingRight: '5px',
          paddingLeft: '5px',
          float: 'left'
        }
      });
      b = new_dom_element({
        nodeName: 'button',
        innerHTML: btn.txt,
        onclick: btn.click,
        style: {
          display: "inline-block",
          padding: "6px 12px",
          marginBottom: "0",
          fontSize: "x-large",
          fontWeight: "400",
          height: '70px',
          lineHeight: "1.42857143",
          textAlign: "center",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          touchAction: "manipulation",
          cursor: "pointer",
          userSelect: "none",
          border: "1px solid transparent",
          borderRadius: "4px",
          width: "100%",
          backgroundColor: btn.backgroundColor,
          color: "#fff"
        }
      });
      this.footer.appendChild(d);
      results.push(d.appendChild(b));
    }
    return results;
  };

  new_alert_msg.prototype.hide_btn = function() {
    this.footer.style.display = 'none';
    return this.img.style.display = 'inline';
  };

  new_alert_msg.prototype.show_btn = function() {
    this.footer.style.display = 'block';
    return this.img.style.display = 'none';
  };

  new_alert_msg.prototype.hide = function() {
    this.background.style.display = 'none';
    return this.rotatating = false;
  };

  new_alert_msg.prototype.show = function() {
    this.background.style.display = 'block';
    this.rotatating = true;
    return this._loop_spinner_();
  };

  new_alert_msg.prototype.setMsg = function(msg) {
    return this.msg.innerHTML = msg;
  };

  return new_alert_msg;

})();

_index_current_popup = 10000;

spinal_new_popup = function(title, params) {
  var _drag_end_func, _drag_evt_func, b, clientX, clientY, close_element, extention, height, old_x, old_y, repos, res, t, top_x, top_y, w, width;
  if (params == null) {
    params = {};
  }
  if (params.popup_closer == null) {
    b = new_dom_element({
      parentNode: document.body,
      id: "popup_closer",
      onmousedown: function() {
        if (typeof params.onclose === "function") {
          params.onclose();
        }
        document.body.removeChild(b);
        return document.body.removeChild(w);
      },
      ondrop: function(evt) {
        if (!evt) {
          evt = window.event;
        }
        evt.cancelBubble = true;
        if (typeof evt.stopPropagation === "function") {
          evt.stopPropagation();
        }
        if (typeof evt.preventDefault === "function") {
          evt.preventDefault();
        }
        if (typeof evt.stopImmediatePropagation === "function") {
          evt.stopImmediatePropagation();
        }
        return false;
      },
      style: {
        position: "fixed",
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        background: params.fixed_opacity || "#000",
        opacity: params.fixed_opacity || 0,
        zIndex: _index_current_popup
      }
    });
  }
  if ((params.event != null) && params.event.clientX) {
    clientX = params.event.clientX;
    clientY = params.event.clientY;
  } else {
    clientX = window.innerWidth / 2 - 10;
    clientY = window.innerHeight / 2 - 10;
  }
  top_x = params.top_x || -1000;
  top_y = params.top_y || -1000;
  old_x = 0;
  old_y = 0;
  w = void 0;
  if (params.width != null) {
    width = params.width;
  }
  if (params.height != null) {
    height = params.height;
  }
  repos = function() {
    top_x = clientX - w.clientWidth / 2;
    top_y = clientY - w.clientHeight / 2;
    if ((top_x + w.clientWidth) > window.innerWidth) {
      top_x = window.innerWidth - w.clientWidth - 50;
    }
    if ((top_y + w.clientHeight) > window.innerHeight) {
      top_y = window.innerHeight - w.clientHeight + 50;
    }
    if (top_x < 50) {
      top_x = 50;
    }
    if (top_y < 50) {
      top_y = 50;
    }
    w.style.left = top_x;
    return w.style.top = top_y;
  };
  _drag_evt_func = function(evt) {
    top_x += evt.clientX - old_x;
    top_y += evt.clientY - old_y;
    w.style.left = top_x;
    w.style.top = top_y;
    old_x = evt.clientX;
    old_y = evt.clientY;
    return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
  };
  _drag_end_func = function(evt) {
    if (typeof document.detachEvent === "function") {
      document.detachEvent("onmousemove", _drag_evt_func);
    }
    if (typeof document.detachEvent === "function") {
      document.detachEvent("onmouseup", _drag_end_func);
    }
    if (typeof document.removeEventListener === "function") {
      document.removeEventListener("mousemove", _drag_evt_func, true);
    }
    return typeof document.removeEventListener === "function" ? document.removeEventListener("mouseup", _drag_end_func, true) : void 0;
  };
  extention = "px";
  if (!params.top_x) {
    setTimeout(repos, 1);
    extention = "%";
  }
  w = new_dom_element({
    parentNode: document.body,
    className: "Popup",
    style: {
      position: "absolute",
      left: top_x,
      top: top_y,
      width: width + extention,
      height: height + extention,
      zIndex: _index_current_popup + 1,
      border: 'thin solid black',
      background: '#e5e5e5',
      resize: 'both',
      overflow: 'auto',
      paddingBottom: '8px'
    }
  });
  _index_current_popup += 2;
  close_element = new_dom_element({
    parentNode: w,
    className: "PopupClose",
    txt: "Close",
    style: {
      float: 'right',
      marginRight: '4px',
      marginTop: '4px',
      cursor: 'pointer'
    },
    onmousedown: function(evt) {
      if (typeof params.onclose === "function") {
        params.onclose();
      }
      if (b != null) {
        document.body.removeChild(b);
      }
      return document.body.removeChild(w);
    }
  });
  if (title) {
    t = new_dom_element({
      parentNode: w,
      className: "PopupTitle",
      innerHTML: title,
      style: {
        background: '#262626',
        padding: '5 10 3 10',
        height: '22px',
        fontSize: '12px',
        borderBottom: 'thin solid black',
        cursor: 'pointer',
        color: 'white'
      },
      onmousedown: function(evt) {
        old_x = evt.clientX;
        old_y = evt.clientY;
        top_x = parseInt(w.style.left);
        top_y = parseInt(w.style.top);
        document.addEventListener("mousemove", _drag_evt_func, true);
        document.addEventListener("mouseup", _drag_end_func, true);
        return typeof evt.preventDefault === "function" ? evt.preventDefault() : void 0;
      }
    });
  }
  res = new_dom_element({
    parentNode: w,
    className: "PopupWindow",
    style: {
      padding: "6px",
      height: '100%',
      color: '#262626'
    }
  });
  if (params.child != null) {
    res.appendChild(params.child);
  }
  return res;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":3,"url":11,"xhr2":17}],10:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":3,"timers":10}],11:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":12,"punycode":4,"querystring":8}],12:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],13:[function(require,module,exports){
var Vue // late bind
var version
var map = (window.__VUE_HOT_MAP__ = Object.create(null))
var installed = false
var isBrowserify = false
var initHookName = 'beforeCreate'

exports.install = function (vue, browserify) {
  if (installed) { return }
  installed = true

  Vue = vue.__esModule ? vue.default : vue
  version = Vue.version.split('.').map(Number)
  isBrowserify = browserify

  // compat with < 2.0.0-alpha.7
  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init'
  }

  exports.compatible = version[0] >= 2
  if (!exports.compatible) {
    console.warn(
      '[HMR] You are using a version of vue-hot-reload-api that is ' +
        'only compatible with Vue.js core ^2.0.0.'
    )
    return
  }
}

/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if(map[id]) { return }
  
  var Ctor = null
  if (typeof options === 'function') {
    Ctor = options
    options = Ctor.options
  }
  makeOptionsHot(id, options)
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  }
}

/**
 * Check if module is recorded
 *
 * @param {String} id
 */

exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined'
}

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render
    options.render = function (h, ctx) {
      var instances = map[id].instances
      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent)
      }
      return render(h, ctx)
    }
  } else {
    injectHook(options, initHookName, function() {
      var record = map[id]
      if (!record.Ctor) {
        record.Ctor = this.constructor
      }
      record.instances.push(this)
    })
    injectHook(options, 'beforeDestroy', function() {
      var instances = map[id].instances
      instances.splice(instances.indexOf(this), 1)
    })
  }
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook(options, name, hook) {
  var existing = options[name]
  options[name] = existing
    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]
    : [hook]
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg)
    } catch (e) {
      console.error(e)
      console.warn(
        'Something went wrong during Vue component hot-reload. Full reload required.'
      )
    }
  }
}

function updateOptions (oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key]
    }
  }
  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1]
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id]
  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate()
    })
    return
  }
  if (typeof options === 'function') {
    options = options.options
  }
  if (record.Ctor) {
    record.Ctor.options.render = options.render
    record.Ctor.options.staticRenderFns = options.staticRenderFns
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render
      instance.$options.staticRenderFns = options.staticRenderFns
      // reset static trees
      // pre 2.5, all static trees are cahced together on the instance
      if (instance._staticTrees) {
        instance._staticTrees = []
      }
      // 2.5.0
      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = []
      }
      // 2.5.3
      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = []
      }
      // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)
      instance.$forceUpdate()
    })
  } else {
    // functional or no instance created yet
    record.options.render = options.render
    record.options.staticRenderFns = options.staticRenderFns

    // handle functional component re-render
    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options)
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles
        if (injectStyles) {
          var render = options.render
          record.options.render = function (h, ctx) {
            injectStyles.call(ctx)
            return render(h, ctx)
          }
        }
      }
      record.options._Ctor = null
      // 2.5.3
      if (Array.isArray(record.options.cached)) {
        record.options.cached = []
      }
      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate()
      })
    }
  }
})

exports.reload = tryWrap(function (id, options) {
  var record = map[id]
  if (options) {
    if (typeof options === 'function') {
      options = options.options
    }
    makeOptionsHot(id, options)
    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options
      }
      var newCtor = record.Ctor.super.extend(options)
      record.Ctor.options = newCtor.options
      record.Ctor.cid = newCtor.cid
      record.Ctor.prototype = newCtor.prototype
      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release()
      }
    } else {
      updateOptions(record.options, options)
    }
  }
  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate()
    } else {
      console.warn(
        'Root or manually mounted instance modified. Full reload required.'
      )
    }
  })
})

},{}],14:[function(require,module,exports){
/*!
 * vue-material v1.0.0-beta-8
 * Made with <3 by marcosmoura 2018
 * Released under the MIT License.
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"));
	else if(typeof define === 'function' && define.amd)
		define(["vue"], factory);
	else if(typeof exports === 'object')
		exports["VueMaterial"] = factory(require("vue"));
	else
		root["VueMaterial"] = factory(root["Vue"]);
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 54);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(56);

var _MdReactive = __webpack_require__(28);

var _MdReactive2 = _interopRequireDefault(_MdReactive);

var _MdTheme = __webpack_require__(29);

var _MdTheme2 = _interopRequireDefault(_MdTheme);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var init = function init() {
  var material = new _MdReactive2.default({
    ripple: true,
    theming: {},
    locale: {
      startYear: 1900,
      endYear: 2099,
      dateFormat: 'YYYY-MM-DD',
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      shorterDays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'],
      shorterMonths: ['J', 'F', 'M', 'A', 'M', 'Ju', 'Ju', 'A', 'Se', 'O', 'N', 'D'],
      firstDayOfAWeek: 0
    }
  });

  Object.defineProperties(material.theming, {
    metaColors: {
      get: function get() {
        return _MdTheme2.default.metaColors;
      },
      set: function set(metaColors) {
        _MdTheme2.default.metaColors = metaColors;
      }
    },
    theme: {
      get: function get() {
        return _MdTheme2.default.theme;
      },
      set: function set(theme) {
        _MdTheme2.default.theme = theme;
      }
    },
    enabled: {
      get: function get() {
        return _MdTheme2.default.enabled;
      },
      set: function set(enabled) {
        _MdTheme2.default.enabled = enabled;
      }
    }
  });

  return material;
};

exports.default = function (Vue) {
  if (!Vue.material) {
    Vue.material = init();
    Vue.prototype.$material = Vue.material;
  }
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (newComponent) {
  var defaults = {
    props: {
      mdTheme: null
    },
    computed: {
      $mdActiveTheme: function $mdActiveTheme() {
        var enabled = _MdTheme2.default.enabled,
            getThemeName = _MdTheme2.default.getThemeName,
            getAncestorTheme = _MdTheme2.default.getAncestorTheme;


        if (enabled && this.mdTheme !== false) {
          return getThemeName(this.mdTheme || getAncestorTheme(this));
        }

        return null;
      }
    }
  };

  return (0, _deepmerge2.default)(defaults, newComponent);
};

var _MdTheme = __webpack_require__(29);

var _MdTheme2 = _interopRequireDefault(_MdTheme);

var _deepmerge = __webpack_require__(30);

var _deepmerge2 = _interopRequireDefault(_deepmerge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var isDate = __webpack_require__(36)

var MILLISECONDS_IN_HOUR = 3600000
var MILLISECONDS_IN_MINUTE = 60000
var DEFAULT_ADDITIONAL_DIGITS = 2

var parseTokenDateTimeDelimeter = /[T ]/
var parseTokenPlainTime = /:/

// year tokens
var parseTokenYY = /^(\d{2})$/
var parseTokensYYY = [
  /^([+-]\d{2})$/, // 0 additional digits
  /^([+-]\d{3})$/, // 1 additional digit
  /^([+-]\d{4})$/ // 2 additional digits
]

var parseTokenYYYY = /^(\d{4})/
var parseTokensYYYYY = [
  /^([+-]\d{4})/, // 0 additional digits
  /^([+-]\d{5})/, // 1 additional digit
  /^([+-]\d{6})/ // 2 additional digits
]

// date tokens
var parseTokenMM = /^-(\d{2})$/
var parseTokenDDD = /^-?(\d{3})$/
var parseTokenMMDD = /^-?(\d{2})-?(\d{2})$/
var parseTokenWww = /^-?W(\d{2})$/
var parseTokenWwwD = /^-?W(\d{2})-?(\d{1})$/

// time tokens
var parseTokenHH = /^(\d{2}([.,]\d*)?)$/
var parseTokenHHMM = /^(\d{2}):?(\d{2}([.,]\d*)?)$/
var parseTokenHHMMSS = /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/

// timezone tokens
var parseTokenTimezone = /([Z+-].*)$/
var parseTokenTimezoneZ = /^(Z)$/
var parseTokenTimezoneHH = /^([+-])(\d{2})$/
var parseTokenTimezoneHHMM = /^([+-])(\d{2}):?(\d{2})$/

/**
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * @param {Date|String|Number} argument - the value to convert
 * @param {Object} [options] - the object with options
 * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parse('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Parse string '+02014101',
 * // if the additional number of digits in the extended year format is 1:
 * var result = parse('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */
function parse (argument, dirtyOptions) {
  if (isDate(argument)) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime())
  } else if (typeof argument !== 'string') {
    return new Date(argument)
  }

  var options = dirtyOptions || {}
  var additionalDigits = options.additionalDigits
  if (additionalDigits == null) {
    additionalDigits = DEFAULT_ADDITIONAL_DIGITS
  } else {
    additionalDigits = Number(additionalDigits)
  }

  var dateStrings = splitDateString(argument)

  var parseYearResult = parseYear(dateStrings.date, additionalDigits)
  var year = parseYearResult.year
  var restDateString = parseYearResult.restDateString

  var date = parseDate(restDateString, year)

  if (date) {
    var timestamp = date.getTime()
    var time = 0
    var offset

    if (dateStrings.time) {
      time = parseTime(dateStrings.time)
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone)
    } else {
      // get offset accurate to hour in timezones that change offset
      offset = new Date(timestamp + time).getTimezoneOffset()
      offset = new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE).getTimezoneOffset()
    }

    return new Date(timestamp + time + offset * MILLISECONDS_IN_MINUTE)
  } else {
    return new Date(argument)
  }
}

function splitDateString (dateString) {
  var dateStrings = {}
  var array = dateString.split(parseTokenDateTimeDelimeter)
  var timeString

  if (parseTokenPlainTime.test(array[0])) {
    dateStrings.date = null
    timeString = array[0]
  } else {
    dateStrings.date = array[0]
    timeString = array[1]
  }

  if (timeString) {
    var token = parseTokenTimezone.exec(timeString)
    if (token) {
      dateStrings.time = timeString.replace(token[1], '')
      dateStrings.timezone = token[1]
    } else {
      dateStrings.time = timeString
    }
  }

  return dateStrings
}

function parseYear (dateString, additionalDigits) {
  var parseTokenYYY = parseTokensYYY[additionalDigits]
  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits]

  var token

  // YYYY or ±YYYYY
  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)
  if (token) {
    var yearString = token[1]
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    }
  }

  // YY or ±YYY
  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)
  if (token) {
    var centuryString = token[1]
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    }
  }

  // Invalid ISO-formatted year
  return {
    year: null
  }
}

function parseDate (dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) {
    return null
  }

  var token
  var date
  var month
  var week

  // YYYY
  if (dateString.length === 0) {
    date = new Date(0)
    date.setUTCFullYear(year)
    return date
  }

  // YYYY-MM
  token = parseTokenMM.exec(dateString)
  if (token) {
    date = new Date(0)
    month = parseInt(token[1], 10) - 1
    date.setUTCFullYear(year, month)
    return date
  }

  // YYYY-DDD or YYYYDDD
  token = parseTokenDDD.exec(dateString)
  if (token) {
    date = new Date(0)
    var dayOfYear = parseInt(token[1], 10)
    date.setUTCFullYear(year, 0, dayOfYear)
    return date
  }

  // YYYY-MM-DD or YYYYMMDD
  token = parseTokenMMDD.exec(dateString)
  if (token) {
    date = new Date(0)
    month = parseInt(token[1], 10) - 1
    var day = parseInt(token[2], 10)
    date.setUTCFullYear(year, month, day)
    return date
  }

  // YYYY-Www or YYYYWww
  token = parseTokenWww.exec(dateString)
  if (token) {
    week = parseInt(token[1], 10) - 1
    return dayOfISOYear(year, week)
  }

  // YYYY-Www-D or YYYYWwwD
  token = parseTokenWwwD.exec(dateString)
  if (token) {
    week = parseInt(token[1], 10) - 1
    var dayOfWeek = parseInt(token[2], 10) - 1
    return dayOfISOYear(year, week, dayOfWeek)
  }

  // Invalid ISO-formatted date
  return null
}

function parseTime (timeString) {
  var token
  var hours
  var minutes

  // hh
  token = parseTokenHH.exec(timeString)
  if (token) {
    hours = parseFloat(token[1].replace(',', '.'))
    return (hours % 24) * MILLISECONDS_IN_HOUR
  }

  // hh:mm or hhmm
  token = parseTokenHHMM.exec(timeString)
  if (token) {
    hours = parseInt(token[1], 10)
    minutes = parseFloat(token[2].replace(',', '.'))
    return (hours % 24) * MILLISECONDS_IN_HOUR +
      minutes * MILLISECONDS_IN_MINUTE
  }

  // hh:mm:ss or hhmmss
  token = parseTokenHHMMSS.exec(timeString)
  if (token) {
    hours = parseInt(token[1], 10)
    minutes = parseInt(token[2], 10)
    var seconds = parseFloat(token[3].replace(',', '.'))
    return (hours % 24) * MILLISECONDS_IN_HOUR +
      minutes * MILLISECONDS_IN_MINUTE +
      seconds * 1000
  }

  // Invalid ISO-formatted time
  return null
}

function parseTimezone (timezoneString) {
  var token
  var absoluteOffset

  // Z
  token = parseTokenTimezoneZ.exec(timezoneString)
  if (token) {
    return 0
  }

  // ±hh
  token = parseTokenTimezoneHH.exec(timezoneString)
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60
    return (token[1] === '+') ? -absoluteOffset : absoluteOffset
  }

  // ±hh:mm or ±hhmm
  token = parseTokenTimezoneHHMM.exec(timezoneString)
  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)
    return (token[1] === '+') ? -absoluteOffset : absoluteOffset
  }

  return 0
}

function dayOfISOYear (isoYear, week, day) {
  week = week || 0
  day = day || 0
  var date = new Date(0)
  date.setUTCFullYear(isoYear, 0, 4)
  var fourthOfJanuaryDay = date.getUTCDay() || 7
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay
  date.setUTCDate(date.getUTCDate() + diff)
  return date
}

module.exports = parse


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (name, options) {
  return {
    validator: function validator(value) {
      if (options.includes(value)) {
        return true;
      }

      _vue2.default.util.warn('The ' + name + ' prop is invalid. Given value: ' + value + '. Available options: ' + options.join(', ') + '.', undefined);

      return false;
    }
  };
};

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdIcon/MdIcon.vue
var MdIcon = __webpack_require__(151);
var MdIcon_default = /*#__PURE__*/__webpack_require__.n(MdIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-59c14b8f","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdIcon/MdIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.mdSrc
    ? _c("md-svg-loader", {
        staticClass: "md-icon md-icon-image",
        class: [_vm.$mdActiveTheme],
        attrs: { "md-src": _vm.mdSrc },
        on: {
          "md-loaded": function($event) {
            _vm.$emit("md-loaded")
          }
        }
      })
    : _c(
        "i",
        { staticClass: "md-icon md-icon-font", class: [_vm.$mdActiveTheme] },
        [_vm._t("default")],
        2
      )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdIcon_MdIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-59c14b8f", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdIcon/MdIcon.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(150)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdIcon_default.a,
  MdIcon_MdIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdIcon/MdIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-59c14b8f", Component.options)
  } else {
    hotAPI.reload("data-v-59c14b8f", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdIcon_MdIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var MdUuid = function MdUuid() {
  return Math.random().toString(36).slice(4);
};

exports.default = MdUuid;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdRipple/MdRipple.vue
var MdRipple = __webpack_require__(93);
var MdRipple_default = /*#__PURE__*/__webpack_require__.n(MdRipple);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7692b1af","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdRipple/MdRipple.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      class: ["md-ripple", _vm.rippleClasses],
      on: {
        "&touchstart": function($event) {
          $event.stopPropagation()
          _vm.touchStartCheck($event)
        },
        "&touchmove": function($event) {
          $event.stopPropagation()
          _vm.touchMoveCheck($event)
        },
        "&touchend": function($event) {
          $event.stopPropagation()
          _vm.clearWave($event)
        },
        "&mousedown": function($event) {
          $event.stopPropagation()
          _vm.startRipple($event)
        },
        "&mouseup": function($event) {
          $event.stopPropagation()
          _vm.clearWave($event)
        }
      }
    },
    [
      _vm._t("default"),
      _vm._v(" "),
      !_vm.isDisabled
        ? _c(
            "transition-group",
            { attrs: { name: "md-ripple" } },
            _vm._l(_vm.ripples, function(ripple, index) {
              return _c("span", {
                key: "ripple" + index,
                class: ["md-ripple-wave", _vm.waveClasses],
                style: ripple.waveStyles
              })
            })
          )
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdRipple_MdRipple = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7692b1af", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdRipple/MdRipple.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(92)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdRipple_default.a,
  MdRipple_MdRipple,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdRipple/MdRipple.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7692b1af", Component.options)
  } else {
    hotAPI.reload("data-v-7692b1af", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdRipple_MdRipple = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var now = __webpack_require__(65)
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function(object) {
  if (!object) {
    object = root;
  }
  object.requestAnimationFrame = raf
  object.cancelAnimationFrame = caf
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialog.vue
var MdDialog = __webpack_require__(206);
var MdDialog_default = /*#__PURE__*/__webpack_require__.n(MdDialog);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-f080a6a2","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialog.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-portal",
    [
      _c("transition", { attrs: { name: "md-dialog" } }, [
        _vm.mdActive
          ? _c(
              "div",
              _vm._g(
                {
                  staticClass: "md-dialog",
                  class: [_vm.dialogClasses, _vm.$mdActiveTheme],
                  on: {
                    keydown: function($event) {
                      if (
                        !("button" in $event) &&
                        _vm._k($event.keyCode, "esc", 27, $event.key)
                      ) {
                        return null
                      }
                      _vm.onEsc($event)
                    }
                  }
                },
                _vm.$listeners
              ),
              [
                _c("md-focus-trap", [
                  _c(
                    "div",
                    { staticClass: "md-dialog-container" },
                    [
                      _vm._t("default"),
                      _vm._v(" "),
                      _c(
                        "keep-alive",
                        [
                          _vm.mdBackdrop
                            ? _c("md-overlay", {
                                class: _vm.mdBackdropClass,
                                attrs: {
                                  "md-fixed": "",
                                  "md-active": _vm.mdActive
                                },
                                on: { click: _vm.onClick }
                              })
                            : _vm._e()
                        ],
                        1
                      )
                    ],
                    2
                  )
                ])
              ],
              1
            )
          : _vm._e()
      ])
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialog_MdDialog = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f080a6a2", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialog.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(205)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialog_default.a,
  MdDialog_MdDialog,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialog.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f080a6a2", Component.options)
  } else {
    hotAPI.reload("data-v-f080a6a2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDialog_MdDialog = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdRipple = __webpack_require__(19);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

var _MdListItemContent = __webpack_require__(283);

var _MdListItemContent2 = _interopRequireDefault(_MdListItemContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  mixins: [_MdRipple2.default],
  components: {
    MdListItemContent: _MdListItemContent2.default
  },
  props: {
    disabled: Boolean
  },
  computed: {
    isDisabled: function isDisabled() {
      return !this.mdRipple || this.disabled;
    }
  }
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function (context, props) {
  return _extends({}, props, context.$options.components['router-link'].options.props);
};

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdButton_vue__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdButton_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdButton_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(98)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdButton_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdButton/MdButton.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7d2cd822", Component.options)
  } else {
    hotAPI.reload("data-v-7d2cd822", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdInput/MdInput.vue
var MdInput = __webpack_require__(159);
var MdInput_default = /*#__PURE__*/__webpack_require__.n(MdInput);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-69de42aa","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdInput/MdInput.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "input",
    _vm._g(
      _vm._b(
        {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.model,
              expression: "model"
            }
          ],
          staticClass: "md-input",
          domProps: { value: _vm.model },
          on: {
            focus: _vm.onFocus,
            blur: _vm.onBlur,
            input: function($event) {
              if ($event.target.composing) {
                return
              }
              _vm.model = $event.target.value
            }
          }
        },
        "input",
        _vm.attributes,
        false
      ),
      _vm.listeners
    )
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdInput_MdInput = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-69de42aa", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdInput/MdInput.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdInput_default.a,
  MdInput_MdInput,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdInput/MdInput.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-69de42aa", Component.options)
  } else {
    hotAPI.reload("data-v-69de42aa", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdInput_MdInput = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = {
  props: {
    value: {},
    placeholder: String,
    name: String,
    maxlength: [String, Number],
    readonly: Boolean,
    required: Boolean,
    disabled: Boolean,
    mdCounter: [String, Number]
  },
  data: function data() {
    return {
      localValue: this.value,
      textareaHeight: false
    };
  },

  computed: {
    model: {
      get: function get() {
        return this.localValue;
      },
      set: function set(value) {
        var _this = this;

        if (value.constructor.name.toLowerCase() !== 'inputevent') {
          this.$nextTick(function () {
            _this.localValue = value;
          });
        }
      }
    },
    clear: function clear() {
      return this.MdField.clear;
    },
    attributes: function attributes() {
      return _extends({}, this.$attrs, {
        type: this.type,
        id: this.id,
        name: this.name,
        disabled: this.disabled,
        required: this.required,
        placeholder: this.placeholder,
        readonly: this.readonly,
        maxlength: this.maxlength
      });
    }
  },
  watch: {
    model: function model() {
      this.setFieldValue();
    },
    clear: function clear(_clear) {
      if (_clear) {
        this.clearField();
      }
    },
    placeholder: function placeholder() {
      this.setPlaceholder();
    },
    disabled: function disabled() {
      this.setDisabled();
    },
    required: function required() {
      this.setRequired();
    },
    maxlength: function maxlength() {
      this.setMaxlength();
    },
    mdCounter: function mdCounter() {
      this.setMaxlength();
    },
    localValue: function localValue(val) {
      this.$emit('input', val);
    },
    value: function value(val) {
      this.localValue = val;
    }
  },
  methods: {
    clearField: function clearField() {
      this.$el.value = '';
      this.model = '';
      this.setFieldValue();
    },
    setLabelFor: function setLabelFor() {
      if (this.$el.parentNode) {
        var label = this.$el.parentNode.querySelector('label');

        if (label) {
          var forAttribute = label.getAttribute('for');

          if (!forAttribute || forAttribute.indexOf('md-') >= 0) {
            label.setAttribute('for', this.id);
          }
        }
      }
    },
    setFieldValue: function setFieldValue() {
      this.MdField.value = this.model;
    },
    setPlaceholder: function setPlaceholder() {
      this.MdField.placeholder = Boolean(this.placeholder);
    },
    setDisabled: function setDisabled() {
      this.MdField.disabled = Boolean(this.disabled);
    },
    setRequired: function setRequired() {
      this.MdField.required = Boolean(this.required);
    },
    setMaxlength: function setMaxlength() {
      if (this.mdCounter) {
        this.MdField.counter = parseInt(this.mdCounter, 10);
      } else {
        this.MdField.maxlength = parseInt(this.maxlength, 10);
      }
    },
    onFocus: function onFocus() {
      this.MdField.focused = true;
    },
    onBlur: function onBlur() {
      this.MdField.focused = false;
    }
  },
  created: function created() {
    this.setFieldValue();
    this.setPlaceholder();
    this.setDisabled();
    this.setRequired();
    this.setMaxlength();
  },
  mounted: function mounted() {
    this.setLabelFor();
  }
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'MdPortal',
  abstract: true,
  props: {
    mdAttachToParent: Boolean,
    mdTarget: {
      type: null,
      validator: function validator(value) {
        if (HTMLElement && value && value instanceof HTMLElement) {
          return true;
        }

        _vue2.default.util.warn('The md-target-el prop is invalid. You should pass a valid HTMLElement.', this);

        return false;
      }
    }
  },
  data: function data() {
    return {
      leaveTimeout: null,
      originalParentEl: null
    };
  },
  computed: {
    transitionName: function transitionName() {
      var childrenComponent = this._vnode.componentOptions.children[0];

      if (childrenComponent) {
        var transition = childrenComponent.data.transition;

        if (transition) {
          return transition.name;
        } else {
          var _transition = childrenComponent.componentOptions.propsData.name;

          if (_transition) {
            return _transition;
          }
        }
      }

      return 'v';
    },
    leaveClass: function leaveClass() {
      return this.transitionName + '-leave';
    },
    leaveActiveClass: function leaveActiveClass() {
      return this.transitionName + '-leave-active';
    },
    leaveToClass: function leaveToClass() {
      return this.transitionName + '-leave-to';
    }
  },
  watch: {
    mdTarget: function mdTarget(newTarget, oldTarget) {
      this.changeParentEl(newTarget);

      if (oldTarget) {
        this.$forceUpdate();
      }
    }
  },
  methods: {
    getTransitionDuration: function getTransitionDuration(el) {
      var duration = getComputedStyle(el).transitionDuration;
      var num = parseFloat(duration, 10);
      var unit = duration.match(/m?s/);
      var milliseconds = null;

      if (unit) {
        unit = unit[0];
      }

      switch (unit) {
        case 's':
          milliseconds = num * 1000;
          break;

        case 'ms':
          milliseconds = num;
          break;

        default:
          milliseconds = 0;
          break;
      }

      return milliseconds;
    },
    killGhostElement: function killGhostElement(el) {
      if (el.parentNode) {
        this.changeParentEl(this.originalParentEl);
        this.$options._parentElm = this.originalParentEl;
        el.parentNode.removeChild(el);
      }
    },
    initDestroy: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(manualCall) {
        var _this = this;

        var el;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                el = this.$el;


                if (manualCall && this.$el.nodeType === Node.COMMENT_NODE) {
                  el = this.$vnode.elm;
                }

                el.classList.add(this.leaveClass);
                el.classList.add(this.leaveActiveClass);
                _context.next = 6;
                return this.$nextTick();

              case 6:
                el.classList.add(this.leaveToClass);

                clearTimeout(this.leaveTimeout);
                this.leaveTimeout = setTimeout(function () {
                  _this.destroyElement(el);
                }, this.getTransitionDuration(el));

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function initDestroy(_x) {
        return _ref.apply(this, arguments);
      }

      return initDestroy;
    }(),
    destroyElement: function destroyElement(el) {
      var _this2 = this;

      requestAnimationFrame(function () {
        el.classList.remove(_this2.leaveClass);
        el.classList.remove(_this2.leaveActiveClass);
        el.classList.remove(_this2.leaveToClass);
        _this2.$emit('md-destroy');
        _this2.killGhostElement(el);
      });
    },
    changeParentEl: function changeParentEl(newTarget) {
      newTarget && newTarget.appendChild(this.$el);
    }
  },
  mounted: function mounted() {
    if (!this.originalParentEl) {
      this.originalParentEl = this.$el.parentNode;
      this.$emit('md-initial-parent', this.$el.parentNode);
    }

    if (this.mdAttachToParent && this.$el.parentNode.parentNode) {
      this.changeParentEl(this.$el.parentNode.parentNode);
    } else if (document) {
      this.changeParentEl(this.mdTarget || document.body);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.$el.classList) {
      this.initDestroy();
    } else {
      this.killGhostElement(this.$el);
    }
  },
  render: function render(createElement) {
    var defaultSlot = this.$slots.default;

    if (defaultSlot && defaultSlot[0]) {
      return defaultSlot[0];
    }
  }
};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  methods: {
    isAssetIcon: function isAssetIcon(icon) {
      return (/\w+[/\\.]\w+/.test(icon)
      );
    }
  }
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    mdRipple: {
      type: Boolean,
      default: true
    }
  }
};

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdField.vue
var MdField = __webpack_require__(148);
var MdField_default = /*#__PURE__*/__webpack_require__.n(MdField);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2ecd7b97","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdField.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-field",
      class: [_vm.$mdActiveTheme, _vm.fieldClasses],
      on: { blur: _vm.onBlur }
    },
    [
      _vm._t("default"),
      _vm._v(" "),
      _vm.hasCounter
        ? _c("span", { staticClass: "md-count" }, [
            _vm._v(
              _vm._s(_vm.valueLength) +
                " / " +
                _vm._s(_vm.MdField.maxlength || _vm.MdField.counter)
            )
          ])
        : _vm._e(),
      _vm._v(" "),
      _c(
        "transition",
        { attrs: { name: "md-input-action", appear: "" } },
        [
          _vm.hasValue && _vm.mdClearable
            ? _c(
                "md-button",
                {
                  staticClass:
                    "md-icon-button md-dense md-input-action md-clear",
                  attrs: { tabindex: "-1", disabled: _vm.MdField.disabled },
                  on: { click: _vm.clearInput }
                },
                [_c("md-clear-icon")],
                1
              )
            : _vm._e()
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "transition",
        { attrs: { name: "md-input-action", appear: "" } },
        [
          _vm.hasPasswordToggle
            ? _c(
                "md-button",
                {
                  staticClass:
                    "md-icon-button md-dense md-input-action md-toggle-password",
                  attrs: { tabindex: "-1" },
                  on: { click: _vm.togglePassword }
                },
                [
                  _vm.MdField.togglePassword
                    ? _c("md-password-off-icon")
                    : _c("md-password-on-icon")
                ],
                1
              )
            : _vm._e()
        ],
        1
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdField_MdField = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2ecd7b97", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdField.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(147)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdField_default.a,
  MdField_MdField,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdField.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2ecd7b97", Component.options)
  } else {
    hotAPI.reload("data-v-2ecd7b97", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdField_MdField = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * var result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay (dirtyDate) {
  var date = parse(dirtyDate)
  date.setHours(0, 0, 0, 0)
  return date
}

module.exports = startOfDay


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var startOfWeek = __webpack_require__(175)

/**
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * var result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek (dirtyDate) {
  return startOfWeek(dirtyDate, {weekStartsOn: 1})
}

module.exports = startOfISOWeek


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdOverlay/MdOverlay.vue
var MdOverlay = __webpack_require__(182);
var MdOverlay_default = /*#__PURE__*/__webpack_require__.n(MdOverlay);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-0e05c97a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdOverlay/MdOverlay.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-portal",
    { attrs: { "md-attach-to-parent": _vm.mdAttachToParent } },
    [
      _c("transition", { attrs: { name: "md-overlay" } }, [
        _vm.mdActive
          ? _c(
              "div",
              _vm._g(
                { staticClass: "md-overlay", class: _vm.overlayClasses },
                _vm.$listeners
              )
            )
          : _vm._e()
      ])
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdOverlay_MdOverlay = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0e05c97a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdOverlay/MdOverlay.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(181)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdOverlay_default.a,
  MdOverlay_MdOverlay,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdOverlay/MdOverlay.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0e05c97a", Component.options)
  } else {
    hotAPI.reload("data-v-0e05c97a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdOverlay_MdOverlay = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * var result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */
function getDaysInMonth (dirtyDate) {
  var date = parse(dirtyDate)
  var year = date.getFullYear()
  var monthIndex = date.getMonth()
  var lastDayOfMonth = new Date(0)
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0)
  lastDayOfMonth.setHours(0, 0, 0, 0)
  return lastDayOfMonth.getDate()
}

module.exports = getDaysInMonth


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdPopover_vue__ = __webpack_require__(199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdPopover_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdPopover_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(198)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdPopover_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdPopover/MdPopover.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d36236a6", Component.options)
  } else {
    hotAPI.reload("data-v-d36236a6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (el, config, cb) {
  if ('MutationObserver' in window) {
    var observer = new window.MutationObserver(cb);

    observer.observe(el, config);

    return {
      disconnect: function disconnect() {
        observer.disconnect();
      }
    };
  }
};

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableHead.vue
var MdTableHead = __webpack_require__(361);
var MdTableHead_default = /*#__PURE__*/__webpack_require__.n(MdTableHead);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-98ddc082","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableHead.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "th",
    {
      staticClass: "md-table-head",
      class: _vm.headClasses,
      style: _vm.headStyles,
      on: { click: _vm.changeSort }
    },
    [
      _vm.$slots.default
        ? _c("div", { staticClass: "md-table-head-container" }, [
            _c(
              "div",
              { staticClass: "md-table-head-label" },
              [_vm._t("default")],
              2
            )
          ])
        : _c(
            "md-ripple",
            {
              staticClass: "md-table-head-container",
              attrs: { "md-disabled": !_vm.hasSort }
            },
            [
              _c(
                "div",
                { staticClass: "md-table-head-label" },
                [
                  _vm.hasSort
                    ? _c(
                        "md-upward-icon",
                        { staticClass: "md-table-sortable-icon" },
                        [_vm._v("arrow_upward")]
                      )
                    : _vm._e(),
                  _vm._v("\n\n      " + _vm._s(_vm.label) + "\n\n      "),
                  _vm.tooltip
                    ? _c("md-tooltip", [_vm._v(_vm._s(_vm.tooltip))])
                    : _vm._e()
                ],
                1
              )
            ]
          )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableHead = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-98ddc082", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableHead.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(360)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableHead_default.a,
  MdTable_MdTableHead,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableHead.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-98ddc082", Component.options)
  } else {
    hotAPI.reload("data-v-98ddc082", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableHead = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (data) {
  var Instance = {};

  _vue2.default.util.defineReactive(Instance, 'reactive', data);

  return Instance.reactive;
};

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var msColor = null;
var themeColor = null;
var maskIcon = null;

exports.default = new _vue2.default({
  data: function data() {
    return {
      prefix: 'md-theme-',
      theme: 'default',
      enabled: true,
      metaColors: false
    };
  },
  computed: {
    themeTarget: function themeTarget() {
      if (!this.$isServer) {
        return document.documentElement;
      }

      return false;
    },
    fullThemeName: function fullThemeName() {
      return this.getThemeName();
    }
  },
  watch: {
    enabled: {
      immediate: true,
      handler: function handler() {
        var fullThemeName = this.fullThemeName,
            themeTarget = this.themeTarget,
            enabled = this.enabled;


        if (themeTarget) {
          if (enabled) {
            themeTarget.classList.add(fullThemeName);
            this.metaColors && this.setHtmlMetaColors(fullThemeName);
          } else {
            themeTarget.classList.remove(fullThemeName);
            this.metaColors && this.setHtmlMetaColors();
          }
        }
      }
    },
    theme: function theme(newTheme, oldTheme) {
      var getThemeName = this.getThemeName,
          themeTarget = this.themeTarget;


      newTheme = getThemeName(newTheme);

      themeTarget.classList.remove(getThemeName(oldTheme));
      themeTarget.classList.add(newTheme);

      if (this.metaColors) {
        this.setHtmlMetaColors(newTheme);
      }
    },
    metaColors: function metaColors(meta) {
      if (meta) {
        this.setHtmlMetaColors(this.fullThemeName);
      } else {
        this.setHtmlMetaColors();
      }
    }
  },
  methods: {
    getAncestorTheme: function getAncestorTheme(component) {
      var _this = this;

      if (component) {
        var currentTheme = component.mdTheme;
        var getParentThemeName = function getParentThemeName(parent) {
          if (parent) {
            var mdTheme = parent.mdTheme,
                $parent = parent.$parent;


            if (mdTheme && mdTheme !== currentTheme) {
              return mdTheme;
            }

            return getParentThemeName($parent);
          }

          return _this.theme;
        };

        return getParentThemeName(component.$parent);
      }

      return null;
    },
    getThemeName: function getThemeName(theme) {
      var themeName = theme || this.theme;

      return this.prefix + themeName;
    },
    setMicrosoftColors: function setMicrosoftColors(primaryColor) {
      if (msColor) {
        msColor.setAttribute('content', primaryColor);
      }
    },
    setThemeColors: function setThemeColors(primaryColor) {
      if (themeColor) {
        themeColor.setAttribute('content', primaryColor);
      }
    },
    setMaskColors: function setMaskColors(primaryColor) {
      if (maskIcon) {
        maskIcon.setAttribute('color', primaryColor);
      }
    },
    setHtmlMetaColors: function setHtmlMetaColors(themeName) {
      var primaryColor = '#fff';

      if (themeName) {
        var computedStyle = window.getComputedStyle(document.documentElement);

        primaryColor = computedStyle.getPropertyValue('--' + themeName + '-primary');
      }

      if (primaryColor) {
        this.setMicrosoftColors(primaryColor);
        this.setThemeColors(primaryColor);
        this.setMaskColors(primaryColor);
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    msColor = document.querySelector('[name="msapplication-TileColor"]');
    themeColor = document.querySelector('[name="theme-color"]');
    maskIcon = document.querySelector('[rel="mask-icon"]');

    if (this.enabled && this.metaColors) {
      window.addEventListener('load', function () {
        _this2.setHtmlMetaColors(_this2.fullThemeName);
      });
    }
  }
});

/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, optionsArgument) {
	var clone = !optionsArgument || optionsArgument.clone !== false;

	return (clone && isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, optionsArgument)
		: value
}

function defaultArrayMerge(target, source, optionsArgument) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, optionsArgument)
	})
}

function mergeObject(target, source, optionsArgument) {
	var destination = {};
	if (isMergeableObject(target)) {
		Object.keys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], optionsArgument);
		});
	}
	Object.keys(source).forEach(function(key) {
		if (!isMergeableObject(source[key]) || !target[key]) {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], optionsArgument);
		} else {
			destination[key] = deepmerge(target[key], source[key], optionsArgument);
		}
	});
	return destination
}

function deepmerge(target, source, optionsArgument) {
	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var options = optionsArgument || { arrayMerge: defaultArrayMerge };
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, optionsArgument)
	} else if (sourceIsArray) {
		var arrayMerge = options.arrayMerge || defaultArrayMerge;
		return arrayMerge(target, source, optionsArgument)
	} else {
		return mergeObject(target, source, optionsArgument)
	}
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, optionsArgument)
	}, {})
};

var deepmerge_1 = deepmerge;

/* harmony default export */ __webpack_exports__["default"] = (deepmerge_1);


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mdAppModes = ['fixed', 'fixed-last', 'reveal', 'overlap', 'flexible'];

exports.default = {
  props: {
    mdMode: _extends({
      type: String
    }, (0, _MdPropValidator2.default)('md-mode', mdAppModes)),
    mdWaterfall: Boolean,
    mdScrollbar: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      revealTimer: null,
      revealLastPos: 0,
      manualTick: false,
      MdApp: {
        options: {
          mode: null,
          waterfall: false,
          flexible: false
        },
        toolbar: {
          element: null,
          titleElement: null,
          height: '0px',
          initialHeight: 0,
          top: 0,
          titleSize: 20,
          hasElevation: true,
          revealActive: false,
          fixedLastActive: false,
          fixedLastHeight: false,
          overlapOff: false
        },
        drawer: {
          initialWidth: 0,
          active: false,
          mode: 'temporary',
          width: 0
        }
      }
    };
  },
  provide: function provide() {
    return {
      MdApp: this.MdApp
    };
  },

  computed: {
    contentStyles: function contentStyles() {
      var drawer = this.MdApp.drawer;

      if (drawer.active && drawer.mode === 'persistent' && drawer.submode === 'full') {
        return {
          'padding-left': drawer.width
        };
      }
    },
    containerStyles: function containerStyles() {
      var drawer = this.MdApp.drawer;
      var styles = {};

      if (this.mdMode && this.mdMode !== 'fixed') {
        styles['margin-top'] = this.MdApp.toolbar.initialHeight + 'px';
      }

      if (drawer.mode === 'persistent' && drawer.submode === 'mini') {
        styles['padding-left'] = !drawer.active ? drawer.initialWidth + 'px' : 0;
      }

      return styles;
    },
    scrollerClasses: function scrollerClasses() {
      if (this.mdScrollbar) {
        return 'md-scrollbar';
      }
    },
    appClasses: function appClasses() {
      return {
        'md-waterfall': this.mdWaterfall,
        'md-flexible': this.mdMode === 'flexible',
        'md-fixed': this.mdMode === 'fixed',
        'md-fixed-last': this.mdMode === 'fixed-last',
        'md-reveal': this.mdMode === 'reveal',
        'md-overlap': this.mdMode === 'overlap',
        'md-drawer-active': this.MdApp.drawer.active
      };
    }
  },
  watch: {
    mdMode: function mdMode(mode) {
      this.MdApp.options.mode = mode;
    },
    mdWaterfall: function mdWaterfall(waterfall) {
      this.MdApp.options.waterfall = waterfall;
      this.setToolbarElevation();
    }
  },
  methods: {
    setToolbarElevation: function setToolbarElevation() {
      this.MdApp.toolbar.hasElevation = !this.mdWaterfall;
    },
    setToolbarTimer: function setToolbarTimer(scrollTop) {
      var _this = this;

      window.clearTimeout(this.revealTimer);

      this.revealTimer = window.setTimeout(function () {
        _this.revealLastPos = scrollTop;
      }, 100);
    },
    setToolbarMarginAndHeight: function setToolbarMarginAndHeight(margin, height) {
      this.MdApp.toolbar.top = margin;
      this.MdApp.toolbar.height = height;
    },
    getToolbarConstrants: function getToolbarConstrants($event) {
      var toolbarHeight = this.MdApp.toolbar.element.offsetHeight;
      var safeAmount = 10;
      var threshold = toolbarHeight + safeAmount;
      var scrollTop = $event.target.scrollTop;

      if (!this.MdApp.toolbar.initialHeight) {
        this.MdApp.toolbar.initialHeight = toolbarHeight;
      }

      return {
        toolbarHeight: toolbarHeight,
        safeAmount: safeAmount,
        threshold: threshold,
        scrollTop: scrollTop,
        initialHeight: this.MdApp.toolbar.initialHeight
      };
    },
    handleWaterfallScroll: function handleWaterfallScroll($event) {
      var _getToolbarConstrants = this.getToolbarConstrants($event),
          threshold = _getToolbarConstrants.threshold,
          scrollTop = _getToolbarConstrants.scrollTop;

      var elevationMark = 4;

      if (this.mdMode === 'reveal') {
        elevationMark = threshold;
      }

      this.MdApp.toolbar.hasElevation = scrollTop >= elevationMark;
    },
    handleFlexibleMode: function handleFlexibleMode($event) {
      var _getToolbarConstrants2 = this.getToolbarConstrants($event),
          scrollTop = _getToolbarConstrants2.scrollTop,
          initialHeight = _getToolbarConstrants2.initialHeight;

      var toolbar = this.MdApp.toolbar.element;
      var firstRow = toolbar.querySelector('.md-toolbar-row:first-child');
      var firstRowHeight = firstRow.offsetHeight;
      var scrollAmount = initialHeight - scrollTop;
      var shouldKeepFlexible = scrollTop < initialHeight - firstRowHeight;

      if (firstRowHeight) {
        if (shouldKeepFlexible) {
          toolbar.style.height = scrollAmount + 'px';
        } else {
          toolbar.style.height = firstRowHeight + 'px';
        }
      }

      var titleElement = this.MdApp.toolbar.titleElement;
      if (titleElement) {
        var targetSize = 20;
        var initialSize = this.MdApp.toolbar.titleSize;

        if (shouldKeepFlexible) {
          var newSize = Math.max(0, 1 - (scrollTop - initialSize) / (scrollAmount + initialSize + 0.000001)) * (initialSize - targetSize) + targetSize;

          titleElement.style.fontSize = newSize + 'px';
        } else {
          titleElement.style.fontSize = '20px';
        }
      }

      var _getToolbarConstrants3 = this.getToolbarConstrants($event),
          threshold = _getToolbarConstrants3.threshold,
          toolbarHeight = _getToolbarConstrants3.toolbarHeight;

      this.setToolbarMarginAndHeight(scrollTop - threshold, toolbarHeight);
    },
    handleRevealMode: function handleRevealMode($event) {
      var _getToolbarConstrants4 = this.getToolbarConstrants($event),
          toolbarHeight = _getToolbarConstrants4.toolbarHeight,
          safeAmount = _getToolbarConstrants4.safeAmount,
          threshold = _getToolbarConstrants4.threshold,
          scrollTop = _getToolbarConstrants4.scrollTop;

      this.setToolbarTimer(scrollTop);
      this.setToolbarMarginAndHeight(scrollTop - threshold, toolbarHeight);

      if (scrollTop >= threshold) {
        this.MdApp.toolbar.revealActive = this.revealLastPos > scrollTop + safeAmount;
      } else {
        this.MdApp.toolbar.revealActive = true;
      }
    },
    handleFixedLastMode: function handleFixedLastMode($event) {
      var _getToolbarConstrants5 = this.getToolbarConstrants($event),
          scrollTop = _getToolbarConstrants5.scrollTop,
          toolbarHeight = _getToolbarConstrants5.toolbarHeight,
          safeAmount = _getToolbarConstrants5.safeAmount;

      var toolbar = this.MdApp.toolbar.element;
      var firstRow = toolbar.querySelector('.md-toolbar-row:first-child');
      var firstRowHeight = firstRow.offsetHeight;

      this.setToolbarTimer(scrollTop);
      this.setToolbarMarginAndHeight(scrollTop - firstRowHeight, toolbarHeight);
      this.MdApp.toolbar.fixedLastHeight = firstRowHeight;

      if (scrollTop >= firstRowHeight) {
        this.MdApp.toolbar.fixedLastActive = this.revealLastPos > scrollTop + safeAmount;
      } else {
        this.MdApp.toolbar.fixedLastActive = true;
      }
    },
    handleOverlapMode: function handleOverlapMode($event) {
      var _getToolbarConstrants6 = this.getToolbarConstrants($event),
          toolbarHeight = _getToolbarConstrants6.toolbarHeight,
          scrollTop = _getToolbarConstrants6.scrollTop,
          initialHeight = _getToolbarConstrants6.initialHeight;

      var toolbar = this.MdApp.toolbar.element;
      var firstRow = toolbar.querySelector('.md-toolbar-row:first-child');
      var firstRowHeight = firstRow.offsetHeight;
      var newHeight = initialHeight - scrollTop - scrollTop * 100 / (initialHeight - firstRowHeight - firstRowHeight / 1.5);

      if (firstRowHeight) {
        if (scrollTop < initialHeight - firstRowHeight && newHeight >= firstRowHeight) {
          this.MdApp.toolbar.overlapOff = false;
          toolbar.style.height = newHeight + 'px';
        } else {
          this.MdApp.toolbar.overlapOff = true;
          toolbar.style.height = firstRowHeight + 'px';
        }
      }

      this.setToolbarMarginAndHeight(scrollTop, toolbarHeight);
    },
    handleModeScroll: function handleModeScroll($event) {
      if (this.mdMode === 'reveal') {
        this.handleRevealMode($event);
      } else if (this.mdMode === 'fixed-last') {
        this.handleFixedLastMode($event);
      } else if (this.mdMode === 'overlap') {
        this.handleOverlapMode($event);
      } else if (this.mdMode === 'flexible') {
        this.handleFlexibleMode($event);
      }
    },
    handleScroll: function handleScroll($event) {
      var _this2 = this;

      if (this.MdApp.toolbar.element) {
        (0, _raf2.default)(function () {
          if (_this2.mdWaterfall) {
            _this2.handleWaterfallScroll($event);
          }

          if (_this2.mdMode) {
            _this2.handleModeScroll($event);
          }
        });
      }
    }
  },
  created: function created() {
    this.MdApp.options.mode = this.mdMode;
    this.MdApp.options.waterfall = this.mdWaterfall;
    this.setToolbarElevation();
  },
  mounted: function mounted() {
    var fakeEvent = {
      target: {
        scrollTop: 0
      }
    };

    if (this.mdMode === 'reveal') {
      this.MdApp.toolbar.revealActive = true;
      this.handleRevealMode(fakeEvent);
    }

    if (this.mdMode === 'flexible') {
      this.MdApp.toolbar.revealActive = true;
      this.handleFlexibleMode(fakeEvent);
    }

    if (this.mdMode === 'fixed-last') {
      this.MdApp.toolbar.fixedLastActive = true;
      this.handleFixedLastMode(fakeEvent);
    }

    if (this.mdMode === 'overlap') {
      this.handleOverlapMode(fakeEvent);
    }
  }
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdReactive = __webpack_require__(28);

var _MdReactive2 = _interopRequireDefault(_MdReactive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hasEvents = false;
var eventTarget = null;
var supportsPassiveEvent = false;
var MdFocused = new _MdReactive2.default({
  currentElement: null
});

function checkPassiveEventSupport() {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassiveEvent = { passive: true };
      }
    });
    window.addEventListener('ghost', null, opts);
  } catch (e) {}
}

function setKeyboardInteraction(_ref) {
  var keyCode = _ref.keyCode,
      target = _ref.target;

  MdFocused.currentElement = target;
}

function setMouseAndTouchInteraction(event) {
  MdFocused.currentElement = null;
}

function createKeyboardEvents() {
  eventTarget.addEventListener('keyup', setKeyboardInteraction);
}

function createPointerEvents() {
  eventTarget.addEventListener('pointerup', setMouseAndTouchInteraction);
}

function createMSPointerEvents() {
  eventTarget.addEventListener('MSPointerUp', setMouseAndTouchInteraction);
}

function createMouseAndTouchEvents() {
  eventTarget.addEventListener('mouseup', setMouseAndTouchInteraction);

  if ('ontouchend' in window) {
    eventTarget.addEventListener('touchend', setMouseAndTouchInteraction, supportsPassiveEvent);
  }
}

function bindEvents() {
  if (window.PointerEvent) {
    createPointerEvents();
  } else if (window.MSPointerEvent) {
    createMSPointerEvents();
  } else {
    createMouseAndTouchEvents();
  }

  createKeyboardEvents();
}

function createEvents() {
  if (!hasEvents) {
    eventTarget = document.body;
    checkPassiveEventSupport();
    bindEvents();
    hasEvents = true;
  }
}

exports.default = {
  data: function data() {
    return {
      mdHasFocus: false
    };
  },
  computed: {
    focusedElement: function focusedElement() {
      return MdFocused.currentElement;
    }
  },
  watch: {
    focusedElement: function focusedElement(el) {
      this.mdHasFocus = el === this.$el;
    }
  },
  mounted: function mounted() {
    createEvents();
  }
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    model: [String, Number, Boolean, Array],
    value: {
      type: [String, Number, Boolean],
      default: 'on'
    },
    name: [String, Number],
    required: Boolean,
    disabled: Boolean
  },
  model: {
    prop: 'model',
    event: 'change'
  },
  data: function data() {
    return {
      rippleActive: false
    };
  },
  computed: {
    isSelected: function isSelected() {
      if (this.isModelArray) {
        return this.model.includes(this.value);
      }

      if (this.isModelBoolean && this.value === 'on') {
        return this.model;
      }

      return this.model === this.value;
    },
    isModelArray: function isModelArray() {
      return Array.isArray(this.model);
    },
    isModelBoolean: function isModelBoolean() {
      return typeof this.model === 'boolean';
    },
    checkClasses: function checkClasses() {
      return {
        'md-checked': this.isSelected,
        'md-disabled': this.disabled,
        'md-required': this.required
      };
    }
  },
  methods: {
    removeItemFromModel: function removeItemFromModel(newModel) {
      var index = newModel.indexOf(this.value);

      if (index !== -1) {
        newModel.splice(index, 1);
      }
    },
    handleArrayCheckbox: function handleArrayCheckbox() {
      var newModel = this.model;

      if (!this.isSelected) {
        newModel.push(this.value);
      } else {
        this.removeItemFromModel(newModel);
      }

      this.$emit('change', newModel);
    },
    handleStringCheckbox: function handleStringCheckbox() {
      if (!this.isSelected) {
        this.$emit('change', this.value);
      } else {
        this.$emit('change', null);
      }
    },
    handleBooleanCheckbox: function handleBooleanCheckbox() {
      this.$emit('change', !this.model);
    },
    toggleCheck: function toggleCheck() {
      if (!this.disabled) {
        this.rippleActive = true;

        if (this.isModelArray) {
          this.handleArrayCheckbox();
        } else if (this.isModelBoolean) {
          this.handleBooleanCheckbox();
        } else {
          this.handleStringCheckbox();
        }
      }
    }
  }
};

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdClearIcon.vue
var MdClearIcon = __webpack_require__(149);
var MdClearIcon_default = /*#__PURE__*/__webpack_require__.n(MdClearIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-f53126ba","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdClearIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(1, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "svg",
      {
        attrs: {
          height: "24",
          viewBox: "0 0 24 24",
          width: "24",
          xmlns: "http://www.w3.org/2000/svg"
        }
      },
      [
        _c("path", {
          attrs: {
            d:
              "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
          }
        }),
        _vm._v(" "),
        _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } })
      ]
    )
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _vm._m(0, false, true)
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdClearIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f53126ba", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdClearIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdClearIcon_default.a,
  icons_MdClearIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdClearIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f53126ba", Component.options)
  } else {
    hotAPI.reload("data-v-f53126ba", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdClearIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdContent_vue__ = __webpack_require__(164);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdContent_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdContent_vue__);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdContent_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdContent/MdContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-500cc355", Component.options)
  } else {
    hotAPI.reload("data-v-500cc355", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 36 */
/***/ (function(module, exports) {

/**
 * @category Common Helpers
 * @summary Is the given argument an instance of Date?
 *
 * @description
 * Is the given argument an instance of Date?
 *
 * @param {*} argument - the argument to check
 * @returns {Boolean} the given argument is an instance of Date
 *
 * @example
 * // Is 'mayonnaise' a Date?
 * var result = isDate('mayonnaise')
 * //=> false
 */
function isDate (argument) {
  return argument instanceof Date
}

module.exports = isDate


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)
var startOfISOWeek = __webpack_require__(22)

/**
 * @category ISO Week-Numbering Year Helpers
 * @summary Get the ISO week-numbering year of the given date.
 *
 * @description
 * Get the ISO week-numbering year of the given date,
 * which always starts 3 days before the year's first Thursday.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the ISO week-numbering year
 *
 * @example
 * // Which ISO-week numbering year is 2 January 2005?
 * var result = getISOYear(new Date(2005, 0, 2))
 * //=> 2004
 */
function getISOYear (dirtyDate) {
  var date = parse(dirtyDate)
  var year = date.getFullYear()

  var fourthOfJanuaryOfNextYear = new Date(0)
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4)
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0)
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear)

  var fourthOfJanuaryOfThisYear = new Date(0)
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4)
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0)
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear)

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year
  } else {
    return year - 1
  }
}

module.exports = getISOYear


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var isDate = __webpack_require__(36)

/**
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {Date} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} argument must be an instance of Date
 *
 * @example
 * // For the valid date:
 * var result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the invalid date:
 * var result = isValid(new Date(''))
 * //=> false
 */
function isValid (dirtyDate) {
  if (isDate(dirtyDate)) {
    return !isNaN(dirtyDate)
  } else {
    throw new TypeError(toString.call(dirtyDate) + ' is not an instance of Date')
  }
}

module.exports = isValid


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)
var getDaysInMonth = __webpack_require__(24)

/**
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added
 * @returns {Date} the new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * var result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */
function addMonths (dirtyDate, dirtyAmount) {
  var date = parse(dirtyDate)
  var amount = Number(dirtyAmount)
  var desiredMonth = date.getMonth() + amount
  var dateWithDesiredMonth = new Date(0)
  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1)
  dateWithDesiredMonth.setHours(0, 0, 0, 0)
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth)
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()))
  return date
}

module.exports = addMonths


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdFocusTrap',
  abstract: true,
  methods: {
    setFocus: function setFocus() {
      var _this = this;

      window.setTimeout(function () {
        if (_this.$el.tagName) {
          _this.$el.setAttribute('tabindex', '-1');
          _this.$el.focus();
        }
      }, 20);
    }
  },
  mounted: function mounted() {
    this.setFocus();
  },
  render: function render() {
    try {
      var defaultSlot = this.$slots.default;

      if (!defaultSlot) {
        return null;
      }

      if (defaultSlot.length > 1) {
        throw new Error();
      }

      return defaultSlot[0];
    } catch (e) {
      _vue2.default.util.warn('MdFocusTrap can only render one, and exactly one child component.', this);
    }

    return null;
  }
};

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdEmptyState/MdEmptyState.vue
var MdEmptyState = __webpack_require__(240);
var MdEmptyState_default = /*#__PURE__*/__webpack_require__.n(MdEmptyState);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-d8a893a2","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdEmptyState/MdEmptyState.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("transition", { attrs: { name: "md-empty-state", appear: "" } }, [
    _c(
      "div",
      {
        staticClass: "md-empty-state",
        class: [_vm.emptyStateClasses, _vm.$mdActiveTheme],
        style: _vm.emptyStateStyles
      },
      [
        _c(
          "div",
          { staticClass: "md-empty-state-container" },
          [
            _vm.mdIcon
              ? [
                  _vm.isAssetIcon(_vm.mdIcon)
                    ? _c("md-icon", {
                        staticClass: "md-empty-state-icon",
                        attrs: { "md-src": _vm.mdIcon }
                      })
                    : _c("md-icon", { staticClass: "md-empty-state-icon" }, [
                        _vm._v(_vm._s(_vm.mdIcon))
                      ])
                ]
              : _vm._e(),
            _vm._v(" "),
            _vm.mdLabel
              ? _c("strong", { staticClass: "md-empty-state-label" }, [
                  _vm._v(_vm._s(_vm.mdLabel))
                ])
              : _vm._e(),
            _vm._v(" "),
            _vm.mdDescription
              ? _c("p", { staticClass: "md-empty-state-description" }, [
                  _vm._v(_vm._s(_vm.mdDescription))
                ])
              : _vm._e(),
            _vm._v(" "),
            _vm._t("default")
          ],
          2
        )
      ]
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdEmptyState_MdEmptyState = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-d8a893a2", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdEmptyState/MdEmptyState.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(239)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdEmptyState_default.a,
  MdEmptyState_MdEmptyState,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdEmptyState/MdEmptyState.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d8a893a2", Component.options)
  } else {
    hotAPI.reload("data-v-d8a893a2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdEmptyState_MdEmptyState = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  mdRounded: Boolean,
  mdSize: {
    type: Number,
    default: 420
  },
  mdIcon: String,
  mdLabel: String,
  mdDescription: String
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdIcon2.default.name, _MdIcon2.default);
};

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdMenu/MdMenu.vue
var MdMenu = __webpack_require__(249);
var MdMenu_default = /*#__PURE__*/__webpack_require__.n(MdMenu);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-577c0662","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdMenu/MdMenu.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    _vm._g({ staticClass: "md-menu" }, _vm.$listeners),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdMenu_MdMenu = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-577c0662", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdMenu/MdMenu.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(248)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdMenu_default.a,
  MdMenu_MdMenu,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdMenu/MdMenu.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-577c0662", Component.options)
  } else {
    hotAPI.reload("data-v-577c0662", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdMenu_MdMenu = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdMenu/MdMenuContent.vue
var MdMenuContent = __webpack_require__(251);
var MdMenuContent_default = /*#__PURE__*/__webpack_require__.n(MdMenuContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2c16774c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdMenu/MdMenuContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-popover",
    {
      attrs: {
        "md-settings": _vm.popperSettings,
        "md-active": _vm.shouldRender
      }
    },
    [
      _vm.shouldRender
        ? _c(
            "transition",
            _vm._g(
              { attrs: { name: "md-menu-content", css: _vm.didMount } },
              _vm.$listeners
            ),
            [
              _c(
                "div",
                {
                  ref: "menu",
                  class: [
                    _vm.menuClasses,
                    _vm.mdContentClass,
                    _vm.$mdActiveTheme
                  ],
                  style: _vm.menuStyles,
                  on: {
                    keydown: [
                      function($event) {
                        if (
                          !("button" in $event) &&
                          _vm._k(
                            $event.keyCode,
                            "arrow-down",
                            undefined,
                            $event.key
                          )
                        ) {
                          return null
                        }
                        $event.preventDefault()
                        _vm.setHighlight("down")
                      },
                      function($event) {
                        if (
                          !("button" in $event) &&
                          _vm._k(
                            $event.keyCode,
                            "arrow-up",
                            undefined,
                            $event.key
                          )
                        ) {
                          return null
                        }
                        $event.preventDefault()
                        _vm.setHighlight("up")
                      },
                      function($event) {
                        if (
                          !("button" in $event) &&
                          _vm._k($event.keyCode, "space", 32, $event.key)
                        ) {
                          return null
                        }
                        $event.preventDefault()
                        _vm.setSelection($event)
                      },
                      function($event) {
                        if (
                          !("button" in $event) &&
                          _vm._k($event.keyCode, "enter", 13, $event.key)
                        ) {
                          return null
                        }
                        $event.preventDefault()
                        _vm.setSelection($event)
                      }
                    ]
                  }
                },
                [
                  _c(
                    "div",
                    {
                      ref: "container",
                      staticClass: "md-menu-content-container md-scrollbar",
                      class: _vm.$mdActiveTheme
                    },
                    [
                      _c(
                        "md-list",
                        _vm._b(
                          {
                            class: _vm.listClasses,
                            on: {
                              keydown: function($event) {
                                if (
                                  !("button" in $event) &&
                                  _vm._k($event.keyCode, "esc", 27, $event.key)
                                ) {
                                  return null
                                }
                                _vm.onEsc($event)
                              }
                            }
                          },
                          "md-list",
                          _vm.filteredAttrs,
                          false
                        ),
                        [_vm._t("default")],
                        2
                      )
                    ],
                    1
                  )
                ]
              )
            ]
          )
        : _vm._e()
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdMenu_MdMenuContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2c16774c", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdMenu/MdMenuContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(250)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdMenuContent_default.a,
  MdMenu_MdMenuContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdMenu/MdMenuContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2c16774c", Component.options)
  } else {
    hotAPI.reload("data-v-2c16774c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdMenu_MdMenuContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (el, eventName, observerFn, options) {
  function killObserver() {
    el.removeEventListener(eventName, observerFn);
  }

  el.addEventListener(eventName, observerFn, options || false);

  return {
    destroy: killObserver
  };
};

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdList.vue
var MdList = __webpack_require__(254);
var MdList_default = /*#__PURE__*/__webpack_require__.n(MdList);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-16ed17ef","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdList.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "ul",
    _vm._g(
      _vm._b(
        { staticClass: "md-list", class: [_vm.$mdActiveTheme] },
        "ul",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdList_MdList = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-16ed17ef", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdList.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(253)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdList_default.a,
  MdList_MdList,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdList.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-16ed17ef", Component.options)
  } else {
    hotAPI.reload("data-v-16ed17ef", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdList_MdList = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdListItem_vue__ = __webpack_require__(280);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdListItem_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdListItem_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(279)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdListItem_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItem.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-cff46336", Component.options)
  } else {
    hotAPI.reload("data-v-cff46336", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ['click', 'dblclick', 'mousedown', 'mouseup'];

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSteppers/MdStepHeader.vue
var MdStepHeader = __webpack_require__(333);
var MdStepHeader_default = /*#__PURE__*/__webpack_require__.n(MdStepHeader);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-43e95866","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSteppers/MdStepHeader.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-button",
    _vm._g(
      _vm._b(
        {
          staticClass: "md-stepper-header",
          class: _vm.classes,
          attrs: { disabled: _vm.shouldDisable },
          nativeOn: {
            click: function($event) {
              _vm.MdSteppers.setActiveStep(_vm.index)
            }
          }
        },
        "md-button",
        _vm.data.props,
        false
      ),
      _vm.data.events
    ),
    [
      _vm.data.error
        ? _c("md-warning-icon", { staticClass: "md-stepper-icon" })
        : _c(
            "div",
            { staticClass: "md-stepper-number" },
            [
              _vm.data.done && _vm.data.editable
                ? _c("md-edit-icon", { staticClass: "md-stepper-editable" })
                : _vm.data.done
                  ? _c("md-check-icon", { staticClass: "md-stepper-done" })
                  : [_vm._v(_vm._s(_vm.MdSteppers.getStepperNumber(_vm.index)))]
            ],
            2
          ),
      _vm._v(" "),
      _c("div", { staticClass: "md-stepper-text" }, [
        _c("span", { staticClass: "md-stepper-label" }, [
          _vm._v(_vm._s(_vm.data.label))
        ]),
        _vm._v(" "),
        _vm.data.error
          ? _c("span", { staticClass: "md-stepper-error" }, [
              _vm._v(_vm._s(_vm.data.error))
            ])
          : _vm.data.description
            ? _c("span", { staticClass: "md-stepper-description" }, [
                _vm._v(_vm._s(_vm.data.description))
              ])
            : _vm._e()
      ])
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSteppers_MdStepHeader = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-43e95866", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSteppers/MdStepHeader.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdStepHeader_default.a,
  MdSteppers_MdStepHeader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSteppers/MdStepHeader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-43e95866", Component.options)
  } else {
    hotAPI.reload("data-v-43e95866", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSteppers_MdStepHeader = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableRow.vue
var MdTableRow = __webpack_require__(370);
var MdTableRow_default = /*#__PURE__*/__webpack_require__.n(MdTableRow);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-00a4496a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableRow.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "tr",
    _vm._g(
      {
        staticClass: "md-table-row",
        class: _vm.rowClasses,
        on: { click: _vm.onClick }
      },
      _vm.$listeners
    ),
    [
      _vm.selectableCount
        ? _c("md-table-cell-selection", {
            attrs: {
              "md-disabled": _vm.mdDisabled,
              "md-selectable": _vm.mdSelectable === "multiple",
              "md-row-id": _vm.mdIndex
            },
            model: {
              value: _vm.isSelected,
              callback: function($$v) {
                _vm.isSelected = $$v
              },
              expression: "isSelected"
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _vm._t("default")
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableRow = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-00a4496a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableRow.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(369)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableRow_default.a,
  MdTable_MdTableRow,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableRow.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-00a4496a", Component.options)
  } else {
    hotAPI.reload("data-v-00a4496a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableRow = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableCellSelection.vue
var MdTableCellSelection = __webpack_require__(372);
var MdTableCellSelection_default = /*#__PURE__*/__webpack_require__.n(MdTableCellSelection);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-50a4b70a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableCellSelection.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.mdSelectable
    ? _c("td", { staticClass: "md-table-cell md-table-cell-selection" }, [
        _c(
          "div",
          { staticClass: "md-table-cell-container" },
          [
            _c("md-checkbox", {
              attrs: { disabled: !_vm.mdSelectable || _vm.mdDisabled },
              on: { change: _vm.onChange },
              model: {
                value: _vm.isSelected,
                callback: function($$v) {
                  _vm.isSelected = $$v
                },
                expression: "isSelected"
              }
            })
          ],
          1
        )
      ])
    : _vm._e()
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableCellSelection = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-50a4b70a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableCellSelection.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(371)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableCellSelection_default.a,
  MdTable_MdTableCellSelection,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableCellSelection.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-50a4b70a", Component.options)
  } else {
    hotAPI.reload("data-v-50a4b70a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableCellSelection = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdToolbar/MdToolbar.vue
var MdToolbar = __webpack_require__(379);
var MdToolbar_default = /*#__PURE__*/__webpack_require__.n(MdToolbar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-38a0b4d9","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdToolbar/MdToolbar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-toolbar",
      class: [_vm.$mdActiveTheme, "md-elevation-" + _vm.mdElevation]
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdToolbar_MdToolbar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-38a0b4d9", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdToolbar/MdToolbar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(378)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdToolbar_default.a,
  MdToolbar_MdToolbar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdToolbar/MdToolbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-38a0b4d9", Component.options)
  } else {
    hotAPI.reload("data-v-38a0b4d9", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdToolbar_MdToolbar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(55);

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _components = __webpack_require__(57);

var MdComponents = _interopRequireWildcard(_components);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VueMaterial = function VueMaterial(Vue) {
  (0, _material2.default)(Vue);

  Object.values(MdComponents).forEach(function (MdComponent) {
    Vue.use(MdComponent);
  });
};

VueMaterial.version = '__VERSION__';

exports.default = VueMaterial;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))

/***/ }),
/* 56 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MdTooltip = exports.MdToolbar = exports.MdTabs = exports.MdTable = exports.MdSwitch = exports.MdSubheader = exports.MdSteppers = exports.MdSpeedDial = exports.MdSnackbar = exports.MdRipple = exports.MdRadio = exports.MdProgress = exports.MdMenu = exports.MdList = exports.MdLayout = exports.MdImage = exports.MdIcon = exports.MdHighlightText = exports.MdField = exports.MdEmptyState = exports.MdElevation = exports.MdDrawer = exports.MdDivider = exports.MdDialogPrompt = exports.MdDialogConfirm = exports.MdDialogAlert = exports.MdDialog = exports.MdDatepicker = exports.MdContent = exports.MdChips = exports.MdCheckbox = exports.MdCard = exports.MdButton = exports.MdBottomBar = exports.MdAvatar = exports.MdAutocomplete = exports.MdApp = undefined;

var _MdApp = __webpack_require__(58);

var _MdApp2 = _interopRequireDefault(_MdApp);

var _MdAutocomplete = __webpack_require__(78);

var _MdAutocomplete2 = _interopRequireDefault(_MdAutocomplete);

var _MdAvatar = __webpack_require__(84);

var _MdAvatar2 = _interopRequireDefault(_MdAvatar);

var _MdBottomBar = __webpack_require__(88);

var _MdBottomBar2 = _interopRequireDefault(_MdBottomBar);

var _MdButton = __webpack_require__(97);

var _MdButton2 = _interopRequireDefault(_MdButton);

var _MdCard = __webpack_require__(103);

var _MdCard2 = _interopRequireDefault(_MdCard);

var _MdCheckbox = __webpack_require__(139);

var _MdCheckbox2 = _interopRequireDefault(_MdCheckbox);

var _MdChips = __webpack_require__(143);

var _MdChips2 = _interopRequireDefault(_MdChips);

var _MdContent = __webpack_require__(163);

var _MdContent2 = _interopRequireDefault(_MdContent);

var _MdDatepicker = __webpack_require__(165);

var _MdDatepicker2 = _interopRequireDefault(_MdDatepicker);

var _MdDialog = __webpack_require__(209);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

var _MdDialogAlert = __webpack_require__(219);

var _MdDialogAlert2 = _interopRequireDefault(_MdDialogAlert);

var _MdDialogConfirm = __webpack_require__(222);

var _MdDialogConfirm2 = _interopRequireDefault(_MdDialogConfirm);

var _MdDialogPrompt = __webpack_require__(225);

var _MdDialogPrompt2 = _interopRequireDefault(_MdDialogPrompt);

var _MdDivider = __webpack_require__(228);

var _MdDivider2 = _interopRequireDefault(_MdDivider);

var _MdDrawer = __webpack_require__(232);

var _MdDrawer2 = _interopRequireDefault(_MdDrawer);

var _MdElevation = __webpack_require__(236);

var _MdElevation2 = _interopRequireDefault(_MdElevation);

var _MdEmptyState = __webpack_require__(238);

var _MdEmptyState2 = _interopRequireDefault(_MdEmptyState);

var _MdField = __webpack_require__(241);

var _MdField2 = _interopRequireDefault(_MdField);

var _MdHighlightText = __webpack_require__(268);

var _MdHighlightText2 = _interopRequireDefault(_MdHighlightText);

var _MdIcon = __webpack_require__(43);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

var _MdImage = __webpack_require__(272);

var _MdImage2 = _interopRequireDefault(_MdImage);

var _MdLayout = __webpack_require__(276);

var _MdLayout2 = _interopRequireDefault(_MdLayout);

var _MdList = __webpack_require__(278);

var _MdList2 = _interopRequireDefault(_MdList);

var _MdMenu = __webpack_require__(296);

var _MdMenu2 = _interopRequireDefault(_MdMenu);

var _MdProgress = __webpack_require__(299);

var _MdProgress2 = _interopRequireDefault(_MdProgress);

var _MdRadio = __webpack_require__(307);

var _MdRadio2 = _interopRequireDefault(_MdRadio);

var _MdRipple = __webpack_require__(311);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

var _MdSnackbar = __webpack_require__(312);

var _MdSnackbar2 = _interopRequireDefault(_MdSnackbar);

var _MdSpeedDial = __webpack_require__(319);

var _MdSpeedDial2 = _interopRequireDefault(_MdSpeedDial);

var _MdSteppers = __webpack_require__(329);

var _MdSteppers2 = _interopRequireDefault(_MdSteppers);

var _MdSubheader = __webpack_require__(343);

var _MdSubheader2 = _interopRequireDefault(_MdSubheader);

var _MdSwitch = __webpack_require__(347);

var _MdSwitch2 = _interopRequireDefault(_MdSwitch);

var _MdTable = __webpack_require__(351);

var _MdTable2 = _interopRequireDefault(_MdTable);

var _MdTabs = __webpack_require__(389);

var _MdTabs2 = _interopRequireDefault(_MdTabs);

var _MdToolbar = __webpack_require__(395);

var _MdToolbar2 = _interopRequireDefault(_MdToolbar);

var _MdTooltip = __webpack_require__(396);

var _MdTooltip2 = _interopRequireDefault(_MdTooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.MdApp = _MdApp2.default;
exports.MdAutocomplete = _MdAutocomplete2.default;
exports.MdAvatar = _MdAvatar2.default;
exports.MdBottomBar = _MdBottomBar2.default;
exports.MdButton = _MdButton2.default;
exports.MdCard = _MdCard2.default;
exports.MdCheckbox = _MdCheckbox2.default;
exports.MdChips = _MdChips2.default;
exports.MdContent = _MdContent2.default;
exports.MdDatepicker = _MdDatepicker2.default;
exports.MdDialog = _MdDialog2.default;
exports.MdDialogAlert = _MdDialogAlert2.default;
exports.MdDialogConfirm = _MdDialogConfirm2.default;
exports.MdDialogPrompt = _MdDialogPrompt2.default;
exports.MdDivider = _MdDivider2.default;
exports.MdDrawer = _MdDrawer2.default;
exports.MdElevation = _MdElevation2.default;
exports.MdEmptyState = _MdEmptyState2.default;
exports.MdField = _MdField2.default;
exports.MdHighlightText = _MdHighlightText2.default;
exports.MdIcon = _MdIcon2.default;
exports.MdImage = _MdImage2.default;
exports.MdLayout = _MdLayout2.default;
exports.MdList = _MdList2.default;
exports.MdMenu = _MdMenu2.default;
exports.MdProgress = _MdProgress2.default;
exports.MdRadio = _MdRadio2.default;
exports.MdRipple = _MdRipple2.default;
exports.MdSnackbar = _MdSnackbar2.default;
exports.MdSpeedDial = _MdSpeedDial2.default;
exports.MdSteppers = _MdSteppers2.default;
exports.MdSubheader = _MdSubheader2.default;
exports.MdSwitch = _MdSwitch2.default;
exports.MdTable = _MdTable2.default;
exports.MdTabs = _MdTabs2.default;
exports.MdToolbar = _MdToolbar2.default;
exports.MdTooltip = _MdTooltip2.default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdApp = __webpack_require__(59);

var _MdApp2 = _interopRequireDefault(_MdApp);

var _MdAppToolbar = __webpack_require__(70);

var _MdAppToolbar2 = _interopRequireDefault(_MdAppToolbar);

var _MdAppContent = __webpack_require__(73);

var _MdAppContent2 = _interopRequireDefault(_MdAppContent);

var _MdAppDrawer = __webpack_require__(76);

var _MdAppDrawer2 = _interopRequireDefault(_MdAppDrawer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdApp2.default.name, _MdApp2.default);
  Vue.component(_MdAppToolbar2.default.name, _MdAppToolbar2.default);
  Vue.component(_MdAppContent2.default.name, _MdAppContent2.default);
  Vue.component(_MdAppDrawer2.default.name, _MdAppDrawer2.default);
};

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdApp_vue__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdApp_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdApp_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(60)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdApp_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdApp.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-8b7389b6", Component.options)
  } else {
    hotAPI.reload("data-v-8b7389b6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 60 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdAppSideDrawer = __webpack_require__(62);

var _MdAppSideDrawer2 = _interopRequireDefault(_MdAppSideDrawer);

var _MdAppInternalDrawer = __webpack_require__(67);

var _MdAppInternalDrawer2 = _interopRequireDefault(_MdAppInternalDrawer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var componentTypes = ['md-app-toolbar', 'md-app-drawer', 'md-app-content'];

function buildSlots(children, context, functionalContext, options) {
  var slots = [];

  if (children) {
    children.forEach(function (child) {
      var data = child.data;
      var componentOptions = child.componentOptions;

      if (data && componentTypes.includes(data.slot) || componentOptions && componentTypes.includes(componentOptions.tag)) {
        child.data.slot = data.slot || componentOptions.tag;
        child.data.provide = options.Ctor.options.provide;
        child.context = context;
        child.functionalContext = functionalContext;

        slots.push(child);
      }
    });
  }

  return slots;
}

function getDrawers(children) {
  var drawerVnodes = children.filter(function (child) {
    return child.componentOptions.tag === 'md-app-drawer';
  });

  return drawerVnodes.length ? drawerVnodes : [];
}

function hasInternalDrawer(attrs) {
  var mdPermanent = attrs && attrs['md-permanent'];

  return mdPermanent && (mdPermanent === 'clipped' || mdPermanent === 'card');
}

exports.default = {
  name: 'MdApp',
  functional: true,
  render: function render(createElement, _ref) {
    var children = _ref.children,
        props = _ref.props,
        data = _ref.data;

    var appComponent = _MdAppSideDrawer2.default;

    var _createElement = createElement(appComponent),
        context = _createElement.context,
        functionalContext = _createElement.functionalContext,
        componentOptions = _createElement.componentOptions;

    var slots = buildSlots(children, context, functionalContext, componentOptions);
    var drawers = getDrawers(slots);

    drawers.forEach(function (drawer) {
      if (drawer && hasInternalDrawer(drawer.data.attrs)) {
        appComponent = _MdAppInternalDrawer2.default;
      }
    });

    var staticClass = {};
    if (data.staticClass) {
      data.staticClass.split(/\s+/).forEach(function (name) {
        if (name.length === 0) return;
        staticClass[name] = true;
      });
    }

    return createElement(appComponent, {
      attrs: props,
      class: _extends({}, staticClass, data.class),
      style: _extends({}, data.staticStyle, data.style)
    }, slots);
  }
};

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdApp/MdAppSideDrawer.vue
var MdAppSideDrawer = __webpack_require__(64);
var MdAppSideDrawer_default = /*#__PURE__*/__webpack_require__.n(MdAppSideDrawer);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2aaa67a6","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdApp/MdAppSideDrawer.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-app md-app-side-drawer md-layout-row",
      class: [_vm.appClasses, _vm.$mdActiveTheme]
    },
    [
      _vm._t("md-app-drawer"),
      _vm._v(" "),
      _c(
        "main",
        {
          staticClass: "md-app-container md-flex md-layout-column",
          class: [_vm.$mdActiveTheme, _vm.scrollerClasses],
          style: _vm.contentStyles,
          on: {
            "&scroll": function($event) {
              _vm.handleScroll($event)
            }
          }
        },
        [
          _vm._t("md-app-toolbar"),
          _vm._v(" "),
          _c(
            "div",
            {
              staticClass: "md-app-scroller md-layout-column md-flex",
              class: [_vm.$mdActiveTheme, _vm.scrollerClasses],
              style: _vm.containerStyles,
              on: {
                "&scroll": function($event) {
                  _vm.handleScroll($event)
                }
              }
            },
            [_vm._t("md-app-content")],
            2
          )
        ],
        2
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdApp_MdAppSideDrawer = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2aaa67a6", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdApp/MdAppSideDrawer.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(63)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAppSideDrawer_default.a,
  MdApp_MdAppSideDrawer,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdAppSideDrawer.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2aaa67a6", Component.options)
  } else {
    hotAPI.reload("data-v-2aaa67a6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdApp_MdAppSideDrawer = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 63 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdAppMixin = __webpack_require__(31);

var _MdAppMixin2 = _interopRequireDefault(_MdAppMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdAppInternalSideDrawer',
  mixins: [_MdAppMixin2.default]
});

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);



/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(66)))

/***/ }),
/* 66 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdApp/MdAppInternalDrawer.vue
var MdAppInternalDrawer = __webpack_require__(69);
var MdAppInternalDrawer_default = /*#__PURE__*/__webpack_require__.n(MdAppInternalDrawer);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-f33ea0da","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdApp/MdAppInternalDrawer.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-app md-app-internal-drawer md-layout-column",
      class: [_vm.appClasses, _vm.$mdActiveTheme]
    },
    [
      _vm._t("md-app-toolbar"),
      _vm._v(" "),
      _c(
        "main",
        {
          staticClass: "md-app-container md-flex md-layout-row",
          class: [_vm.$mdActiveTheme, _vm.scrollerClasses],
          style: [_vm.containerStyles, _vm.contentStyles]
        },
        [
          _vm._t("md-app-drawer"),
          _vm._v(" "),
          _c(
            "div",
            {
              staticClass: "md-app-scroller md-layout-column md-flex",
              class: [_vm.$mdActiveTheme, _vm.scrollerClasses]
            },
            [_vm._t("md-app-content")],
            2
          )
        ],
        2
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdApp_MdAppInternalDrawer = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f33ea0da", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdApp/MdAppInternalDrawer.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(68)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAppInternalDrawer_default.a,
  MdApp_MdAppInternalDrawer,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdAppInternalDrawer.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f33ea0da", Component.options)
  } else {
    hotAPI.reload("data-v-f33ea0da", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdApp_MdAppInternalDrawer = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 68 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdAppMixin = __webpack_require__(31);

var _MdAppMixin2 = _interopRequireDefault(_MdAppMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdAppInternalDrawer',
  mixins: [_MdAppMixin2.default]
});

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdApp/MdAppToolbar.vue
var MdAppToolbar = __webpack_require__(72);
var MdAppToolbar_default = /*#__PURE__*/__webpack_require__.n(MdAppToolbar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2d3e4174","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdApp/MdAppToolbar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-toolbar",
    _vm._g(
      _vm._b(
        {
          staticClass: "md-app-toolbar",
          class: _vm.toolbarClasses,
          style: _vm.toolbarStyles
        },
        "md-toolbar",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdApp_MdAppToolbar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2d3e4174", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdApp/MdAppToolbar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(71)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAppToolbar_default.a,
  MdApp_MdAppToolbar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdAppToolbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2d3e4174", Component.options)
  } else {
    hotAPI.reload("data-v-2d3e4174", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdApp_MdAppToolbar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 71 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdAppToolbar',
  inject: ['MdApp'],
  computed: {
    toolbarClasses: function toolbarClasses() {
      return {
        'md-no-elevation': !this.MdApp.toolbar.hasElevation,
        'md-reveal-active': this.MdApp.toolbar.revealActive,
        'md-fixed-last-active': this.MdApp.toolbar.fixedLastActive,
        'md-overlap-off': this.MdApp.toolbar.overlapOff
      };
    },
    toolbarStyles: function toolbarStyles() {
      var styles = {
        'top': this.MdApp.toolbar.top + 'px'
      };

      if (this.MdApp.toolbar.fixedLastActive) {
        styles['transform'] = 'translate3D(0, ' + this.MdApp.toolbar.fixedLastHeight + 'px, 0)';
      }

      return styles;
    }
  },
  mounted: function mounted() {
    var title = this.$el.querySelector('.md-title, .md-display-1, .md-display-2');

    this.MdApp.toolbar.element = this.$el;
    this.MdApp.toolbar.titleElement = title;

    if (title) {
      this.MdApp.toolbar.titleSize = parseInt(window.getComputedStyle(title).fontSize, 10);
    }
  }
};

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdApp/MdAppContent.vue
var MdAppContent = __webpack_require__(75);
var MdAppContent_default = /*#__PURE__*/__webpack_require__.n(MdAppContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-65f3d944","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdApp/MdAppContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.showCard
    ? _c(
        "md-card",
        _vm._g(
          _vm._b(
            { staticClass: "md-app-content md-flex" },
            "md-card",
            _vm.$attrs,
            false
          ),
          _vm.$listeners
        ),
        [_vm._t("default")],
        2
      )
    : _c(
        "md-content",
        _vm._g(
          _vm._b(
            { staticClass: "md-app-content md-flex" },
            "md-content",
            _vm.$attrs,
            false
          ),
          _vm.$listeners
        ),
        [_vm._t("default")],
        2
      )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdApp_MdAppContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-65f3d944", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdApp/MdAppContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(74)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAppContent_default.a,
  MdApp_MdAppContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdAppContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-65f3d944", Component.options)
  } else {
    hotAPI.reload("data-v-65f3d944", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdApp_MdAppContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 74 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdAppContent',
  inject: ['MdApp'],
  computed: {
    showCard: function showCard() {
      return this.MdApp.options && this.MdApp.options.mode === 'overlap';
    }
  }
};

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdApp/MdAppDrawer.vue
var MdAppDrawer = __webpack_require__(77);
var MdAppDrawer_default = /*#__PURE__*/__webpack_require__.n(MdAppDrawer);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-1d41d1f6","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdApp/MdAppDrawer.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-drawer",
    _vm._g(
      _vm._b({ staticClass: "md-app-drawer" }, "md-drawer", _vm.$attrs, false),
      _vm.$listeners
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdApp_MdAppDrawer = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-1d41d1f6", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdApp/MdAppDrawer.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAppDrawer_default.a,
  MdApp_MdAppDrawer,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdApp/MdAppDrawer.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1d41d1f6", Component.options)
  } else {
    hotAPI.reload("data-v-1d41d1f6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdApp_MdAppDrawer = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

//
//
//
//
//
//

exports.default = {
  name: 'MdAppDrawer',
  inject: ['MdApp'],
  data: function data() {
    return {
      drawerElement: {
        mdActive: null,
        mode: null,
        submode: null
      }
    };
  },
  computed: {
    visible: function visible() {
      return this.drawerElement.mdActive;
    },
    mode: function mode() {
      return this.drawerElement.mode;
    },
    submode: function submode() {
      return this.drawerElement.submode;
    }
  },
  watch: {
    visible: function visible(_visible) {
      this.MdApp.drawer.width = this.getDrawerWidth();
      this.MdApp.drawer.active = _visible;
    },
    mode: function mode(_mode) {
      this.MdApp.drawer.mode = _mode;
    },
    submode: function submode(_submode) {
      this.MdApp.drawer.submode = _submode;
    }
  },
  methods: {
    getDrawerWidth: function getDrawerWidth() {
      if (this.$el) {
        return window.getComputedStyle(this.$el).width;
      }

      return 0;
    }
  },
  mounted: function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.$nextTick();

            case 2:
              this.drawerElement = this.$children[0];
              this.MdApp.drawer.width = this.getDrawerWidth();
              this.MdApp.drawer.active = this.visible;
              this.MdApp.drawer.mode = this.mode;
              this.MdApp.drawer.submode = this.submode;
              this.MdApp.drawer.initialWidth = this.$el.offsetWidth;

            case 8:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function mounted() {
      return _ref.apply(this, arguments);
    }

    return mounted;
  }()
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdAutocomplete = __webpack_require__(79);

var _MdAutocomplete2 = _interopRequireDefault(_MdAutocomplete);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdAutocomplete2.default.name, _MdAutocomplete2.default);
};

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdAutocomplete/MdAutocomplete.vue
var MdAutocomplete = __webpack_require__(81);
var MdAutocomplete_default = /*#__PURE__*/__webpack_require__.n(MdAutocomplete);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-130e5ea2","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdAutocomplete/MdAutocomplete.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-field",
    {
      staticClass: "md-autocomplete",
      class: _vm.fieldClasses,
      attrs: { "md-clearable": "", "md-inline": _vm.isBoxLayout }
    },
    [
      _c(
        "md-menu",
        {
          attrs: {
            "md-direction": "bottom-start",
            "md-dense": _vm.mdDense,
            "md-align-trigger": "",
            "md-full-width": "",
            "md-active": _vm.showMenu
          },
          on: {
            "update:mdActive": function($event) {
              _vm.showMenu = $event
            }
          }
        },
        [
          _c(
            "md-input",
            _vm._b(
              {
                attrs: {
                  id: _vm.mdInputId,
                  name: _vm.mdInputName,
                  maxlength: _vm.mdInputMaxlength,
                  placeholder: _vm.mdInputPlaceholder
                },
                on: {
                  focus: function($event) {
                    $event.stopPropagation()
                    _vm.openOnFocus($event)
                  },
                  blur: _vm.hideOptions,
                  input: _vm.onInput,
                  click: function($event) {
                    $event.stopPropagation()
                    $event.preventDefault()
                    _vm.openOnFocus($event)
                  }
                },
                model: {
                  value: _vm.searchTerm,
                  callback: function($$v) {
                    _vm.searchTerm = $$v
                  },
                  expression: "searchTerm"
                }
              },
              "md-input",
              _vm.$attrs,
              false
            )
          ),
          _vm._v(" "),
          _c(
            "md-menu-content",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.hasScopedEmptySlot || _vm.hasFilteredItems,
                  expression: "hasScopedEmptySlot || hasFilteredItems"
                }
              ],
              class: _vm.contentClasses
            },
            [
              _vm.isPromisePending
                ? _c(
                    "div",
                    { staticClass: "md-autocomplete-loading" },
                    [
                      _c("md-progress-spinner", {
                        attrs: {
                          "md-diameter": 40,
                          "md-stroke": 4,
                          "md-mode": "indeterminate"
                        }
                      })
                    ],
                    1
                  )
                : _vm._e(),
              _vm._v(" "),
              _vm.hasFilteredItems
                ? _c(
                    "div",
                    { staticClass: "md-autocomplete-items" },
                    _vm._l(_vm.getOptions(), function(item, index) {
                      return _c(
                        "md-menu-item",
                        {
                          key: index,
                          on: {
                            click: function($event) {
                              _vm.selectItem(item, $event)
                            }
                          }
                        },
                        [
                          _vm.$scopedSlots["md-autocomplete-item"]
                            ? _vm._t("md-autocomplete-item", null, {
                                item: item,
                                term: _vm.searchTerm
                              })
                            : [_vm._v(_vm._s(item))]
                        ],
                        2
                      )
                    })
                  )
                : _vm.hasScopedEmptySlot
                  ? _c("md-menu-item", [
                      _c(
                        "div",
                        { staticClass: "md-autocomplete-empty" },
                        [
                          _vm._t("md-autocomplete-empty", null, {
                            term: _vm.searchTerm
                          })
                        ],
                        2
                      )
                    ])
                  : _vm._e()
            ],
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _vm._t("default")
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdAutocomplete_MdAutocomplete = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-130e5ea2", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdAutocomplete/MdAutocomplete.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(80)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAutocomplete_default.a,
  MdAutocomplete_MdAutocomplete,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdAutocomplete/MdAutocomplete.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-130e5ea2", Component.options)
  } else {
    hotAPI.reload("data-v-130e5ea2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdAutocomplete_MdAutocomplete = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 80 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _fuzzysearch = __webpack_require__(82);

var _fuzzysearch2 = _interopRequireDefault(_fuzzysearch);

var _isPromise2 = __webpack_require__(83);

var _isPromise3 = _interopRequireDefault(_isPromise2);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'MdAutocomplete',
  props: {
    value: {
      type: null,
      required: true
    },
    mdDense: Boolean,
    mdLayout: _extends({
      type: String,
      default: 'floating'
    }, (0, _MdPropValidator2.default)('md-layout', ['floating', 'box'])),
    mdOpenOnFocus: {
      type: Boolean,
      default: true
    },
    mdFuzzySearch: {
      type: Boolean,
      default: true
    },
    mdOptions: {
      type: [Array, Promise],
      required: true
    },
    mdInputName: String,
    mdInputId: String,
    mdInputMaxlength: [String, Number],
    mdInputPlaceholder: [String, Number]
  },
  data: function data() {
    return {
      searchTerm: this.value,
      showMenu: false,
      triggerPopover: false,
      isPromisePending: false,
      filteredAsyncOptions: []
    };
  },

  computed: {
    isBoxLayout: function isBoxLayout() {
      return this.mdLayout === 'box';
    },
    fieldClasses: function fieldClasses() {
      if (this.isBoxLayout) {
        return 'md-autocomplete-box';
      }
    },
    contentClasses: function contentClasses() {
      if (this.isBoxLayout) {
        return 'md-autocomplete-box-content';
      }
    },
    filteredStaticOptions: function filteredStaticOptions() {
      if (this.isPromise(this.mdOptions)) {
        return false;
      }

      var firstItem = this.mdOptions[0];

      if (this.mdOptions[0] && this.searchTerm) {
        if (typeof firstItem === 'string') {
          return this.filterByString();
        } else if ((typeof firstItem === 'undefined' ? 'undefined' : _typeof(firstItem)) === 'object') {
          return this.filterByObject();
        }
      }

      return this.mdOptions;
    },
    hasFilteredItems: function hasFilteredItems() {
      return this.filteredStaticOptions.length > 0 || this.filteredAsyncOptions.length > 0;
    },
    hasScopedEmptySlot: function hasScopedEmptySlot() {
      return this.$scopedSlots['md-autocomplete-empty'];
    }
  },
  watch: {
    mdOptions: {
      deep: true,
      immediate: true,
      handler: function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!this.isPromise(this.mdOptions)) {
                    _context.next = 6;
                    break;
                  }

                  this.isPromisePending = true;
                  _context.next = 4;
                  return this.mdOptions;

                case 4:
                  this.filteredAsyncOptions = _context.sent;

                  this.isPromisePending = false;

                case 6:
                case 'end':
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function handler() {
          return _ref.apply(this, arguments);
        }

        return handler;
      }()
    },

    value: function value(val) {
      this.searchTerm = val;
    }
  },
  methods: {
    getOptions: function getOptions() {
      if (this.isPromise(this.mdOptions)) {
        return this.filteredAsyncOptions;
      }

      return this.filteredStaticOptions;
    },
    isPromise: function isPromise(obj) {
      return (0, _isPromise3.default)(obj);
    },
    matchText: function matchText(item) {
      var target = item.toLowerCase();
      var search = this.searchTerm.toLowerCase();

      if (this.mdFuzzySearch) {
        return (0, _fuzzysearch2.default)(search, target);
      }

      return target.includes(search);
    },
    filterByString: function filterByString() {
      var _this = this;

      return this.mdOptions.filter(function (item) {
        return _this.matchText(item);
      });
    },
    filterByObject: function filterByObject() {
      var _this2 = this;

      return this.mdOptions.filter(function (item) {
        var values = Object.values(item);
        var valuesCount = values.length;

        for (var i = 0; i <= valuesCount; i++) {
          if (typeof values[i] === 'string' && _this2.matchText(values[i])) {
            return true;
          }
        }
      });
    },
    openOnFocus: function openOnFocus() {
      if (this.mdOpenOnFocus) {
        this.showOptions();
      }
    },
    onInput: function onInput(value) {
      this.$emit('input', value);

      if (!this.mdOpenOnFocus) {
        this.showOptions();
      }

      if (this.searchTerm.constructor.name.toLowerCase() !== 'inputevent') {
        this.$emit('md-changed', this.searchTerm);
      }
    },
    showOptions: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.showMenu) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', false);

              case 2:

                this.showMenu = true;
                _context2.next = 5;
                return this.$nextTick();

              case 5:
                this.triggerPopover = true;
                this.$emit('md-opened');

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function showOptions() {
        return _ref2.apply(this, arguments);
      }

      return showOptions;
    }(),
    hideOptions: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.$nextTick();

              case 2:
                this.showMenu = false;
                _context3.next = 5;
                return this.$nextTick();

              case 5:
                this.triggerPopover = false;
                this.$emit('md-closed');

              case 7:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function hideOptions() {
        return _ref3.apply(this, arguments);
      }

      return hideOptions;
    }(),
    selectItem: function selectItem(item, $event) {
      var content = $event.target.textContent.trim();

      this.searchTerm = content;
      this.$emit('input', item);
      this.$emit('md-selected', item);
      this.hideOptions();
    }
  }
};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function fuzzysearch (needle, haystack) {
  var tlen = haystack.length;
  var qlen = needle.length;
  if (qlen > tlen) {
    return false;
  }
  if (qlen === tlen) {
    return needle === haystack;
  }
  outer: for (var i = 0, j = 0; i < qlen; i++) {
    var nch = needle.charCodeAt(i);
    while (j < tlen) {
      if (haystack.charCodeAt(j++) === nch) {
        continue outer;
      }
    }
    return false;
  }
  return true;
}

module.exports = fuzzysearch;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdAvatar = __webpack_require__(85);

var _MdAvatar2 = _interopRequireDefault(_MdAvatar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdAvatar2.default.name, _MdAvatar2.default);
};

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdAvatar/MdAvatar.vue
var MdAvatar = __webpack_require__(87);
var MdAvatar_default = /*#__PURE__*/__webpack_require__.n(MdAvatar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2bc61fcf","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdAvatar/MdAvatar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-avatar", class: [_vm.$mdActiveTheme] },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdAvatar_MdAvatar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2bc61fcf", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdAvatar/MdAvatar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(86)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdAvatar_default.a,
  MdAvatar_MdAvatar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdAvatar/MdAvatar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2bc61fcf", Component.options)
  } else {
    hotAPI.reload("data-v-2bc61fcf", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdAvatar_MdAvatar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 86 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdAvatar'
}); //
//
//
//
//
//

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdBottomBar = __webpack_require__(89);

var _MdBottomBar2 = _interopRequireDefault(_MdBottomBar);

var _MdBottomBarItem = __webpack_require__(95);

var _MdBottomBarItem2 = _interopRequireDefault(_MdBottomBarItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdBottomBar2.default.name, _MdBottomBar2.default);
  Vue.component(_MdBottomBarItem2.default.name, _MdBottomBarItem2.default);
};

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdBottomBar/MdBottomBar.vue
var MdBottomBar = __webpack_require__(91);
var MdBottomBar_default = /*#__PURE__*/__webpack_require__.n(MdBottomBar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-0fac6773","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdBottomBar/MdBottomBar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-bottom-bar",
      class: [_vm.$mdActiveTheme, _vm.barClasses]
    },
    [
      _c(
        "md-ripple",
        {
          attrs: {
            "md-disabled": _vm.mdType === "fixed",
            "md-active": _vm.MdBottomBar.mouseEvent
          }
        },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdBottomBar_MdBottomBar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0fac6773", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdBottomBar/MdBottomBar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(90)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdBottomBar_default.a,
  MdBottomBar_MdBottomBar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdBottomBar/MdBottomBar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0fac6773", Component.options)
  } else {
    hotAPI.reload("data-v-0fac6773", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdBottomBar_MdBottomBar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = new _MdComponent2.default({
  name: 'MdBottomBar',
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    mdSyncRoute: Boolean,
    mdActiveItem: [String, Number],
    mdType: _extends({
      type: String,
      default: 'fixed'
    }, (0, _MdPropValidator2.default)('md-type', ['fixed', 'shift']))
  },
  data: function data() {
    return {
      MdBottomBar: {
        mouseEvent: null,
        activeItem: null,
        items: {}
      }
    };
  },
  provide: function provide() {
    return {
      MdBottomBar: this.MdBottomBar
    };
  },

  computed: {
    activeItem: function activeItem() {
      return this.MdBottomBar.activeItem;
    },
    barClasses: function barClasses() {
      return _defineProperty({}, 'md-type-' + this.mdType, true);
    }
  },
  watch: {
    activeItem: function activeItem() {
      this.$emit('md-changed', this.activeItem);
    }
  },
  methods: {
    setupWatchers: function setupWatchers() {
      if (this.mdSyncRoute) {
        this.$watch('$route', {
          deep: true,
          handler: function handler() {
            if (this.mdSyncRoute) {
              this.setActiveItemByRoute();
            }
          }
        });
      }
    },
    hasActiveItem: function hasActiveItem() {
      return this.MdBottomBar.activeItem || this.mdActiveItem;
    },
    getItemsAndKeys: function getItemsAndKeys() {
      var items = this.MdBottomBar.items;

      return {
        items: items,
        keys: Object.keys(items)
      };
    },
    setActiveItemByIndex: function setActiveItemByIndex(index) {
      var _getItemsAndKeys = this.getItemsAndKeys(),
          keys = _getItemsAndKeys.keys;

      if (!this.mdActiveItem) {
        this.MdBottomBar.activeItem = keys[index];
      } else {
        this.MdBottomBar.activeItem = this.mdActiveItem;
      }
    },
    setActiveItemByRoute: function setActiveItemByRoute() {
      var _this = this;

      var _getItemsAndKeys2 = this.getItemsAndKeys(),
          items = _getItemsAndKeys2.items,
          keys = _getItemsAndKeys2.keys;

      var tabIndex = null;

      if (this.$router) {
        keys.forEach(function (key, index) {
          var item = items[key];
          var toProp = item.props.to;

          if (toProp && toProp === _this.$route.path) {
            tabIndex = index;
          }
        });
      }

      if (!this.hasActiveItem()) {
        if (keys[tabIndex]) {
          this.MdBottomBar.activeItem = keys[tabIndex];
        } else {
          this.MdBottomBar.activeItem = keys[0];
        }
      } else if (keys[tabIndex]) {
        this.MdBottomBar.activeItem = keys[tabIndex];
      }
    }
  },
  created: function created() {
    this.MdBottomBar.type = this.mdType;
  },
  mounted: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var _this2 = this;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.$nextTick();

            case 2:

              if (this.mdSyncRoute) {
                this.setActiveItemByRoute();
              } else {
                this.setActiveItemByIndex(0);
              }

              window.setTimeout(function () {
                _this2.setupWatchers();
              }, 100);

            case 4:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function mounted() {
      return _ref2.apply(this, arguments);
    }

    return mounted;
  }()
});

/***/ }),
/* 92 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdDebounce = __webpack_require__(94);

var _MdDebounce2 = _interopRequireDefault(_MdDebounce);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdRipple',
  props: {
    mdActive: null,
    mdDisabled: Boolean,
    mdCentered: Boolean
  },
  data: function data() {
    return {
      ripples: [],
      touchTimeout: null,
      eventType: null
    };
  },
  computed: {
    isDisabled: function isDisabled() {
      return !this.$material.ripple || this.mdDisabled;
    },
    rippleClasses: function rippleClasses() {
      return {
        'md-disabled': this.isDisabled
      };
    },
    waveClasses: function waveClasses() {
      return {
        'md-centered': this.mdCentered
      };
    }
  },
  watch: {
    mdActive: function mdActive(active) {
      var isBoolean = typeof active === 'boolean';
      var isEvent = active.constructor.name.toLowerCase() === 'mouseevent';

      if (isBoolean && this.mdCentered && active) {
        this.startRipple({
          type: 'mousedown'
        });
        this.$emit('update:mdActive', false);
      } else if (isEvent) {
        this.startRipple(active);
        this.$emit('update:mdActive', false);
      }
      this.clearWave();
    }
  },
  methods: {
    touchMoveCheck: function touchMoveCheck() {
      window.clearTimeout(this.touchTimeout);
    },
    touchStartCheck: function touchStartCheck($event) {
      var _this = this;

      this.touchTimeout = window.setTimeout(function () {
        _this.startRipple($event);
      }, 100);
    },
    startRipple: function startRipple($event) {
      var _this2 = this;

      (0, _raf2.default)(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var eventType, isDisabled, mdCentered, size, position;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                eventType = _this2.eventType, isDisabled = _this2.isDisabled, mdCentered = _this2.mdCentered;


                if (!isDisabled && (!eventType || eventType === $event.type)) {
                  size = _this2.getSize();
                  position = null;


                  if (mdCentered) {
                    position = _this2.getCenteredPosition(size);
                  } else {
                    position = _this2.getHitPosition($event, size);
                  }

                  _this2.eventType = $event.type;
                  _this2.ripples.push({
                    animating: true,
                    waveStyles: _this2.applyStyles(position, size)
                  });
                }

              case 2:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      })));
    },
    applyStyles: function applyStyles(position, size) {
      size += 'px';

      return _extends({}, position, {
        width: size,
        height: size
      });
    },

    clearWave: (0, _MdDebounce2.default)(function () {
      this.ripples = [];
    }, 2000),
    getSize: function getSize() {
      var _$el = this.$el,
          offsetWidth = _$el.offsetWidth,
          offsetHeight = _$el.offsetHeight;


      return Math.round(Math.max(offsetWidth, offsetHeight));
    },
    getCenteredPosition: function getCenteredPosition(size) {
      var halfSize = -size / 2 + 'px';

      return {
        'margin-top': halfSize,
        'margin-left': halfSize
      };
    },
    getHitPosition: function getHitPosition($event, elementSize) {
      var rect = this.$el.getBoundingClientRect();
      var top = $event.pageY;
      var left = $event.pageX;

      if ($event.type === 'touchstart') {
        top = $event.changedTouches[0].pageY;
        left = $event.changedTouches[0].pageX;
      }

      return {
        top: top - rect.top - elementSize / 2 - document.documentElement.scrollTop + 'px',
        left: left - rect.left - elementSize / 2 - document.documentElement.scrollLeft + 'px'
      };
    }
  }
});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (fn, time) {
  var timeout = void 0;
  return function () {
    var _this = this,
        _arguments = arguments;

    var functionCall = function functionCall() {
      return fn.apply(_this, _arguments);
    };
    clearTimeout(timeout);
    timeout = setTimeout(functionCall, time);
  };
};

/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdBottomBar/MdBottomBarItem.vue
var MdBottomBarItem = __webpack_require__(96);
var MdBottomBarItem_default = /*#__PURE__*/__webpack_require__.n(MdBottomBarItem);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7ba29fa6","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdBottomBar/MdBottomBarItem.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-button",
    _vm._g(
      _vm._b(
        {
          staticClass: "md-bottom-bar-item",
          class: _vm.itemClasses,
          attrs: {
            id: _vm.id,
            disabled: _vm.mdDisabled,
            "md-ripple": _vm.MdBottomBar.type === "fixed"
          },
          on: { click: _vm.setActiveItem }
        },
        "md-button",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [
      _vm.$slots.default
        ? _vm._t("default")
        : [
            _vm.isAssetIcon(_vm.mdIcon)
              ? _c("md-icon", {
                  staticClass: "md-bottom-bar-icon",
                  attrs: { "md-src": _vm.mdIcon }
                })
              : _c("md-icon", { staticClass: "md-bottom-bar-icon" }, [
                  _vm._v(_vm._s(_vm.mdIcon))
                ]),
            _vm._v(" "),
            _c("span", { staticClass: "md-bottom-bar-label" }, [
              _vm._v(_vm._s(_vm.mdLabel))
            ])
          ]
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdBottomBar_MdBottomBarItem = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7ba29fa6", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdBottomBar/MdBottomBarItem.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdBottomBarItem_default.a,
  MdBottomBar_MdBottomBarItem,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdBottomBar/MdBottomBarItem.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7ba29fa6", Component.options)
  } else {
    hotAPI.reload("data-v-7ba29fa6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdBottomBar_MdBottomBarItem = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdAssetIcon = __webpack_require__(18);

var _MdAssetIcon2 = _interopRequireDefault(_MdAssetIcon);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdRouterLinkProps = __webpack_require__(12);

var _MdRouterLinkProps2 = _interopRequireDefault(_MdRouterLinkProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ignoredProps = ['id', 'mdLabel', 'mdIcon', 'mdDisabled']; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdBottomBarItem',
  mixins: [_MdAssetIcon2.default],
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-bottom-bar-item-' + (0, _MdUuid2.default)();
      }
    },
    to: null,
    mdLabel: String,
    mdIcon: String,
    mdDisabled: Boolean
  },
  inject: ['MdBottomBar'],
  watch: {
    $props: {
      deep: true,
      handler: function handler() {
        this.setItemData();
      }
    },
    $attrs: {
      deep: true,
      handler: function handler() {
        this.setItemData();
      }
    }
  },
  computed: {
    itemClasses: function itemClasses() {
      return {
        'md-active': this.id === this.MdBottomBar.activeItem
      };
    }
  },
  methods: {
    getPropValues: function getPropValues() {
      var _this = this;

      var propNames = Object.keys(this.$options.props);
      var values = {};

      propNames.forEach(function (prop) {
        if (!ignoredProps.includes(prop)) {
          if (_this[prop]) {
            values[prop] = _this[prop];
          } else if (_this.$attrs && _this.$attrs.hasOwnProperty(prop)) {
            if (prop) {
              values[prop] = _this.$attrs[prop];
            } else {
              values[prop] = true;
            }
          }
        }
      });

      return values;
    },
    setItemData: function setItemData() {
      this.$set(this.MdBottomBar.items, this.id, {
        disabled: this.mdDisabled,
        options: this.mdTemplateOptions,
        props: this.getPropValues()
      });
    },
    setActiveItem: function setActiveItem($event) {
      this.MdBottomBar.activeItem = this.id;

      if (this.MdBottomBar.type === 'shift') {
        this.MdBottomBar.mouseEvent = $event;
      }
    }
  },
  beforeCreate: function beforeCreate() {
    var _this2 = this;

    if (this.$router && this.$options.propsData.to) {
      var componentProps = (0, _MdRouterLinkProps2.default)(this, this.$options.props);
      var propNames = Object.keys(this.$options.propsData);

      this.$options.props = componentProps;
      propNames.forEach(function (prop) {
        if (!ignoredProps.includes(prop)) {
          _this2.$attrs[prop] = _this2.$options.propsData[prop];
        }
      });
    }
  },
  created: function created() {
    this.setItemData();
  },
  beforeDestroy: function beforeDestroy() {
    this.$delete(this.MdBottomBar.items, this.id);
  }
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdButton = __webpack_require__(13);

var _MdButton2 = _interopRequireDefault(_MdButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdButton2.default.name, _MdButton2.default);
};

/***/ }),
/* 98 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdFocused = __webpack_require__(32);

var _MdFocused2 = _interopRequireDefault(_MdFocused);

var _MdRipple = __webpack_require__(19);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

var _MdRouterLinkProps = __webpack_require__(12);

var _MdRouterLinkProps2 = _interopRequireDefault(_MdRouterLinkProps);

var _MdButtonContent = __webpack_require__(100);

var _MdButtonContent2 = _interopRequireDefault(_MdButtonContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdButton',
  components: {
    MdButtonContent: _MdButtonContent2.default
  },
  mixins: [_MdRipple2.default, _MdFocused2.default],
  props: {
    href: String,
    type: {
      type: String,
      default: 'button'
    },
    disabled: Boolean,
    to: null
  },
  render: function render(createElement) {
    var buttonContent = createElement('md-button-content', {
      attrs: {
        mdRipple: this.mdRipple,
        disabled: this.disabled
      }
    }, this.$slots.default);
    var buttonAttrs = {
      staticClass: 'md-button',
      class: [this.$mdActiveTheme, {
        'md-ripple-off': !this.mdRipple,
        'md-focused': this.mdHasFocus
      }],
      attrs: _extends({}, this.attrs, {
        href: this.href,
        disabled: this.disabled,
        type: !this.href && (this.type || 'button')
      }),
      on: this.$listeners
    };
    var tag = 'button';

    if (this.href) {
      tag = 'a';
    } else if (this.$router && this.to) {
      this.$options.props = (0, _MdRouterLinkProps2.default)(this, this.$options.props);

      tag = 'router-link';
      buttonAttrs.props = this.$props;
      delete buttonAttrs.props.type;
      delete buttonAttrs.attrs.type;
      delete buttonAttrs.props.href;
      delete buttonAttrs.attrs.href;
    }

    return createElement(tag, buttonAttrs, [buttonContent]);
  }
});

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdButton/MdButtonContent.vue
var MdButtonContent = __webpack_require__(102);
var MdButtonContent_default = /*#__PURE__*/__webpack_require__.n(MdButtonContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-008ae93a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdButton/MdButtonContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-ripple",
    { attrs: { "md-disabled": !_vm.mdRipple || _vm.disabled } },
    [_c("div", { staticClass: "md-button-content" }, [_vm._t("default")], 2)]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdButton_MdButtonContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-008ae93a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdButton/MdButtonContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(101)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdButtonContent_default.a,
  MdButton_MdButtonContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdButton/MdButtonContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-008ae93a", Component.options)
  } else {
    hotAPI.reload("data-v-008ae93a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdButton_MdButtonContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 101 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdButtonContent',
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    mdRipple: Boolean,
    disabled: Boolean
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdCard = __webpack_require__(104);

var _MdCard2 = _interopRequireDefault(_MdCard);

var _MdCardArea = __webpack_require__(107);

var _MdCardArea2 = _interopRequireDefault(_MdCardArea);

var _MdCardHeader = __webpack_require__(110);

var _MdCardHeader2 = _interopRequireDefault(_MdCardHeader);

var _MdCardHeaderText = __webpack_require__(113);

var _MdCardHeaderText2 = _interopRequireDefault(_MdCardHeaderText);

var _MdCardMedia = __webpack_require__(115);

var _MdCardMedia2 = _interopRequireDefault(_MdCardMedia);

var _MdCardMediaActions = __webpack_require__(118);

var _MdCardMediaActions2 = _interopRequireDefault(_MdCardMediaActions);

var _MdCardMediaCover = __webpack_require__(121);

var _MdCardMediaCover2 = _interopRequireDefault(_MdCardMediaCover);

var _MdCardContent = __webpack_require__(124);

var _MdCardContent2 = _interopRequireDefault(_MdCardContent);

var _MdCardExpand = __webpack_require__(127);

var _MdCardExpand2 = _interopRequireDefault(_MdCardExpand);

var _MdCardExpandTrigger = __webpack_require__(130);

var _MdCardExpandTrigger2 = _interopRequireDefault(_MdCardExpandTrigger);

var _MdCardExpandContent = __webpack_require__(133);

var _MdCardExpandContent2 = _interopRequireDefault(_MdCardExpandContent);

var _MdCardActions = __webpack_require__(136);

var _MdCardActions2 = _interopRequireDefault(_MdCardActions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdCard2.default.name, _MdCard2.default);
  Vue.component(_MdCardArea2.default.name, _MdCardArea2.default);
  Vue.component(_MdCardHeader2.default.name, _MdCardHeader2.default);
  Vue.component(_MdCardHeaderText2.default.name, _MdCardHeaderText2.default);
  Vue.component(_MdCardMedia2.default.name, _MdCardMedia2.default);
  Vue.component(_MdCardMediaActions2.default.name, _MdCardMediaActions2.default);
  Vue.component(_MdCardMediaCover2.default.name, _MdCardMediaCover2.default);
  Vue.component(_MdCardContent2.default.name, _MdCardContent2.default);
  Vue.component(_MdCardExpand2.default.name, _MdCardExpand2.default);
  Vue.component(_MdCardExpandTrigger2.default.name, _MdCardExpandTrigger2.default);
  Vue.component(_MdCardExpandContent2.default.name, _MdCardExpandContent2.default);
  Vue.component(_MdCardActions2.default.name, _MdCardActions2.default);
};

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCard.vue
var MdCard = __webpack_require__(106);
var MdCard_default = /*#__PURE__*/__webpack_require__.n(MdCard);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-24f7f3af","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCard.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card", class: [_vm.$mdActiveTheme, _vm.cardClasses] },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCard_MdCard = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-24f7f3af", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCard.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(105)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCard_default.a,
  MdCard_MdCard,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCard.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-24f7f3af", Component.options)
  } else {
    hotAPI.reload("data-v-24f7f3af", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdCard_MdCard = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 105 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdCard',
  props: {
    mdWithHover: Boolean
  },
  data: function data() {
    return {
      MdCard: {
        expand: false
      }
    };
  },
  provide: function provide() {
    return {
      MdCard: this.MdCard
    };
  },

  computed: {
    cardClasses: function cardClasses() {
      return {
        'md-with-hover': this.mdWithHover,
        'md-expand-active': this.MdCard.expand
      };
    }
  }
}); //
//
//
//
//
//

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardArea/MdCardArea.vue
var MdCardArea = __webpack_require__(109);
var MdCardArea_default = /*#__PURE__*/__webpack_require__.n(MdCardArea);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-132f02d7","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardArea/MdCardArea.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-area", class: _vm.areaClasses },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardArea_MdCardArea = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-132f02d7", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardArea/MdCardArea.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(108)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardArea_default.a,
  MdCardArea_MdCardArea,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardArea/MdCardArea.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-132f02d7", Component.options)
  } else {
    hotAPI.reload("data-v-132f02d7", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardArea_MdCardArea = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 108 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardArea',
  props: {
    mdInset: Boolean
  },
  computed: {
    areaClasses: function areaClasses() {
      return {
        'md-inset': this.mdInset
      };
    }
  }
};

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardHeader/MdCardHeader.vue
var MdCardHeader = __webpack_require__(112);
var MdCardHeader_default = /*#__PURE__*/__webpack_require__.n(MdCardHeader);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4d103817","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardHeader/MdCardHeader.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "md-card-header" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardHeader_MdCardHeader = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4d103817", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardHeader/MdCardHeader.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(111)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardHeader_default.a,
  MdCardHeader_MdCardHeader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardHeader/MdCardHeader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4d103817", Component.options)
  } else {
    hotAPI.reload("data-v-4d103817", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardHeader_MdCardHeader = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 111 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardHeader'
};

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardHeader/MdCardHeaderText.vue
var MdCardHeaderText = __webpack_require__(114);
var MdCardHeaderText_default = /*#__PURE__*/__webpack_require__.n(MdCardHeaderText);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-49a3ab64","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardHeader/MdCardHeaderText.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-header-text" },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardHeader_MdCardHeaderText = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-49a3ab64", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardHeader/MdCardHeaderText.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardHeaderText_default.a,
  MdCardHeader_MdCardHeaderText,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardHeader/MdCardHeaderText.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-49a3ab64", Component.options)
  } else {
    hotAPI.reload("data-v-49a3ab64", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardHeader_MdCardHeaderText = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardHeaderText',
  data: function data() {
    return {
      parentClasses: null
    };
  },
  mounted: function mounted() {
    this.parentClasses = this.$parent.$el.classList;

    if (this.parentClasses.contains('md-card-header')) {
      this.parentClasses.add('md-card-header-flex');
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.parentClasses.remove('md-card-header-flex');
  }
};

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMedia.vue
var MdCardMedia = __webpack_require__(117);
var MdCardMedia_default = /*#__PURE__*/__webpack_require__.n(MdCardMedia);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-33e1f253","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMedia.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-media", class: _vm.mediaClasses },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardMedia_MdCardMedia = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-33e1f253", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardMedia/MdCardMedia.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(116)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardMedia_default.a,
  MdCardMedia_MdCardMedia,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardMedia/MdCardMedia.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-33e1f253", Component.options)
  } else {
    hotAPI.reload("data-v-33e1f253", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardMedia_MdCardMedia = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 116 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdCardMedia',
  props: {
    mdRatio: _extends({
      type: String
    }, (0, _MdPropValidator2.default)('md-ratio', ['16-9', '16/9', '16:9', '4-3', '4/3', '4:3', '1-1', '1/1', '1:1'])),
    mdMedium: Boolean,
    mdBig: Boolean
  },
  computed: {
    mediaClasses: function mediaClasses() {
      var classes = {};

      if (this.mdRatio) {
        var ratio = this.getAspectRatio();

        if (ratio) {
          var _ratio = _slicedToArray(ratio, 2),
              horiz = _ratio[0],
              vert = _ratio[1];

          classes['md-ratio-' + horiz + '-' + vert] = true;
        }
      }

      if (this.mdMedium || this.mdBig) {
        classes = {
          'md-medium': this.mdMedium,
          'md-big': this.mdBig
        };
      }

      return classes;
    }
  },
  methods: {
    getAspectRatio: function getAspectRatio() {
      var ratio = [];

      if (this.mdRatio.indexOf(':') !== -1) {
        ratio = this.mdRatio.split(':');
      } else if (this.mdRatio.indexOf('/') !== -1) {
        ratio = this.mdRatio.split('/');
      } else if (this.mdRatio.indexOf('-') !== -1) {
        ratio = this.mdRatio.split('-');
      }

      return ratio.length === 2 ? ratio : null;
    }
  }
};

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMediaActions.vue
var MdCardMediaActions = __webpack_require__(120);
var MdCardMediaActions_default = /*#__PURE__*/__webpack_require__.n(MdCardMediaActions);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-102584da","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMediaActions.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-media-actions" },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardMedia_MdCardMediaActions = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-102584da", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardMedia/MdCardMediaActions.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(119)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardMediaActions_default.a,
  MdCardMedia_MdCardMediaActions,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardMedia/MdCardMediaActions.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-102584da", Component.options)
  } else {
    hotAPI.reload("data-v-102584da", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardMedia_MdCardMediaActions = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 119 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardMediaActions'
};

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMediaCover.vue
var MdCardMediaCover = __webpack_require__(123);
var MdCardMediaCover_default = /*#__PURE__*/__webpack_require__.n(MdCardMediaCover);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-20dfcfd4","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardMedia/MdCardMediaCover.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-media-cover", class: _vm.coverClasses },
    [
      _vm._t("default"),
      _vm._v(" "),
      _vm.mdTextScrim
        ? _c("div", {
            ref: "backdrop",
            staticClass: "md-card-backdrop",
            style: _vm.coverStyles
          })
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardMedia_MdCardMediaCover = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-20dfcfd4", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardMedia/MdCardMediaCover.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(122)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardMediaCover_default.a,
  MdCardMedia_MdCardMediaCover,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardMedia/MdCardMediaCover.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-20dfcfd4", Component.options)
  } else {
    hotAPI.reload("data-v-20dfcfd4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardMedia_MdCardMediaCover = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 122 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//

exports.default = {
  name: 'MdCardMediaCover',
  props: {
    mdTextScrim: Boolean,
    mdSolid: Boolean
  },
  data: function data() {
    return {
      backdropBackground: {}
    };
  },
  computed: {
    coverClasses: function coverClasses() {
      return {
        'md-text-scrim': this.mdTextScrim,
        'md-solid': this.mdSolid
      };
    },
    coverStyles: function coverStyles() {
      return {
        background: this.backdropBackground
      };
    }
  },
  methods: {
    applyScrimColor: function applyScrimColor(darkness) {
      if (this.$refs.backdrop) {
        this.backdropBackground = 'linear-gradient(to bottom, rgba(0, 0, 0, 0) 20%, rgba(0, 0, 0, ' + darkness / 2 + ') 66%, rgba(0, 0, 0, ' + darkness + ') 100%)';
      }
    },
    applySolidColor: function applySolidColor(darkness) {
      var area = this.$el.querySelector('.md-card-area');

      if (area) {
        area.style.background = 'rgba(0, 0, 0, ' + darkness + ')';
      }
    },
    getImageLightness: function getImageLightness(image, onLoad, onError) {
      var canvas = document.createElement('canvas');

      image.crossOrigin = 'Anonymous';

      image.onload = function () {
        var colorSum = 0;
        var ctx = void 0;
        var imageData = void 0;
        var imageMetadata = void 0;
        var r = void 0;
        var g = void 0;
        var b = void 0;
        var average = void 0;

        canvas.width = this.width;
        canvas.height = this.height;
        ctx = canvas.getContext('2d');

        ctx.drawImage(this, 0, 0);

        imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        imageMetadata = imageData.data;

        for (var x = 0, len = imageMetadata.length; x < len; x += 4) {
          r = imageMetadata[x];
          g = imageMetadata[x + 1];
          b = imageMetadata[x + 2];

          average = Math.floor((r + g + b) / 3);
          colorSum += average;
        }

        onLoad(Math.floor(colorSum / (this.width * this.height)));
      };

      image.onerror = onError;
    }
  },
  mounted: function mounted() {
    var _this = this;

    var applyBackground = function applyBackground() {
      var darkness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.6;

      if (_this.mdTextScrim) {
        _this.applyScrimColor(darkness);
      } else if (_this.mdSolid) {
        _this.applySolidColor(darkness);
      }
    };
    var image = this.$el.querySelector('img');

    if (image && (this.mdTextScrim || this.mdSolid)) {
      this.getImageLightness(image, function (lightness) {
        var limit = 256;
        var darkness = (Math.abs(limit - lightness) * 100 / limit + 15) / 100;

        if (darkness >= 0.7) {
          darkness = 0.7;
        }

        applyBackground(darkness);
      }, applyBackground);
    }
  }
};

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardContent/MdCardContent.vue
var MdCardContent = __webpack_require__(126);
var MdCardContent_default = /*#__PURE__*/__webpack_require__.n(MdCardContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-36a98486","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardContent/MdCardContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "md-card-content" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardContent_MdCardContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-36a98486", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardContent/MdCardContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(125)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardContent_default.a,
  MdCardContent_MdCardContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardContent/MdCardContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-36a98486", Component.options)
  } else {
    hotAPI.reload("data-v-36a98486", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardContent_MdCardContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 125 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardContent'
};

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardExpand/MdCardExpand.vue
var MdCardExpand = __webpack_require__(129);
var MdCardExpand_default = /*#__PURE__*/__webpack_require__.n(MdCardExpand);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-d46d3592","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardExpand/MdCardExpand.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "md-card-expand" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardExpand_MdCardExpand = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-d46d3592", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardExpand/MdCardExpand.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(128)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardExpand_default.a,
  MdCardExpand_MdCardExpand,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardExpand/MdCardExpand.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d46d3592", Component.options)
  } else {
    hotAPI.reload("data-v-d46d3592", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardExpand_MdCardExpand = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 128 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardExpand',
  inject: ['MdCard']
};

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdCardExpandTrigger_vue__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdCardExpandTrigger_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdCardExpandTrigger_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(131)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdCardExpandTrigger_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardExpand/MdCardExpandTrigger.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4ede00b1", Component.options)
  } else {
    hotAPI.reload("data-v-4ede00b1", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 131 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = {
  name: 'MdCardExpandTrigger',
  inject: ['MdCard'],
  render: function render(createElement) {
    var _this = this;

    var _$slots$default = _slicedToArray(this.$slots.default, 1),
        trigger = _$slots$default[0];

    var staticClass = ' md-card-expand-trigger';
    var listeners = {
      click: function click() {
        _this.MdCard.expand = !_this.MdCard.expand;
      }
    };

    if (trigger) {
      trigger.componentOptions.listeners = _extends({}, trigger.componentOptions.listeners, listeners);
      trigger.data.staticClass += staticClass;

      return trigger;
    }

    return createElement('div', {
      staticClass: staticClass,
      on: listeners
    });
  }
};

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardExpand/MdCardExpandContent.vue
var MdCardExpandContent = __webpack_require__(135);
var MdCardExpandContent_default = /*#__PURE__*/__webpack_require__.n(MdCardExpandContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-604296f2","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardExpand/MdCardExpandContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-card-expand-content", style: _vm.contentStyles },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardExpand_MdCardExpandContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-604296f2", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardExpand/MdCardExpandContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(134)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardExpandContent_default.a,
  MdCardExpand_MdCardExpandContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardExpand/MdCardExpandContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-604296f2", Component.options)
  } else {
    hotAPI.reload("data-v-604296f2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardExpand_MdCardExpandContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 134 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdCardExpandContent',
  inject: ['MdCard'],
  data: function data() {
    return {
      marginTop: 0
    };
  },
  computed: {
    expand: function expand() {
      return this.MdCard.expand;
    },
    contentStyles: function contentStyles() {
      return {
        'margin-top': '-' + this.marginTop + 'px',
        'opacity': this.marginTop === 0 ? 1 : 0
      };
    }
  },
  watch: {
    expand: function expand(_expand) {
      if (!_expand) {
        this.marginTop = this.$el.children[0].offsetHeight;
      } else {
        this.marginTop = 0;
      }
    }
  },
  mounted: function mounted() {
    this.marginTop = this.$el.children[0].offsetHeight;
  }
};

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCard/MdCardActions/MdCardActions.vue
var MdCardActions = __webpack_require__(138);
var MdCardActions_default = /*#__PURE__*/__webpack_require__.n(MdCardActions);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2894ebc5","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCard/MdCardActions/MdCardActions.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-card-actions",
      class: "md-alignment-" + _vm.mdAlignment
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCardActions_MdCardActions = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2894ebc5", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCard/MdCardActions/MdCardActions.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(137)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCardActions_default.a,
  MdCardActions_MdCardActions,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCard/MdCardActions/MdCardActions.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2894ebc5", Component.options)
  } else {
    hotAPI.reload("data-v-2894ebc5", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdCard_MdCardActions_MdCardActions = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 137 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var alignments = ['left', 'right', 'space-between'];

exports.default = {
  name: 'MdCardActions',
  props: {
    mdAlignment: _extends({
      type: String,
      default: 'right'
    }, (0, _MdPropValidator2.default)('md-alignment', alignments))
  }
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdCheckbox = __webpack_require__(140);

var _MdCheckbox2 = _interopRequireDefault(_MdCheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdCheckbox2.default.name, _MdCheckbox2.default);
};

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdCheckbox/MdCheckbox.vue
var MdCheckbox = __webpack_require__(142);
var MdCheckbox_default = /*#__PURE__*/__webpack_require__.n(MdCheckbox);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7c2899cf","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdCheckbox/MdCheckbox.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-checkbox",
      class: [_vm.$mdActiveTheme, _vm.checkClasses]
    },
    [
      _c(
        "div",
        {
          staticClass: "md-checkbox-container",
          on: {
            click: function($event) {
              $event.stopPropagation()
              _vm.toggleCheck($event)
            }
          }
        },
        [
          _c(
            "md-ripple",
            {
              attrs: {
                "md-centered": "",
                "md-active": _vm.rippleActive,
                "md-disabled": _vm.disabled
              },
              on: {
                "update:mdActive": function($event) {
                  _vm.rippleActive = $event
                }
              }
            },
            [
              _c(
                "input",
                _vm._b(
                  { attrs: { type: "checkbox" } },
                  "input",
                  {
                    id: _vm.id,
                    name: _vm.name,
                    disabled: _vm.disabled,
                    required: _vm.required,
                    value: _vm.value
                  },
                  false
                )
              )
            ]
          )
        ],
        1
      ),
      _vm._v(" "),
      _vm.$slots.default
        ? _c(
            "label",
            {
              staticClass: "md-checkbox-label",
              attrs: { for: _vm.id },
              on: {
                click: function($event) {
                  $event.preventDefault()
                  _vm.toggleCheck($event)
                }
              }
            },
            [_vm._t("default")],
            2
          )
        : _vm._e()
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdCheckbox_MdCheckbox = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7c2899cf", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdCheckbox/MdCheckbox.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(141)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCheckbox_default.a,
  MdCheckbox_MdCheckbox,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdCheckbox/MdCheckbox.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7c2899cf", Component.options)
  } else {
    hotAPI.reload("data-v-7c2899cf", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdCheckbox_MdCheckbox = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 141 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdCheckboxMixin = __webpack_require__(33);

var _MdCheckboxMixin2 = _interopRequireDefault(_MdCheckboxMixin);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdCheckbox',
  mixins: [_MdCheckboxMixin2.default],
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-checkbox-' + (0, _MdUuid2.default)();
      }
    }
  }
}); //
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdChips = __webpack_require__(144);

var _MdChips2 = _interopRequireDefault(_MdChips);

var _MdChip = __webpack_require__(160);

var _MdChip2 = _interopRequireDefault(_MdChip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdChips2.default.name, _MdChips2.default);
  Vue.component(_MdChip2.default.name, _MdChip2.default);
};

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdChips/MdChips.vue
var MdChips = __webpack_require__(146);
var MdChips_default = /*#__PURE__*/__webpack_require__.n(MdChips);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-0b3d2a1e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdChips/MdChips.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-field",
    { staticClass: "md-chips", class: [_vm.$mdActiveTheme, _vm.chipsClasses] },
    [
      _vm._t("default"),
      _vm._v(" "),
      _vm._l(_vm.value, function(chip, key) {
        return _c(
          "md-chip",
          {
            key: chip,
            attrs: {
              "md-deletable": !_vm.mdStatic,
              "md-clickable": !_vm.mdStatic,
              "md-duplicated": _vm.duplicatedChip === chip
            },
            on: {
              keydown: function($event) {
                if (
                  !("button" in $event) &&
                  _vm._k($event.keyCode, "enter", 13, $event.key)
                ) {
                  return null
                }
                _vm.$emit("md-click", chip, key)
              },
              "md-delete": function($event) {
                $event.stopPropagation()
                _vm.removeChip(chip)
              }
            },
            nativeOn: {
              click: function($event) {
                _vm.$emit("md-click", chip, key)
              }
            }
          },
          [
            _vm.$scopedSlots["md-chip"]
              ? _vm._t("md-chip", [_vm._v(_vm._s(chip))], { chip: chip })
              : [_vm._v(_vm._s(chip))]
          ],
          2
        )
      }),
      _vm._v(" "),
      !_vm.mdStatic && _vm.modelRespectLimit
        ? _c("md-input", {
            ref: "input",
            attrs: {
              type: _vm.mdInputType,
              id: _vm.id,
              placeholder: _vm.mdPlaceholder
            },
            on: {
              input: _vm.handleInput,
              keydown: [
                function($event) {
                  if (
                    !("button" in $event) &&
                    _vm._k($event.keyCode, "enter", 13, $event.key)
                  ) {
                    return null
                  }
                  _vm.insertChip($event)
                },
                function($event) {
                  if (!("button" in $event) && $event.keyCode !== 8) {
                    return null
                  }
                  _vm.handleBackRemove($event)
                }
              ]
            },
            model: {
              value: _vm.inputValue,
              callback: function($$v) {
                _vm.inputValue = typeof $$v === "string" ? $$v.trim() : $$v
              },
              expression: "inputValue"
            }
          })
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdChips_MdChips = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0b3d2a1e", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdChips/MdChips.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(145)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdChips_default.a,
  MdChips_MdChips,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdChips/MdChips.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0b3d2a1e", Component.options)
  } else {
    hotAPI.reload("data-v-0b3d2a1e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdChips_MdChips = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 145 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdField = __webpack_require__(20);

var _MdField2 = _interopRequireDefault(_MdField);

var _MdInput = __webpack_require__(14);

var _MdInput2 = _interopRequireDefault(_MdInput);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdChips',
  components: {
    MdField: _MdField2.default,
    MdInput: _MdInput2.default
  },
  props: {
    value: Array,
    id: {
      type: [String, Number],
      default: function _default() {
        return 'md-chips-' + (0, _MdUuid2.default)();
      }
    },
    mdInputType: _extends({
      type: [String, Number]
    }, (0, _MdPropValidator2.default)('md-input-type', ['email', 'number', 'password', 'search', 'tel', 'text', 'url'])),
    mdPlaceholder: [String, Number],
    mdStatic: Boolean,
    mdLimit: Number,
    mdCheckDuplicated: {
      type: Boolean,
      default: false
    },
    mdFormat: {
      type: Function
    }
  },
  data: function data() {
    return {
      inputValue: '',
      duplicatedChip: null
    };
  },
  computed: {
    chipsClasses: function chipsClasses() {
      return {
        'md-has-value': this.value && this.value.length
      };
    },
    modelRespectLimit: function modelRespectLimit() {
      return !this.mdLimit || this.value.length < this.mdLimit;
    },
    formattedInputValue: function formattedInputValue() {
      if (!this.mdFormat) {
        return this.inputValue;
      }
      return this.mdFormat(this.inputValue);
    }
  },
  methods: {
    insertChip: function insertChip(_ref) {
      var _this = this;

      var target = _ref.target;

      var inputValue = this.formattedInputValue;

      if (!inputValue || !this.modelRespectLimit) {
        return;
      }

      if (this.value.includes(inputValue)) {
        this.duplicatedChip = null;
        // to trigger animate
        this.$nextTick(function () {
          _this.duplicatedChip = inputValue;
        });
        return;
      }

      this.value.push(inputValue);
      this.$emit('input', this.value);
      this.$emit('md-insert', inputValue);
      this.inputValue = '';
    },
    removeChip: function removeChip(chip) {
      var _this2 = this;

      var index = this.value.indexOf(chip);

      this.value.splice(index, 1);
      this.$emit('input', this.value);
      this.$emit('md-delete', chip, index);
      this.$nextTick(function () {
        return _this2.$refs.input.$el.focus();
      });
    },
    handleBackRemove: function handleBackRemove() {
      if (!this.inputValue) {
        this.removeChip(this.value[this.value.length - 1]);
      }
    },
    handleInput: function handleInput() {
      if (this.mdCheckDuplicated) {
        this.checkDuplicated();
      } else {
        this.duplicatedChip = null;
      }
    },
    checkDuplicated: function checkDuplicated() {
      if (!this.value.includes(this.formattedInputValue)) {
        this.duplicatedChip = null;
        return false;
      }

      if (!this.mdCheckDuplicated) {
        return false;
      }

      this.duplicatedChip = this.formattedInputValue;
    }
  },
  watch: {
    value: function value() {
      this.checkDuplicated();
    }
  }
});

/***/ }),
/* 147 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdClearIcon = __webpack_require__(34);

var _MdClearIcon2 = _interopRequireDefault(_MdClearIcon);

var _MdPasswordOffIcon = __webpack_require__(155);

var _MdPasswordOffIcon2 = _interopRequireDefault(_MdPasswordOffIcon);

var _MdPasswordOnIcon = __webpack_require__(157);

var _MdPasswordOnIcon2 = _interopRequireDefault(_MdPasswordOnIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdField',
  components: {
    MdClearIcon: _MdClearIcon2.default,
    MdPasswordOffIcon: _MdPasswordOffIcon2.default,
    MdPasswordOnIcon: _MdPasswordOnIcon2.default
  },
  props: {
    mdInline: Boolean,
    mdClearable: Boolean,
    mdCounter: {
      type: Boolean,
      default: true
    },
    mdTogglePassword: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      showPassword: false,
      MdField: {
        value: null,
        focused: false,
        highlighted: false,
        disabled: false,
        required: false,
        placeholder: false,
        textarea: false,
        autogrow: false,
        maxlength: null,
        counter: null,
        password: null,
        togglePassword: false,
        clear: false,
        file: false
      }
    };
  },
  provide: function provide() {
    return {
      MdField: this.MdField
    };
  },

  computed: {
    stringValue: function stringValue() {
      return (this.MdField.value || this.MdField.value === 0) && this.MdField.value.toString();
    },
    hasCounter: function hasCounter() {
      return this.mdCounter && (this.MdField.maxlength || this.MdField.counter);
    },
    hasPasswordToggle: function hasPasswordToggle() {
      return this.mdTogglePassword && this.MdField.password;
    },
    hasValue: function hasValue() {
      return this.stringValue && this.stringValue.length > 0;
    },
    valueLength: function valueLength() {
      if (this.stringValue) {
        return this.stringValue.length;
      }

      return 0;
    },
    fieldClasses: function fieldClasses() {
      return {
        'md-inline': this.mdInline,
        'md-clearable': this.mdClearable,
        'md-focused': this.MdField.focused,
        'md-highlight': this.MdField.highlighted,
        'md-disabled': this.MdField.disabled,
        'md-required': this.MdField.required,
        'md-has-value': this.hasValue,
        'md-has-placeholder': this.MdField.placeholder,
        'md-has-textarea': this.MdField.textarea,
        'md-has-password': this.MdField.password,
        'md-has-file': this.MdField.file,
        'md-has-select': this.MdField.select,
        'md-autogrow': this.MdField.autogrow
      };
    }
  },
  methods: {
    clearInput: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.MdField.clear = true;
                _context.next = 3;
                return this.$nextTick();

              case 3:
                this.MdField.clear = false;

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function clearInput() {
        return _ref.apply(this, arguments);
      }

      return clearInput;
    }(),
    togglePassword: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.MdField.togglePassword = !this.MdField.togglePassword;

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function togglePassword() {
        return _ref2.apply(this, arguments);
      }

      return togglePassword;
    }(),
    onBlur: function onBlur() {
      this.MdField.highlighted = false;
    }
  }
});

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdClearIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 150 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdSvgLoader = __webpack_require__(152);

var _MdSvgLoader2 = _interopRequireDefault(_MdSvgLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdIcon',
  components: {
    MdSvgLoader: _MdSvgLoader2.default
  },
  props: {
    mdSrc: String
  }
});

/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSvgLoader/MdSvgLoader.vue
var MdSvgLoader = __webpack_require__(154);
var MdSvgLoader_default = /*#__PURE__*/__webpack_require__.n(MdSvgLoader);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-0db3655e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSvgLoader/MdSvgLoader.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("i", {
    staticClass: "md-svg-loader",
    domProps: { innerHTML: _vm._s(_vm.html) }
  })
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSvgLoader_MdSvgLoader = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0db3655e", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSvgLoader/MdSvgLoader.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(153)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSvgLoader_default.a,
  MdSvgLoader_MdSvgLoader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSvgLoader/MdSvgLoader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0db3655e", Component.options)
  } else {
    hotAPI.reload("data-v-0db3655e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSvgLoader_MdSvgLoader = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 153 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

//
//
//
//

var mdSVGStore = {};

exports.default = {
  name: 'MdSVGLoader',
  props: {
    mdSrc: {
      type: String,
      required: true
    }
  },
  data: function data() {
    return {
      html: null,
      error: null
    };
  },
  watch: {
    mdSrc: function mdSrc() {
      this.html = null;
      this.loadSVG();
    }
  },
  methods: {
    isSVG: function isSVG(mimetype) {
      return mimetype.indexOf('svg') >= 0;
    },
    setHtml: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return mdSVGStore[this.mdSrc];

              case 2:
                this.html = _context.sent;
                _context.next = 5;
                return this.$nextTick();

              case 5:

                this.$emit('md-loaded');

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setHtml(_x) {
        return _ref.apply(this, arguments);
      }

      return setHtml;
    }(),
    unexpectedError: function unexpectedError(reject) {
      this.error = 'Something bad happened trying to fetch ' + this.mdSrc + '.';
      reject(this.error);
    },
    loadSVG: function loadSVG() {
      var _this = this;

      if (!mdSVGStore.hasOwnProperty(this.mdSrc)) {
        mdSVGStore[this.mdSrc] = new Promise(function (resolve, reject) {
          var request = new window.XMLHttpRequest();

          request.open('GET', _this.mdSrc, true);

          request.onload = function () {
            var mimetype = request.getResponseHeader('content-type');

            if (request.status === 200) {
              if (_this.isSVG(mimetype)) {
                resolve(request.response);
                _this.setHtml();
              } else {
                _this.error = 'The file ' + _this.mdSrc + ' is not a valid SVG.';
                reject(_this.error);
              }
            } else if (request.status >= 400 && request.status < 500) {
              _this.error = 'The file ' + _this.mdSrc + ' do not exists.';
              reject(_this.error);
            } else {
              _this.unexpectedError(reject);
            }
          };

          request.onerror = function () {
            return _this.unexpectedError(reject);
          };
          request.onabort = function () {
            return _this.unexpectedError(reject);
          };
          request.send();
        });
      } else {
        this.setHtml();
      }
    }
  },
  mounted: function mounted() {
    this.loadSVG();
  }
};

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdPasswordOffIcon.vue
var MdPasswordOffIcon = __webpack_require__(156);
var MdPasswordOffIcon_default = /*#__PURE__*/__webpack_require__.n(MdPasswordOffIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4113206a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdPasswordOffIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: {
              d: "M0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0zm0 0h24v24H0z",
              fill: "none"
            }
          }),
          _vm._v(" "),
          _c("path", {
            attrs: {
              d:
                "M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"
            }
          })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdPasswordOffIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4113206a", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdPasswordOffIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdPasswordOffIcon_default.a,
  icons_MdPasswordOffIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdPasswordOffIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4113206a", Component.options)
  } else {
    hotAPI.reload("data-v-4113206a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdPasswordOffIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdPasswordOffIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdPasswordOnIcon.vue
var MdPasswordOnIcon = __webpack_require__(158);
var MdPasswordOnIcon_default = /*#__PURE__*/__webpack_require__.n(MdPasswordOnIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-71ec8df4","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdPasswordOnIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } }),
          _vm._v(" "),
          _c("path", {
            attrs: {
              d:
                "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"
            }
          })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdPasswordOnIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-71ec8df4", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdPasswordOnIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdPasswordOnIcon_default.a,
  icons_MdPasswordOnIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdPasswordOnIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-71ec8df4", Component.options)
  } else {
    hotAPI.reload("data-v-71ec8df4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdPasswordOnIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdPasswordOnIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdFieldMixin = __webpack_require__(15);

var _MdFieldMixin2 = _interopRequireDefault(_MdFieldMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdInput',
  mixins: [_MdFieldMixin2.default],
  inject: ['MdField'],
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-input-' + (0, _MdUuid2.default)();
      }
    },
    type: {
      type: String,
      default: 'text'
    }
  },
  computed: {
    toggleType: function toggleType() {
      return this.MdField.togglePassword;
    },
    isPassword: function isPassword() {
      return this.type === 'password';
    },
    listeners: function listeners() {
      var l = _extends({}, this.$listeners);
      delete l.input;
      return l;
    }
  },
  watch: {
    type: function type(_type) {
      this.setPassword(this.isPassword);
    },
    toggleType: function toggleType(toggle) {
      if (toggle) {
        this.setTypeText();
      } else {
        this.setTypePassword();
      }
    }
  },
  methods: {
    setPassword: function setPassword(state) {
      this.MdField.password = state;
      this.MdField.togglePassword = false;
    },
    setTypePassword: function setTypePassword() {
      this.$el.type = 'password';
    },
    setTypeText: function setTypeText() {
      this.$el.type = 'text';
    }
  },
  created: function created() {
    this.setPassword(this.isPassword);
  },
  beforeDestroy: function beforeDestroy() {
    this.setPassword(false);
  }
});

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdChips/MdChip.vue
var MdChip = __webpack_require__(162);
var MdChip_default = /*#__PURE__*/__webpack_require__.n(MdChip);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-84ba771c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdChips/MdChip.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("transition", { attrs: { name: "md-chip", appear: "" } }, [
    _c(
      "div",
      _vm._g(
        {
          staticClass: "md-chip",
          class: [_vm.$mdActiveTheme, _vm.chipClasses],
          attrs: { tabindex: "0" }
        },
        _vm.$listeners
      ),
      [
        _vm.mdClickable || !_vm.mdRipple
          ? _c(
              "md-ripple",
              { attrs: { "md-disabled": _vm.mdDisabled } },
              [_vm._t("default")],
              2
            )
          : _vm._t("default"),
        _vm._v(" "),
        _c(
          "transition",
          { attrs: { name: "md-input-action", appear: "" } },
          [
            _vm.mdDeletable
              ? _c(
                  "md-button",
                  {
                    staticClass:
                      "md-icon-button md-dense md-input-action md-clear",
                    attrs: { tabindex: "-1" },
                    on: {
                      click: function($event) {
                        _vm.$emit("md-delete", $event)
                      }
                    }
                  },
                  [_c("md-clear-icon")],
                  1
                )
              : _vm._e()
          ],
          1
        )
      ],
      2
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdChips_MdChip = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-84ba771c", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdChips/MdChip.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(161)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdChip_default.a,
  MdChips_MdChip,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdChips/MdChip.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-84ba771c", Component.options)
  } else {
    hotAPI.reload("data-v-84ba771c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdChips_MdChip = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 161 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdFocused = __webpack_require__(32);

var _MdFocused2 = _interopRequireDefault(_MdFocused);

var _MdRipple = __webpack_require__(19);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

var _MdClearIcon = __webpack_require__(34);

var _MdClearIcon2 = _interopRequireDefault(_MdClearIcon);

var _MdButton = __webpack_require__(13);

var _MdButton2 = _interopRequireDefault(_MdButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdChip',
  components: {
    MdButton: _MdButton2.default,
    MdClearIcon: _MdClearIcon2.default
  },
  mixins: [_MdFocused2.default, _MdRipple2.default],
  props: {
    mdDisabled: Boolean,
    mdDeletable: Boolean,
    mdClickable: Boolean,
    mdDuplicated: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    chipClasses: function chipClasses() {
      return {
        'md-disabled': this.mdDisabled,
        'md-deletable': this.mdDeletable,
        'md-clickable': this.mdClickable,
        'md-focused': this.mdHasFocus,
        'md-duplicated': this.mdDuplicated
      };
    }
  }
}); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdContent = __webpack_require__(35);

var _MdContent2 = _interopRequireDefault(_MdContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdContent2.default.name, _MdContent2.default);
};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdContent',
  props: {
    mdTag: {
      type: String,
      default: 'div'
    }
  },
  render: function render(createElement) {
    return createElement(this.mdTag, {
      staticClass: 'md-content',
      class: [this.$mdActiveTheme],
      attrs: this.$attrs,
      on: this.$listeners
    }, this.$slots.default);
  }
});

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDatepicker = __webpack_require__(166);

var _MdDatepicker2 = _interopRequireDefault(_MdDatepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDatepicker2.default.name, _MdDatepicker2.default);
};

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDatepicker/MdDatepicker.vue
var MdDatepicker = __webpack_require__(168);
var MdDatepicker_default = /*#__PURE__*/__webpack_require__.n(MdDatepicker);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-37fe792f","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDatepicker/MdDatepicker.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-field",
    {
      class: ["md-datepicker", { "md-native": !this.mdOverrideNative }],
      attrs: { "md-clearable": "" }
    },
    [
      _c("md-date-icon", {
        staticClass: "md-date-icon",
        nativeOn: {
          click: function($event) {
            _vm.toggleDialog($event)
          }
        }
      }),
      _vm._v(" "),
      _c("md-input", {
        ref: "input",
        attrs: { type: _vm.type, pattern: "[0-9]{4}-[0-9]{2}-[0-9]{2}" },
        nativeOn: {
          focus: function($event) {
            _vm.onFocus($event)
          }
        },
        model: {
          value: _vm.modelDate,
          callback: function($$v) {
            _vm.modelDate = $$v
          },
          expression: "modelDate"
        }
      }),
      _vm._v(" "),
      _vm._t("default"),
      _vm._v(" "),
      _c(
        "keep-alive",
        [
          _vm.showDialog
            ? _c("md-datepicker-dialog", {
                attrs: {
                  "md-date": _vm.selectedDate,
                  "md-disabled-dates": _vm.mdDisabledDates
                },
                on: {
                  "update:mdDate": function($event) {
                    _vm.selectedDate = $event
                  },
                  "md-closed": _vm.toggleDialog
                }
              })
            : _vm._e()
        ],
        1
      ),
      _vm._v(" "),
      _c("md-overlay", {
        staticClass: "md-datepicker-overlay",
        attrs: { "md-fixed": "", "md-active": _vm.showDialog },
        on: { click: _vm.toggleDialog }
      })
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDatepicker_MdDatepicker = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-37fe792f", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDatepicker/MdDatepicker.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(167)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDatepicker_default.a,
  MdDatepicker_MdDatepicker,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDatepicker/MdDatepicker.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-37fe792f", Component.options)
  } else {
    hotAPI.reload("data-v-37fe792f", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDatepicker_MdDatepicker = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 167 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _isFirefox = __webpack_require__(169);

var _isFirefox2 = _interopRequireDefault(_isFirefox);

var _format = __webpack_require__(170);

var _format2 = _interopRequireDefault(_format);

var _parse = __webpack_require__(3);

var _parse2 = _interopRequireDefault(_parse);

var _is_valid = __webpack_require__(38);

var _is_valid2 = _interopRequireDefault(_is_valid);

var _MdOverlay = __webpack_require__(23);

var _MdOverlay2 = _interopRequireDefault(_MdOverlay);

var _MdDatepickerDialog = __webpack_require__(183);

var _MdDatepickerDialog2 = _interopRequireDefault(_MdDatepickerDialog);

var _MdDateIcon = __webpack_require__(207);

var _MdDateIcon2 = _interopRequireDefault(_MdDateIcon);

var _MdField = __webpack_require__(20);

var _MdField2 = _interopRequireDefault(_MdField);

var _MdInput = __webpack_require__(14);

var _MdInput2 = _interopRequireDefault(_MdInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdDatepicker',
  components: {
    MdOverlay: _MdOverlay2.default,
    MdDateIcon: _MdDateIcon2.default,
    MdField: _MdField2.default,
    MdInput: _MdInput2.default,
    MdDatepickerDialog: _MdDatepickerDialog2.default
  },
  props: {
    value: [String, Date],
    mdDisabledDates: [Array, Function],
    mdOpenOnFocus: {
      type: Boolean,
      default: true
    },
    mdOverrideNative: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      showDialog: false,
      modelDate: null,
      selectedDate: null
    };
  },
  computed: {
    type: function type() {
      return this.mdOverrideNative ? 'text' : 'date';
    }
  },
  watch: {
    selectedDate: function selectedDate(_selectedDate) {
      if (_selectedDate) {
        this.modelDate = this.dateToHTMLString(_selectedDate);
        this.$emit('input', _selectedDate);
      }
    },
    value: function value() {
      if (this.value) {
        this.modelDate = this.dateToHTMLString(this.value);
      }
    },
    modelDate: function modelDate(value) {
      if (value) {
        var parsedDate = (0, _parse2.default)(value);

        if ((0, _is_valid2.default)(parsedDate)) {
          this.selectedDate = parsedDate;
        }
      }
    }
  },
  methods: {
    toggleDialog: function toggleDialog() {
      if (!_isFirefox2.default || this.mdOverrideNative) {
        this.showDialog = !this.showDialog;
      } else {
        this.$refs.input.$el.click();
      }
    },
    onFocus: function onFocus() {
      if (this.mdOpenOnFocus) {
        this.toggleDialog();
      }
    },
    dateToHTMLString: function dateToHTMLString(date) {
      if (date) {
        var formattedDate = null;
        var dateFormat = this.$material.locale.dateFormat || 'YYYY-MM-DD';

        try {
          formattedDate = (0, _format2.default)(date, dateFormat);
        } catch (error) {
          _vue2.default.util.warn('The datepicker value is not a valid date. Given value: ' + date + '.', this);
        }

        return formattedDate;
      }
    }
  },
  created: function created() {
    this.modelDate = this.dateToHTMLString(this.value);
    this.selectedDate = this.value;
  }
};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var getDayOfYear = __webpack_require__(171)
var getISOWeek = __webpack_require__(174)
var getISOYear = __webpack_require__(37)
var parse = __webpack_require__(3)
var isValid = __webpack_require__(38)
var enLocale = __webpack_require__(177)

/**
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format.
 *
 * Accepted tokens:
 * | Unit                    | Token | Result examples                  |
 * |-------------------------|-------|----------------------------------|
 * | Month                   | M     | 1, 2, ..., 12                    |
 * |                         | Mo    | 1st, 2nd, ..., 12th              |
 * |                         | MM    | 01, 02, ..., 12                  |
 * |                         | MMM   | Jan, Feb, ..., Dec               |
 * |                         | MMMM  | January, February, ..., December |
 * | Quarter                 | Q     | 1, 2, 3, 4                       |
 * |                         | Qo    | 1st, 2nd, 3rd, 4th               |
 * | Day of month            | D     | 1, 2, ..., 31                    |
 * |                         | Do    | 1st, 2nd, ..., 31st              |
 * |                         | DD    | 01, 02, ..., 31                  |
 * | Day of year             | DDD   | 1, 2, ..., 366                   |
 * |                         | DDDo  | 1st, 2nd, ..., 366th             |
 * |                         | DDDD  | 001, 002, ..., 366               |
 * | Day of week             | d     | 0, 1, ..., 6                     |
 * |                         | do    | 0th, 1st, ..., 6th               |
 * |                         | dd    | Su, Mo, ..., Sa                  |
 * |                         | ddd   | Sun, Mon, ..., Sat               |
 * |                         | dddd  | Sunday, Monday, ..., Saturday    |
 * | Day of ISO week         | E     | 1, 2, ..., 7                     |
 * | ISO week                | W     | 1, 2, ..., 53                    |
 * |                         | Wo    | 1st, 2nd, ..., 53rd              |
 * |                         | WW    | 01, 02, ..., 53                  |
 * | Year                    | YY    | 00, 01, ..., 99                  |
 * |                         | YYYY  | 1900, 1901, ..., 2099            |
 * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |
 * |                         | GGGG  | 1900, 1901, ..., 2099            |
 * | AM/PM                   | A     | AM, PM                           |
 * |                         | a     | am, pm                           |
 * |                         | aa    | a.m., p.m.                       |
 * | Hour                    | H     | 0, 1, ... 23                     |
 * |                         | HH    | 00, 01, ... 23                   |
 * |                         | h     | 1, 2, ..., 12                    |
 * |                         | hh    | 01, 02, ..., 12                  |
 * | Minute                  | m     | 0, 1, ..., 59                    |
 * |                         | mm    | 00, 01, ..., 59                  |
 * | Second                  | s     | 0, 1, ..., 59                    |
 * |                         | ss    | 00, 01, ..., 59                  |
 * | 1/10 of second          | S     | 0, 1, ..., 9                     |
 * | 1/100 of second         | SS    | 00, 01, ..., 99                  |
 * | Millisecond             | SSS   | 000, 001, ..., 999               |
 * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |
 * |                         | ZZ    | -0100, +0000, ..., +1200         |
 * | Seconds timestamp       | X     | 512969520                        |
 * | Milliseconds timestamp  | x     | 512969520900                     |
 *
 * The characters wrapped in square brackets are escaped.
 *
 * The result may vary by locale.
 *
 * @param {Date|String|Number} date - the original date
 * @param {String} [format='YYYY-MM-DDTHH:mm:ss.SSSZ'] - the string of tokens
 * @param {Object} [options] - the object with options
 * @param {Object} [options.locale=enLocale] - the locale object
 * @returns {String} the formatted date string
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(
 *   new Date(2014, 1, 11),
 *   'MM/DD/YYYY'
 * )
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * var eoLocale = require('date-fns/locale/eo')
 * var result = format(
 *   new Date(2014, 6, 2),
 *   'Do [de] MMMM YYYY',
 *   {locale: eoLocale}
 * )
 * //=> '2-a de julio 2014'
 */
function format (dirtyDate, dirtyFormatStr, dirtyOptions) {
  var formatStr = dirtyFormatStr ? String(dirtyFormatStr) : 'YYYY-MM-DDTHH:mm:ss.SSSZ'
  var options = dirtyOptions || {}

  var locale = options.locale
  var localeFormatters = enLocale.format.formatters
  var formattingTokensRegExp = enLocale.format.formattingTokensRegExp
  if (locale && locale.format && locale.format.formatters) {
    localeFormatters = locale.format.formatters

    if (locale.format.formattingTokensRegExp) {
      formattingTokensRegExp = locale.format.formattingTokensRegExp
    }
  }

  var date = parse(dirtyDate)

  if (!isValid(date)) {
    return 'Invalid Date'
  }

  var formatFn = buildFormatFn(formatStr, localeFormatters, formattingTokensRegExp)

  return formatFn(date)
}

var formatters = {
  // Month: 1, 2, ..., 12
  'M': function (date) {
    return date.getMonth() + 1
  },

  // Month: 01, 02, ..., 12
  'MM': function (date) {
    return addLeadingZeros(date.getMonth() + 1, 2)
  },

  // Quarter: 1, 2, 3, 4
  'Q': function (date) {
    return Math.ceil((date.getMonth() + 1) / 3)
  },

  // Day of month: 1, 2, ..., 31
  'D': function (date) {
    return date.getDate()
  },

  // Day of month: 01, 02, ..., 31
  'DD': function (date) {
    return addLeadingZeros(date.getDate(), 2)
  },

  // Day of year: 1, 2, ..., 366
  'DDD': function (date) {
    return getDayOfYear(date)
  },

  // Day of year: 001, 002, ..., 366
  'DDDD': function (date) {
    return addLeadingZeros(getDayOfYear(date), 3)
  },

  // Day of week: 0, 1, ..., 6
  'd': function (date) {
    return date.getDay()
  },

  // Day of ISO week: 1, 2, ..., 7
  'E': function (date) {
    return date.getDay() || 7
  },

  // ISO week: 1, 2, ..., 53
  'W': function (date) {
    return getISOWeek(date)
  },

  // ISO week: 01, 02, ..., 53
  'WW': function (date) {
    return addLeadingZeros(getISOWeek(date), 2)
  },

  // Year: 00, 01, ..., 99
  'YY': function (date) {
    return addLeadingZeros(date.getFullYear(), 4).substr(2)
  },

  // Year: 1900, 1901, ..., 2099
  'YYYY': function (date) {
    return addLeadingZeros(date.getFullYear(), 4)
  },

  // ISO week-numbering year: 00, 01, ..., 99
  'GG': function (date) {
    return String(getISOYear(date)).substr(2)
  },

  // ISO week-numbering year: 1900, 1901, ..., 2099
  'GGGG': function (date) {
    return getISOYear(date)
  },

  // Hour: 0, 1, ... 23
  'H': function (date) {
    return date.getHours()
  },

  // Hour: 00, 01, ..., 23
  'HH': function (date) {
    return addLeadingZeros(date.getHours(), 2)
  },

  // Hour: 1, 2, ..., 12
  'h': function (date) {
    var hours = date.getHours()
    if (hours === 0) {
      return 12
    } else if (hours > 12) {
      return hours % 12
    } else {
      return hours
    }
  },

  // Hour: 01, 02, ..., 12
  'hh': function (date) {
    return addLeadingZeros(formatters['h'](date), 2)
  },

  // Minute: 0, 1, ..., 59
  'm': function (date) {
    return date.getMinutes()
  },

  // Minute: 00, 01, ..., 59
  'mm': function (date) {
    return addLeadingZeros(date.getMinutes(), 2)
  },

  // Second: 0, 1, ..., 59
  's': function (date) {
    return date.getSeconds()
  },

  // Second: 00, 01, ..., 59
  'ss': function (date) {
    return addLeadingZeros(date.getSeconds(), 2)
  },

  // 1/10 of second: 0, 1, ..., 9
  'S': function (date) {
    return Math.floor(date.getMilliseconds() / 100)
  },

  // 1/100 of second: 00, 01, ..., 99
  'SS': function (date) {
    return addLeadingZeros(Math.floor(date.getMilliseconds() / 10), 2)
  },

  // Millisecond: 000, 001, ..., 999
  'SSS': function (date) {
    return addLeadingZeros(date.getMilliseconds(), 3)
  },

  // Timezone: -01:00, +00:00, ... +12:00
  'Z': function (date) {
    return formatTimezone(date.getTimezoneOffset(), ':')
  },

  // Timezone: -0100, +0000, ... +1200
  'ZZ': function (date) {
    return formatTimezone(date.getTimezoneOffset())
  },

  // Seconds timestamp: 512969520
  'X': function (date) {
    return Math.floor(date.getTime() / 1000)
  },

  // Milliseconds timestamp: 512969520900
  'x': function (date) {
    return date.getTime()
  }
}

function buildFormatFn (formatStr, localeFormatters, formattingTokensRegExp) {
  var array = formatStr.match(formattingTokensRegExp)
  var length = array.length

  var i
  var formatter
  for (i = 0; i < length; i++) {
    formatter = localeFormatters[array[i]] || formatters[array[i]]
    if (formatter) {
      array[i] = formatter
    } else {
      array[i] = removeFormattingTokens(array[i])
    }
  }

  return function (date) {
    var output = ''
    for (var i = 0; i < length; i++) {
      if (array[i] instanceof Function) {
        output += array[i](date, formatters)
      } else {
        output += array[i]
      }
    }
    return output
  }
}

function removeFormattingTokens (input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|]$/g, '')
  }
  return input.replace(/\\/g, '')
}

function formatTimezone (offset, delimeter) {
  delimeter = delimeter || ''
  var sign = offset > 0 ? '-' : '+'
  var absOffset = Math.abs(offset)
  var hours = Math.floor(absOffset / 60)
  var minutes = absOffset % 60
  return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2)
}

function addLeadingZeros (number, targetLength) {
  var output = Math.abs(number).toString()
  while (output.length < targetLength) {
    output = '0' + output
  }
  return output
}

module.exports = format


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)
var startOfYear = __webpack_require__(172)
var differenceInCalendarDays = __webpack_require__(173)

/**
 * @category Day Helpers
 * @summary Get the day of the year of the given date.
 *
 * @description
 * Get the day of the year of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the day of year
 *
 * @example
 * // Which day of the year is 2 July 2014?
 * var result = getDayOfYear(new Date(2014, 6, 2))
 * //=> 183
 */
function getDayOfYear (dirtyDate) {
  var date = parse(dirtyDate)
  var diff = differenceInCalendarDays(date, startOfYear(date))
  var dayOfYear = diff + 1
  return dayOfYear
}

module.exports = getDayOfYear


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * var result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear (dirtyDate) {
  var cleanDate = parse(dirtyDate)
  var date = new Date(0)
  date.setFullYear(cleanDate.getFullYear(), 0, 1)
  date.setHours(0, 0, 0, 0)
  return date
}

module.exports = startOfYear


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var startOfDay = __webpack_require__(21)

var MILLISECONDS_IN_MINUTE = 60000
var MILLISECONDS_IN_DAY = 86400000

/**
 * @category Day Helpers
 * @summary Get the number of calendar days between the given dates.
 *
 * @description
 * Get the number of calendar days between the given dates.
 *
 * @param {Date|String|Number} dateLeft - the later date
 * @param {Date|String|Number} dateRight - the earlier date
 * @returns {Number} the number of calendar days
 *
 * @example
 * // How many calendar days are between
 * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
 * var result = differenceInCalendarDays(
 *   new Date(2012, 6, 2, 0, 0),
 *   new Date(2011, 6, 2, 23, 0)
 * )
 * //=> 366
 */
function differenceInCalendarDays (dirtyDateLeft, dirtyDateRight) {
  var startOfDayLeft = startOfDay(dirtyDateLeft)
  var startOfDayRight = startOfDay(dirtyDateRight)

  var timestampLeft = startOfDayLeft.getTime() -
    startOfDayLeft.getTimezoneOffset() * MILLISECONDS_IN_MINUTE
  var timestampRight = startOfDayRight.getTime() -
    startOfDayRight.getTimezoneOffset() * MILLISECONDS_IN_MINUTE

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a day is not constant
  // (e.g. it's different in the day of the daylight saving time clock shift)
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY)
}

module.exports = differenceInCalendarDays


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)
var startOfISOWeek = __webpack_require__(22)
var startOfISOYear = __webpack_require__(176)

var MILLISECONDS_IN_WEEK = 604800000

/**
 * @category ISO Week Helpers
 * @summary Get the ISO week of the given date.
 *
 * @description
 * Get the ISO week of the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the ISO week
 *
 * @example
 * // Which week of the ISO-week numbering year is 2 January 2005?
 * var result = getISOWeek(new Date(2005, 0, 2))
 * //=> 53
 */
function getISOWeek (dirtyDate) {
  var date = parse(dirtyDate)
  var diff = startOfISOWeek(date).getTime() - startOfISOYear(date).getTime()

  // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1
}

module.exports = getISOWeek


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @param {Object} [options] - the object with options
 * @param {Number} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), {weekStartsOn: 1})
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek (dirtyDate, dirtyOptions) {
  var weekStartsOn = dirtyOptions ? (Number(dirtyOptions.weekStartsOn) || 0) : 0

  var date = parse(dirtyDate)
  var day = date.getDay()
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn

  date.setDate(date.getDate() - diff)
  date.setHours(0, 0, 0, 0)
  return date
}

module.exports = startOfWeek


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var getISOYear = __webpack_require__(37)
var startOfISOWeek = __webpack_require__(22)

/**
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of an ISO year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * var result = startOfISOYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOYear (dirtyDate) {
  var year = getISOYear(dirtyDate)
  var fourthOfJanuary = new Date(0)
  fourthOfJanuary.setFullYear(year, 0, 4)
  fourthOfJanuary.setHours(0, 0, 0, 0)
  var date = startOfISOWeek(fourthOfJanuary)
  return date
}

module.exports = startOfISOYear


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

var buildDistanceInWordsLocale = __webpack_require__(178)
var buildFormatLocale = __webpack_require__(179)

/**
 * @category Locales
 * @summary English locale.
 */
module.exports = {
  distanceInWords: buildDistanceInWordsLocale(),
  format: buildFormatLocale()
}


/***/ }),
/* 178 */
/***/ (function(module, exports) {

function buildDistanceInWordsLocale () {
  var distanceInWordsLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },

    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },

    halfAMinute: 'half a minute',

    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },

    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },

    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },

    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },

    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },

    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },

    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },

    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },

    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },

    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },

    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  }

  function localize (token, count, options) {
    options = options || {}

    var result
    if (typeof distanceInWordsLocale[token] === 'string') {
      result = distanceInWordsLocale[token]
    } else if (count === 1) {
      result = distanceInWordsLocale[token].one
    } else {
      result = distanceInWordsLocale[token].other.replace('{{count}}', count)
    }

    if (options.addSuffix) {
      if (options.comparison > 0) {
        return 'in ' + result
      } else {
        return result + ' ago'
      }
    }

    return result
  }

  return {
    localize: localize
  }
}

module.exports = buildDistanceInWordsLocale


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var buildFormattingTokensRegExp = __webpack_require__(180)

function buildFormatLocale () {
  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
  var months3char = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  var monthsFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  var weekdays2char = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']
  var weekdays3char = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  var weekdaysFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  var meridiemUppercase = ['AM', 'PM']
  var meridiemLowercase = ['am', 'pm']
  var meridiemFull = ['a.m.', 'p.m.']

  var formatters = {
    // Month: Jan, Feb, ..., Dec
    'MMM': function (date) {
      return months3char[date.getMonth()]
    },

    // Month: January, February, ..., December
    'MMMM': function (date) {
      return monthsFull[date.getMonth()]
    },

    // Day of week: Su, Mo, ..., Sa
    'dd': function (date) {
      return weekdays2char[date.getDay()]
    },

    // Day of week: Sun, Mon, ..., Sat
    'ddd': function (date) {
      return weekdays3char[date.getDay()]
    },

    // Day of week: Sunday, Monday, ..., Saturday
    'dddd': function (date) {
      return weekdaysFull[date.getDay()]
    },

    // AM, PM
    'A': function (date) {
      return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0]
    },

    // am, pm
    'a': function (date) {
      return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0]
    },

    // a.m., p.m.
    'aa': function (date) {
      return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0]
    }
  }

  // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.
  var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W']
  ordinalFormatters.forEach(function (formatterToken) {
    formatters[formatterToken + 'o'] = function (date, formatters) {
      return ordinal(formatters[formatterToken](date))
    }
  })

  return {
    formatters: formatters,
    formattingTokensRegExp: buildFormattingTokensRegExp(formatters)
  }
}

function ordinal (number) {
  var rem100 = number % 100
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st'
      case 2:
        return number + 'nd'
      case 3:
        return number + 'rd'
    }
  }
  return number + 'th'
}

module.exports = buildFormatLocale


/***/ }),
/* 180 */
/***/ (function(module, exports) {

var commonFormatterKeys = [
  'M', 'MM', 'Q', 'D', 'DD', 'DDD', 'DDDD', 'd',
  'E', 'W', 'WW', 'YY', 'YYYY', 'GG', 'GGGG',
  'H', 'HH', 'h', 'hh', 'm', 'mm',
  's', 'ss', 'S', 'SS', 'SSS',
  'Z', 'ZZ', 'X', 'x'
]

function buildFormattingTokensRegExp (formatters) {
  var formatterKeys = []
  for (var key in formatters) {
    if (formatters.hasOwnProperty(key)) {
      formatterKeys.push(key)
    }
  }

  var formattingTokens = commonFormatterKeys
    .concat(formatterKeys)
    .sort()
    .reverse()
  var formattingTokensRegExp = new RegExp(
    '(\\[[^\\[]*\\])|(\\\\)?' + '(' + formattingTokens.join('|') + '|.)', 'g'
  )

  return formattingTokensRegExp
}

module.exports = buildFormattingTokensRegExp


/***/ }),
/* 181 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdPortal = __webpack_require__(16);

var _MdPortal2 = _interopRequireDefault(_MdPortal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdOverlay',
  components: {
    MdPortal: _MdPortal2.default
  },
  props: {
    mdActive: Boolean,
    mdAttachToParent: Boolean,
    mdFixed: Boolean
  },
  computed: {
    overlayClasses: function overlayClasses() {
      return {
        'md-fixed': this.mdFixed
      };
    }
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 183 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDatepicker/MdDatepickerDialog.vue
var MdDatepickerDialog = __webpack_require__(185);
var MdDatepickerDialog_default = /*#__PURE__*/__webpack_require__.n(MdDatepickerDialog);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4f0a3d52","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDatepicker/MdDatepickerDialog.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-popover",
    { attrs: { "md-settings": _vm.popperSettings, "md-active": "" } },
    [
      _c(
        "transition",
        { attrs: { name: "md-datepicker-dialog", appear: "" } },
        [
          _c(
            "div",
            {
              staticClass: "md-datepicker-dialog",
              class: [_vm.$mdActiveTheme]
            },
            [
              _c("div", { staticClass: "md-datepicker-header" }, [
                _c(
                  "span",
                  {
                    staticClass: "md-datepicker-year-select",
                    class: { "md-selected": _vm.currentView === "year" },
                    on: {
                      click: function($event) {
                        _vm.currentView = "year"
                      }
                    }
                  },
                  [_vm._v(_vm._s(_vm.selectedYear))]
                ),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    staticClass: "md-datepicker-date-select",
                    class: { "md-selected": _vm.currentView !== "year" },
                    on: {
                      click: function($event) {
                        _vm.currentView = "day"
                      }
                    }
                  },
                  [
                    _c("strong", { staticClass: "md-datepicker-dayname" }, [
                      _vm._v(_vm._s(_vm.shortDayName) + ", ")
                    ]),
                    _vm._v(" "),
                    _c("strong", { staticClass: "md-datepicker-monthname" }, [
                      _vm._v(_vm._s(_vm.shortMonthName))
                    ]),
                    _vm._v(" "),
                    _c("strong", { staticClass: "md-datepicker-day" }, [
                      _vm._v(_vm._s(_vm.currentDay))
                    ])
                  ]
                )
              ]),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "md-datepicker-body" },
                [
                  _c(
                    "transition",
                    { attrs: { name: "md-datepicker-body-header" } },
                    [
                      _vm.currentView === "day"
                        ? _c(
                            "div",
                            { staticClass: "md-datepicker-body-header" },
                            [
                              _c(
                                "md-button",
                                {
                                  staticClass: "md-dense md-icon-button",
                                  on: { click: _vm.previousMonth }
                                },
                                [_c("md-arrow-left-icon")],
                                1
                              ),
                              _vm._v(" "),
                              _c(
                                "md-button",
                                {
                                  staticClass: "md-dense md-icon-button",
                                  on: { click: _vm.nextMonth }
                                },
                                [_c("md-arrow-right-icon")],
                                1
                              )
                            ],
                            1
                          )
                        : _vm._e()
                    ]
                  ),
                  _vm._v(" "),
                  _c(
                    "div",
                    {
                      staticClass: "md-datepicker-body-content",
                      style: _vm.contentStyles
                    },
                    [
                      _c(
                        "transition",
                        { attrs: { name: "md-datepicker-view" } },
                        [
                          _vm.currentView === "day"
                            ? _c(
                                "transition-group",
                                {
                                  staticClass:
                                    "md-datepicker-panel md-datepicker-calendar",
                                  class: _vm.calendarClasses,
                                  attrs: {
                                    tag: "div",
                                    name: "md-datepicker-month"
                                  }
                                },
                                _vm._l([_vm.currentDate], function(
                                  month,
                                  index
                                ) {
                                  return _c(
                                    "div",
                                    {
                                      key: month.getMonth(),
                                      staticClass:
                                        "md-datepicker-panel md-datepicker-month"
                                    },
                                    [
                                      _c(
                                        "md-button",
                                        {
                                          staticClass:
                                            "md-dense md-datepicker-month-trigger",
                                          on: {
                                            click: function($event) {
                                              _vm.currentView = "month"
                                            }
                                          }
                                        },
                                        [
                                          _vm._v(
                                            _vm._s(_vm.currentMonthName) +
                                              " " +
                                              _vm._s(_vm.currentYear)
                                          )
                                        ]
                                      ),
                                      _vm._v(" "),
                                      _c(
                                        "div",
                                        { staticClass: "md-datepicker-week" },
                                        [
                                          _vm._l(
                                            _vm.locale.shorterDays,
                                            function(day, index) {
                                              return index >=
                                                _vm.firstDayOfAWeek
                                                ? _c("span", { key: index }, [
                                                    _vm._v(_vm._s(day))
                                                  ])
                                                : _vm._e()
                                            }
                                          ),
                                          _vm._v(" "),
                                          _vm._l(
                                            _vm.locale.shorterDays,
                                            function(day, index) {
                                              return index < _vm.firstDayOfAWeek
                                                ? _c("span", { key: index }, [
                                                    _vm._v(_vm._s(day))
                                                  ])
                                                : _vm._e()
                                            }
                                          )
                                        ],
                                        2
                                      ),
                                      _vm._v(" "),
                                      _c(
                                        "div",
                                        { staticClass: "md-datepicker-days" },
                                        [
                                          _vm._l(_vm.prefixEmptyDays, function(
                                            day
                                          ) {
                                            return _c("span", {
                                              key: "day-empty-" + day,
                                              staticClass: "md-datepicker-empty"
                                            })
                                          }),
                                          _vm._v(" "),
                                          _vm._l(_vm.daysInMonth, function(
                                            day
                                          ) {
                                            return _c(
                                              "div",
                                              {
                                                key: "day-" + day,
                                                staticClass: "md-datepicker-day"
                                              },
                                              [
                                                _c(
                                                  "span",
                                                  {
                                                    staticClass:
                                                      "md-datepicker-day-button",
                                                    class: {
                                                      "md-datepicker-selected": _vm.isSelectedDay(
                                                        day
                                                      ),
                                                      "md-datepicker-today": _vm.isToday(
                                                        day
                                                      ),
                                                      "md-datepicker-disabled": _vm.isDisabled(
                                                        day
                                                      )
                                                    },
                                                    on: {
                                                      click: function($event) {
                                                        _vm.selectDate(day)
                                                      }
                                                    }
                                                  },
                                                  [_vm._v(_vm._s(day))]
                                                )
                                              ]
                                            )
                                          })
                                        ],
                                        2
                                      )
                                    ],
                                    1
                                  )
                                })
                              )
                            : _vm.currentView === "month"
                              ? _c(
                                  "div",
                                  {
                                    staticClass:
                                      "md-datepicker-panel md-datepicker-month-selector"
                                  },
                                  [
                                    _c(
                                      "md-button",
                                      {
                                        staticClass:
                                          "md-datepicker-year-trigger",
                                        on: {
                                          click: function($event) {
                                            _vm.currentView = "year"
                                          }
                                        }
                                      },
                                      [_vm._v(_vm._s(_vm.currentYear))]
                                    ),
                                    _vm._v(" "),
                                    _vm._l(_vm.locale.months, function(
                                      month,
                                      index
                                    ) {
                                      return _c(
                                        "span",
                                        {
                                          key: month,
                                          staticClass:
                                            "md-datepicker-month-button",
                                          class: {
                                            "md-datepicker-selected":
                                              _vm.currentMonthName === month
                                          },
                                          on: {
                                            click: function($event) {
                                              _vm.switchMonth(index)
                                            }
                                          }
                                        },
                                        [_vm._v(_vm._s(month))]
                                      )
                                    })
                                  ],
                                  2
                                )
                              : _vm.currentView === "year"
                                ? _c(
                                    "keep-alive",
                                    [
                                      _c(
                                        "md-content",
                                        {
                                          staticClass:
                                            "md-datepicker-panel md-datepicker-year-selector md-scrollbar"
                                        },
                                        _vm._l(_vm.availableYears, function(
                                          year
                                        ) {
                                          return _c(
                                            "span",
                                            {
                                              key: year,
                                              staticClass:
                                                "md-datepicker-year-button",
                                              class: {
                                                "md-datepicker-selected":
                                                  _vm.currentYear === year
                                              },
                                              on: {
                                                click: function($event) {
                                                  _vm.switchYear(year)
                                                }
                                              }
                                            },
                                            [_vm._v(_vm._s(year))]
                                          )
                                        })
                                      )
                                    ],
                                    1
                                  )
                                : _vm._e()
                        ],
                        1
                      )
                    ],
                    1
                  ),
                  _vm._v(" "),
                  _c(
                    "md-dialog-actions",
                    { staticClass: "md-datepicker-body-footer" },
                    [
                      _c(
                        "md-button",
                        {
                          staticClass: "md-primary",
                          on: { click: _vm.onCancel }
                        },
                        [_vm._v("Cancel")]
                      ),
                      _vm._v(" "),
                      _c(
                        "md-button",
                        {
                          staticClass: "md-primary",
                          on: { click: _vm.onConfirm }
                        },
                        [_vm._v("Ok")]
                      )
                    ],
                    1
                  )
                ],
                1
              )
            ]
          )
        ]
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDatepicker_MdDatepickerDialog = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4f0a3d52", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDatepicker/MdDatepickerDialog.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(184)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDatepickerDialog_default.a,
  MdDatepicker_MdDatepickerDialog,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDatepicker/MdDatepickerDialog.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4f0a3d52", Component.options)
  } else {
    hotAPI.reload("data-v-4f0a3d52", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDatepicker_MdDatepickerDialog = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 184 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _add_months = __webpack_require__(39);

var _add_months2 = _interopRequireDefault(_add_months);

var _start_of_month = __webpack_require__(186);

var _start_of_month2 = _interopRequireDefault(_start_of_month);

var _sub_months = __webpack_require__(187);

var _sub_months2 = _interopRequireDefault(_sub_months);

var _get_date = __webpack_require__(188);

var _get_date2 = _interopRequireDefault(_get_date);

var _get_day = __webpack_require__(189);

var _get_day2 = _interopRequireDefault(_get_day);

var _get_days_in_month = __webpack_require__(24);

var _get_days_in_month2 = _interopRequireDefault(_get_days_in_month);

var _get_month = __webpack_require__(190);

var _get_month2 = _interopRequireDefault(_get_month);

var _get_year = __webpack_require__(191);

var _get_year2 = _interopRequireDefault(_get_year);

var _is_equal = __webpack_require__(192);

var _is_equal2 = _interopRequireDefault(_is_equal);

var _is_same_day = __webpack_require__(193);

var _is_same_day2 = _interopRequireDefault(_is_same_day);

var _is_today = __webpack_require__(194);

var _is_today2 = _interopRequireDefault(_is_today);

var _set_date = __webpack_require__(195);

var _set_date2 = _interopRequireDefault(_set_date);

var _set_month = __webpack_require__(196);

var _set_month2 = _interopRequireDefault(_set_month);

var _set_year = __webpack_require__(197);

var _set_year2 = _interopRequireDefault(_set_year);

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPopover = __webpack_require__(25);

var _MdPopover2 = _interopRequireDefault(_MdPopover);

var _MdArrowRightIcon = __webpack_require__(201);

var _MdArrowRightIcon2 = _interopRequireDefault(_MdArrowRightIcon);

var _MdArrowLeftIcon = __webpack_require__(203);

var _MdArrowLeftIcon2 = _interopRequireDefault(_MdArrowLeftIcon);

var _MdDialog = __webpack_require__(10);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var daysInAWeek = 7;

var getElements = function getElements(el, selector) {
  if (el && el.querySelector) {
    return el.querySelectorAll(selector);
  }

  return false;
};

exports.default = new _MdComponent2.default({
  name: 'MdDatepickerDialog',
  components: {
    MdPopover: _MdPopover2.default,
    MdArrowRightIcon: _MdArrowRightIcon2.default,
    MdArrowLeftIcon: _MdArrowLeftIcon2.default,
    MdDialog: _MdDialog2.default
  },
  props: {
    mdDate: Date,
    mdDisabledDates: [Array, Function]
  },
  data: function data() {
    return {
      currentDate: null,
      selectedDate: null,
      showDialog: false,
      monthAction: null,
      currentView: 'day',
      contentStyles: {},
      availableYears: null
    };
  },
  computed: {
    firstDayOfAWeek: function firstDayOfAWeek() {
      // normalize
      var firstDayOfAWeek = Number(this.$material.locale.firstDayOfAWeek);
      if (Number.isNaN(firstDayOfAWeek) || !Number.isFinite(firstDayOfAWeek)) {
        return 0;
      }
      firstDayOfAWeek = Math.floor(firstDayOfAWeek) % daysInAWeek;
      firstDayOfAWeek += firstDayOfAWeek < 0 ? daysInAWeek : 0;
      return firstDayOfAWeek;
    },
    locale: function locale() {
      return this.$material.locale;
    },
    popperSettings: function popperSettings() {
      return {
        placement: 'bottom-start',
        modifiers: {
          keepTogether: {
            enabled: true
          },
          flip: {
            enabled: false
          }
        }
      };
    },
    calendarClasses: function calendarClasses() {
      if (this.monthAction === 'next') {
        return 'md-next';
      }

      return 'md-previous';
    },
    firstDayOfMonth: function firstDayOfMonth() {
      return (0, _start_of_month2.default)(this.currentDate).getDay();
    },
    prefixEmptyDays: function prefixEmptyDays() {
      var prefixEmptyDays = this.firstDayOfMonth - this.firstDayOfAWeek;
      prefixEmptyDays += prefixEmptyDays < 0 ? daysInAWeek : 0;
      return prefixEmptyDays;
    },
    daysInMonth: function daysInMonth() {
      return (0, _get_days_in_month2.default)(this.currentDate);
    },
    currentDay: function currentDay() {
      if (this.selectedDate) {
        return (0, _get_date2.default)(this.selectedDate);
      }

      return (0, _get_date2.default)(this.currentDate);
    },
    currentMonth: function currentMonth() {
      return (0, _get_month2.default)(this.currentDate);
    },
    currentMonthName: function currentMonthName() {
      return this.locale.months[this.currentMonth];
    },
    currentYear: function currentYear() {
      return (0, _get_year2.default)(this.currentDate);
    },
    selectedYear: function selectedYear() {
      if (this.selectedDate) {
        return (0, _get_year2.default)(this.selectedDate);
      }

      return (0, _get_year2.default)(this.currentDate);
    },
    shortDayName: function shortDayName() {
      if (this.selectedDate) {
        return this.locale.shortDays[(0, _get_day2.default)(this.selectedDate)];
      }

      return this.locale.shortDays[(0, _get_day2.default)(this.currentDate)];
    },
    shortMonthName: function shortMonthName() {
      if (this.selectedDate) {
        return this.locale.shortMonths[(0, _get_month2.default)(this.selectedDate)];
      }

      return this.locale.shortMonths[(0, _get_month2.default)(this.currentDate)];
    }
  },
  watch: {
    mdDate: function mdDate() {
      this.currentDate = this.mdDate || new Date();
      this.selectedDate = this.mdDate;
    },
    currentDate: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(next, previous) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:

                if (previous) {
                  this.setContentStyles();
                }

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function currentDate(_x, _x2) {
        return _ref.apply(this, arguments);
      }

      return currentDate;
    }(),
    currentView: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var activeYear;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.$nextTick();

              case 2:

                if (this.currentView === 'year') {
                  activeYear = getElements(this.$el, '.md-datepicker-year-button.md-datepicker-selected');


                  if (activeYear.length) {
                    activeYear[0].scrollIntoView({
                      behavior: 'instant',
                      block: 'center',
                      inline: 'center'
                    });
                  }
                }

              case 3:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function currentView() {
        return _ref2.apply(this, arguments);
      }

      return currentView;
    }()
  },
  methods: {
    setContentStyles: function setContentStyles() {
      var months = getElements(this.$el, '.md-datepicker-month');

      if (months.length) {
        var nextMonth = months[months.length - 1];

        this.contentStyles = {
          height: nextMonth.offsetHeight + 10 + 'px'
        };
      }
    },
    setAvailableYears: function setAvailableYears() {
      var _locale = this.locale,
          startYear = _locale.startYear,
          endYear = _locale.endYear;

      var counter = startYear;
      var years = [];

      while (counter <= endYear) {
        years.push(counter++);
      }

      this.availableYears = years;
    },
    handleDisabledDateByArray: function handleDisabledDateByArray(date) {
      return this.mdDisabledDates.some(function (disabledDate) {
        return (0, _is_same_day2.default)(disabledDate, date);
      });
    },
    isDisabled: function isDisabled(day) {
      if (this.mdDisabledDates) {
        var targetDate = (0, _set_date2.default)(this.currentDate, day);

        if (Array.isArray(this.mdDisabledDates)) {
          return this.handleDisabledDateByArray(targetDate);
        } else if (typeof this.mdDisabledDates === 'function') {
          return this.mdDisabledDates(targetDate);
        }
      }
    },
    isSelectedDay: function isSelectedDay(day) {
      return (0, _is_equal2.default)(this.selectedDate, (0, _set_date2.default)(this.currentDate, day));
    },
    isToday: function isToday(day) {
      return (0, _is_today2.default)((0, _set_date2.default)(this.currentDate, day));
    },
    previousMonth: function previousMonth() {
      this.monthAction = 'previous';
      this.currentDate = (0, _sub_months2.default)(this.currentDate, 1);
    },
    nextMonth: function nextMonth() {
      this.monthAction = 'next';
      this.currentDate = (0, _add_months2.default)(this.currentDate, 1);
    },
    switchMonth: function switchMonth(index) {
      this.currentDate = (0, _set_month2.default)(this.currentDate, index);
      this.currentView = 'day';
    },
    switchYear: function switchYear(year) {
      this.currentDate = (0, _set_year2.default)(this.currentDate, year);
      this.currentView = 'month';
    },
    selectDate: function selectDate(day) {
      this.currentDate = (0, _set_date2.default)(this.currentDate, day);
      this.selectedDate = this.currentDate;
      this.$emit('update:mdDate', this.selectedDate);
    },
    closeDialog: function closeDialog() {
      this.$emit('md-closed');
    },
    onClose: function onClose() {
      this.closeDialog();
    },
    onCancel: function onCancel() {
      this.closeDialog();
    },
    onConfirm: function onConfirm() {
      this.closeDialog();
      this.$emit('update:mdDate', this.selectedDate);
    }
  },
  created: function created() {
    var _this = this;

    this.setAvailableYears();
    this.currentDate = this.mdDate || new Date();
    this.selectedDate = this.mdDate;
    this.currentView = 'day';

    window.setTimeout(function () {
      _this.setContentStyles();
    }, 50);
  }
});

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|String|Number} date - the original date
 * @returns {Date} the start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * var result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth (dirtyDate) {
  var date = parse(dirtyDate)
  date.setDate(1)
  date.setHours(0, 0, 0, 0)
  return date
}

module.exports = startOfMonth


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var addMonths = __webpack_require__(39)

/**
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be subtracted
 * @returns {Date} the new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * var result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths (dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount)
  return addMonths(dirtyDate, -amount)
}

module.exports = subMonths


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Day Helpers
 * @summary Get the day of the month of the given date.
 *
 * @description
 * Get the day of the month of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the day of month
 *
 * @example
 * // Which day of the month is 29 February 2012?
 * var result = getDate(new Date(2012, 1, 29))
 * //=> 29
 */
function getDate (dirtyDate) {
  var date = parse(dirtyDate)
  var dayOfMonth = date.getDate()
  return dayOfMonth
}

module.exports = getDate


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Weekday Helpers
 * @summary Get the day of the week of the given date.
 *
 * @description
 * Get the day of the week of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the day of week
 *
 * @example
 * // Which day of the week is 29 February 2012?
 * var result = getDay(new Date(2012, 1, 29))
 * //=> 3
 */
function getDay (dirtyDate) {
  var date = parse(dirtyDate)
  var day = date.getDay()
  return day
}

module.exports = getDay


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Month Helpers
 * @summary Get the month of the given date.
 *
 * @description
 * Get the month of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the month
 *
 * @example
 * // Which month is 29 February 2012?
 * var result = getMonth(new Date(2012, 1, 29))
 * //=> 1
 */
function getMonth (dirtyDate) {
  var date = parse(dirtyDate)
  var month = date.getMonth()
  return month
}

module.exports = getMonth


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Year Helpers
 * @summary Get the year of the given date.
 *
 * @description
 * Get the year of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the year
 *
 * @example
 * // Which year is 2 July 2014?
 * var result = getYear(new Date(2014, 6, 2))
 * //=> 2014
 */
function getYear (dirtyDate) {
  var date = parse(dirtyDate)
  var year = date.getFullYear()
  return year
}

module.exports = getYear


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|String|Number} dateLeft - the first date to compare
 * @param {Date|String|Number} dateRight - the second date to compare
 * @returns {Boolean} the dates are equal
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * var result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0)
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */
function isEqual (dirtyLeftDate, dirtyRightDate) {
  var dateLeft = parse(dirtyLeftDate)
  var dateRight = parse(dirtyRightDate)
  return dateLeft.getTime() === dateRight.getTime()
}

module.exports = isEqual


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var startOfDay = __webpack_require__(21)

/**
 * @category Day Helpers
 * @summary Are the given dates in the same day?
 *
 * @description
 * Are the given dates in the same day?
 *
 * @param {Date|String|Number} dateLeft - the first date to check
 * @param {Date|String|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * var result = isSameDay(
 *   new Date(2014, 8, 4, 6, 0),
 *   new Date(2014, 8, 4, 18, 0)
 * )
 * //=> true
 */
function isSameDay (dirtyDateLeft, dirtyDateRight) {
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft)
  var dateRightStartOfDay = startOfDay(dirtyDateRight)

  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime()
}

module.exports = isSameDay


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

var startOfDay = __webpack_require__(21)

/**
 * @category Day Helpers
 * @summary Is the given date today?
 *
 * @description
 * Is the given date today?
 *
 * @param {Date|String|Number} date - the date to check
 * @returns {Boolean} the date is today
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * var result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */
function isToday (dirtyDate) {
  return startOfDay(dirtyDate).getTime() === startOfDay(new Date()).getTime()
}

module.exports = isToday


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} dayOfMonth - the day of the month of the new date
 * @returns {Date} the new date with the day of the month setted
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * var result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
function setDate (dirtyDate, dirtyDayOfMonth) {
  var date = parse(dirtyDate)
  var dayOfMonth = Number(dirtyDayOfMonth)
  date.setDate(dayOfMonth)
  return date
}

module.exports = setDate


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)
var getDaysInMonth = __webpack_require__(24)

/**
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} month - the month of the new date
 * @returns {Date} the new date with the month setted
 *
 * @example
 * // Set February to 1 September 2014:
 * var result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
function setMonth (dirtyDate, dirtyMonth) {
  var date = parse(dirtyDate)
  var month = Number(dirtyMonth)
  var year = date.getFullYear()
  var day = date.getDate()

  var dateWithDesiredMonth = new Date(0)
  dateWithDesiredMonth.setFullYear(year, month, 15)
  dateWithDesiredMonth.setHours(0, 0, 0, 0)
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth)
  // Set the last day of the new month
  // if the original date was the last day of the longer month
  date.setMonth(month, Math.min(day, daysInMonth))
  return date
}

module.exports = setMonth


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

var parse = __webpack_require__(3)

/**
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} year - the year of the new date
 * @returns {Date} the new date with the year setted
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * var result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
function setYear (dirtyDate, dirtyYear) {
  var date = parse(dirtyDate)
  var year = Number(dirtyYear)
  date.setFullYear(year)
  return date
}

module.exports = setYear


/***/ }),
/* 198 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _popper = __webpack_require__(200);

var _popper2 = _interopRequireDefault(_popper);

var _deepmerge = __webpack_require__(30);

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _MdPortal = __webpack_require__(16);

var _MdPortal2 = _interopRequireDefault(_MdPortal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'MdPopover',
  abstract: true,
  components: {
    MdPortal: _MdPortal2.default
  },
  props: {
    mdActive: Boolean,
    mdSettings: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      popperInstance: null,
      originalParentEl: null,
      shouldRender: false,
      shouldActivate: false
    };
  },
  computed: {
    popoverClasses: function popoverClasses() {
      if (this.shouldActivate) {
        return 'md-active';
      } else if (this.shouldRender) {
        return 'md-rendering';
      }
    }
  },
  watch: {
    mdActive: {
      immediate: true,
      handler: function handler(shouldRender) {
        this.shouldRender = shouldRender;

        if (shouldRender) {
          this.bindPopper();
        } else {
          this.shouldActivate = false;
        }
      }
    },
    mdSettings: function mdSettings() {
      if (this.popperInstance) {
        this.createPopper();
      }
    }
  },
  methods: {
    getPopperOptions: function getPopperOptions() {
      var _this = this;

      return {
        placement: 'bottom',
        modifiers: {
          preventOverflow: {
            boundariesElement: 'viewport',
            padding: 16
          },
          computeStyle: {
            gpuAcceleration: false
          }
        },
        onCreate: function onCreate() {
          _this.shouldActivate = true;
          _this.$emit('md-active');
        }
      };
    },
    setOriginalParent: function setOriginalParent(el) {
      if (!this.originalParentEl) {
        this.originalParentEl = el;
      }
    },
    killPopper: function killPopper() {
      if (this.popperInstance) {
        this.popperInstance.destroy();
        this.popperInstance = null;
      }
    },
    bindPopper: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:

                if (this.originalParentEl) {
                  this.createPopper();
                }

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function bindPopper() {
        return _ref.apply(this, arguments);
      }

      return bindPopper;
    }(),
    createPopper: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var options;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this.mdSettings) {
                  options = (0, _deepmerge2.default)(this.getPopperOptions(), this.mdSettings);


                  if (this.$el.nodeType !== Node.COMMENT_NODE) {
                    this.popperInstance = new _popper2.default(this.originalParentEl, this.$el, options);
                  }
                }

              case 1:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function createPopper() {
        return _ref2.apply(this, arguments);
      }

      return createPopper;
    }(),
    resetPopper: function resetPopper() {
      if (this.popperInstance) {
        this.killPopper();
        this.createPopper();
      }
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.killPopper();
  },
  mounted: function mounted() {
    this.resetPopper();
  },
  render: function render(createElement) {
    return createElement(_MdPortal2.default, {
      props: _extends({}, this.$attrs),
      on: _extends({}, this.$listeners, {
        'md-initial-parent': this.setOriginalParent,
        'md-destroy': this.killPopper
      })
    }, this.$slots.default);
  }
};

/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.9
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    if (element) {
      return element.ownerDocument.documentElement;
    }

    return document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function () {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE10$1() && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);


/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(17)))

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdArrowRightIcon.vue
var MdArrowRightIcon = __webpack_require__(202);
var MdArrowRightIcon_default = /*#__PURE__*/__webpack_require__.n(MdArrowRightIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-1e23e1bf","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdArrowRightIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: { d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z" }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0-.25h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdArrowRightIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-1e23e1bf", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdArrowRightIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdArrowRightIcon_default.a,
  icons_MdArrowRightIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdArrowRightIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1e23e1bf", Component.options)
  } else {
    hotAPI.reload("data-v-1e23e1bf", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdArrowRightIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdArrowRightIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdArrowLeftIcon.vue
var MdArrowLeftIcon = __webpack_require__(204);
var MdArrowLeftIcon_default = /*#__PURE__*/__webpack_require__.n(MdArrowLeftIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-5cc7b6f4","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdArrowLeftIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: { d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z" }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0-.5h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdArrowLeftIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5cc7b6f4", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdArrowLeftIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdArrowLeftIcon_default.a,
  icons_MdArrowLeftIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdArrowLeftIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5cc7b6f4", Component.options)
  } else {
    hotAPI.reload("data-v-5cc7b6f4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdArrowLeftIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdArrowLeftIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 205 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPortal = __webpack_require__(16);

var _MdPortal2 = _interopRequireDefault(_MdPortal);

var _MdOverlay = __webpack_require__(23);

var _MdOverlay2 = _interopRequireDefault(_MdOverlay);

var _MdFocusTrap = __webpack_require__(40);

var _MdFocusTrap2 = _interopRequireDefault(_MdFocusTrap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdDialog',
  components: {
    MdPortal: _MdPortal2.default,
    MdOverlay: _MdOverlay2.default,
    MdFocusTrap: _MdFocusTrap2.default
  },
  props: {
    mdActive: Boolean,
    mdBackdrop: {
      type: Boolean,
      default: true
    },
    mdBackdropClass: {
      type: String,
      default: 'md-dialog-overlay'
    },
    mdCloseOnEsc: {
      type: Boolean,
      default: true
    },
    mdClickOutsideToClose: {
      type: Boolean,
      default: true
    },
    mdFullscreen: {
      type: Boolean,
      default: true
    },
    mdAnimateFromSource: Boolean
  },
  computed: {
    dialogClasses: function dialogClasses() {
      return {
        'md-dialog-fullscreen': this.mdFullscreen
      };
    }
  },
  watch: {
    mdActive: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(isActive) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:

                if (isActive) {
                  this.$emit('md-opened');
                } else {
                  this.$emit('md-closed');
                }

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function mdActive(_x) {
        return _ref.apply(this, arguments);
      }

      return mdActive;
    }()
  },
  methods: {
    closeDialog: function closeDialog() {
      this.$emit('update:mdActive', false);
    },
    onClick: function onClick() {
      if (this.mdClickOutsideToClose) {
        this.closeDialog();
      }
    },
    onEsc: function onEsc() {
      if (this.mdCloseOnEsc) {
        this.closeDialog();
      }
    }
  }
});

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdDateIcon.vue
var MdDateIcon = __webpack_require__(208);
var MdDateIcon_default = /*#__PURE__*/__webpack_require__.n(MdDateIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-644b79cc","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdDateIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: {
              d:
                "M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"
            }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdDateIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-644b79cc", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdDateIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDateIcon_default.a,
  icons_MdDateIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdDateIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-644b79cc", Component.options)
  } else {
    hotAPI.reload("data-v-644b79cc", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdDateIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdDateIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDialog = __webpack_require__(10);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

var _MdDialogTitle = __webpack_require__(210);

var _MdDialogTitle2 = _interopRequireDefault(_MdDialogTitle);

var _MdDialogContent = __webpack_require__(213);

var _MdDialogContent2 = _interopRequireDefault(_MdDialogContent);

var _MdDialogActions = __webpack_require__(216);

var _MdDialogActions2 = _interopRequireDefault(_MdDialogActions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDialog2.default.name, _MdDialog2.default);
  Vue.component(_MdDialogTitle2.default.name, _MdDialogTitle2.default);
  Vue.component(_MdDialogContent2.default.name, _MdDialogContent2.default);
  Vue.component(_MdDialogActions2.default.name, _MdDialogActions2.default);
};

/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogTitle.vue
var MdDialogTitle = __webpack_require__(212);
var MdDialogTitle_default = /*#__PURE__*/__webpack_require__.n(MdDialogTitle);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-879275ce","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogTitle.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "span",
    { staticClass: "md-dialog-title md-title" },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialog_MdDialogTitle = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-879275ce", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogTitle.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(211)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogTitle_default.a,
  MdDialog_MdDialogTitle,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogTitle.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-879275ce", Component.options)
  } else {
    hotAPI.reload("data-v-879275ce", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDialog_MdDialogTitle = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 211 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogTitle'
};

/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogContent.vue
var MdDialogContent = __webpack_require__(215);
var MdDialogContent_default = /*#__PURE__*/__webpack_require__.n(MdDialogContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-dae90f0c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "md-dialog-content" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialog_MdDialogContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-dae90f0c", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(214)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogContent_default.a,
  MdDialog_MdDialogContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-dae90f0c", Component.options)
  } else {
    hotAPI.reload("data-v-dae90f0c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDialog_MdDialogContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 214 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogContent'
};

/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogActions.vue
var MdDialogActions = __webpack_require__(218);
var MdDialogActions_default = /*#__PURE__*/__webpack_require__.n(MdDialogActions);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-092eaafe","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogActions.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "md-dialog-actions" }, [_vm._t("default")], 2)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialog_MdDialogActions = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-092eaafe", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogActions.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(217)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogActions_default.a,
  MdDialog_MdDialogActions,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogActions.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-092eaafe", Component.options)
  } else {
    hotAPI.reload("data-v-092eaafe", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDialog_MdDialogActions = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 217 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogActions'
};

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDialog = __webpack_require__(10);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

var _MdDialogAlert = __webpack_require__(220);

var _MdDialogAlert2 = _interopRequireDefault(_MdDialogAlert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDialog2.default.name, _MdDialog2.default);
  Vue.component(_MdDialogAlert2.default.name, _MdDialogAlert2.default);
};

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogAlert/MdDialogAlert.vue
var MdDialogAlert = __webpack_require__(221);
var MdDialogAlert_default = /*#__PURE__*/__webpack_require__.n(MdDialogAlert);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-197ab94b","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogAlert/MdDialogAlert.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-dialog",
    _vm._g(
      _vm._b(
        { attrs: { "md-fullscreen": false } },
        "md-dialog",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [
      _vm.mdTitle
        ? _c("md-dialog-title", [_vm._v(_vm._s(_vm.mdTitle))])
        : _vm._e(),
      _vm._v(" "),
      _vm.mdContent
        ? _c("md-dialog-content", {
            domProps: { innerHTML: _vm._s(_vm.mdContent) }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "md-dialog-actions",
        [
          _c(
            "md-button",
            {
              staticClass: "md-primary",
              on: {
                click: function($event) {
                  _vm.$emit("update:mdActive", false)
                }
              }
            },
            [_vm._v(_vm._s(_vm.mdConfirmText))]
          )
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialogAlert_MdDialogAlert = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-197ab94b", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogAlert/MdDialogAlert.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogAlert_default.a,
  MdDialogAlert_MdDialogAlert,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogAlert/MdDialogAlert.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-197ab94b", Component.options)
  } else {
    hotAPI.reload("data-v-197ab94b", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdDialog_MdDialogAlert_MdDialogAlert = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogAlert',
  props: {
    mdTitle: String,
    mdContent: String,
    mdConfirmText: {
      type: String,
      default: 'Ok'
    }
  }
};

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDialog = __webpack_require__(10);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

var _MdDialogConfirm = __webpack_require__(223);

var _MdDialogConfirm2 = _interopRequireDefault(_MdDialogConfirm);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDialog2.default.name, _MdDialog2.default);
  Vue.component(_MdDialogConfirm2.default.name, _MdDialogConfirm2.default);
};

/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogConfirm/MdDialogConfirm.vue
var MdDialogConfirm = __webpack_require__(224);
var MdDialogConfirm_default = /*#__PURE__*/__webpack_require__.n(MdDialogConfirm);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-acc7afda","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogConfirm/MdDialogConfirm.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-dialog",
    _vm._g(
      _vm._b(
        { attrs: { "md-fullscreen": false } },
        "md-dialog",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [
      _vm.mdTitle
        ? _c("md-dialog-title", [_vm._v(_vm._s(_vm.mdTitle))])
        : _vm._e(),
      _vm._v(" "),
      _vm.mdContent
        ? _c("md-dialog-content", {
            domProps: { innerHTML: _vm._s(_vm.mdContent) }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "md-dialog-actions",
        [
          _c(
            "md-button",
            { staticClass: "md-primary", on: { click: _vm.onCancel } },
            [_vm._v(_vm._s(_vm.mdCancelText))]
          ),
          _vm._v(" "),
          _c(
            "md-button",
            { staticClass: "md-primary", on: { click: _vm.onConfirm } },
            [_vm._v(_vm._s(_vm.mdConfirmText))]
          )
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialogConfirm_MdDialogConfirm = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-acc7afda", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogConfirm/MdDialogConfirm.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogConfirm_default.a,
  MdDialogConfirm_MdDialogConfirm,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogConfirm/MdDialogConfirm.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-acc7afda", Component.options)
  } else {
    hotAPI.reload("data-v-acc7afda", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdDialog_MdDialogConfirm_MdDialogConfirm = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogConfirm',
  props: {
    mdTitle: String,
    mdContent: String,
    mdConfirmText: {
      type: String,
      default: 'Ok'
    },
    mdCancelText: {
      type: String,
      default: 'Cancel'
    }
  },
  methods: {
    onCancel: function onCancel() {
      this.$emit('md-cancel');
      this.$emit('update:mdActive', false);
    },
    onConfirm: function onConfirm() {
      this.$emit('md-confirm');
      this.$emit('update:mdActive', false);
    }
  }
};

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDialog = __webpack_require__(10);

var _MdDialog2 = _interopRequireDefault(_MdDialog);

var _MdDialogPrompt = __webpack_require__(226);

var _MdDialogPrompt2 = _interopRequireDefault(_MdDialogPrompt);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDialog2.default.name, _MdDialog2.default);
  Vue.component(_MdDialogPrompt2.default.name, _MdDialogPrompt2.default);
};

/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDialog/MdDialogPrompt/MdDialogPrompt.vue
var MdDialogPrompt = __webpack_require__(227);
var MdDialogPrompt_default = /*#__PURE__*/__webpack_require__.n(MdDialogPrompt);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7b3c8c22","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDialog/MdDialogPrompt/MdDialogPrompt.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-dialog",
    _vm._b(
      {
        attrs: { "md-fullscreen": false },
        on: { "md-opened": _vm.setInputFocus }
      },
      "md-dialog",
      _vm.$attrs,
      false
    ),
    [
      _vm.mdTitle
        ? _c("md-dialog-title", [_vm._v(_vm._s(_vm.mdTitle))])
        : _vm._e(),
      _vm._v(" "),
      _vm.mdContent
        ? _c("md-dialog-content", {
            domProps: { innerHTML: _vm._s(_vm.mdContent) }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "md-dialog-content",
        [
          _c(
            "md-field",
            [
              _c("md-input", {
                ref: "input",
                attrs: {
                  id: _vm.mdInputId,
                  name: _vm.mdInputName,
                  maxlength: _vm.mdInputMaxlength,
                  placeholder: _vm.mdInputPlaceholder
                },
                nativeOn: {
                  keydown: function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key)
                    ) {
                      return null
                    }
                    _vm.onConfirm($event)
                  }
                },
                model: {
                  value: _vm.inputValue,
                  callback: function($$v) {
                    _vm.inputValue = $$v
                  },
                  expression: "inputValue"
                }
              })
            ],
            1
          )
        ],
        1
      ),
      _vm._v(" "),
      _c(
        "md-dialog-actions",
        [
          _c(
            "md-button",
            { staticClass: "md-primary", on: { click: _vm.onCancel } },
            [_vm._v(_vm._s(_vm.mdCancelText))]
          ),
          _vm._v(" "),
          _c(
            "md-button",
            { staticClass: "md-primary", on: { click: _vm.onConfirm } },
            [_vm._v(_vm._s(_vm.mdConfirmText))]
          )
        ],
        1
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDialogPrompt_MdDialogPrompt = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7b3c8c22", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDialog/MdDialogPrompt/MdDialogPrompt.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDialogPrompt_default.a,
  MdDialogPrompt_MdDialogPrompt,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDialog/MdDialogPrompt/MdDialogPrompt.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7b3c8c22", Component.options)
  } else {
    hotAPI.reload("data-v-7b3c8c22", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdDialog_MdDialogPrompt_MdDialogPrompt = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdDialogPrompt',
  props: {
    value: {},
    mdTitle: String,
    mdInputName: String,
    mdInputId: String,
    mdInputMaxlength: [String, Number],
    mdInputPlaceholder: [String, Number],
    mdContent: String,
    mdConfirmText: {
      type: String,
      default: 'Ok'
    },
    mdCancelText: {
      type: String,
      default: 'Cancel'
    }
  },
  data: function data() {
    return {
      inputValue: null
    };
  },
  watch: {
    value: function value() {
      this.inputValue = this.value;
    }
  },
  methods: {
    onCancel: function onCancel() {
      this.$emit('md-cancel');
      this.$emit('update:mdActive', false);
    },
    onConfirm: function onConfirm() {
      this.$emit('input', this.inputValue);
      this.$emit('md-confirm', this.inputValue);
      this.$emit('update:mdActive', false);
    },
    setInputFocus: function setInputFocus() {
      var _this = this;

      window.setTimeout(function () {
        _this.$refs.input.$el.focus();
      }, 50);
    }
  },
  created: function created() {
    this.inputValue = this.value;
  }
};

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDivider = __webpack_require__(229);

var _MdDivider2 = _interopRequireDefault(_MdDivider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDivider2.default.name, _MdDivider2.default);
};

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDivider/MdDivider.vue
var MdDivider = __webpack_require__(231);
var MdDivider_default = /*#__PURE__*/__webpack_require__.n(MdDivider);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-8ca7ced6","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDivider/MdDivider.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.insideList
    ? _c("li", { staticClass: "md-divider", class: [_vm.$mdActiveTheme] })
    : _c("hr", { staticClass: "md-divider", class: [_vm.$mdActiveTheme] })
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDivider_MdDivider = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-8ca7ced6", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDivider/MdDivider.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(230)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDivider_default.a,
  MdDivider_MdDivider,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDivider/MdDivider.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-8ca7ced6", Component.options)
  } else {
    hotAPI.reload("data-v-8ca7ced6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDivider_MdDivider = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 230 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdDivider',
  computed: {
    insideList: function insideList() {
      return this.$parent.$options._componentTag === 'md-list';
    }
  }
}); //
//
//
//
//

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdDrawer = __webpack_require__(233);

var _MdDrawer2 = _interopRequireDefault(_MdDrawer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdDrawer2.default.name, _MdDrawer2.default);
};

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdDrawer/MdDrawer.vue
var MdDrawer = __webpack_require__(235);
var MdDrawer_default = /*#__PURE__*/__webpack_require__.n(MdDrawer);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-801caa62","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdDrawer/MdDrawer.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-drawer",
      class: [_vm.$mdActiveTheme, _vm.drawerClasses]
    },
    [
      _vm._t("default"),
      _vm._v(" "),
      _vm.mdFixed
        ? _c("md-overlay", {
            attrs: { "md-active": _vm.mdActive },
            on: { click: _vm.closeDrawer }
          })
        : _c("md-overlay", {
            attrs: { "md-active": _vm.mdActive, "md-attach-to-parent": "" },
            on: { click: _vm.closeDrawer }
          })
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdDrawer_MdDrawer = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-801caa62", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdDrawer/MdDrawer.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(234)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDrawer_default.a,
  MdDrawer_MdDrawer,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdDrawer/MdDrawer.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-801caa62", Component.options)
  } else {
    hotAPI.reload("data-v-801caa62", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdDrawer_MdDrawer = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 234 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdOverlay = __webpack_require__(23);

var _MdOverlay2 = _interopRequireDefault(_MdOverlay);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdDrawer',
  components: {
    MdOverlay: _MdOverlay2.default
  },
  props: {
    mdLeft: Boolean,
    mdRight: Boolean,
    mdPermanent: _extends({
      type: String
    }, (0, _MdPropValidator2.default)('md-permanent', ['full', 'clipped', 'card'])),
    mdPersistent: _extends({
      type: String
    }, (0, _MdPropValidator2.default)('md-persistent', ['mini', 'full'])),
    mdActive: Boolean,
    mdFixed: Boolean
  },
  watch: {
    mdActive: function mdActive(visible) {
      if (visible) {
        this.$emit('md-opened');
      } else {
        this.$emit('md-closed');
      }
    }
  },
  computed: {
    drawerClasses: function drawerClasses() {
      var classes = {
        'md-left': this.mdLeft,
        'md-right': this.mdRight,
        'md-temporary': this.isTemporary,
        'md-persistent': this.mdPersistent,
        'md-permanent': this.mdPermanent,
        'md-active': this.mdActive,
        'md-fixed': this.mdFixed
      };

      if (this.mdPermanent) {
        classes['md-permanent-' + this.mdPermanent] = true;
      }

      if (this.mdPersistent) {
        classes['md-persistent-' + this.mdPersistent] = true;
      }

      return classes;
    },
    isTemporary: function isTemporary() {
      return !this.mdPermanent && !this.mdPersistent;
    },
    mode: function mode() {
      if (this.mdPersistent) {
        return 'persistent';
      }

      if (this.mdPermanent) {
        return 'permanent';
      }

      return 'temporary';
    },
    submode: function submode() {
      if (this.mdPersistent) {
        return this.mdPersistent;
      }

      if (this.mdPermanent) {
        return this.mdPermanent;
      }
    }
  },
  methods: {
    closeDrawer: function closeDrawer() {
      this.$emit('update:mdActive', false);
    }
  }
});

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(237);

exports.default = function (Vue) {};

/***/ }),
/* 237 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdEmptyState = __webpack_require__(41);

var _MdEmptyState2 = _interopRequireDefault(_MdEmptyState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdEmptyState2.default.name, _MdEmptyState2.default);
};

/***/ }),
/* 239 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdEmptyStateProps = __webpack_require__(42);

var _MdEmptyStateProps2 = _interopRequireDefault(_MdEmptyStateProps);

var _MdAssetIcon = __webpack_require__(18);

var _MdAssetIcon2 = _interopRequireDefault(_MdAssetIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdEmptyState',
  mixins: [_MdAssetIcon2.default],
  props: _MdEmptyStateProps2.default,
  computed: {
    emptyStateClasses: function emptyStateClasses() {
      return {
        'md-rounded': this.mdRounded
      };
    },
    emptyStateStyles: function emptyStateStyles() {
      if (this.mdRounded) {
        var size = this.mdSize + 'px';

        return {
          width: size,
          height: size
        };
      }
    }
  }
}); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdIcon = __webpack_require__(43);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

var _MdSelect = __webpack_require__(242);

var _MdSelect2 = _interopRequireDefault(_MdSelect);

var _MdField = __webpack_require__(20);

var _MdField2 = _interopRequireDefault(_MdField);

var _MdFile = __webpack_require__(261);

var _MdFile2 = _interopRequireDefault(_MdFile);

var _MdInput = __webpack_require__(14);

var _MdInput2 = _interopRequireDefault(_MdInput);

var _MdTextarea = __webpack_require__(266);

var _MdTextarea2 = _interopRequireDefault(_MdTextarea);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.use(_MdIcon2.default);
  Vue.use(_MdSelect2.default);
  Vue.component(_MdField2.default.name, _MdField2.default);
  Vue.component(_MdFile2.default.name, _MdFile2.default);
  Vue.component(_MdInput2.default.name, _MdInput2.default);
  Vue.component(_MdTextarea2.default.name, _MdTextarea2.default);
};

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSelect = __webpack_require__(243);

var _MdSelect2 = _interopRequireDefault(_MdSelect);

var _MdOption = __webpack_require__(255);

var _MdOption2 = _interopRequireDefault(_MdOption);

var _MdOptgroup = __webpack_require__(258);

var _MdOptgroup2 = _interopRequireDefault(_MdOptgroup);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSelect2.default.name, _MdSelect2.default);
  Vue.component(_MdOption2.default.name, _MdOption2.default);
  Vue.component(_MdOptgroup2.default.name, _MdOptgroup2.default);
};

/***/ }),
/* 243 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdSelect/MdSelect.vue
var MdSelect = __webpack_require__(245);
var MdSelect_default = /*#__PURE__*/__webpack_require__.n(MdSelect);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7e35dfa3","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdSelect/MdSelect.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-menu",
    {
      staticClass: "md-select",
      class: { "md-disabled": _vm.disabled },
      attrs: {
        "md-close-on-select": false,
        "md-active": _vm.showSelect,
        "md-offset-x": _vm.offset.x,
        "md-offset-y": _vm.offset.y,
        "md-dense": _vm.mdDense
      },
      on: {
        "update:mdActive": function($event) {
          _vm.showSelect = $event
        },
        "md-closed": _vm.onClose
      }
    },
    [
      _c(
        "md-input",
        _vm._g(
          _vm._b(
            {
              ref: "input",
              staticClass: "md-input md-select-value",
              attrs: {
                readonly: "",
                disabled: _vm.disabled,
                required: _vm.required,
                placeholder: _vm.placeholder
              },
              on: {
                focus: function($event) {
                  $event.preventDefault()
                  _vm.onFocus($event)
                },
                blur: function($event) {
                  $event.preventDefault()
                  _vm.removeHighlight($event)
                },
                click: _vm.openSelect,
                keydown: [
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "down", 40, $event.key)
                    ) {
                      return null
                    }
                    _vm.openSelect($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key)
                    ) {
                      return null
                    }
                    _vm.openSelect($event)
                  },
                  function($event) {
                    if (
                      !("button" in $event) &&
                      _vm._k($event.keyCode, "space", 32, $event.key)
                    ) {
                      return null
                    }
                    _vm.openSelect($event)
                  }
                ]
              },
              model: {
                value: _vm.MdSelect.label,
                callback: function($$v) {
                  _vm.$set(_vm.MdSelect, "label", $$v)
                },
                expression: "MdSelect.label"
              }
            },
            "md-input",
            _vm.$attrs,
            false
          ),
          _vm.inputListeners
        )
      ),
      _vm._v(" "),
      _c("md-drop-down-icon", {
        nativeOn: {
          click: function($event) {
            _vm.openSelect($event)
          }
        }
      }),
      _vm._v(" "),
      _c(
        "keep-alive",
        [
          _c(
            "md-menu-content",
            {
              ref: "menu",
              staticClass: "md-select-menu",
              style: _vm.menuStyles,
              attrs: { "md-content-class": _vm.mdClass },
              on: { enter: _vm.onMenuEnter }
            },
            [_vm.showSelect ? _vm._t("default") : _vm._e()],
            2
          )
        ],
        1
      ),
      _vm._v(" "),
      !_vm.showSelect
        ? _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: false,
                  expression: "false"
                }
              ]
            },
            [_vm._t("default")],
            2
          )
        : _vm._e(),
      _vm._v(" "),
      _c("input", {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.model,
            expression: "model"
          }
        ],
        staticClass: "md-input-fake",
        attrs: { disabled: _vm.disabled, readonly: "", tabindex: "-1" },
        domProps: { value: _vm.model },
        on: {
          input: function($event) {
            if ($event.target.composing) {
              return
            }
            _vm.model = $event.target.value
          }
        }
      }),
      _vm._v(" "),
      _c(
        "select",
        _vm._b(
          {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.model,
                expression: "model"
              }
            ],
            attrs: { readonly: "", tabindex: "-1" },
            on: {
              change: function($event) {
                var $$selectedVal = Array.prototype.filter
                  .call($event.target.options, function(o) {
                    return o.selected
                  })
                  .map(function(o) {
                    var val = "_value" in o ? o._value : o.value
                    return val
                  })
                _vm.model = $event.target.multiple
                  ? $$selectedVal
                  : $$selectedVal[0]
              }
            }
          },
          "select",
          _vm.attributes,
          false
        )
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSelect_MdSelect = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7e35dfa3", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdSelect/MdSelect.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(244)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSelect_default.a,
  MdSelect_MdSelect,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdSelect/MdSelect.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7e35dfa3", Component.options)
  } else {
    hotAPI.reload("data-v-7e35dfa3", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdSelect_MdSelect = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 244 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdDropDownIcon = __webpack_require__(246);

var _MdDropDownIcon2 = _interopRequireDefault(_MdDropDownIcon);

var _MdMenu = __webpack_require__(44);

var _MdMenu2 = _interopRequireDefault(_MdMenu);

var _MdMenuContent = __webpack_require__(45);

var _MdMenuContent2 = _interopRequireDefault(_MdMenuContent);

var _MdInput = __webpack_require__(14);

var _MdInput2 = _interopRequireDefault(_MdInput);

var _MdFieldMixin = __webpack_require__(15);

var _MdFieldMixin2 = _interopRequireDefault(_MdFieldMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var defaultOffset = {
  x: -15,
  y: -48
};

exports.default = {
  name: 'MdSelect',
  components: {
    MdInput: _MdInput2.default,
    MdMenu: _MdMenu2.default,
    MdMenuContent: _MdMenuContent2.default,
    MdDropDownIcon: _MdDropDownIcon2.default
  },
  mixins: [_MdFieldMixin2.default],
  props: {
    mdDense: Boolean,
    mdClass: String,
    multiple: Boolean,
    id: String,
    name: String
  },
  inject: ['MdField'],
  data: function data() {
    return {
      menuStyles: {},
      offset: {
        x: defaultOffset.x,
        y: 0
      },
      showSelect: true,
      didMount: false,
      MdSelect: {
        items: {},
        label: null,
        multiple: false,
        modelValue: this.localValue,
        setValue: this.setValue,
        setContent: this.setContent,
        setMultipleValue: this.setMultipleValue,
        setMultipleContent: this.setMultipleContent
      }
    };
  },
  provide: function provide() {
    var MdSelect = this.MdSelect;

    return { MdSelect: MdSelect };
  },

  computed: {
    inputListeners: function inputListeners() {
      return _extends({}, this.$listeners, {
        input: undefined
      });
    }
  },
  watch: {
    localValue: {
      immediate: true,
      handler: function handler(val) {
        this.setFieldContent();
        this.MdSelect.modelValue = this.localValue;
        this.emitSelected(val);
      }
    },
    multiple: {
      immediate: true,
      handler: function handler(isMultiple) {
        var _this = this;

        this.MdSelect.multiple = isMultiple;
        this.$nextTick(function () {
          return _this.initialLocalValueByDefault();
        });
      }
    }
  },
  methods: {
    elHasScroll: function elHasScroll(el) {
      return el.scrollHeight > el.offsetHeight;
    },
    scrollToSelectedOption: function scrollToSelectedOption(el, menu) {
      var top = el.offsetTop;
      var elHeight = el.offsetHeight;
      var menuHeight = menu.offsetHeight;

      menu.scrollTop = top - (menuHeight - elHeight) / 2;
    },
    setOffsets: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(target) {
        var menu, selected;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.$isServer) {
                  menu = this.$refs.menu.$refs.container;


                  if (menu) {
                    selected = target || menu.querySelector('.md-selected');


                    if (selected) {
                      this.scrollToSelectedOption(selected, menu);
                      this.offset.y = defaultOffset.y - selected.offsetTop + menu.scrollTop + 8;
                      this.menuStyles = {
                        'transform-origin': '0 ' + Math.abs(this.offset.y) + 'px'
                      };
                    } else {
                      this.offset.y = defaultOffset.y + 1;
                      this.menuStyles = {};
                    }
                  }
                }

              case 1:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setOffsets(_x) {
        return _ref.apply(this, arguments);
      }

      return setOffsets;
    }(),
    onMenuEnter: function onMenuEnter() {
      if (!this.didMount) {
        return;
      }

      this.setOffsets();
      this.MdField.focused = true;
      this.$emit('md-opened');
    },
    applyHighlight: function applyHighlight() {
      this.MdField.focused = false;
      this.MdField.highlighted = true;
      this.$refs.input.$el.focus();
    },
    onClose: function onClose() {
      this.$emit('md-closed');
      if (this.didMount) {
        this.applyHighlight();
      }
    },
    onFocus: function onFocus() {
      if (this.didMount) {
        this.applyHighlight();
      }
    },
    removeHighlight: function removeHighlight() {
      this.MdField.highlighted = false;
    },
    openSelect: function openSelect() {
      if (!this.disabled) {
        this.showSelect = true;
      }
    },
    arrayAccessorRemove: function arrayAccessorRemove(arr, index) {
      var before = arr.slice(0, index);
      var after = arr.slice(index + 1, arr.length);
      return before.concat(after);
    },
    toggleArrayValue: function toggleArrayValue(value) {
      var index = this.localValue.indexOf(value);
      var includes = index > -1;
      if (!includes) {
        this.localValue = this.localValue.concat([value]);
      } else {
        this.localValue = this.arrayAccessorRemove(this.localValue, index);
      }
    },
    setValue: function setValue(newValue) {
      this.model = newValue;
      this.setFieldValue();
      this.showSelect = false;
    },
    setContent: function setContent(newLabel) {
      this.MdSelect.label = newLabel;
    },
    setContentByValue: function setContentByValue() {
      var textContent = this.MdSelect.items[this.localValue];

      if (textContent) {
        this.setContent(textContent);
      } else {
        this.setContent('');
      }
    },
    setMultipleValue: function setMultipleValue(value) {
      var newValue = value;
      this.toggleArrayValue(newValue);
      this.setFieldValue();
    },
    setMultipleContentByValue: function setMultipleContentByValue() {
      var _this2 = this;

      if (!this.localValue) {
        this.initialLocalValueByDefault();
      }
      var content = [];

      this.localValue.forEach(function (item) {
        var textContent = _this2.MdSelect.items[item];

        if (textContent) {
          content.push(textContent);
        }
      });

      this.setContent(content.join(', '));
    },
    setFieldContent: function setFieldContent() {
      if (this.multiple) {
        this.setMultipleContentByValue();
      } else {
        this.setContentByValue();
      }
    },
    initialLocalValueByDefault: function initialLocalValueByDefault() {
      var isArray = Array.isArray(this.localValue);
      if (this.multiple && !isArray) {
        var isSet = this.localValue !== undefined && this.localValue !== null;
        this.localValue = isSet ? [this.localValue] : [];
        return;
      }
      if (!this.multiple && isArray) {
        this.localValue = this.localValue.length > 0 ? this.localValue[0] : null;
      }
    },
    emitSelected: function emitSelected(value) {
      this.$emit('md-selected', value);
    }
  },
  mounted: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              this.showSelect = false;
              this.setFieldContent();

              _context2.next = 4;
              return this.$nextTick();

            case 4:
              this.didMount = true;

            case 5:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function mounted() {
      return _ref2.apply(this, arguments);
    }

    return mounted;
  }()
};

/***/ }),
/* 246 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdDropDownIcon.vue
var MdDropDownIcon = __webpack_require__(247);
var MdDropDownIcon_default = /*#__PURE__*/__webpack_require__.n(MdDropDownIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-44db031d","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdDropDownIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", { attrs: { d: "M7 10l5 5 5-5z" } }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdDropDownIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-44db031d", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdDropDownIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdDropDownIcon_default.a,
  icons_MdDropDownIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdDropDownIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-44db031d", Component.options)
  } else {
    hotAPI.reload("data-v-44db031d", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdDropDownIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdDropDownIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 248 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = {
  name: 'MdMenu',
  props: {
    mdActive: Boolean,
    mdAlignTrigger: Boolean,
    mdOffsetX: Number,
    mdOffsetY: Number,
    mdFullWidth: Boolean,
    mdDense: Boolean,
    mdDirection: _extends({
      type: String,
      default: 'bottom-start'
    }, (0, _MdPropValidator2.default)('md-direction', ['top-end', 'top-start', 'bottom-end', 'bottom-start'])),
    mdCloseOnSelect: {
      type: Boolean,
      default: true
    },
    mdSize: _extends({
      type: String,
      default: 'small'
    }, (0, _MdPropValidator2.default)('md-size', ['auto', 'small', 'medium', 'big', 'huge']))
  },
  data: function data() {
    return {
      triggerEl: null,
      MdMenu: {
        instance: this,
        active: this.mdActive,
        direction: this.mdDirection,
        size: this.mdSize,
        alignTrigger: this.mdAlignTrigger,
        offsetX: this.mdOffsetX,
        offsetY: this.mdOffsetY,
        fullWidth: this.mdFullWidth,
        dense: this.mdDense,
        closeOnSelect: this.mdCloseOnSelect,
        bodyClickObserver: null,
        windowResizeObserver: null,
        $el: this.$el
      }
    };
  },
  provide: function provide() {
    return {
      MdMenu: this.MdMenu
    };
  },

  computed: {
    isActive: function isActive() {
      return this.MdMenu.active;
    }
  },
  watch: {
    mdActive: {
      immediate: true,
      handler: function handler(isActive) {
        this.MdMenu.active = isActive;
      }
    },
    mdDirection: function mdDirection(direction) {
      this.MdMenu.direction = direction;
    },
    mdSize: function mdSize(size) {
      this.MdMenu.size = size;
    },
    mdAlignTrigger: function mdAlignTrigger(aligned) {
      this.MdMenu.alignTrigger = aligned;
    },
    mdOffsetX: function mdOffsetX(offset) {
      this.MdMenu.offsetX = offset;
    },
    mdOffsetY: function mdOffsetY(offset) {
      this.MdMenu.offsetY = offset;
    },
    isActive: function isActive(_isActive) {
      this.$emit('update:mdActive', _isActive);

      if (!_isActive) {
        this.$emit('md-closed');
      } else {
        this.$emit('md-opened');
      }
    }
  },
  methods: {
    toggleContent: function toggleContent($event) {
      this.MdMenu.active = !this.MdMenu.active;
    }
  },
  mounted: function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this.MdMenu.$el = this.$el;
              _context.next = 3;
              return this.$nextTick();

            case 3:

              this.triggerEl = this.$el.querySelector('[md-menu-trigger]');

              if (this.triggerEl) {
                this.triggerEl.addEventListener('click', this.toggleContent);
              }

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function mounted() {
      return _ref.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    if (this.triggerEl) {
      this.triggerEl.removeEventListener('click', this.toggleContent);
    }
  }
};

/***/ }),
/* 250 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdObserveEvent = __webpack_require__(46);

var _MdObserveEvent2 = _interopRequireDefault(_MdObserveEvent);

var _MdResizeObserver = __webpack_require__(252);

var _MdResizeObserver2 = _interopRequireDefault(_MdResizeObserver);

var _MdPopover = __webpack_require__(25);

var _MdPopover2 = _interopRequireDefault(_MdPopover);

var _MdFocusTrap = __webpack_require__(40);

var _MdFocusTrap2 = _interopRequireDefault(_MdFocusTrap);

var _MdList = __webpack_require__(47);

var _MdList2 = _interopRequireDefault(_MdList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdMenuContent',
  components: {
    MdPopover: _MdPopover2.default,
    MdFocusTrap: _MdFocusTrap2.default,
    MdList: _MdList2.default
  },
  props: {
    mdListClass: [String, Boolean],
    mdContentClass: [String, Boolean]
  },
  inject: ['MdMenu'],
  data: function data() {
    return {
      highlightIndex: -1,
      didMount: false,
      highlightItems: [],
      popperSettings: null,
      menuStyles: ''
    };
  },
  computed: {
    filteredAttrs: function filteredAttrs() {
      var attrs = this.$attrs;
      delete attrs.id;
      return attrs;
    },
    highlightedItem: function highlightedItem() {
      return this.highlightItems[this.highlightIndex];
    },
    shouldRender: function shouldRender() {
      return this.MdMenu.active;
    },
    menuClasses: function menuClasses() {
      var _ref;

      var prefix = 'md-menu-content-';

      return _ref = {}, _defineProperty(_ref, prefix + this.MdMenu.direction, true), _defineProperty(_ref, prefix + this.MdMenu.size, true), _defineProperty(_ref, 'md-menu-content', this.didMount), _defineProperty(_ref, 'md-shallow', !this.didMount), _ref;
    },
    listClasses: function listClasses() {
      return _extends({
        'md-dense': this.MdMenu.dense
      }, this.mdListClass);
    }
  },
  watch: {
    shouldRender: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_shouldRender) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!_shouldRender) {
                  _context.next = 7;
                  break;
                }

                this.setPopperSettings();
                _context.next = 4;
                return this.$nextTick();

              case 4:
                this.setInitialHighlightIndex();
                this.createClickEventObserver();
                this.createResizeObserver();

              case 7:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function shouldRender(_x) {
        return _ref2.apply(this, arguments);
      }

      return shouldRender;
    }()
  },
  methods: {
    setPopperSettings: function setPopperSettings() {
      var _MdMenu = this.MdMenu,
          direction = _MdMenu.direction,
          alignTrigger = _MdMenu.alignTrigger;

      var _getOffsets = this.getOffsets(),
          offsetX = _getOffsets.offsetX,
          offsetY = _getOffsets.offsetY;

      if (!this.hasCustomOffsets()) {
        if (this.MdMenu.instance.$el && this.MdMenu.instance.$el.offsetHeight) {
          offsetY = -this.MdMenu.instance.$el.offsetHeight - 11;
        }

        if (direction.includes('start')) {
          offsetX = -8;
        } else if (direction.includes('end')) {
          offsetX = 8;
        }
      }

      this.popperSettings = {
        placement: direction,
        modifiers: {
          keepTogether: {
            enabled: true
          },
          flip: {
            enabled: false
          },
          offset: {
            offset: offsetX + ', ' + offsetY
          }
        }
      };
    },
    setInitialHighlightIndex: function setInitialHighlightIndex() {
      var _this = this;

      this.setHighlightItems();
      this.highlightItems.forEach(function (item, index) {
        if (item.classList.contains('md-selected')) {
          _this.highlightIndex = index - 1;
        }
      });
    },
    setHighlightItems: function setHighlightItems() {
      if (this.$el.querySelectorAll) {
        var items = this.$el.querySelectorAll('.md-list-item-container:not(.md-list-item-default):not([disabled])');

        this.highlightItems = Array.from(items);
      }
    },
    setHighlight: function setHighlight(direction) {
      this.setHighlightItems();

      if (this.highlightItems.length) {
        if (direction === 'down') {
          if (this.highlightIndex === this.highlightItems.length - 1) {
            this.highlightIndex = 0;
          } else {
            this.highlightIndex++;
          }
        } else {
          if (this.highlightIndex === 0) {
            this.highlightIndex = this.highlightItems.length - 1;
          } else {
            this.highlightIndex--;
          }
        }

        this.clearAllHighlights();
        this.setItemHighlight();
      }
    },
    clearAllHighlights: function clearAllHighlights() {
      this.highlightItems.forEach(function (item) {
        item.parentNode.__vue__.highlighted = false;
      });
    },
    setItemHighlight: function setItemHighlight() {
      if (this.highlightedItem) {
        this.highlightedItem.parentNode.__vue__.highlighted = true;
        if (this.$parent.$parent.setOffsets) {
          this.$parent.$parent.setOffsets(this.highlightedItem.parentNode);
        }
      }
    },
    setSelection: function setSelection() {
      if (this.highlightedItem) {
        this.highlightedItem.parentNode.click();
      }
    },
    onEsc: function onEsc() {
      this.MdMenu.active = false;
    },
    getOffsets: function getOffsets() {
      return {
        offsetX: this.MdMenu.offsetX || 0,
        offsetY: this.MdMenu.offsetY || 0
      };
    },
    hasCustomOffsets: function hasCustomOffsets() {
      var _MdMenu2 = this.MdMenu,
          offsetX = _MdMenu2.offsetX,
          offsetY = _MdMenu2.offsetY,
          alignTrigger = _MdMenu2.alignTrigger;


      return Boolean(alignTrigger || offsetY || offsetX);
    },
    createClickEventObserver: function createClickEventObserver() {
      var _this2 = this;

      if (document) {
        this.MdMenu.bodyClickObserver = new _MdObserveEvent2.default(document.body, 'click', function ($event) {
          $event.stopPropagation();
          var isMdMenu = _this2.MdMenu.$el ? _this2.MdMenu.$el.contains($event.target) : false;
          var isMenuContentEl = _this2.$refs.menu ? _this2.$refs.menu.contains($event.target) : false;
          if (!_this2.$el.contains($event.target) && !isMdMenu && !isMenuContentEl) {
            _this2.MdMenu.active = false;
            _this2.MdMenu.bodyClickObserver.destroy();
            _this2.MdMenu.windowResizeObserver.destroy();
          }
        });
      }
    },
    createResizeObserver: function createResizeObserver() {
      this.MdMenu.windowResizeObserver = new _MdResizeObserver2.default(window, this.setStyles);
    },
    setupWatchers: function setupWatchers() {
      this.$watch('MdMenu.direction', this.setPopperSettings);
      this.$watch('MdMenu.alignTrigger', this.setPopperSettings);
      this.$watch('MdMenu.offsetX', this.setPopperSettings);
      this.$watch('MdMenu.offsetY', this.setPopperSettings);
    },
    setStyles: function setStyles() {
      if (this.MdMenu.fullWidth) {
        this.menuStyles = '\n          width: ' + this.MdMenu.instance.$el.offsetWidth + 'px;\n          max-width: ' + this.MdMenu.instance.$el.offsetWidth + 'px\n        ';
      }
    }
  },
  mounted: function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.$nextTick();

            case 2:
              this.setHighlightItems();
              this.setupWatchers();
              this.setStyles();
              this.didMount = true;

            case 6:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function mounted() {
      return _ref3.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    if (this.MdMenu.bodyClickObserver) {
      this.MdMenu.bodyClickObserver.destroy();
    }

    if (this.MdMenu.windowResizeObserver) {
      this.MdMenu.windowResizeObserver.destroy();
    }
  }
});

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdObserveEvent = __webpack_require__(46);

var _MdObserveEvent2 = _interopRequireDefault(_MdObserveEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var el = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var observerFn = arguments[1];

  var observer = (0, _MdObserveEvent2.default)(el, 'resize', function () {
    (0, _raf2.default)(observerFn);
  }, { passive: true });

  return {
    destroy: function destroy() {
      return observer.destroy;
    }
  };
};

/***/ }),
/* 253 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdList'
}); //
//
//
//
//
//

/***/ }),
/* 255 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdSelect/MdOption.vue
var MdOption = __webpack_require__(257);
var MdOption_default = /*#__PURE__*/__webpack_require__.n(MdOption);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-32c8ce9c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdSelect/MdOption.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-menu-item",
    {
      class: _vm.optionClasses,
      attrs: { disabled: _vm.isDisabled },
      on: { click: _vm.setSelection }
    },
    [
      _vm.MdSelect.multiple
        ? _c("md-checkbox", {
            staticClass: "md-primary",
            attrs: { disabled: _vm.isDisabled },
            model: {
              value: _vm.isChecked,
              callback: function($$v) {
                _vm.isChecked = $$v
              },
              expression: "isChecked"
            }
          })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "span",
        { ref: "text", staticClass: "md-list-item-text" },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSelect_MdOption = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-32c8ce9c", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdSelect/MdOption.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(256)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdOption_default.a,
  MdSelect_MdOption,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdSelect/MdOption.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-32c8ce9c", Component.options)
  } else {
    hotAPI.reload("data-v-32c8ce9c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdSelect_MdOption = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 256 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdOption',
  props: {
    value: [String, Number, Boolean],
    disabled: Boolean
  },
  inject: {
    MdSelect: {},
    MdOptgroup: {
      default: {}
    }
  },
  data: function data() {
    return {
      uniqueId: 'md-option-' + (0, _MdUuid2.default)(),
      isSelected: false,
      isChecked: false
    };
  },
  computed: {
    selectValue: function selectValue() {
      return this.MdSelect.modelValue;
    },
    isMultiple: function isMultiple() {
      return this.MdSelect.multiple;
    },
    isDisabled: function isDisabled() {
      return this.MdOptgroup.disabled || this.disabled;
    },
    key: function key() {
      var isSet = this.value || this.value === 0;
      return isSet ? this.value : this.uniqueId;
    },
    inputLabel: function inputLabel() {
      return this.MdSelect.label;
    },
    optionClasses: function optionClasses() {
      return {
        'md-selected': this.isSelected || this.isChecked
      };
    }
  },
  watch: {
    selectValue: function selectValue() {
      this.setIsSelected();
    },
    isChecked: function isChecked(val) {
      if (val === this.isSelected) {
        return;
      }
      this.setSelection();
    },
    isSelected: function isSelected(val) {
      this.isChecked = val;
    }
  },
  methods: {
    getTextContent: function getTextContent() {
      if (this.$el) {
        return this.$el.textContent.trim();
      }

      var slot = this.$slots.default;

      return slot ? slot[0].text.trim() : '';
    },
    setIsSelected: function setIsSelected() {
      if (!this.isMultiple) {
        this.isSelected = this.selectValue === this.value;
        return;
      }
      if (this.selectValue === undefined) {
        this.isSelected = false;
        return;
      }
      this.isSelected = this.selectValue.includes(this.value);
    },
    setSingleSelection: function setSingleSelection() {
      this.MdSelect.setValue(this.value);
    },
    setMultipleSelection: function setMultipleSelection() {
      this.MdSelect.setMultipleValue(this.value);
    },
    setSelection: function setSelection() {
      if (!this.isDisabled) {
        if (this.isMultiple) {
          this.setMultipleSelection();
        } else {
          this.setSingleSelection();
        }
      }
    },
    setItem: function setItem() {
      this.$set(this.MdSelect.items, this.key, this.getTextContent());
    }
  },
  updated: function updated() {
    this.setItem();
  },
  created: function created() {
    this.setItem();
    this.setIsSelected();
  }
}; //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdSelect/MdOptgroup.vue
var MdOptgroup = __webpack_require__(260);
var MdOptgroup_default = /*#__PURE__*/__webpack_require__.n(MdOptgroup);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-60840a93","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdSelect/MdOptgroup.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-optgroup" },
    [
      _c("md-subheader", [_vm._v(_vm._s(_vm.label))]),
      _vm._v(" "),
      _vm._t("default")
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSelect_MdOptgroup = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-60840a93", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdSelect/MdOptgroup.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(259)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdOptgroup_default.a,
  MdSelect_MdOptgroup,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdSelect/MdOptgroup.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-60840a93", Component.options)
  } else {
    hotAPI.reload("data-v-60840a93", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdSelect_MdOptgroup = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 259 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//

exports.default = {
  name: 'MdOptgroup',
  props: {
    label: String,
    disabled: Boolean
  },
  provide: function provide() {
    return {
      MdOptgroup: {
        disabled: this.disabled
      }
    };
  }
};

/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdFile/MdFile.vue
var MdFile = __webpack_require__(263);
var MdFile_default = /*#__PURE__*/__webpack_require__.n(MdFile);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-16fac4a3","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdFile/MdFile.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-file" },
    [
      _c("md-file-icon", {
        nativeOn: {
          click: function($event) {
            _vm.openPicker($event)
          }
        }
      }),
      _vm._v(" "),
      _c(
        "input",
        _vm._b(
          {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.model,
                expression: "model"
              }
            ],
            staticClass: "md-input",
            attrs: { readonly: "" },
            domProps: { value: _vm.model },
            on: {
              focus: _vm.openPicker,
              blur: _vm.onBlur,
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.model = $event.target.value
              }
            }
          },
          "input",
          {
            disabled: _vm.disabled,
            required: _vm.required,
            placeholder: _vm.placeholder
          },
          false
        )
      ),
      _vm._v(" "),
      _c(
        "input",
        _vm._g(
          _vm._b(
            {
              ref: "inputFile",
              attrs: { type: "file" },
              on: { change: _vm.onChange }
            },
            "input",
            _vm.attributes,
            false
          ),
          _vm.$listeners
        )
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdFile_MdFile = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-16fac4a3", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdFile/MdFile.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(262)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdFile_default.a,
  MdFile_MdFile,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdFile/MdFile.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-16fac4a3", Component.options)
  } else {
    hotAPI.reload("data-v-16fac4a3", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdFile_MdFile = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 262 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdFileIcon = __webpack_require__(264);

var _MdFileIcon2 = _interopRequireDefault(_MdFileIcon);

var _MdFieldMixin = __webpack_require__(15);

var _MdFieldMixin2 = _interopRequireDefault(_MdFieldMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdFile',
  components: {
    MdFileIcon: _MdFileIcon2.default
  },
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-file-' + (0, _MdUuid2.default)();
      }
    },
    name: String
  },
  mixins: [_MdFieldMixin2.default],
  inject: ['MdField'],
  methods: {
    getMultipleName: function getMultipleName(files) {
      var names = [];

      [].concat(_toConsumableArray(files)).forEach(function (_ref) {
        var name = _ref.name;
        return names.push(name);
      });

      return names.join(', ');
    },
    getFileName: function getFileName(files, target) {
      if (!files) {
        return target.value.split('\\').pop();
      }

      if (files.length > 1) {
        return this.getMultipleName(files);
      }

      if (files.length === 1) {
        return files[0].name;
      }

      return null;
    },
    openPicker: function openPicker() {
      this.onFocus();
      this.$refs.inputFile.click();
    },
    onChange: function onChange($event) {
      this.onFileSelected($event);
    },
    onFileSelected: function onFileSelected(_ref2) {
      var target = _ref2.target,
          dataTransfer = _ref2.dataTransfer;

      var files = target.files || dataTransfer.files;

      this.model = this.getFileName(files, target);
      this.$emit('md-change', files || target.value);
    }
  },
  created: function created() {
    this.MdField.file = true;
  },
  beforeDestroy: function beforeDestroy() {
    this.MdField.file = false;
  }
};

/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdFileIcon.vue
var MdFileIcon = __webpack_require__(265);
var MdFileIcon_default = /*#__PURE__*/__webpack_require__.n(MdFileIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-3bd0ca30","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdFileIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: {
              d:
                "M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6H10v9.5c0 1.38 1.12 2.5 2.5 2.5s2.5-1.12 2.5-2.5V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6h-1.5z"
            }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdFileIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3bd0ca30", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdFileIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdFileIcon_default.a,
  icons_MdFileIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdFileIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3bd0ca30", Component.options)
  } else {
    hotAPI.reload("data-v-3bd0ca30", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdFileIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdFileIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 266 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdField/MdTextarea/MdTextarea.vue
var MdTextarea = __webpack_require__(267);
var MdTextarea_default = /*#__PURE__*/__webpack_require__.n(MdTextarea);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-445d103a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdField/MdTextarea/MdTextarea.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "textarea",
    _vm._g(
      _vm._b(
        {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.model,
              expression: "model"
            }
          ],
          staticClass: "md-textarea",
          style: _vm.textareaStyles,
          domProps: { value: _vm.model },
          on: {
            focus: _vm.onFocus,
            blur: _vm.onBlur,
            input: function($event) {
              if ($event.target.composing) {
                return
              }
              _vm.model = $event.target.value
            }
          }
        },
        "textarea",
        _vm.attributes,
        false
      ),
      _vm.listeners
    )
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTextarea_MdTextarea = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-445d103a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdField/MdTextarea/MdTextarea.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTextarea_default.a,
  MdTextarea_MdTextarea,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdField/MdTextarea/MdTextarea.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-445d103a", Component.options)
  } else {
    hotAPI.reload("data-v-445d103a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdField_MdTextarea_MdTextarea = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdFieldMixin = __webpack_require__(15);

var _MdFieldMixin2 = _interopRequireDefault(_MdFieldMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function calculateContentHeight(el, lineHeight) {
  var origHeight = el.style.height;
  var height = el.offsetHeight;
  var scrollHeight = el.scrollHeight;

  el.style.overflow = 'hidden';

  if (height >= scrollHeight) {
    el.style.height = height + lineHeight + 'px';

    if (scrollHeight < el.scrollHeight) {
      el.style.height = origHeight;

      return height;
    }
  }

  return scrollHeight;
}

exports.default = new _MdComponent2.default({
  name: 'MdTextarea',
  mixins: [_MdFieldMixin2.default],
  inject: ['MdField'],
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-textarea-' + (0, _MdUuid2.default)();
      }
    },
    mdAutogrow: Boolean
  },
  computed: {
    listeners: function listeners() {
      return _extends({}, this.$listeners, {
        input: this.onInput
      });
    },
    textareaStyles: function textareaStyles() {
      return {
        height: this.textareaHeight
      };
    }
  },
  methods: {
    getTextAreaLineSize: function getTextAreaLineSize() {
      var style = window.getComputedStyle(this.$el);

      return parseInt(style.lineHeight, 10);
    },
    setTextAreaSize: function setTextAreaSize(height) {
      var newHeight = height;

      if (!height) {
        var size = this.getTextAreaLineSize();

        newHeight = calculateContentHeight(this.$el, size);
      }

      this.textareaHeight = newHeight + 'px';
    },
    applyStyles: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.mdAutogrow) {
                  _context.next = 6;
                  break;
                }

                this.setTextAreaSize(32);
                _context.next = 4;
                return this.$nextTick();

              case 4:
                this.setTextAreaSize();
                window.setTimeout(function () {
                  _this.$el.style.overflow = 'auto';
                }, 10);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function applyStyles() {
        return _ref.apply(this, arguments);
      }

      return applyStyles;
    }(),
    setTextarea: function setTextarea() {
      this.MdField.textarea = true;
    },
    setAutogrow: function setAutogrow() {
      this.MdField.autogrow = this.mdAutogrow;
    },
    onInput: function onInput() {
      this.setFieldValue();
      this.applyStyles();
    }
  },
  created: function created() {
    this.setTextarea();
    this.setAutogrow();
  },
  mounted: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.$nextTick();

            case 2:
              this.applyStyles();

            case 3:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function mounted() {
      return _ref2.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    this.setTextarea(false);
  }
});

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdHighlightText = __webpack_require__(269);

var _MdHighlightText2 = _interopRequireDefault(_MdHighlightText);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdHighlightText2.default.name, _MdHighlightText2.default);
};

/***/ }),
/* 269 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdHighlightText_vue__ = __webpack_require__(271);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdHighlightText_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdHighlightText_vue__);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(270)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdHighlightText_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdHighlightText/MdHighlightText.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-41eb36a5", Component.options)
  } else {
    hotAPI.reload("data-v-41eb36a5", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 270 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(7);

var _vue2 = _interopRequireDefault(_vue);

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getHTMLOutput(str) {
  var text = str;

  if (!text) {
    text = '$&';
  }

  return '<span class="md-highlight-text-match">' + text + '</span>';
}

function fuzzyHighlight(text, term) {
  if (term.length === 0) {
    return text;
  }

  var offset = text.toLowerCase().indexOf(term[0].toLowerCase());

  if (offset === -1) {
    return '';
  }

  var last = 0;
  for (var i = 1; i < term.length; i++) {
    if (text[offset + i] !== term[i]) {
      break;
    }

    last = i;
  }

  var before = text.slice(0, offset);
  var match = getHTMLOutput(text.slice(offset, offset + last + 1));
  var after = fuzzyHighlight(text.slice(offset + last + 1), term.slice(last + 1));

  return before + match + after;
}

function normalHighlight(text, term) {
  var matches = new RegExp(term + '(?!([^<]+)?<)', 'gi');

  return text.replace(matches, getHTMLOutput());
}

function generateHighlight(_ref, term, isFuzzy) {
  var text = _ref.text;

  if (text && term && term[0]) {
    if (isFuzzy) {
      return fuzzyHighlight(text, term) || text;
    }

    return normalHighlight(text, term);
  }

  return text;
}

exports.default = new _MdComponent2.default({
  name: 'MdHighlightText',
  abstract: true,
  props: {
    mdTerm: String,
    mdFuzzySearch: {
      type: Boolean,
      default: true
    }
  },
  render: function render(createElement) {
    try {
      var defaultSlot = this.$slots.default;

      if (!defaultSlot) {
        return null;
      }

      if (defaultSlot.length > 1 || defaultSlot[0].tag) {
        throw new Error();
      }

      var HTMLContent = generateHighlight(defaultSlot[0], this.mdTerm, this.mdFuzzySearch);

      return createElement('div', {
        staticClass: 'md-highlight-text',
        class: this.$mdActiveTheme,
        domProps: {
          innerHTML: HTMLContent
        }
      });
    } catch (e) {
      _vue2.default.util.warn('MdHighlightText can only render text nodes.', this);
    }

    return null;
  }
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdImage = __webpack_require__(273);

var _MdImage2 = _interopRequireDefault(_MdImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdImage2.default.name, _MdImage2.default);
};

/***/ }),
/* 273 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdImage/MdImage.vue
var MdImage = __webpack_require__(275);
var MdImage_default = /*#__PURE__*/__webpack_require__.n(MdImage);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4511ea59","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdImage/MdImage.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-image", class: [_vm.$mdActiveTheme] },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdImage_MdImage = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4511ea59", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdImage/MdImage.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(274)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdImage_default.a,
  MdImage_MdImage,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdImage/MdImage.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4511ea59", Component.options)
  } else {
    hotAPI.reload("data-v-4511ea59", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdImage_MdImage = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 274 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdImage',
  props: {
    mdSrc: String
  }
});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(277);

exports.default = function (Vue) {};

/***/ }),
/* 277 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdList = __webpack_require__(47);

var _MdList2 = _interopRequireDefault(_MdList);

var _MdListItem = __webpack_require__(48);

var _MdListItem2 = _interopRequireDefault(_MdListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdList2.default.name, _MdList2.default);
  Vue.component(_MdListItem2.default.name, _MdListItem2.default);
};

/***/ }),
/* 279 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdInteractionEvents = __webpack_require__(49);

var _MdInteractionEvents2 = _interopRequireDefault(_MdInteractionEvents);

var _MdRouterLinkProps = __webpack_require__(12);

var _MdRouterLinkProps2 = _interopRequireDefault(_MdRouterLinkProps);

var _MdListItemDefault = __webpack_require__(281);

var _MdListItemDefault2 = _interopRequireDefault(_MdListItemDefault);

var _MdListItemButton = __webpack_require__(285);

var _MdListItemButton2 = _interopRequireDefault(_MdListItemButton);

var _MdListItemLink = __webpack_require__(287);

var _MdListItemLink2 = _interopRequireDefault(_MdListItemLink);

var _MdListItemRouter = __webpack_require__(289);

var _MdListItemRouter2 = _interopRequireDefault(_MdListItemRouter);

var _MdListItemExpand = __webpack_require__(291);

var _MdListItemExpand2 = _interopRequireDefault(_MdListItemExpand);

var _MdButton = __webpack_require__(13);

var _MdButton2 = _interopRequireDefault(_MdButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hasExpansion(props) {
  return props.hasOwnProperty('mdExpand') && props.mdExpand !== false;
}

function resolveScopedSlot(props, children) {
  if (hasExpansion(props)) {
    return {
      'md-expand': function mdExpand() {
        return children['md-expand'][0];
      }
    };
  }
}

exports.default = {
  name: 'MdListItem',
  functional: true,
  components: {
    MdButton: _MdButton2.default
  },
  render: function render(createElement, _ref) {
    var parent = _ref.parent,
        props = _ref.props,
        listeners = _ref.listeners,
        data = _ref.data,
        slots = _ref.slots;

    var children = slots();
    var listComponent = _MdListItemDefault2.default;
    var staticClass = 'md-list-item';

    if (hasExpansion(props)) {
      listComponent = _MdListItemExpand2.default;
    } else if (parent && parent.$router && props.to) {
      listComponent = _MdListItemRouter2.default;
      listComponent.props = (0, _MdRouterLinkProps2.default)(parent, {
        target: String
      });
      delete listComponent.props.href;
    } else if (props.href) {
      listComponent = _MdListItemLink2.default;
    } else {
      var listenerNames = Object.keys(listeners);

      listenerNames.forEach(function (listener) {
        if (_MdInteractionEvents2.default.includes(listener)) {
          listComponent = _MdListItemButton2.default;
        }
      });
    }

    if (data.staticClass) {
      staticClass += ' ' + data.staticClass;
    }

    return createElement('li', _extends({}, data, {
      staticClass: staticClass,
      on: listeners
    }), [createElement(listComponent, {
      props: props,
      scopedSlots: resolveScopedSlot(props, children),
      staticClass: 'md-list-item-container md-button-clean',
      on: listeners
    }, children.default)]);
  }
};

/***/ }),
/* 281 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemDefault.vue
var MdListItemDefault = __webpack_require__(282);
var MdListItemDefault_default = /*#__PURE__*/__webpack_require__.n(MdListItemDefault);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-b4eac868","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemDefault.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-list-item-default", on: { click: _vm.toggleControl } },
    [
      _c(
        "md-list-item-content",
        { attrs: { "md-disabled": "" } },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemDefault = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-b4eac868", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemDefault.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemDefault_default.a,
  MdListItem_MdListItemDefault,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemDefault.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b4eac868", Component.options)
  } else {
    hotAPI.reload("data-v-b4eac868", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemDefault = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdListItemMixin = __webpack_require__(11);

var _MdListItemMixin2 = _interopRequireDefault(_MdListItemMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdListItemDefault',
  mixins: [_MdListItemMixin2.default],
  methods: {
    toggleControl: function toggleControl() {
      var control = this.$el.querySelector('.md-checkbox-container, .md-switch-container, .md-radio-container');

      if (control) {
        control.click();
      }
    }
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 283 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemContent.vue
var MdListItemContent = __webpack_require__(284);
var MdListItemContent_default = /*#__PURE__*/__webpack_require__.n(MdListItemContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-af37c3f8","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-ripple",
    {
      staticClass: "md-list-item-content",
      attrs: { "md-disabled": _vm.mdDisabled }
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-af37c3f8", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemContent.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemContent_default.a,
  MdListItem_MdListItemContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-af37c3f8", Component.options)
  } else {
    hotAPI.reload("data-v-af37c3f8", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdListItemContent',
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    mdDisabled: Boolean
  }
}; //
//
//
//
//
//

/***/ }),
/* 285 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemButton.vue
var MdListItemButton = __webpack_require__(286);
var MdListItemButton_default = /*#__PURE__*/__webpack_require__.n(MdListItemButton);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4d27ca12","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemButton.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "button",
    {
      staticClass: "md-list-item-button",
      attrs: { type: "button", disabled: _vm.disabled }
    },
    [
      _c(
        "md-list-item-content",
        { attrs: { "md-disabled": _vm.isDisabled } },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemButton = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4d27ca12", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemButton.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemButton_default.a,
  MdListItem_MdListItemButton,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemButton.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4d27ca12", Component.options)
  } else {
    hotAPI.reload("data-v-4d27ca12", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemButton = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdListItemMixin = __webpack_require__(11);

var _MdListItemMixin2 = _interopRequireDefault(_MdListItemMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdListItemButton',
  mixins: [_MdListItemMixin2.default]
}; //
//
//
//
//
//
//
//

/***/ }),
/* 287 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemLink.vue
var MdListItemLink = __webpack_require__(288);
var MdListItemLink_default = /*#__PURE__*/__webpack_require__.n(MdListItemLink);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-49acb202","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemLink.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "a",
    _vm._b({ staticClass: "md-list-item-link" }, "a", _vm.$props, false),
    [
      _c(
        "md-list-item-content",
        { attrs: { "md-disabled": _vm.isDisabled } },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemLink = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-49acb202", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemLink.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemLink_default.a,
  MdListItem_MdListItemLink,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemLink.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-49acb202", Component.options)
  } else {
    hotAPI.reload("data-v-49acb202", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemLink = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdListItemMixin = __webpack_require__(11);

var _MdListItemMixin2 = _interopRequireDefault(_MdListItemMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdListItemLink',
  mixins: [_MdListItemMixin2.default],
  props: {
    download: String,
    href: String,
    hreflang: String,
    ping: String,
    rel: String,
    target: String,
    type: String
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemRouter.vue
var MdListItemRouter = __webpack_require__(290);
var MdListItemRouter_default = /*#__PURE__*/__webpack_require__.n(MdListItemRouter);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-091cb0e4","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemRouter.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "router-link",
    _vm._b(
      { staticClass: "md-list-item-router" },
      "router-link",
      _vm.routerProps,
      false
    ),
    [
      _c(
        "md-list-item-content",
        { attrs: { "md-disabled": _vm.isDisabled } },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemRouter = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-091cb0e4", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemRouter.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemRouter_default.a,
  MdListItem_MdListItemRouter,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemRouter.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-091cb0e4", Component.options)
  } else {
    hotAPI.reload("data-v-091cb0e4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemRouter = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdListItemMixin = __webpack_require__(11);

var _MdListItemMixin2 = _interopRequireDefault(_MdListItemMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdListItemRouter',
  mixins: [_MdListItemMixin2.default],
  computed: {
    routerProps: function routerProps() {
      return this.$props;
    }
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 291 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemExpand.vue
var MdListItemExpand = __webpack_require__(293);
var MdListItemExpand_default = /*#__PURE__*/__webpack_require__.n(MdListItemExpand);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-378e4342","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdList/MdListItem/MdListItemExpand.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-list-item-expand", class: _vm.expandClasses },
    [
      _c(
        "md-list-item-content",
        {
          attrs: { "md-disabled": _vm.isDisabled },
          nativeOn: {
            click: function($event) {
              _vm.toggleExpand($event)
            }
          }
        },
        [
          _vm._t("default"),
          _vm._v(" "),
          _c("md-arrow-down-icon", { staticClass: "md-list-expand-icon" })
        ],
        2
      ),
      _vm._v(" "),
      _c(
        "div",
        {
          ref: "listExpand",
          staticClass: "md-list-expand",
          style: _vm.expandStyles
        },
        [_vm._t("md-expand")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdListItem_MdListItemExpand = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-378e4342", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdList/MdListItem/MdListItemExpand.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(292)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdListItemExpand_default.a,
  MdListItem_MdListItemExpand,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdList/MdListItem/MdListItemExpand.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-378e4342", Component.options)
  } else {
    hotAPI.reload("data-v-378e4342", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdList_MdListItem_MdListItemExpand = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 292 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdArrowDownIcon = __webpack_require__(294);

var _MdArrowDownIcon2 = _interopRequireDefault(_MdArrowDownIcon);

var _MdListItemMixin = __webpack_require__(11);

var _MdListItemMixin2 = _interopRequireDefault(_MdListItemMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdListItemExpand',
  components: {
    MdArrowDownIcon: _MdArrowDownIcon2.default
  },
  mixins: [_MdListItemMixin2.default],
  data: function data() {
    return {
      expandStyles: {},
      showContent: false
    };
  },
  props: {
    mdExpanded: Boolean
  },
  computed: {
    expandClasses: function expandClasses() {
      return {
        'md-active': this.showContent
      };
    }
  },
  methods: {
    getChildrenSize: function getChildrenSize() {
      var expandEl = this.$refs.listExpand;
      var size = 0;

      Array.from(expandEl.children).forEach(function (child) {
        size += child.offsetHeight;
      });

      return size;
    },
    fetchStyle: function fetchStyle() {
      var _this = this;

      return new Promise(function (resolve) {
        (0, _raf2.default)(function () {
          var fullHeight = 0;

          if (!_this.showContent) {
            fullHeight = 'auto'; // this.getChildrenSize() + 'px'
          }

          _this.expandStyles = { height: fullHeight };
          resolve();
        });
      });
    },
    toggleExpand: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.fetchStyle();

              case 2:
                this.showContent = !this.showContent;

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function toggleExpand() {
        return _ref.apply(this, arguments);
      }

      return toggleExpand;
    }(),
    open: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.showContent) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', false);

              case 2:
                _context2.next = 4;
                return this.fetchStyle();

              case 4:
                this.showContent = true;

              case 5:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function open() {
        return _ref2.apply(this, arguments);
      }

      return open;
    }(),
    close: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this.showContent) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt('return', false);

              case 2:
                _context3.next = 4;
                return this.fetchStyle();

              case 4:
                this.showContent = false;

              case 5:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function close() {
        return _ref3.apply(this, arguments);
      }

      return close;
    }()
  },
  watch: {
    mdExpanded: function mdExpanded() {
      if (this.mdExpanded) {
        this.open();
      } else {
        this.close();
      }
    },
    showContent: function showContent() {
      this.$emit('update:mdExpanded', this.showContent);
    }
  },
  mounted: function mounted() {
    if (this.mdExpanded) {
      this.open();
    }
  }
};

/***/ }),
/* 294 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdArrowDownIcon.vue
var MdArrowDownIcon = __webpack_require__(295);
var MdArrowDownIcon_default = /*#__PURE__*/__webpack_require__.n(MdArrowDownIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-2443de21","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdArrowDownIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: { d: "M7.41 7.84L12 12.42l4.59-4.58L18 9.25l-6 6-6-6z" }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0-.75h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdArrowDownIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2443de21", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdArrowDownIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdArrowDownIcon_default.a,
  icons_MdArrowDownIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdArrowDownIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2443de21", Component.options)
  } else {
    hotAPI.reload("data-v-2443de21", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdArrowDownIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdArrowDownIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdMenu = __webpack_require__(44);

var _MdMenu2 = _interopRequireDefault(_MdMenu);

var _MdMenuContent = __webpack_require__(45);

var _MdMenuContent2 = _interopRequireDefault(_MdMenuContent);

var _MdMenuItem = __webpack_require__(297);

var _MdMenuItem2 = _interopRequireDefault(_MdMenuItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdMenu2.default.name, _MdMenu2.default);
  Vue.component(_MdMenuContent2.default.name, _MdMenuContent2.default);
  Vue.component(_MdMenuItem2.default.name, _MdMenuItem2.default);
};

/***/ }),
/* 297 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdMenu/MdMenuItem.vue
var MdMenuItem = __webpack_require__(298);
var MdMenuItem_default = /*#__PURE__*/__webpack_require__.n(MdMenuItem);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-26762702","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdMenu/MdMenuItem.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-list-item",
    _vm._g(
      _vm._b(
        {
          staticClass: "md-menu-item",
          class: [_vm.itemClasses, _vm.$mdActiveTheme],
          attrs: { disabled: _vm.disabled, tabindex: _vm.highlighted && -1 }
        },
        "md-list-item",
        _vm.$attrs,
        false
      ),
      _vm.listeners
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdMenu_MdMenuItem = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-26762702", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdMenu/MdMenuItem.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdMenuItem_default.a,
  MdMenu_MdMenuItem,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdMenu/MdMenuItem.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-26762702", Component.options)
  } else {
    hotAPI.reload("data-v-26762702", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdMenu_MdMenuItem = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdInteractionEvents = __webpack_require__(49);

var _MdInteractionEvents2 = _interopRequireDefault(_MdInteractionEvents);

var _MdListItem = __webpack_require__(48);

var _MdListItem2 = _interopRequireDefault(_MdListItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdMenuItem',
  props: {
    disabled: Boolean
  },
  inject: ['MdMenu'],
  data: function data() {
    return {
      listeners: {},
      highlighted: false
    };
  },
  computed: {
    itemClasses: function itemClasses() {
      return {
        'md-highlight': this.highlighted
      };
    }
  },
  created: function created() {
    var _this = this;

    if (this.MdMenu.closeOnSelect) {
      var listenerNames = Object.keys(this.$listeners);
      var hasInteraction = false;

      listenerNames.forEach(function (listener) {
        if (_MdInteractionEvents2.default.includes(listener)) {
          _this.listeners[listener] = function ($event) {
            if (!_this.disabled) {
              _this.$listeners[listener]($event);
              _this.MdMenu.active = false;

              if (_this.MdMenu.eventObserver) {
                _this.MdMenu.eventObserver.destroy();
              }
            }
          };
        } else {
          _this.listeners[listener] = _this.$listeners[listener];
        }
      });
    } else {
      this.listeners = this.$listeners;
    }
  }
}); //
//
//
//
//
//

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdProgressBar = __webpack_require__(300);

var _MdProgressBar2 = _interopRequireDefault(_MdProgressBar);

var _MdProgressSpinner = __webpack_require__(303);

var _MdProgressSpinner2 = _interopRequireDefault(_MdProgressSpinner);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdProgressBar2.default.name, _MdProgressBar2.default);
  Vue.component(_MdProgressSpinner2.default.name, _MdProgressSpinner2.default);
};

/***/ }),
/* 300 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdProgress/MdProgressBar/MdProgressBar.vue
var MdProgressBar = __webpack_require__(302);
var MdProgressBar_default = /*#__PURE__*/__webpack_require__.n(MdProgressBar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-ec82e758","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdProgress/MdProgressBar/MdProgressBar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("transition", { attrs: { name: "md-progress-bar", appear: "" } }, [
    _c(
      "div",
      {
        staticClass: "md-progress-bar",
        class: [_vm.progressClasses, _vm.$mdActiveTheme]
      },
      [
        _c("div", {
          staticClass: "md-progress-bar-track",
          style: _vm.progressTrackStyle
        }),
        _vm._v(" "),
        _c("div", {
          staticClass: "md-progress-bar-fill",
          style: _vm.progressValueStyle
        }),
        _vm._v(" "),
        _c("div", {
          staticClass: "md-progress-bar-buffer",
          attrs: { Style: _vm.progressBufferStyle }
        })
      ]
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdProgressBar_MdProgressBar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-ec82e758", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdProgress/MdProgressBar/MdProgressBar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(301)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdProgressBar_default.a,
  MdProgressBar_MdProgressBar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdProgress/MdProgressBar/MdProgressBar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ec82e758", Component.options)
  } else {
    hotAPI.reload("data-v-ec82e758", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdProgress_MdProgressBar_MdProgressBar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 301 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdProgressBar',
  props: {
    mdValue: {
      type: Number,
      default: 0
    },
    mdBuffer: {
      type: Number,
      default: 0
    },
    mdMode: _extends({
      type: String,
      default: 'determinate'
    }, (0, _MdPropValidator2.default)('md-mode', ['determinate', 'indeterminate', 'query', 'buffer']))
  },
  computed: {
    isDeterminate: function isDeterminate() {
      return this.mdMode === 'determinate';
    },
    isBuffer: function isBuffer() {
      return this.mdMode === 'buffer';
    },
    hasAmountFill: function hasAmountFill() {
      return this.isBuffer || this.isDeterminate;
    },
    progressClasses: function progressClasses() {
      return 'md-' + this.mdMode;
    },
    progressValueStyle: function progressValueStyle() {
      if (this.hasAmountFill) {
        return 'width: ' + this.mdValue + '%';
      }
    },
    progressTrackStyle: function progressTrackStyle() {
      if (this.hasAmountFill) {
        return 'width: ' + this.mdBuffer + '%';
      }
    },
    progressBufferStyle: function progressBufferStyle() {
      if (this.hasAmountFill) {
        return 'left: calc(' + this.mdBuffer + '% + 8px)';
      }
    }
  }
});

/***/ }),
/* 303 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdProgress/MdProgressSpinner/MdProgressSpinner.vue
var MdProgressSpinner = __webpack_require__(305);
var MdProgressSpinner_default = /*#__PURE__*/__webpack_require__.n(MdProgressSpinner);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-0abf13e0","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdProgress/MdProgressSpinner/MdProgressSpinner.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "transition",
    { attrs: { name: "md-progress-spinner", appear: "" } },
    [
      _c(
        "div",
        {
          staticClass: "md-progress-spinner",
          class: [_vm.progressClasses, _vm.$mdActiveTheme]
        },
        [
          _c(
            "svg",
            {
              staticClass: "md-progress-spinner-draw",
              style: _vm.svgStyles,
              attrs: {
                preserveAspectRatio: "xMidYMid meet",
                focusable: "false",
                viewBox: "0 0 " + _vm.mdDiameter + " " + _vm.mdDiameter
              }
            },
            [
              _c("circle", {
                staticClass: "md-progress-spinner-circle",
                style: _vm.circleStyles,
                attrs: { cx: "50%", cy: "50%", r: _vm.circleRadius }
              })
            ]
          )
        ]
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdProgressSpinner_MdProgressSpinner = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-0abf13e0", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdProgress/MdProgressSpinner/MdProgressSpinner.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(304)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdProgressSpinner_default.a,
  MdProgressSpinner_MdProgressSpinner,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdProgress/MdProgressSpinner/MdProgressSpinner.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0abf13e0", Component.options)
  } else {
    hotAPI.reload("data-v-0abf13e0", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var MdProgress_MdProgressSpinner_MdProgressSpinner = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 304 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdProgressSpinnerAnimation = __webpack_require__(306);

var _MdProgressSpinnerAnimation2 = _interopRequireDefault(_MdProgressSpinnerAnimation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MdProgressSpinner = {
  styleTag: null,
  diameters: new Set()
};

exports.default = new _MdComponent2.default({
  name: 'MdProgressSpinner',
  props: {
    mdValue: {
      type: Number,
      default: 0
    },
    mdDiameter: {
      type: Number,
      default: 60
    },
    mdStroke: {
      type: Number,
      default: 6
    },
    mdMode: _extends({
      type: String,
      default: 'determinate'
    }, (0, _MdPropValidator2.default)('md-mode', ['determinate', 'indeterminate']))
  },
  computed: {
    isDeterminate: function isDeterminate() {
      return this.mdMode === 'determinate';
    },
    isIndeterminate: function isIndeterminate() {
      return this.mdMode === 'indeterminate';
    },
    isIE: function isIE() {
      if (!this.$isServer) {
        return navigator.userAgent.toLowerCase().includes('trident');
      }
      return false;
    },
    progressClasses: function progressClasses() {
      var _ref;

      var animationClass = 'md-progress-spinner-indeterminate';

      if (this.isIE) {
        animationClass += '-fallback';
      }

      return _ref = {}, _defineProperty(_ref, animationClass, true), _defineProperty(_ref, 'md-' + this.mdMode, true), _ref;
    },
    svgStyles: function svgStyles() {
      var size = this.mdDiameter + 'px';

      return {
        width: size,
        height: size
      };
    },
    circleStyles: function circleStyles() {
      return {
        'stroke-dashoffset': this.circleStrokeDashOffset,
        'stroke-dasharray': this.circleStrokeDashArray,
        'stroke-width': this.circleStrokeWidth,
        'animation-name': 'md-progress-spinner-stroke-rotate-' + this.mdDiameter
      };
    },
    circleRadius: function circleRadius() {
      return (this.mdDiameter - this.mdStroke) / 2;
    },
    circleStrokeWidth: function circleStrokeWidth() {
      return this.mdStroke + 'px';
    },
    circleCircumference: function circleCircumference() {
      return 2 * Math.PI * this.circleRadius;
    },
    circleStrokeDashArray: function circleStrokeDashArray() {
      return this.circleCircumference + 'px';
    },
    circleStrokeDashOffset: function circleStrokeDashOffset() {
      if (this.isDeterminate) {
        return this.circleCircumference * (100 - this.mdValue) / 100 + 'px';
      }

      if (this.isIndeterminate && this.isIE) {
        return this.circleCircumference * 0.2 + 'px';
      }

      return null;
    }
  },
  watch: {
    mdDiameter: function mdDiameter() {
      this.attachStyleTag();
    }
  },
  methods: {
    getAnimationCSS: function getAnimationCSS() {
      return _MdProgressSpinnerAnimation2.default.replace(/START_VALUE/g, '' + 0.95 * this.circleCircumference).replace(/END_VALUE/g, '' + 0.2 * this.circleCircumference).replace(/DIAMETER/g, '' + this.mdDiameter);
    },
    attachStyleTag: function attachStyleTag() {
      var styleTag = MdProgressSpinner.styleTag;

      if (!styleTag) {
        styleTag = document.getElementById('md-progress-spinner-styles');
      }

      if (!styleTag) {
        styleTag = document.createElement('style');

        styleTag.id = 'md-progress-spinner-styles';
        document.head.appendChild(styleTag);
        MdProgressSpinner.styleTag = styleTag;
      }

      if (styleTag && styleTag.sheet) {
        styleTag.sheet.insertRule(this.getAnimationCSS(), 0);
      }

      MdProgressSpinner.diameters.add(this.mdDiameter);
    }
  },
  mounted: function mounted() {
    this.attachStyleTag();
  }
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = "\n  @keyframes md-progress-spinner-stroke-rotate-DIAMETER {\n    0% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotate(0);\n    }\n\n    12.5% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotate(0);\n    }\n\n    12.51% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotateX(180deg) rotate(72.5deg);\n    }\n\n    25% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotateX(180deg) rotate(72.5deg);\n    }\n\n    25.1% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotate(270deg);\n    }\n\n    37.5% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotate(270deg);\n    }\n\n    37.51% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotateX(180deg) rotate(161.5deg);\n    }\n\n    50% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotateX(180deg) rotate(161.5deg);\n    }\n\n    50.01% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotate(180deg);\n    }\n\n    62.5% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotate(180deg);\n    }\n\n    62.51% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotateX(180deg) rotate(251.5deg);\n    }\n\n    75% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotateX(180deg) rotate(251.5deg);\n    }\n\n    75.01% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotate(90deg);\n    }\n\n    87.5% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotate(90deg);\n    }\n\n    87.51% {\n      stroke-dashoffset: END_VALUE;\n      transform: rotateX(180deg) rotate(341.5deg);\n    }\n\n    100% {\n      stroke-dashoffset: START_VALUE;\n      transform: rotateX(180deg) rotate(341.5deg);\n    }\n  }\n";

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdRadio = __webpack_require__(308);

var _MdRadio2 = _interopRequireDefault(_MdRadio);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdRadio2.default.name, _MdRadio2.default);
};

/***/ }),
/* 308 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdRadio/MdRadio.vue
var MdRadio = __webpack_require__(310);
var MdRadio_default = /*#__PURE__*/__webpack_require__.n(MdRadio);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-b5b900ce","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdRadio/MdRadio.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-radio", class: [_vm.$mdActiveTheme, _vm.radioClasses] },
    [
      _c(
        "div",
        {
          staticClass: "md-radio-container",
          on: {
            click: function($event) {
              $event.stopPropagation()
              _vm.toggleCheck($event)
            }
          }
        },
        [
          _c(
            "md-ripple",
            {
              attrs: {
                "md-centered": "",
                "md-active": _vm.rippleActive,
                "md-disabled": _vm.disabled
              },
              on: {
                "update:mdActive": function($event) {
                  _vm.rippleActive = $event
                }
              }
            },
            [
              _c(
                "input",
                _vm._b(
                  { attrs: { type: "radio" } },
                  "input",
                  {
                    id: _vm.id,
                    name: _vm.name,
                    disabled: _vm.disabled,
                    required: _vm.required,
                    value: _vm.value
                  },
                  false
                )
              )
            ]
          )
        ],
        1
      ),
      _vm._v(" "),
      _vm.$slots.default
        ? _c(
            "label",
            {
              staticClass: "md-radio-label",
              attrs: { for: _vm.id },
              on: {
                click: function($event) {
                  $event.preventDefault()
                  _vm.toggleCheck($event)
                }
              }
            },
            [_vm._t("default")],
            2
          )
        : _vm._e()
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdRadio_MdRadio = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-b5b900ce", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdRadio/MdRadio.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(309)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdRadio_default.a,
  MdRadio_MdRadio,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdRadio/MdRadio.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b5b900ce", Component.options)
  } else {
    hotAPI.reload("data-v-b5b900ce", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdRadio_MdRadio = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 309 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdRadio',
  components: {
    MdRipple: _MdRipple2.default
  },
  props: {
    model: [String, Number, Boolean],
    value: {
      type: [String, Number, Boolean],
      default: 'on'
    },
    id: {
      type: String,
      default: function _default() {
        return 'md-radio-' + (0, _MdUuid2.default)();
      }
    },
    name: [String, Number],
    required: Boolean,
    disabled: Boolean
  },
  model: {
    prop: 'model',
    event: 'change'
  },
  data: function data() {
    return {
      rippleActive: false
    };
  },
  computed: {
    isSelected: function isSelected() {
      return this.model === this.value;
    },
    radioClasses: function radioClasses() {
      return {
        'md-checked': this.isSelected,
        'md-disabled': this.disabled,
        'md-required': this.required
      };
    }
  },
  methods: {
    toggleCheck: function toggleCheck() {
      if (!this.disabled) {
        this.rippleActive = true;
        this.$emit('change', this.value);
      }
    }
  }
}); //
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdRipple = __webpack_require__(8);

var _MdRipple2 = _interopRequireDefault(_MdRipple);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdRipple2.default.name, _MdRipple2.default);
};

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSnackbar = __webpack_require__(313);

var _MdSnackbar2 = _interopRequireDefault(_MdSnackbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSnackbar2.default.name, _MdSnackbar2.default);
};

/***/ }),
/* 313 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSnackbar/MdSnackbar.vue
var MdSnackbar = __webpack_require__(315);
var MdSnackbar_default = /*#__PURE__*/__webpack_require__.n(MdSnackbar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7063bc8f","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSnackbar/MdSnackbar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.mdPersistent && _vm.mdDuration !== Infinity
    ? _c(
        "md-portal",
        [
          _c(
            "keep-alive",
            [
              _vm.mdActive
                ? _c(
                    "md-snackbar-content",
                    {
                      attrs: {
                        "md-classes": [_vm.snackbarClasses, _vm.$mdActiveTheme]
                      }
                    },
                    [_vm._t("default")],
                    2
                  )
                : _vm._e()
            ],
            1
          )
        ],
        1
      )
    : _c(
        "md-portal",
        [
          _vm.mdActive
            ? _c(
                "md-snackbar-content",
                {
                  attrs: {
                    "md-classes": [_vm.snackbarClasses, _vm.$mdActiveTheme]
                  }
                },
                [_vm._t("default")],
                2
              )
            : _vm._e()
        ],
        1
      )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSnackbar_MdSnackbar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7063bc8f", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSnackbar/MdSnackbar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(314)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSnackbar_default.a,
  MdSnackbar_MdSnackbar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSnackbar/MdSnackbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7063bc8f", Component.options)
  } else {
    hotAPI.reload("data-v-7063bc8f", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSnackbar_MdSnackbar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 314 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdPortal = __webpack_require__(16);

var _MdPortal2 = _interopRequireDefault(_MdPortal);

var _MdSnackbarContent = __webpack_require__(316);

var _MdSnackbarContent2 = _interopRequireDefault(_MdSnackbarContent);

var _MdSnackbarQueue = __webpack_require__(318);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = new _MdComponent2.default({
  name: 'MdSnackbar',
  components: {
    MdPortal: _MdPortal2.default,
    MdSnackbarContent: _MdSnackbarContent2.default
  },
  props: {
    mdActive: Boolean,
    mdPersistent: Boolean,
    mdDuration: {
      type: Number,
      default: 4000
    },
    mdPosition: _extends({
      type: String,
      default: 'center'
    }, (0, _MdPropValidator2.default)('md-position', ['center', 'left']))
  },
  computed: {
    snackbarClasses: function snackbarClasses() {
      return _defineProperty({}, 'md-position-' + this.mdPosition, true);
    }
  },
  watch: {
    mdActive: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(isActive) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!isActive) {
                  _context.next = 7;
                  break;
                }

                _context.next = 3;
                return (0, _MdSnackbarQueue.createSnackbar)(this.mdDuration, this);

              case 3:

                this.$emit('update:mdActive', false);
                this.$emit('md-opened');
                _context.next = 9;
                break;

              case 7:
                (0, _MdSnackbarQueue.destroySnackbar)();
                this.$emit('md-closed');

              case 9:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function mdActive(_x) {
        return _ref2.apply(this, arguments);
      }

      return mdActive;
    }()
  }
});

/***/ }),
/* 316 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSnackbar/MdSnackbarContent.vue
var MdSnackbarContent = __webpack_require__(317);
var MdSnackbarContent_default = /*#__PURE__*/__webpack_require__.n(MdSnackbarContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-ffe066cc","hasScoped":false,"buble":{"transforms":{"stripWithFunctional":true}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSnackbar/MdSnackbarContent.vue
var render = function(_h, _vm) {
  var _c = _vm._c
  return _c("transition", { attrs: { name: "md-snackbar", appear: "" } }, [
    _c("div", { staticClass: "md-snackbar", class: _vm.props.mdClasses }, [
      _c("div", { staticClass: "md-snackbar-content" }, [_vm._t("default")], 2)
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSnackbar_MdSnackbarContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-ffe066cc", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSnackbar/MdSnackbarContent.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = true
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSnackbarContent_default.a,
  MdSnackbar_MdSnackbarContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSnackbar/MdSnackbarContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ffe066cc", Component.options)
  } else {
    hotAPI.rerender("data-v-ffe066cc", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSnackbar_MdSnackbarContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdSnackbarContent',
  props: {
    mdClasses: Array
  }
};

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var currentSnackbar = null;
var timeout = null;

function createPromise(duration, context) {
  return new Promise(function (resolve) {
    currentSnackbar = {
      destroy: function destroy() {
        currentSnackbar = null;
        resolve();
      }
    };

    if (duration !== Infinity) {
      timeout = window.setTimeout(function () {
        destroySnackbar();
        context._vnode.componentInstance.initDestroy(true);
      }, duration);
    }
  });
}

var destroySnackbar = exports.destroySnackbar = function destroySnackbar() {
  return new Promise(function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resolve) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (currentSnackbar) {
                window.clearTimeout(timeout);
                currentSnackbar.destroy();
                window.setTimeout(resolve, 400);
              } else {
                resolve();
              }

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, undefined);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
};

var createSnackbar = exports.createSnackbar = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(duration, context) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!currentSnackbar) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return destroySnackbar();

          case 3:
            return _context2.abrupt("return", createPromise(duration, context));

          case 4:
            return _context2.abrupt("return", createPromise(duration, context));

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  }));

  return function createSnackbar(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSpeedDial = __webpack_require__(320);

var _MdSpeedDial2 = _interopRequireDefault(_MdSpeedDial);

var _MdSpeedDialTarget = __webpack_require__(323);

var _MdSpeedDialTarget2 = _interopRequireDefault(_MdSpeedDialTarget);

var _MdSpeedDialContent = __webpack_require__(326);

var _MdSpeedDialContent2 = _interopRequireDefault(_MdSpeedDialContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSpeedDial2.default.name, _MdSpeedDial2.default);
  Vue.component(_MdSpeedDialTarget2.default.name, _MdSpeedDialTarget2.default);
  Vue.component(_MdSpeedDialContent2.default.name, _MdSpeedDialContent2.default);
};

/***/ }),
/* 320 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDial.vue
var MdSpeedDial = __webpack_require__(322);
var MdSpeedDial_default = /*#__PURE__*/__webpack_require__.n(MdSpeedDial);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-470f76d1","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDial.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-speed-dial",
      class: [_vm.$mdActiveTheme, _vm.speedDialClasses]
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSpeedDial_MdSpeedDial = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-470f76d1", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSpeedDial/MdSpeedDial.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(321)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSpeedDial_default.a,
  MdSpeedDial_MdSpeedDial,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSpeedDial/MdSpeedDial.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-470f76d1", Component.options)
  } else {
    hotAPI.reload("data-v-470f76d1", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSpeedDial_MdSpeedDial = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 321 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = new _MdComponent2.default({
  name: 'MdSpeedDial',
  props: {
    mdEvent: _extends({
      type: String,
      default: 'hover'
    }, (0, _MdPropValidator2.default)('md-event', ['click', 'hover'])),
    mdDirection: _extends({
      type: String,
      default: 'top'
    }, (0, _MdPropValidator2.default)('md-direction', ['top', 'bottom'])),
    mdEffect: _extends({
      type: String,
      default: 'fling'
    }, (0, _MdPropValidator2.default)('md-effect', ['fling', 'scale', 'opacity']))
  },
  data: function data() {
    return {
      MdSpeedDial: {
        active: false,
        event: this.mdEvent,
        direction: this.mdDirection
      }
    };
  },
  provide: function provide() {
    return {
      MdSpeedDial: this.MdSpeedDial
    };
  },

  computed: {
    speedDialClasses: function speedDialClasses() {
      var _ref;

      return _ref = {
        'md-active': this.MdSpeedDial.active,
        'md-with-hover': this.mdEvent === 'hover'
      }, _defineProperty(_ref, 'md-direction-' + this.mdDirection, true), _defineProperty(_ref, 'md-effect-' + this.mdEffect, true), _ref;
    }
  }
});

/***/ }),
/* 323 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDialTarget.vue
var MdSpeedDialTarget = __webpack_require__(325);
var MdSpeedDialTarget_default = /*#__PURE__*/__webpack_require__.n(MdSpeedDialTarget);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-654a757c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDialTarget.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-button",
    _vm._g(
      _vm._b(
        {
          staticClass: "md-speed-dial-target md-fab",
          on: { click: _vm.handleClick }
        },
        "md-button",
        _vm.$attrs,
        false
      ),
      _vm.$listeners
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSpeedDial_MdSpeedDialTarget = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-654a757c", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSpeedDial/MdSpeedDialTarget.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(324)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSpeedDialTarget_default.a,
  MdSpeedDial_MdSpeedDialTarget,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSpeedDial/MdSpeedDialTarget.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-654a757c", Component.options)
  } else {
    hotAPI.reload("data-v-654a757c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSpeedDial_MdSpeedDialTarget = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 324 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdButton = __webpack_require__(13);

var _MdButton2 = _interopRequireDefault(_MdButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdSpeedDialTarget',
  components: {
    MdButton: _MdButton2.default
  },
  inject: ['MdSpeedDial'],
  methods: {
    handleClick: function handleClick() {
      if (this.MdSpeedDial.event === 'click') {
        this.MdSpeedDial.active = !this.MdSpeedDial.active;
      }
    }
  }
}; //
//
//
//
//
//

/***/ }),
/* 326 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDialContent.vue
var MdSpeedDialContent = __webpack_require__(328);
var MdSpeedDialContent_default = /*#__PURE__*/__webpack_require__.n(MdSpeedDialContent);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-45ac6418","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSpeedDial/MdSpeedDialContent.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-speed-dial-content" },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSpeedDial_MdSpeedDialContent = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-45ac6418", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSpeedDial/MdSpeedDialContent.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(327)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSpeedDialContent_default.a,
  MdSpeedDial_MdSpeedDialContent,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSpeedDial/MdSpeedDialContent.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-45ac6418", Component.options)
  } else {
    hotAPI.reload("data-v-45ac6418", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSpeedDial_MdSpeedDialContent = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 327 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

//
//
//
//
//
//

function getChildIndex(direction, index, count) {
  if (direction === 'top') {
    return count - index - 1;
  }

  return index;
}

exports.default = {
  name: 'MdSpeedDialContent',
  inject: ['MdSpeedDial'],
  methods: {
    setChildrenIndexes: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _this = this;

        var countChild;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:
                countChild = this.$children.length;


                this.$children.forEach(function (child, index) {
                  if (child._vnode.tag === 'button') {
                    var childIndex = getChildIndex(_this.MdSpeedDial.direction, index, countChild);

                    child.$el.setAttribute('md-button-index', childIndex);
                    child.$el.classList.add('md-raised');
                  }
                });

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setChildrenIndexes() {
        return _ref.apply(this, arguments);
      }

      return setChildrenIndexes;
    }()
  },
  mounted: function mounted() {
    this.setChildrenIndexes();
  },
  updated: function updated() {
    this.setChildrenIndexes();
  }
};

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSteppers = __webpack_require__(330);

var _MdSteppers2 = _interopRequireDefault(_MdSteppers);

var _MdStep = __webpack_require__(340);

var _MdStep2 = _interopRequireDefault(_MdStep);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSteppers2.default.name, _MdSteppers2.default);
  Vue.component(_MdStep2.default.name, _MdStep2.default);
};

/***/ }),
/* 330 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSteppers/MdSteppers.vue
var MdSteppers = __webpack_require__(332);
var MdSteppers_default = /*#__PURE__*/__webpack_require__.n(MdSteppers);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-95acb722","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSteppers/MdSteppers.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "md-steppers",
      class: [_vm.steppersClasses, _vm.$mdActiveTheme]
    },
    [
      !_vm.mdVertical
        ? _c(
            "div",
            { staticClass: "md-steppers-navigation" },
            _vm._l(_vm.MdSteppers.items, function(_, index) {
              return _c("md-step-header", {
                key: index,
                attrs: { index: index }
              })
            })
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "md-steppers-wrapper", style: _vm.contentStyles },
        [
          _c(
            "div",
            {
              staticClass: "md-steppers-container",
              style: _vm.containerStyles
            },
            [_vm._t("default")],
            2
          )
        ]
      )
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSteppers_MdSteppers = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-95acb722", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSteppers/MdSteppers.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(331)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSteppers_default.a,
  MdSteppers_MdSteppers,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSteppers/MdSteppers.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-95acb722", Component.options)
  } else {
    hotAPI.reload("data-v-95acb722", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSteppers_MdSteppers = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 331 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdObserveElement = __webpack_require__(26);

var _MdObserveElement2 = _interopRequireDefault(_MdObserveElement);

var _MdStepHeader = __webpack_require__(50);

var _MdStepHeader2 = _interopRequireDefault(_MdStepHeader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = new _MdComponent2.default({
  name: 'MdSteppers',
  components: {
    MdStepHeader: _MdStepHeader2.default
  },
  props: {
    mdSyncRoute: Boolean,
    mdDynamicHeight: Boolean,
    mdVertical: Boolean,
    mdLinear: Boolean,
    mdAlternative: Boolean,
    mdActiveStep: [String, Number]
  },
  data: function data() {
    return {
      activeStepIndex: 0,
      noTransition: true,
      containerStyles: {},
      contentStyles: {},
      MdSteppers: {
        activeStep: 0,
        isLinear: false,
        isVertical: false,
        items: {}
      }
    };
  },
  provide: function provide() {
    var MdSteppers = this.MdSteppers;

    MdSteppers.getStepperNumber = this.getStepperNumber;
    MdSteppers.setActiveStep = this.setActiveStep;
    MdSteppers.isPreviousStepperDone = this.isPreviousStepperDone;

    return { MdSteppers: MdSteppers };
  },

  computed: {
    steppersClasses: function steppersClasses() {
      return {
        'md-no-transition': this.noTransition,
        'md-alternative': this.mdAlternative,
        'md-horizontal': !this.mdVertical,
        'md-vertical': this.mdVertical,
        'md-dynamic-height': this.mdDynamicHeight
      };
    },
    activeIndex: function activeIndex() {
      return this.MdSteppers.activeStep;
    }
  },
  watch: {
    mdActiveStep: function mdActiveStep(stepper) {
      this.MdSteppers.activeStep = stepper;
      this.$emit('md-changed', stepper);
    },
    mdLinear: function mdLinear(isLinear) {
      this.MdSteppers.isLinear = isLinear;
    },
    mdVertical: function mdVertical(isVertical) {
      this.MdSteppers.isVertical = isVertical;
    },
    activeIndex: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:
                this.setActiveStepIndex();
                this.calculateStepperPos();

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function activeIndex() {
        return _ref.apply(this, arguments);
      }

      return activeIndex;
    }()
  },
  methods: {
    hasActiveStep: function hasActiveStep() {
      return this.MdSteppers.activeStep || this.mdActiveStep;
    },
    getItemsAndKeys: function getItemsAndKeys() {
      var items = this.MdSteppers.items;

      return {
        items: items,
        keys: Object.keys(items)
      };
    },
    getStepperNumber: function getStepperNumber(id) {
      var stepperNames = Object.keys(this.MdSteppers.items);

      return stepperNames.indexOf(id) + 1;
    },
    isStepperDone: function isStepperDone(id) {
      return this.MdSteppers.items[id].done;
    },
    isPreviousStepperDone: function isPreviousStepperDone(id) {
      var items = this.MdSteppers.items;

      var stepperNames = Object.keys(items);
      var activeIndex = this.getStepperNumber(id) - 2;
      var previousIndex = stepperNames[activeIndex];

      if (!previousIndex) {
        return true;
      }

      return items[previousIndex].done;
    },
    isStepperEditable: function isStepperEditable(id) {
      return this.MdSteppers.items[id].editable;
    },
    setStepperAsDone: function setStepperAsDone(id) {
      this.MdSteppers.items[id].done = true;
    },
    setPreviousStepperAsDone: function setPreviousStepperAsDone(newId) {
      var activeIndex = this.getStepperNumber(this.MdSteppers.activeStep);
      var newIndex = this.getStepperNumber(newId);

      if (newIndex > activeIndex) {
        this.setStepperAsDone(this.MdSteppers.activeStep);
      }
    },
    setActiveStep: function setActiveStep(id) {
      if (this.mdLinear && !this.isPreviousStepperDone(id)) {
        return false;
      }

      if (id !== this.MdSteppers.activeStep && (this.isStepperEditable(id) || !this.isStepperDone(id))) {
        this.setPreviousStepperAsDone(id);
        this.MdSteppers.activeStep = id;
        this.$emit('md-changed', id);
        this.$emit('update:mdActiveStep', id);
        this.MdSteppers.items[id].error = null;
      }
    },
    setActiveStepIndex: function setActiveStepIndex() {
      var activeButton = this.$el.querySelector('.md-button.md-active');

      if (activeButton) {
        this.activeStepIndex = [].indexOf.call(activeButton.parentNode.childNodes, activeButton);
      }
    },
    setActiveStepByIndex: function setActiveStepByIndex(index) {
      var _getItemsAndKeys = this.getItemsAndKeys(),
          keys = _getItemsAndKeys.keys;

      if (!this.hasActiveStep()) {
        this.MdSteppers.activeStep = keys[index];
      }
    },
    setActiveStepByRoute: function setActiveStepByRoute() {
      var _this = this;

      var _getItemsAndKeys2 = this.getItemsAndKeys(),
          items = _getItemsAndKeys2.items,
          keys = _getItemsAndKeys2.keys;

      var stepperIndex = null;

      if (this.$router) {
        keys.forEach(function (key, index) {
          var item = items[key];
          var toProp = item.props.to;

          if (toProp && toProp === _this.$route.path) {
            stepperIndex = index;
          }
        });
      }

      if (!this.hasActiveStep() && !stepperIndex) {
        this.MdSteppers.activeStep = keys[0];
      } else {
        this.MdSteppers.activeStep = keys[stepperIndex];

        for (var i = 0; i < stepperIndex; i++) {
          this.setStepperAsDone(keys[i]);
        }
      }
    },
    setupObservers: function setupObservers() {
      var steppersContent = this.$el.querySelector('.md-steppers-wrapper');

      if ('ResizeObserver' in window) {
        this.resizeObserver = new window.ResizeObserver(this.calculateStepperPos);
        this.resizeObserver.observe(this.$el);
      } else {
        window.addEventListener('resize', this.calculateStepperPos);
      }

      if (steppersContent) {
        this.resizeObserver = (0, _MdObserveElement2.default)(this.$el.querySelector('.md-steppers-wrapper'), {
          childList: true,
          characterData: true,
          subtree: true
        }, this.calculateStepperPos);
      }
    },
    calculateStepperPos: function calculateStepperPos() {
      if (!this.mdVertical) {
        var stepperElement = this.$el.querySelector('.md-stepper:nth-child(' + (this.activeStepIndex + 1) + ')');

        this.contentStyles = {
          height: stepperElement.offsetHeight + 'px'
        };

        this.containerStyles = {
          transform: 'translate3D(' + -this.activeStepIndex * 100 + '%, 0, 0)'
        };
      }
    },
    setupWatchers: function setupWatchers() {
      if (this.mdSyncRoute) {
        this.$watch('$route', {
          deep: true,
          handler: function handler() {
            this.setActiveStepByRoute();
          }
        });
      }
    }
  },
  created: function created() {
    this.MdSteppers.activeStep = this.mdActiveStep;
    this.MdSteppers.isLinear = this.mdLinear;
    this.MdSteppers.isVertical = this.mdVertical;
  },
  mounted: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var _this2 = this;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.$nextTick();

            case 2:

              if (this.mdSyncRoute) {
                this.setActiveStepByRoute();
              } else {
                this.setActiveStepByIndex(0);
              }

              _context2.next = 5;
              return this.$nextTick();

            case 5:

              this.setActiveStepIndex();
              this.calculateStepperPos();

              window.setTimeout(function () {
                _this2.noTransition = false;
                _this2.setupObservers();
                _this2.setupWatchers();
              }, 100);

            case 8:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function mounted() {
      return _ref2.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    if (!('ResizeObserver' in window)) {
      window.removeEventListener('resize', this.calculateStepperPos);
    }
  }
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdWarningIcon = __webpack_require__(334);

var _MdWarningIcon2 = _interopRequireDefault(_MdWarningIcon);

var _MdCheckIcon = __webpack_require__(336);

var _MdCheckIcon2 = _interopRequireDefault(_MdCheckIcon);

var _MdEditIcon = __webpack_require__(338);

var _MdEditIcon2 = _interopRequireDefault(_MdEditIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdStepperHeader',
  components: {
    MdWarningIcon: _MdWarningIcon2.default,
    MdCheckIcon: _MdCheckIcon2.default,
    MdEditIcon: _MdEditIcon2.default
  },
  props: {
    index: {
      type: String,
      required: true
    }
  },
  inject: ['MdSteppers'],
  computed: {
    data: function data() {
      return this.MdSteppers.items[this.index];
    },
    shouldDisable: function shouldDisable() {
      var data = this.data,
          index = this.index,
          MdSteppers = this.MdSteppers;


      if (data.done && !data.editable) {
        return true;
      }

      return MdSteppers.isLinear && !MdSteppers.isPreviousStepperDone(index);
    },
    classes: function classes() {
      return {
        'md-active': this.index === this.MdSteppers.activeStep,
        'md-error': this.data.error,
        'md-done': this.data.done
      };
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 334 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdWarningIcon.vue
var MdWarningIcon = __webpack_require__(335);
var MdWarningIcon_default = /*#__PURE__*/__webpack_require__.n(MdWarningIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-8993dc9c","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdWarningIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } }),
          _vm._v(" "),
          _c("path", {
            attrs: { d: "M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z" }
          })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdWarningIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-8993dc9c", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdWarningIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdWarningIcon_default.a,
  icons_MdWarningIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdWarningIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-8993dc9c", Component.options)
  } else {
    hotAPI.reload("data-v-8993dc9c", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdWarningIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdWarningIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 336 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdCheckIcon.vue
var MdCheckIcon = __webpack_require__(337);
var MdCheckIcon_default = /*#__PURE__*/__webpack_require__.n(MdCheckIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4154b05e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdCheckIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } }),
          _vm._v(" "),
          _c("path", {
            attrs: { d: "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" }
          })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdCheckIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4154b05e", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdCheckIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdCheckIcon_default.a,
  icons_MdCheckIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdCheckIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4154b05e", Component.options)
  } else {
    hotAPI.reload("data-v-4154b05e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdCheckIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdCheckIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 338 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdEditIcon.vue
var MdEditIcon = __webpack_require__(339);
var MdEditIcon_default = /*#__PURE__*/__webpack_require__.n(MdEditIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-75d6b514","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdEditIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", {
            attrs: {
              d:
                "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
            }
          }),
          _vm._v(" "),
          _c("path", { attrs: { d: "M0 0h24v24H0z", fill: "none" } })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdEditIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-75d6b514", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdEditIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdEditIcon_default.a,
  icons_MdEditIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdEditIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-75d6b514", Component.options)
  } else {
    hotAPI.reload("data-v-75d6b514", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdEditIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdEditIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 340 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSteppers/MdStep.vue
var MdStep = __webpack_require__(342);
var MdStep_default = /*#__PURE__*/__webpack_require__.n(MdStep);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-8624960e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSteppers/MdStep.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-stepper" },
    [
      _vm.MdSteppers.isVertical
        ? _c("md-step-header", { attrs: { index: _vm.id } })
        : _vm._e(),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "md-stepper-content",
          class: { "md-active": _vm.id === _vm.MdSteppers.activeStep }
        },
        [_vm._t("default")],
        2
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSteppers_MdStep = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-8624960e", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSteppers/MdStep.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(341)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdStep_default.a,
  MdSteppers_MdStep,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSteppers/MdStep.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-8624960e", Component.options)
  } else {
    hotAPI.reload("data-v-8624960e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSteppers_MdStep = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 341 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdStepHeader = __webpack_require__(50);

var _MdStepHeader2 = _interopRequireDefault(_MdStepHeader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdStep',
  components: {
    MdStepHeader: _MdStepHeader2.default
  },
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-stepper-' + (0, _MdUuid2.default)();
      }
    },
    href: [String, Number],
    to: null,
    mdLabel: String,
    mdDescription: String,
    mdError: String,
    mdDone: Boolean,
    mdEditable: {
      type: Boolean,
      default: true
    }
  },
  inject: ['MdSteppers'],
  watch: {
    $props: {
      deep: true,
      handler: function handler() {
        this.setStepperData();
      }
    }
  },
  methods: {
    getPropValues: function getPropValues() {
      var _this = this;

      var propNames = Object.keys(this.$options.props);
      var ignoredProps = ['id', 'mdLabel', 'mdDescription', 'mdError', 'mdEditable'];
      var values = {};

      propNames.forEach(function (prop) {
        if (!ignoredProps.includes(prop)) {
          if (_this[prop]) {
            values[prop] = _this[prop];
          } else if (_this.$attrs.hasOwnProperty(prop)) {
            if (prop) {
              values[prop] = _this.$attrs[prop];
            } else {
              values[prop] = true;
            }
          }
        }
      });

      return values;
    },
    setStepperData: function setStepperData() {
      this.$set(this.MdSteppers.items, this.id, {
        label: this.mdLabel,
        description: this.mdDescription,
        error: this.mdError,
        done: this.mdDone,
        editable: this.mdEditable,
        props: this.getPropValues(),
        events: this.$listeners
      });
    },
    setupWatchers: function setupWatchers() {
      var _this2 = this;

      var getProp = function getProp(prop) {
        if (_this2.MdSteppers.items[_this2.id]) {
          return _this2.MdSteppers.items[_this2.id][prop];
        }
      };

      this.$watch(function () {
        return getProp('error');
      }, function () {
        return _this2.$emit('update:mdError', getProp('error'));
      });

      this.$watch(function () {
        return getProp('done');
      }, function () {
        return _this2.$emit('update:mdDone', getProp('done'));
      });
    }
  },
  created: function created() {
    this.setStepperData();
    this.setupWatchers();
  },
  beforeDestroy: function beforeDestroy() {
    this.$delete(this.MdSteppers.items, this.id);
  },
  render: function render(createElement) {
    var stepperAttrs = {
      staticClass: 'md-stepper',
      attrs: _extends({}, this.$attrs, {
        id: this.id
      }),
      on: this.$listeners
    };

    if (this.href) {
      this.buttonProps = this.$options.props;
    } else if (this.$router && this.to) {
      this.$options.props = MdRouterLinkProps(this, this.$options.props);

      stepperAttrs.props = this.$props;
    }

    return createElement('div', stepperAttrs, this.$slots.default);
  }
};

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSubheader = __webpack_require__(344);

var _MdSubheader2 = _interopRequireDefault(_MdSubheader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSubheader2.default.name, _MdSubheader2.default);
};

/***/ }),
/* 344 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSubheader/MdSubheader.vue
var MdSubheader = __webpack_require__(346);
var MdSubheader_default = /*#__PURE__*/__webpack_require__.n(MdSubheader);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7ff30e86","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSubheader/MdSubheader.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.insideList
    ? _c(
        "li",
        { staticClass: "md-subheader", class: [_vm.$mdActiveTheme] },
        [_vm._t("default")],
        2
      )
    : _c(
        "div",
        { staticClass: "md-subheader", class: [_vm.$mdActiveTheme] },
        [_vm._t("default")],
        2
      )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSubheader_MdSubheader = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7ff30e86", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSubheader/MdSubheader.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(345)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSubheader_default.a,
  MdSubheader_MdSubheader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSubheader/MdSubheader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7ff30e86", Component.options)
  } else {
    hotAPI.reload("data-v-7ff30e86", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSubheader_MdSubheader = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 345 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdSubheader',
  computed: {
    insideList: function insideList() {
      return this.$parent.$options._componentTag === 'md-list';
    }
  }
}); //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdSwitch = __webpack_require__(348);

var _MdSwitch2 = _interopRequireDefault(_MdSwitch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdSwitch2.default.name, _MdSwitch2.default);
};

/***/ }),
/* 348 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdSwitch/MdSwitch.vue
var MdSwitch = __webpack_require__(350);
var MdSwitch_default = /*#__PURE__*/__webpack_require__.n(MdSwitch);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-5ff953a2","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdSwitch/MdSwitch.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-switch", class: [_vm.$mdActiveTheme, _vm.checkClasses] },
    [
      _c(
        "div",
        {
          staticClass: "md-switch-container",
          on: {
            click: function($event) {
              $event.stopPropagation()
              _vm.toggleCheck($event)
            }
          }
        },
        [
          _c(
            "div",
            { staticClass: "md-switch-thumb" },
            [
              _c(
                "md-ripple",
                {
                  attrs: {
                    "md-centered": "",
                    "md-active": _vm.rippleActive,
                    "md-disabled": _vm.disabled
                  },
                  on: {
                    "update:mdActive": function($event) {
                      _vm.rippleActive = $event
                    }
                  }
                },
                [
                  _c(
                    "input",
                    _vm._b(
                      { attrs: { type: "checkbox" } },
                      "input",
                      {
                        id: _vm.id,
                        name: _vm.name,
                        disabled: _vm.disabled,
                        required: _vm.required,
                        value: _vm.value
                      },
                      false
                    )
                  )
                ]
              )
            ],
            1
          )
        ]
      ),
      _vm._v(" "),
      _vm.$slots.default
        ? _c(
            "label",
            {
              staticClass: "md-switch-label",
              attrs: { for: _vm.id },
              on: {
                click: function($event) {
                  $event.preventDefault()
                  _vm.toggleCheck($event)
                }
              }
            },
            [_vm._t("default")],
            2
          )
        : _vm._e()
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdSwitch_MdSwitch = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-5ff953a2", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdSwitch/MdSwitch.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(349)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdSwitch_default.a,
  MdSwitch_MdSwitch,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdSwitch/MdSwitch.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5ff953a2", Component.options)
  } else {
    hotAPI.reload("data-v-5ff953a2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdSwitch_MdSwitch = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 349 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdCheckboxMixin = __webpack_require__(33);

var _MdCheckboxMixin2 = _interopRequireDefault(_MdCheckboxMixin);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdSwitch',
  mixins: [_MdCheckboxMixin2.default],
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-switch-' + (0, _MdUuid2.default)();
      }
    }
  }
}); //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdTableContainer = __webpack_require__(352);

var _MdTableContainer2 = _interopRequireDefault(_MdTableContainer);

var _MdTableToolbar = __webpack_require__(375);

var _MdTableToolbar2 = _interopRequireDefault(_MdTableToolbar);

var _MdTableEmptyState = __webpack_require__(380);

var _MdTableEmptyState2 = _interopRequireDefault(_MdTableEmptyState);

var _MdTableRow = __webpack_require__(51);

var _MdTableRow2 = _interopRequireDefault(_MdTableRow);

var _MdTableHead = __webpack_require__(27);

var _MdTableHead2 = _interopRequireDefault(_MdTableHead);

var _MdTableCell = __webpack_require__(383);

var _MdTableCell2 = _interopRequireDefault(_MdTableCell);

var _MdTablePagination = __webpack_require__(386);

var _MdTablePagination2 = _interopRequireDefault(_MdTablePagination);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component('MdTable', _MdTableContainer2.default);
  Vue.component(_MdTableToolbar2.default.name, _MdTableToolbar2.default);
  Vue.component(_MdTableEmptyState2.default.name, _MdTableEmptyState2.default);
  Vue.component(_MdTableRow2.default.name, _MdTableRow2.default);
  Vue.component(_MdTableHead2.default.name, _MdTableHead2.default);
  Vue.component(_MdTableCell2.default.name, _MdTableCell2.default);
  Vue.component(_MdTablePagination2.default.name, _MdTablePagination2.default);
};

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdTable = __webpack_require__(353);

var _MdTable2 = _interopRequireDefault(_MdTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function processChildren(children, createElement) {
  var slotNames = ['md-table-toolbar', 'md-table-empty-state', 'md-table-pagination'];
  var nodes = Array.from(children);
  var namedSlots = {};

  nodes.forEach(function (node, index) {
    if (node && node.tag) {
      var tag = node.componentOptions && node.componentOptions.tag;

      if (tag && slotNames.includes(tag)) {
        node.data.slot = tag;
        node.data.attrs = node.data.attrs || {};
        namedSlots[tag] = function () {
          return node;
        };
        nodes.splice(index, 1);
      }
    }
  });

  return {
    childNodes: nodes,
    slots: namedSlots
  };
}

exports.default = {
  name: 'MdTableContainer',
  functional: true,
  render: function render(createElement, _ref) {
    var data = _ref.data,
        props = _ref.props,
        children = _ref.children;

    var slotChildren = [];
    var scopedSlots = data.scopedSlots;

    if (children) {
      var _processChildren = processChildren(children, createElement),
          childNodes = _processChildren.childNodes,
          slots = _processChildren.slots;

      slotChildren = childNodes;
      scopedSlots = _extends({}, scopedSlots, slots);
    }

    return createElement(_MdTable2.default, _extends({}, data, {
      props: props,
      scopedSlots: scopedSlots
    }), [slotChildren]);
  }
};

/***/ }),
/* 353 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTable.vue
var MdTable = __webpack_require__(355);
var MdTable_default = /*#__PURE__*/__webpack_require__.n(MdTable);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-aaeced82","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTable.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-tag-switcher",
    { staticClass: "md-table", attrs: { "md-tag": _vm.contentTag } },
    [
      _vm._t("md-table-toolbar"),
      _vm._v(" "),
      _c(
        "keep-alive",
        [
          _vm.$scopedSlots["md-table-alternate-header"] && _vm.selectedCount
            ? _c(
                "md-table-alternate-header",
                [
                  _vm._t("md-table-alternate-header", null, {
                    count: _vm.selectedCount
                  })
                ],
                2
              )
            : _vm._e()
        ],
        1
      ),
      _vm._v(" "),
      _vm.mdFixedHeader
        ? _c(
            "div",
            {
              staticClass: "md-table-fixed-header",
              class: _vm.headerClasses,
              style: _vm.headerStyles
            },
            [_c("table", [_c("md-table-thead")], 1)]
          )
        : _vm._e(),
      _vm._v(" "),
      _c(
        "md-content",
        {
          staticClass: "md-table-content md-scrollbar",
          class: _vm.contentClasses,
          style: _vm.contentStyles,
          on: { scroll: _vm.setScroll }
        },
        [
          _c(
            "table",
            [
              !_vm.mdFixedHeader && _vm.$scopedSlots["md-table-row"]
                ? _c("md-table-thead", { class: _vm.headerClasses })
                : _vm._e(),
              _vm._v(" "),
              !_vm.$scopedSlots["md-table-row"]
                ? _c("tbody", [_vm._t("default")], 2)
                : _vm.value.length
                  ? _c(
                      "tbody",
                      _vm._l(_vm.value, function(item, index) {
                        return _c(
                          "md-table-row-ghost",
                          {
                            key: _vm.getRowId(item[_vm.mdModelId]),
                            attrs: {
                              "md-id": _vm.getRowId(item[_vm.mdModelId]),
                              "md-index": index,
                              "md-item": item
                            }
                          },
                          [_vm._t("md-table-row", null, { item: item })],
                          2
                        )
                      })
                    )
                  : _vm.$scopedSlots["md-table-empty-state"]
                    ? _c("tbody", [
                        _c("tr", [
                          _c(
                            "td",
                            { attrs: { colspan: _vm.headerCount } },
                            [_vm._t("md-table-empty-state")],
                            2
                          )
                        ])
                      ])
                    : _vm._e()
            ],
            1
          ),
          _vm._v(" "),
          _vm._t("md-table-pagination")
        ],
        2
      ),
      _vm._v(" "),
      _vm.value ? _vm._t("default") : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTable = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-aaeced82", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTable.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(354)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTable_default.a,
  MdTable_MdTable,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTable.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-aaeced82", Component.options)
  } else {
    hotAPI.reload("data-v-aaeced82", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTable = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 354 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _raf = __webpack_require__(9);

var _raf2 = _interopRequireDefault(_raf);

var _MdTagSwitcher = __webpack_require__(356);

var _MdTagSwitcher2 = _interopRequireDefault(_MdTagSwitcher);

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdTableThead = __webpack_require__(358);

var _MdTableThead2 = _interopRequireDefault(_MdTableThead);

var _MdTableAlternateHeader = __webpack_require__(366);

var _MdTableAlternateHeader2 = _interopRequireDefault(_MdTableAlternateHeader);

var _MdTableRow = __webpack_require__(51);

var _MdTableRow2 = _interopRequireDefault(_MdTableRow);

var _MdTableRowGhost = __webpack_require__(373);

var _MdTableRowGhost2 = _interopRequireDefault(_MdTableRowGhost);

var _MdTableCellSelection = __webpack_require__(52);

var _MdTableCellSelection2 = _interopRequireDefault(_MdTableCellSelection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var getObjectAttribute = function getObjectAttribute(object, key) {
  var value = object;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = key.split('.')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var attribute = _step.value;

      value = value[attribute];
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return value;
};

exports.default = {
  name: 'MdTable',
  components: {
    MdTagSwitcher: _MdTagSwitcher2.default,
    MdTableAlternateHeader: _MdTableAlternateHeader2.default,
    MdTableThead: _MdTableThead2.default,
    MdTableRow: _MdTableRow2.default,
    MdTableRowGhost: _MdTableRowGhost2.default,
    MdTableCellSelection: _MdTableCellSelection2.default
  },
  props: {
    value: [Array, Object],
    mdModelId: {
      type: String,
      default: 'id'
    },
    mdCard: Boolean,
    mdFixedHeader: Boolean,
    mdHeight: {
      type: Number,
      default: 400
    },
    mdSort: String,
    mdSortOrder: _extends({
      type: String,
      default: 'asc'
    }, (0, _MdPropValidator2.default)('md-sort-order', ['asc', 'desc'])),
    mdSortFn: {
      type: Function,
      default: function _default(value) {
        var _this = this;

        return value.sort(function (a, b) {
          var sortBy = _this.MdTable.sort;
          var aAttr = getObjectAttribute(a, sortBy);
          var bAttr = getObjectAttribute(b, sortBy);
          var isAsc = _this.MdTable.sortOrder === 'asc';
          var isNumber = typeof aAttr === 'number';

          if (isNumber) {
            return isAsc ? bAttr - aAttr : aAttr - bAttr;
          }

          if (isAsc) {
            return bAttr.localeCompare(aAttr);
          }

          return aAttr.localeCompare(bAttr);
        });
      }
    },
    mdSelectedValue: {
      type: [Array, Object]
    }
  },
  data: function data() {
    return {
      fixedHeaderPadding: 0,
      hasContentScroll: false,
      MdTable: {
        items: {},
        sort: null,
        sortOrder: null,
        singleSelection: null,
        selectedItems: [],
        selectable: [],
        fixedHeader: null,
        contentPadding: null,
        contentEl: null,
        // computed
        hasValue: this.hasValue,
        // methods
        emitEvent: this.emitEvent,
        sortTable: this.sortTable,
        manageItemSelection: this.manageItemSelection,
        getModel: this.getModel,
        getModelItem: this.getModelItem,
        selectingMode: null
      }
    };
  },

  computed: {
    contentTag: function contentTag() {
      if (this.mdCard) {
        return 'md-card';
      }

      return 'md-content';
    },
    headerCount: function headerCount() {
      return Object.keys(this.MdTable.items).length;
    },
    selectedCount: function selectedCount() {
      return this.MdTable.selectedItems.length;
    },
    headerStyles: function headerStyles() {
      if (this.mdFixedHeader) {
        return 'padding-right: ' + this.fixedHeaderPadding + 'px';
      }
    },
    hasValue: function hasValue() {
      return this.value && this.value.length !== 0;
    },
    headerClasses: function headerClasses() {
      if (this.mdFixedHeader && this.hasContentScroll || !this.hasValue) {
        return 'md-table-fixed-header-active';
      }
    },
    contentStyles: function contentStyles() {
      if (this.mdFixedHeader) {
        return 'height: ' + this.mdHeight + 'px;max-height: ' + this.mdHeight + 'px';
      }
    },
    contentClasses: function contentClasses() {
      if (this.mdFixedHeader && this.value.length === 0) {
        return 'md-table-empty';
      }
    }
  },
  provide: function provide() {
    var MdTable = this.MdTable;

    return { MdTable: MdTable };
  },

  watch: {
    mdSort: {
      immediate: true,
      handler: function handler() {
        this.MdTable.sort = this.mdSort;
      }
    },
    mdSortOrder: {
      immediate: true,
      handler: function handler() {
        this.MdTable.sortOrder = this.mdSortOrder;
      }
    },
    mdFixedHeader: {
      immediate: true,
      handler: function handler() {
        this.MdTable.fixedHeader = this.mdFixedHeader;
      }
    },
    hasValue: {
      immediate: true,
      handler: function handler() {
        this.MdTable.hasValue = this.hasValue;
      }
    },
    'MdTable.selectedItems': function MdTableSelectedItems(val) {
      this.select(val);
    },
    'MdTable.singleSelection': function MdTableSingleSelection(val) {
      this.select(val);
    },
    mdSelectedValue: function mdSelectedValue() {
      this.syncSelectedValue();
    }
  },
  methods: {
    emitEvent: function emitEvent(eventName, value) {
      this.$emit(eventName, value);
    },
    getRowId: function getRowId(id) {
      if (id) {
        return id;
      }

      return 'md-row-' + (0, _MdUuid2.default)();
    },
    setScroll: function setScroll($event) {
      var _this2 = this;

      (0, _raf2.default)(function () {
        _this2.hasContentScroll = $event.target.scrollTop > 0;
      });
    },
    getContentEl: function getContentEl() {
      return this.$el.querySelector('.md-table-content');
    },
    setContentEl: function setContentEl() {
      this.MdTable.contentEl = this.getContentEl();
    },
    setHeaderPadding: function setHeaderPadding() {
      this.setContentEl();

      var contentEl = this.MdTable.contentEl;

      var tableEl = contentEl.childNodes[0];

      this.fixedHeaderPadding = contentEl.offsetWidth - tableEl.offsetWidth;
    },
    getModel: function getModel() {
      return this.value;
    },
    getModelItem: function getModelItem(index) {
      return this.value[index];
    },
    manageItemSelection: function manageItemSelection(item) {
      if (this.MdTable.selectedItems.includes(item)) {
        this.MdTable.selectedItems = this.MdTable.selectedItems.filter(function (target) {
          return target !== item;
        });
      } else {
        this.MdTable.selectedItems.push(item);
      }
    },
    sortTable: function sortTable() {
      if (Array.isArray(this.value)) {
        this.$emit('input', this.mdSortFn(this.value));
      }
    },
    select: function select(val) {
      this.$emit('update:mdSelectedValue', val);
      this.$emit('md-selected', val);
    },
    syncSelectedValue: function syncSelectedValue() {
      switch (this.MdTable.selectingMode) {
        case 'single':
          this.MdTable.singleSelection = this.mdSelectedValue;
          break;
        case 'multiple':
          this.MdTable.selectedItems = this.mdSelectedValue || [];
          break;
      }
    }
  },
  created: function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.$nextTick();

            case 2:
              this.syncSelectedValue();

            case 3:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function created() {
      return _ref.apply(this, arguments);
    }

    return created;
  }(),
  mounted: function mounted() {
    this.setContentEl();

    if (this.mdFixedHeader) {
      this.setHeaderPadding();
    }
  }
};

/***/ }),
/* 356 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTagSwitcher_vue__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTagSwitcher_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTagSwitcher_vue__);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTagSwitcher_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTagSwitcher/MdTagSwitcher.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6f07a399", Component.options)
  } else {
    hotAPI.reload("data-v-6f07a399", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = {
  functional: true,
  props: {
    mdTag: {
      type: String,
      default: 'div'
    }
  },
  render: function render(createElement, _ref) {
    var props = _ref.props,
        children = _ref.children,
        data = _ref.data,
        listeners = _ref.listeners;

    return createElement(props.mdTag, _extends({}, data, {
      on: listeners
    }), children);
  }
};

/***/ }),
/* 358 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableThead.vue
var MdTableThead = __webpack_require__(359);
var MdTableThead_default = /*#__PURE__*/__webpack_require__.n(MdTableThead);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-8a8392f6","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableThead.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("thead", [
    _c(
      "tr",
      [
        _c("md-table-head-selection"),
        _vm._v(" "),
        _vm._l(_vm.MdTable.items, function(item, index) {
          return _c(
            "md-table-head",
            _vm._b({ key: index }, "md-table-head", item, false)
          )
        })
      ],
      2
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableThead = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-8a8392f6", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableThead.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableThead_default.a,
  MdTable_MdTableThead,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableThead.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-8a8392f6", Component.options)
  } else {
    hotAPI.reload("data-v-8a8392f6", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableThead = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdTableHead = __webpack_require__(27);

var _MdTableHead2 = _interopRequireDefault(_MdTableHead);

var _MdTableHeadSelection = __webpack_require__(364);

var _MdTableHeadSelection2 = _interopRequireDefault(_MdTableHeadSelection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTableThead',
  inject: ['MdTable'],
  components: {
    MdTableHead: _MdTableHead2.default,
    MdTableHeadSelection: _MdTableHeadSelection2.default
  }
};

/***/ }),
/* 360 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdUpwardIcon = __webpack_require__(362);

var _MdUpwardIcon2 = _interopRequireDefault(_MdUpwardIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTableHead',
  components: {
    MdUpwardIcon: _MdUpwardIcon2.default
  },
  props: {
    mdNumeric: Boolean,
    numeric: Boolean,
    label: String,
    tooltip: String,
    sortBy: String
  },
  inject: ['MdTable'],
  data: function data() {
    return {
      width: null
    };
  },
  computed: {
    hasSort: function hasSort() {
      return this.MdTable.sort && this.sortBy;
    },
    isSorted: function isSorted() {
      if (this.MdTable.sort) {
        return this.MdTable.sort === this.sortBy;
      }
    },
    isDescSorted: function isDescSorted() {
      return this.isSorted && this.MdTable.sortOrder === 'desc';
    },
    isAscSorted: function isAscSorted() {
      return this.isSorted && this.MdTable.sortOrder === 'asc';
    },
    headStyles: function headStyles() {
      return {
        width: this.width + 'px'
      };
    },
    headClasses: function headClasses() {
      return {
        'md-numeric': this.numeric || this.mdNumeric,
        'md-sortable': this.hasSort,
        'md-sorted': this.isSorted,
        'md-sorted-desc': this.isDescSorted
      };
    }
  },
  methods: {
    changeSort: function changeSort() {
      if (this.hasSort) {
        if (this.isAscSorted) {
          this.MdTable.sortOrder = 'desc';
        } else {
          this.MdTable.sortOrder = 'asc';
        }

        this.MdTable.sort = this.sortBy;
        this.MdTable.emitEvent('md-sorted', this.MdTable.sort);
        this.MdTable.emitEvent('update:mdSort', this.MdTable.sort);
        this.MdTable.emitEvent('update:mdSortOrder', this.MdTable.sortOrder);
        this.MdTable.sortTable();
      }
    },
    getChildNodesBySelector: function getChildNodesBySelector(el, selector) {
      return Array.from(el.childNodes).filter(function (_ref) {
        var classList = _ref.classList;
        return classList && classList.contains(selector);
      });
    },
    getNodeIndex: function getNodeIndex(nodes, el) {
      return [].indexOf.call(nodes, el);
    },
    setWidth: function setWidth() {
      if (this.MdTable.fixedHeader) {
        var cellSelector = 'md-table-cell';
        var thEls = this.getChildNodesBySelector(this.$el.parentNode, 'md-table-head');
        var tdEls = this.MdTable.contentEl.querySelectorAll('tr:first-child .' + cellSelector);
        var nodeIndex = this.getNodeIndex(thEls, this.$el);

        this.width = tdEls[nodeIndex].offsetWidth;
      }
    }
  },
  updated: function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.$nextTick();

            case 2:
              this.setWidth();

            case 3:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function updated() {
      return _ref2.apply(this, arguments);
    }

    return updated;
  }(),
  mounted: function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.$nextTick();

            case 2:
              this.setWidth();

            case 3:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function mounted() {
      return _ref3.apply(this, arguments);
    }

    return mounted;
  }()
};

/***/ }),
/* 362 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/core/icons/MdUpwardIcon.vue
var MdUpwardIcon = __webpack_require__(363);
var MdUpwardIcon_default = /*#__PURE__*/__webpack_require__.n(MdUpwardIcon);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-235f197a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/core/icons/MdUpwardIcon.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0, false, true)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("md-icon", { staticClass: "md-icon-image" }, [
      _c(
        "svg",
        {
          attrs: {
            height: "24",
            viewBox: "0 0 24 24",
            width: "24",
            xmlns: "http://www.w3.org/2000/svg"
          }
        },
        [
          _c("path", { attrs: { d: "M0 0h24v24H0V0z", fill: "none" } }),
          _vm._v(" "),
          _c("path", {
            attrs: {
              d: "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"
            }
          })
        ]
      )
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var icons_MdUpwardIcon = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-235f197a", esExports)
  }
}
// CONCATENATED MODULE: ./src/core/icons/MdUpwardIcon.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdUpwardIcon_default.a,
  icons_MdUpwardIcon,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/core/icons/MdUpwardIcon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-235f197a", Component.options)
  } else {
    hotAPI.reload("data-v-235f197a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var core_icons_MdUpwardIcon = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdIcon = __webpack_require__(5);

var _MdIcon2 = _interopRequireDefault(_MdIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdUpwardIcon',
  components: {
    MdIcon: _MdIcon2.default
  }
}; //
//
//
//
//
//
//
//
//

/***/ }),
/* 364 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableHeadSelection.vue
var MdTableHeadSelection = __webpack_require__(365);
var MdTableHeadSelection_default = /*#__PURE__*/__webpack_require__.n(MdTableHeadSelection);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-7fa31cbd","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableHeadSelection.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm.selectableCount
    ? _c("md-table-head", { staticClass: "md-table-cell-selection" }, [
        _c(
          "div",
          { staticClass: "md-table-cell-container" },
          [
            _c("md-checkbox", {
              attrs: { model: _vm.allSelected, disabled: _vm.isDisabled },
              on: { change: _vm.onChange }
            })
          ],
          1
        )
      ])
    : _vm._e()
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableHeadSelection = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7fa31cbd", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableHeadSelection.vue
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableHeadSelection_default.a,
  MdTable_MdTableHeadSelection,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableHeadSelection.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7fa31cbd", Component.options)
  } else {
    hotAPI.reload("data-v-7fa31cbd", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableHeadSelection = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdTableHead = __webpack_require__(27);

var _MdTableHead2 = _interopRequireDefault(_MdTableHead);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdTableHeadSelection',
  components: {
    MdTableHead: _MdTableHead2.default
  },
  inject: ['MdTable'],
  computed: {
    selectableCount: function selectableCount() {
      return Object.keys(this.selectable).length;
    },
    isDisabled: function isDisabled() {
      return !this.selectableCount;
    },
    selectable: function selectable() {
      return this.MdTable.selectable;
    },
    selectedItems: function selectedItems() {
      return this.MdTable.selectedItems;
    },
    allSelected: function allSelected() {
      var _this = this;

      if (this.selectableCount === 0) {
        return false;
      }

      return this.selectable.every(function (item) {
        return _this.selectedItems.includes(item);
      });
    }
  },
  methods: {
    onChange: function onChange(val) {
      var _this2 = this;

      if (val) {
        this.MdTable.selectedItems = this.selectedItems.concat(this.selectable.filter(function (item) {
          return !_this2.selectedItems.includes(item);
        }));
      } else {
        this.MdTable.selectedItems = this.selectedItems.filter(function (item) {
          return !_this2.selectable.includes(item);
        });
      }
    }
  }
}; //
//
//
//
//
//
//
//

/***/ }),
/* 366 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableAlternateHeader.vue
var MdTableAlternateHeader = __webpack_require__(368);
var MdTableAlternateHeader_default = /*#__PURE__*/__webpack_require__.n(MdTableAlternateHeader);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4241c118","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableAlternateHeader.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("transition", { attrs: { name: "md-table-alternate-header" } }, [
    _c(
      "div",
      { staticClass: "md-table-alternate-header" },
      [_vm._t("default")],
      2
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableAlternateHeader = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4241c118", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableAlternateHeader.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(367)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableAlternateHeader_default.a,
  MdTable_MdTableAlternateHeader,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableAlternateHeader.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4241c118", Component.options)
  } else {
    hotAPI.reload("data-v-4241c118", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableAlternateHeader = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 367 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTableAlternateHeader'
};

/***/ }),
/* 369 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdTableCellSelection = __webpack_require__(52);

var _MdTableCellSelection2 = _interopRequireDefault(_MdTableCellSelection);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdTableRow',
  components: {
    MdTableCellSelection: _MdTableCellSelection2.default
  },
  props: {
    mdIndex: [Number, String],
    mdId: [Number, String],
    mdSelectable: _extends({
      type: [String]
    }, (0, _MdPropValidator2.default)('md-selectable', ['multiple', 'single'])),
    mdDisabled: Boolean,
    mdAutoSelect: Boolean,
    mdItem: Object
  },
  inject: ['MdTable'],
  data: function data() {
    return {
      index: null,
      isSelected: false
    };
  },
  computed: {
    selectableCount: function selectableCount() {
      return Object.keys(this.MdTable.selectable).length;
    },
    isSingleSelected: function isSingleSelected() {
      return this.MdTable.singleSelection === this.mdItem;
    },
    hasMultipleSelection: function hasMultipleSelection() {
      return this.MdTable.hasValue && this.mdSelectable === 'multiple';
    },
    hasSingleSelection: function hasSingleSelection() {
      return this.MdTable.hasValue && this.mdSelectable === 'single';
    },
    rowClasses: function rowClasses() {
      if (this.MdTable.hasValue) {
        return {
          'md-has-selection': !this.mdDisabled && (this.mdAutoSelect || this.hasSingleSelection),
          'md-selected': this.isSelected,
          'md-selected-single': this.isSingleSelected
        };
      }
    },
    isInSelectedItems: function isInSelectedItems() {
      return this.MdTable.selectedItems.includes(this.mdItem);
    }
  },
  watch: {
    mdDisabled: function mdDisabled() {
      if (this.mdDisabled) {
        this.removeSelectableItem();
      } else {
        this.addSelectableItem();
      }
    },
    isSelected: function isSelected(val) {
      var noChange = val && this.isInSelectedItems || !val && !this.isInSelectedItems;

      if (noChange) {
        return false;
      }

      this.MdTable.manageItemSelection(this.mdItem);
    },
    isInSelectedItems: function isInSelectedItems(val) {
      this.isSelected = val;
    },
    mdSelectable: function mdSelectable() {
      this.MdTable.selectingMode = this.mdSelectable;
    }
  },
  methods: {
    onClick: function onClick() {
      if (this.MdTable.hasValue && !this.mdDisabled) {
        if (this.hasMultipleSelection) {
          this.selectRowIfMultiple();
        } else if (this.hasSingleSelection) {
          this.selectRowIfSingle();
        }
      }
    },
    toggleSelection: function toggleSelection() {
      this.isSelected = !this.isSelected;
    },
    selectRowIfSingle: function selectRowIfSingle() {
      if (this.MdTable.singleSelection === this.mdItem) {
        this.MdTable.singleSelection = null;
      } else {
        this.MdTable.singleSelection = this.mdItem;
      }
    },
    selectRowIfMultiple: function selectRowIfMultiple() {
      if (this.mdAutoSelect) {
        this.toggleSelection();
      }
    },
    addSelectableItem: function addSelectableItem() {
      if (!this.hasMultipleSelection || this.mdDisabled) {
        return;
      }

      if (this.MdTable.selectable.includes(this.mdItem)) {
        return;
      }

      this.MdTable.selectable.push(this.mdItem);
    },
    removeSelectableItem: function removeSelectableItem() {
      var _this = this;

      if (!this.hasMultipleSelection) {
        return;
      }

      this.MdTable.selectable = this.MdTable.selectable.filter(function (item) {
        return item !== _this.mdItem;
      });
    }
  },
  created: function created() {
    this.addSelectableItem();
    this.MdTable.selectingMode = this.mdSelectable;
  },
  beforeDestroy: function beforeDestroy() {
    this.removeSelectableItem();
  }
};

/***/ }),
/* 371 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTableCellSelection',
  props: {
    value: Boolean,
    mdRowId: [Number, String],
    mdSelectable: Boolean,
    mdDisabled: Boolean
  },
  inject: ['MdTable'],
  data: function data() {
    return {
      isSelected: false
    };
  },
  watch: {
    value: function value() {
      this.isSelected = this.value;
    }
  },
  methods: {
    onChange: function onChange() {
      this.$emit('input', this.isSelected);
    }
  }
};

/***/ }),
/* 373 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTableRowGhost_vue__ = __webpack_require__(374);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTableRowGhost_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTableRowGhost_vue__);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTableRowGhost_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableRowGhost.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b1d6a698", Component.options)
  } else {
    hotAPI.reload("data-v-b1d6a698", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: 'MdTableRowGhost',
  abstract: true,
  props: {
    mdIndex: [String, Number],
    mdId: [String, Number],
    mdItem: Object
  },
  render: function render() {
    this.$slots.default[0].componentOptions.propsData.mdIndex = this.mdIndex;
    this.$slots.default[0].componentOptions.propsData.mdId = this.mdId;
    this.$slots.default[0].componentOptions.propsData.mdItem = this.mdItem;

    return this.$slots.default[0];
  }
};

/***/ }),
/* 375 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableToolbar.vue
var MdTableToolbar = __webpack_require__(377);
var MdTableToolbar_default = /*#__PURE__*/__webpack_require__.n(MdTableToolbar);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-3f6f4028","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableToolbar.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-toolbar",
    {
      staticClass: "md-table-toolbar md-transparent",
      attrs: { "md-elevation": 0 }
    },
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableToolbar = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3f6f4028", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableToolbar.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(376)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableToolbar_default.a,
  MdTable_MdTableToolbar,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableToolbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3f6f4028", Component.options)
  } else {
    hotAPI.reload("data-v-3f6f4028", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableToolbar = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 376 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdToolbar = __webpack_require__(53);

var _MdToolbar2 = _interopRequireDefault(_MdToolbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdTableToolbar',
  components: {
    MdToolbar: _MdToolbar2.default
  },
  inject: ['MdTable']
}; //
//
//
//
//
//

/***/ }),
/* 378 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _MdComponent2.default({
  name: 'MdToolbar',
  props: {
    mdElevation: {
      type: [String, Number],
      default: 4
    }
  }
}); //
//
//
//
//
//

/***/ }),
/* 380 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableEmptyState.vue
var MdTableEmptyState = __webpack_require__(382);
var MdTableEmptyState_default = /*#__PURE__*/__webpack_require__.n(MdTableEmptyState);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-6f84743a","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableEmptyState.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-empty-state",
    _vm._b(
      { staticClass: "md-table-empty-state" },
      "md-empty-state",
      _vm.$props,
      false
    ),
    [_vm._t("default")],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableEmptyState = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-6f84743a", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableEmptyState.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(381)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableEmptyState_default.a,
  MdTable_MdTableEmptyState,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableEmptyState.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6f84743a", Component.options)
  } else {
    hotAPI.reload("data-v-6f84743a", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableEmptyState = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 381 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _MdEmptyState = __webpack_require__(41);

var _MdEmptyState2 = _interopRequireDefault(_MdEmptyState);

var _MdEmptyStateProps = __webpack_require__(42);

var _MdEmptyStateProps2 = _interopRequireDefault(_MdEmptyStateProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//

exports.default = {
  name: 'MdTableEmptyState',
  props: _MdEmptyStateProps2.default,
  inject: ['MdTable']
};

/***/ }),
/* 383 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTableCell.vue
var MdTableCell = __webpack_require__(385);
var MdTableCell_default = /*#__PURE__*/__webpack_require__.n(MdTableCell);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-813d6b7e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTableCell.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("td", { staticClass: "md-table-cell", class: _vm.cellClasses }, [
    _c(
      "div",
      { staticClass: "md-table-cell-container" },
      [_vm._t("default")],
      2
    )
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTableCell = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-813d6b7e", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTableCell.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(384)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTableCell_default.a,
  MdTable_MdTableCell,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTableCell.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-813d6b7e", Component.options)
  } else {
    hotAPI.reload("data-v-813d6b7e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTableCell = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 384 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTableCell',
  props: {
    mdLabel: String,
    mdNumeric: Boolean,
    mdTooltip: String,
    mdSortBy: String
  },
  inject: ['MdTable'],
  data: function data() {
    return {
      index: null,
      parentNode: null
    };
  },
  computed: {
    cellClasses: function cellClasses() {
      return {
        'md-numeric': this.mdNumeric
      };
    }
  },
  watch: {
    mdSortBy: function mdSortBy() {
      this.setCellData();
    },
    mdNumeric: function mdNumeric() {
      this.setCellData();
    },
    mdLabel: function mdLabel() {
      this.setCellData();
    },
    mdTooltip: function mdTooltip() {
      this.setCellData();
    }
  },
  methods: {
    setCellData: function setCellData() {
      var $vm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

      this.$set(this.MdTable.items, $vm.index, {
        label: $vm.mdLabel,
        numeric: $vm.mdNumeric,
        tooltip: $vm.mdTooltip,
        sortBy: $vm.mdSortBy
      });
    },
    updateAllCellData: function updateAllCellData() {
      var _this = this;

      this.MdTable.items = {};

      var cells = Array.from(this.parentNode.childNodes).filter(function (_ref) {
        var tagName = _ref.tagName,
            classList = _ref.classList;

        var isSelection = classList && classList.contains('md-table-cell-selection');
        var isTd = tagName && tagName.toLowerCase() === 'td';

        return isTd && !isSelection;
      });

      cells.forEach(function (cell, index) {
        var $vm = cell.__vue__;

        $vm.index = index;

        _this.setCellData($vm);
      });
    }
  },
  mounted: function mounted() {
    this.parentNode = this.$el.parentNode;
    this.updateAllCellData();
  },
  destroyed: function destroyed() {
    var rowRemoved = this.$el.parentNode !== null;

    if (rowRemoved) {
      return false;
    }

    this.updateAllCellData();
  }
};

/***/ }),
/* 386 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTable/MdTablePagination.vue
var MdTablePagination = __webpack_require__(388);
var MdTablePagination_default = /*#__PURE__*/__webpack_require__.n(MdTablePagination);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-4165698e","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTable/MdTablePagination.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-table-pagination" },
    [
      _vm.mdPageOptions !== false
        ? [
            _c("span", { staticClass: "md-table-pagination-label" }, [
              _vm._v(_vm._s(_vm.mdLabel))
            ]),
            _vm._v(" "),
            _c(
              "md-field",
              [
                _c(
                  "md-select",
                  {
                    attrs: {
                      "md-dense": "",
                      "md-class": "md-pagination-select"
                    },
                    on: { changed: _vm.setPageSize },
                    model: {
                      value: _vm.currentPageSize,
                      callback: function($$v) {
                        _vm.currentPageSize = $$v
                      },
                      expression: "currentPageSize"
                    }
                  },
                  _vm._l(_vm.mdPageOptions, function(amount) {
                    return _c(
                      "md-option",
                      { key: amount, attrs: { value: amount } },
                      [_vm._v(_vm._s(amount))]
                    )
                  })
                )
              ],
              1
            )
          ]
        : _vm._e(),
      _vm._v(" "),
      _c("span", [
        _vm._v(
          _vm._s(_vm.currentItemCount) +
            "-" +
            _vm._s(_vm.currentPageCount) +
            " " +
            _vm._s(_vm.mdSeparator) +
            " " +
            _vm._s(_vm.mdTotal)
        )
      ]),
      _vm._v(" "),
      _c(
        "md-button",
        {
          staticClass: "md-icon-button md-table-pagination-previous",
          attrs: { disabled: _vm.mdPage === 1 },
          on: {
            click: function($event) {
              _vm.goToPrevious()
            }
          }
        },
        [_c("md-icon", [_vm._v("keyboard_arrow_left")])],
        1
      ),
      _vm._v(" "),
      _c(
        "md-button",
        {
          staticClass: "md-icon-button md-table-pagination-next",
          on: {
            click: function($event) {
              _vm.goToNext()
            }
          }
        },
        [_c("md-icon", [_vm._v("keyboard_arrow_right")])],
        1
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTable_MdTablePagination = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4165698e", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTable/MdTablePagination.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(387)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTablePagination_default.a,
  MdTable_MdTablePagination,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTable/MdTablePagination.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4165698e", Component.options)
  } else {
    hotAPI.reload("data-v-4165698e", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTable_MdTablePagination = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 387 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  name: 'MdTablePagination',
  inject: ['MdTable'],
  props: {
    mdPageSize: {
      type: [String, Number],
      default: 10
    },
    mdPageOptions: {
      type: Array,
      default: function _default() {
        return [10, 25, 50, 100];
      }
    },
    mdPage: {
      type: Number,
      default: 1
    },
    mdTotal: {
      type: [String, Number],
      default: 'Many'
    },
    mdLabel: {
      type: String,
      default: 'Rows per page:'
    },
    mdSeparator: {
      type: String,
      default: 'of'
    }
  },
  data: function data() {
    return {
      currentPageSize: 0
    };
  },
  computed: {
    currentItemCount: function currentItemCount() {
      return (this.mdPage - 1) * this.mdPageSize + 1;
    },
    currentPageCount: function currentPageCount() {
      return this.mdPage * this.mdPageSize;
    }
  },
  watch: {
    mdPageSize: {
      immediate: true,
      handler: function handler(pageSize) {
        this.currentPageSize = this.pageSize;
      }
    }
  },
  methods: {
    setPageSize: function setPageSize() {
      this.$emit('update:mdPageSize', this.currentPageSize);
    },
    goToPrevious: function goToPrevious() {},
    goToNext: function goToNext() {}
  },
  created: function created() {
    this.currentPageSize = this.mdPageSize;
  }
};

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdTabs = __webpack_require__(390);

var _MdTabs2 = _interopRequireDefault(_MdTabs);

var _MdTab = __webpack_require__(393);

var _MdTab2 = _interopRequireDefault(_MdTab);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdTabs2.default.name, _MdTabs2.default);
  Vue.component(_MdTab2.default.name, _MdTab2.default);
};

/***/ }),
/* 390 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTabs/MdTabs.vue
var MdTabs = __webpack_require__(392);
var MdTabs_default = /*#__PURE__*/__webpack_require__.n(MdTabs);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-733c1bef","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTabs/MdTabs.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "md-tabs", class: [_vm.tabsClasses, _vm.$mdActiveTheme] },
    [
      _c(
        "div",
        {
          ref: "navigation",
          staticClass: "md-tabs-navigation",
          class: _vm.navigationClasses
        },
        [
          _vm._l(_vm.MdTabs.items, function(ref, index) {
            var label = ref.label
            var props = ref.props
            var icon = ref.icon
            var disabled = ref.disabled
            var data = ref.data
            var events = ref.events
            return _c(
              "md-button",
              _vm._g(
                _vm._b(
                  {
                    key: index,
                    class: {
                      "md-active": index === _vm.activeTab,
                      "md-icon-label": icon && label
                    },
                    attrs: { disabled: disabled },
                    nativeOn: {
                      click: function($event) {
                        _vm.setActiveTab(index)
                      }
                    }
                  },
                  "md-button",
                  props,
                  false
                ),
                events
              ),
              [
                _vm.$scopedSlots["md-tab"]
                  ? _vm._t("md-tab", null, {
                      tab: { label: label, icon: icon, data: data }
                    })
                  : [
                      !icon
                        ? [_vm._v(_vm._s(label))]
                        : [
                            _vm.isAssetIcon(icon)
                              ? _c("md-icon", {
                                  staticClass: "md-tab-icon",
                                  attrs: { "md-src": icon }
                                })
                              : _c("md-icon", { staticClass: "md-tab-icon" }, [
                                  _vm._v(_vm._s(icon))
                                ]),
                            _vm._v(" "),
                            _c("span", { staticClass: "md-tab-label" }, [
                              _vm._v(_vm._s(label))
                            ])
                          ]
                    ]
              ],
              2
            )
          }),
          _vm._v(" "),
          _c("span", {
            ref: "indicator",
            staticClass: "md-tabs-indicator",
            class: _vm.indicatorClass,
            style: _vm.indicatorStyles
          })
        ],
        2
      ),
      _vm._v(" "),
      _c(
        "md-content",
        {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.hasContent,
              expression: "hasContent"
            }
          ],
          staticClass: "md-tabs-content",
          style: _vm.contentStyles
        },
        [
          _c(
            "div",
            { staticClass: "md-tabs-container", style: _vm.containerStyles },
            [_vm._t("default")],
            2
          )
        ]
      )
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTabs_MdTabs = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-733c1bef", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTabs/MdTabs.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(391)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTabs_default.a,
  MdTabs_MdTabs,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTabs/MdTabs.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-733c1bef", Component.options)
  } else {
    hotAPI.reload("data-v-733c1bef", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTabs_MdTabs = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 391 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdAssetIcon = __webpack_require__(18);

var _MdAssetIcon2 = _interopRequireDefault(_MdAssetIcon);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdObserveElement = __webpack_require__(26);

var _MdObserveElement2 = _interopRequireDefault(_MdObserveElement);

var _MdContent = __webpack_require__(35);

var _MdContent2 = _interopRequireDefault(_MdContent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = new _MdComponent2.default({
  name: 'MdTabs',
  mixins: [_MdAssetIcon2.default],
  components: {
    MdContent: _MdContent2.default
  },
  props: {
    mdAlignment: _extends({
      type: String,
      default: 'left'
    }, (0, _MdPropValidator2.default)('md-alignment', ['left', 'right', 'centered', 'fixed'])),
    mdElevation: {
      type: [Number, String],
      default: 0
    },
    mdSyncRoute: Boolean,
    mdDynamicHeight: Boolean,
    mdActiveTab: [String, Number]
  },
  data: function data() {
    return {
      resizeObserver: null,
      activeTab: 0,
      activeTabIndex: 0,
      indicatorStyles: {},
      indicatorClass: null,
      noTransition: true,
      containerStyles: {},
      contentStyles: {
        height: '0px'
      },
      hasContent: false,
      MdTabs: {
        items: {}
      },
      alignmentChanging: false
    };
  },
  provide: function provide() {
    return {
      MdTabs: this.MdTabs
    };
  },

  computed: {
    tabsClasses: function tabsClasses() {
      var _ref;

      return _ref = {}, _defineProperty(_ref, 'md-alignment-' + this.mdAlignment, true), _defineProperty(_ref, 'md-no-transition', this.noTransition), _defineProperty(_ref, 'md-dynamic-height', this.mdDynamicHeight), _ref;
    },
    navigationClasses: function navigationClasses() {
      return 'md-elevation-' + this.mdElevation;
    }
  },
  watch: {
    MdTabs: {
      deep: true,
      handler: function handler() {
        this.setHasContent();
      }
    },
    activeTab: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.$nextTick();

              case 2:
                this.setIndicatorStyles();
                this.setActiveTabIndex();
                this.calculateTabPos();

              case 5:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function activeTab() {
        return _ref2.apply(this, arguments);
      }

      return activeTab;
    }(),
    mdActiveTab: function mdActiveTab(tab) {
      this.activeTab = tab;
      this.$emit('md-changed', tab);
    },
    mdAlignment: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this = this;

        var cb;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.alignmentChanging) {
                  _context2.next = 2;
                  break;
                }

                return _context2.abrupt('return', false);

              case 2:

                this.alignmentChanging = true;
                _context2.next = 5;
                return this.$nextTick();

              case 5:
                cb = function cb(event) {
                  if (event.propertyName !== 'min-width') {
                    return false;
                  }

                  _this.$refs.navigation.removeEventListener('transitionend', cb);
                  _this.setIndicatorStyles();
                  _this.alignmentChanging = false;
                };

                this.$refs.navigation.addEventListener('transitionend', cb);

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function mdAlignment() {
        return _ref3.apply(this, arguments);
      }

      return mdAlignment;
    }()
  },
  methods: {
    hasActiveTab: function hasActiveTab() {
      return this.activeTab || this.mdActiveTab;
    },
    getItemsAndKeys: function getItemsAndKeys() {
      var items = this.MdTabs.items;

      return {
        items: items,
        keys: Object.keys(items)
      };
    },
    setActiveTab: function setActiveTab(index) {
      this.activeTab = index;
      this.$emit('md-changed', index);
    },
    setActiveTabIndex: function setActiveTabIndex() {
      var activeButton = this.$el.querySelector('.md-button.md-active');

      if (activeButton) {
        this.activeTabIndex = [].indexOf.call(activeButton.parentNode.childNodes, activeButton);
      }
    },
    setActiveTabByIndex: function setActiveTabByIndex(index) {
      var _getItemsAndKeys = this.getItemsAndKeys(),
          keys = _getItemsAndKeys.keys;

      if (!this.hasActiveTab()) {
        this.activeTab = keys[index];
      }
    },
    setActiveTabByRoute: function setActiveTabByRoute() {
      var _this2 = this;

      var _getItemsAndKeys2 = this.getItemsAndKeys(),
          items = _getItemsAndKeys2.items,
          keys = _getItemsAndKeys2.keys;

      var tabIndex = null;

      if (this.$router) {
        keys.forEach(function (key, index) {
          var item = items[key];
          var toProp = item.props.to;

          if (toProp && toProp === _this2.$route.path) {
            tabIndex = index;
          }
        });
      }

      if (!this.hasActiveTab() && !tabIndex) {
        this.activeTab = keys[0];
      } else {
        this.activeTab = keys[tabIndex];
      }
    },
    setHasContent: function setHasContent() {
      var _getItemsAndKeys3 = this.getItemsAndKeys(),
          items = _getItemsAndKeys3.items,
          keys = _getItemsAndKeys3.keys;

      this.hasContent = keys.some(function (key) {
        return items[key].hasContent;
      });
    },
    setIndicatorStyles: function setIndicatorStyles() {
      var _this3 = this;

      window.requestAnimationFrame(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
        var activeButton, buttonWidth, buttonLeft, indicatorLeft;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this3.$nextTick();

              case 2:
                activeButton = _this3.$el.querySelector('.md-button.md-active');


                if (activeButton && _this3.$refs.indicator) {
                  buttonWidth = activeButton.offsetWidth;
                  buttonLeft = activeButton.offsetLeft;
                  indicatorLeft = _this3.$refs.indicator.offsetLeft;


                  if (indicatorLeft < buttonLeft) {
                    _this3.indicatorClass = 'md-tabs-indicator-right';
                  } else {
                    _this3.indicatorClass = 'md-tabs-indicator-left';
                  }

                  _this3.indicatorStyles = {
                    left: buttonLeft + 'px',
                    width: buttonWidth + 'px'
                  };
                }

              case 4:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, _this3);
      })));
    },
    calculateTabPos: function calculateTabPos() {
      if (this.hasContent) {
        var tabElement = this.$el.querySelector('.md-tab:nth-child(' + (this.activeTabIndex + 1) + ')');

        this.contentStyles = {
          height: tabElement.offsetHeight + 'px'
        };

        this.containerStyles = {
          transform: 'translate3D(' + -this.activeTabIndex * 100 + '%, 0, 0)'
        };
      }
    },
    setupObservers: function setupObservers() {
      var _this4 = this;

      if ('ResizeObserver' in window) {
        this.resizeObserver = new window.ResizeObserver(this.setIndicatorStyles);
        this.resizeObserver.observe(this.$el);
      } else {
        this.resizeObserver = (0, _MdObserveElement2.default)(this.$el.querySelector('.md-tabs-content'), {
          childList: true,
          characterData: true,
          subtree: true
        }, function () {
          _this4.setIndicatorStyles();
          _this4.calculateTabPos();
        });

        window.addEventListener('resize', this.setIndicatorStyles);
      }
    },
    setupWatchers: function setupWatchers() {
      if (this.mdSyncRoute) {
        this.$watch('$route', {
          deep: true,
          handler: function handler() {
            if (this.mdSyncRoute) {
              this.setActiveTabByRoute();
            }
          }
        });
      }
    }
  },
  created: function created() {
    this.setHasContent();
    this.activeTab = this.mdActiveTab;
  },
  mounted: function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var _this5 = this;

      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.$nextTick();

            case 2:

              if (this.mdSyncRoute) {
                this.setActiveTabByRoute();
              } else {
                this.setActiveTabByIndex(0);
              }

              _context4.next = 5;
              return this.$nextTick();

            case 5:

              this.setActiveTabIndex();
              this.calculateTabPos();

              window.setTimeout(function () {
                _this5.noTransition = false;
                _this5.setupObservers();
                _this5.setupWatchers();
              }, 100);

            case 8:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function mounted() {
      return _ref5.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    window.removeEventListener('resize', this.setIndicatorStyles);
  }
});

/***/ }),
/* 393 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTab_vue__ = __webpack_require__(394);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTab_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTab_vue__);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_bustCache_MdTab_vue___default.a,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTabs/MdTab.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4b620898", Component.options)
  } else {
    hotAPI.reload("data-v-4b620898", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _MdUuid = __webpack_require__(6);

var _MdUuid2 = _interopRequireDefault(_MdUuid);

var _MdObserveElement = __webpack_require__(26);

var _MdObserveElement2 = _interopRequireDefault(_MdObserveElement);

var _MdRouterLinkProps = __webpack_require__(12);

var _MdRouterLinkProps2 = _interopRequireDefault(_MdRouterLinkProps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'MdTab',
  props: {
    id: {
      type: String,
      default: function _default() {
        return 'md-tab-' + (0, _MdUuid2.default)();
      }
    },
    href: [String, Number],
    to: null,
    mdDisabled: Boolean,
    mdLabel: [String, Number],
    mdIcon: String,
    mdTemplateData: {
      type: Object,
      default: function _default() {
        return {};
      }
    }
  },
  inject: ['MdTabs'],
  data: function data() {
    return {
      observer: null
    };
  },
  watch: {
    $props: {
      deep: true,
      handler: function handler() {
        this.setTabData();
      }
    },
    $attrs: {
      deep: true,
      handler: function handler() {
        this.setTabData();
      }
    }
  },
  methods: {
    setTabContent: function setTabContent() {
      this.$set(this.MdTabs.items[this.id], 'hasContent', !!this.$slots.default);
    },
    setupObserver: function setupObserver() {
      this.observer = (0, _MdObserveElement2.default)(this.$el, {
        childList: true
      }, this.setTabContent);
    },
    setTabData: function setTabData() {
      this.$set(this.MdTabs.items, this.id, {
        hasContent: !!this.$slots.default,
        label: this.mdLabel,
        icon: this.mdIcon,
        disabled: this.mdDisabled,
        data: this.mdTemplateData,
        props: this.getPropValues(),
        events: this.$listeners
      });
    },
    getPropValues: function getPropValues() {
      var _this = this;

      var propNames = Object.keys(this.$options.props);
      var ignoredProps = ['id', 'mdLabel', 'mdDisabled', 'mdTemplateData'];
      var values = {};

      propNames.forEach(function (prop) {
        if (!ignoredProps.includes(prop)) {
          if (_this[prop]) {
            values[prop] = _this[prop];
          } else if (_this.$attrs.hasOwnProperty(prop)) {
            if (prop) {
              values[prop] = _this.$attrs[prop];
            } else {
              values[prop] = true;
            }
          }
        }
      });

      return values;
    }
  },
  mounted: function mounted() {
    this.setupObserver();
    this.setTabData();
  },
  beforeDestroy: function beforeDestroy() {
    if (this.observer) {
      this.observer.disconnect();
    }

    this.$delete(this.MdTabs.items, this.id);
  },
  render: function render(createElement) {
    var tabAttrs = {
      staticClass: 'md-tab',
      attrs: _extends({}, this.$attrs, {
        id: this.id
      }),
      on: this.$listeners
    };

    if (this.href) {
      this.buttonProps = this.$options.props;
    } else if (this.$router && this.to) {
      this.$options.props = (0, _MdRouterLinkProps2.default)(this, this.$options.props);

      tabAttrs.props = this.$props;
    }

    return createElement('div', tabAttrs, this.$slots.default);
  }
};

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdToolbar = __webpack_require__(53);

var _MdToolbar2 = _interopRequireDefault(_MdToolbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdToolbar2.default.name, _MdToolbar2.default);
};

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _material = __webpack_require__(1);

var _material2 = _interopRequireDefault(_material);

var _MdTooltip = __webpack_require__(397);

var _MdTooltip2 = _interopRequireDefault(_MdTooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (Vue) {
  (0, _material2.default)(Vue);
  Vue.component(_MdTooltip2.default.name, _MdTooltip2.default);
};

/***/ }),
/* 397 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./src/components/MdTooltip/MdTooltip.vue
var MdTooltip = __webpack_require__(399);
var MdTooltip_default = /*#__PURE__*/__webpack_require__.n(MdTooltip);

// CONCATENATED MODULE: ./node_modules/vue-loader/lib/template-compiler?{"id":"data-v-03252be9","hasScoped":false,"buble":{"transforms":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./src/components/MdTooltip/MdTooltip.vue
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "md-popover",
    {
      attrs: {
        "md-settings": _vm.popperSettings,
        "md-active": _vm.shouldRender
      }
    },
    [
      _vm.shouldRender
        ? _c("transition", { attrs: { name: "md-tooltip" } }, [
            _c(
              "div",
              {
                staticClass: "md-tooltip",
                class: [_vm.tooltipClasses, _vm.$mdActiveTheme],
                style: _vm.tooltipStyles
              },
              [_vm._t("default")],
              2
            )
          ])
        : _vm._e()
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ var MdTooltip_MdTooltip = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-03252be9", esExports)
  }
}
// CONCATENATED MODULE: ./src/components/MdTooltip/MdTooltip.vue
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(398)
}
var normalizeComponent = __webpack_require__(0)
/* script */

/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  MdTooltip_default.a,
  MdTooltip_MdTooltip,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "src/components/MdTooltip/MdTooltip.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-03252be9", Component.options)
  } else {
    hotAPI.reload("data-v-03252be9", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ var components_MdTooltip_MdTooltip = __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 398 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//

var _MdComponent = __webpack_require__(2);

var _MdComponent2 = _interopRequireDefault(_MdComponent);

var _MdPropValidator = __webpack_require__(4);

var _MdPropValidator2 = _interopRequireDefault(_MdPropValidator);

var _MdPopover = __webpack_require__(25);

var _MdPopover2 = _interopRequireDefault(_MdPopover);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = new _MdComponent2.default({
  name: 'MdTooltip',
  components: {
    MdPopover: _MdPopover2.default
  },
  props: {
    mdActive: Boolean,
    mdDelay: {
      type: [String, Number],
      default: 0
    },
    mdDirection: _extends({
      type: String,
      default: 'bottom'
    }, (0, _MdPropValidator2.default)('md-direction', ['top', 'right', 'bottom', 'left']))
  },
  data: function data() {
    return {
      shouldRender: false,
      targetEl: null
    };
  },
  computed: {
    tooltipClasses: function tooltipClasses() {
      return 'md-tooltip-' + this.mdDirection;
    },
    tooltipStyles: function tooltipStyles() {
      return 'transition-delay: ' + this.mdDelay + 'ms';
    },
    popperSettings: function popperSettings() {
      return {
        placement: this.mdDirection,
        modifiers: {
          offset: {
            offset: '0, 16'
          }
        }
      };
    }
  },
  watch: {
    mdActive: function mdActive() {
      this.shouldRender = this.mdActive;
    },
    shouldRender: function shouldRender(_shouldRender) {
      this.$emit('update:mdActive', _shouldRender);
    }
  },
  methods: {
    show: function show() {
      this.shouldRender = true;
    },
    hide: function hide() {
      this.shouldRender = false;
    }
  },
  mounted: function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.$nextTick();

            case 2:

              this.shouldRender = this.mdActive;
              this.targetEl = this._vnode.componentInstance.originalParentEl;

              if (this.targetEl) {
                this.targetEl.addEventListener('mouseenter', this.show, false);
                this.targetEl.addEventListener('mouseleave', this.hide, false);
              }

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function mounted() {
      return _ref.apply(this, arguments);
    }

    return mounted;
  }(),
  beforeDestroy: function beforeDestroy() {
    if (this.targetEl) {
      this.targetEl.removeEventListener('mouseenter', this.show);
      this.targetEl.removeEventListener('mouseleave', this.hide);
    }
  }
});

/***/ })
/******/ ]);
});
},{"vue":"vue","vue-hot-reload-api":13}],15:[function(require,module,exports){
/**
  * vue-router v3.0.1
  * (c) 2017 Evan You
  * @license MIT
  */
'use strict';

/*  */

function assert (condition, message) {
  if (!condition) {
    throw new Error(("[vue-router] " + message))
  }
}

function warn (condition, message) {
  if ("production" !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
  }
}

function isError (err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render (_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children)
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h()
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (
        (val && current !== vm) ||
        (!val && current === vm)
      ) {
        matched.instances[name] = val;
      }
    }

    // also register instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);
    if (propsToPass) {
      // clone to prevent mutation
      propsToPass = data.props = extend({}, propsToPass);
      // pass non-declared props as attrs
      var attrs = data.attrs = data.attrs || {};
      for (var key in propsToPass) {
        if (!component.props || !(key in component.props)) {
          attrs[key] = propsToPass[key];
          delete propsToPass[key];
        }
      }
    }

    return h(component, data, children)
  }
};

function resolveProps (route, config) {
  switch (typeof config) {
    case 'undefined':
      return
    case 'object':
      return config
    case 'function':
      return config(route)
    case 'boolean':
      return config ? route.params : undefined
    default:
      if ("production" !== 'production') {
        warn(
          false,
          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
          "expecting an object, function or boolean."
        );
      }
  }
}

function extend (to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function (str) { return encodeURIComponent(str)
  .replace(encodeReserveRE, encodeReserveReplacer)
  .replace(commaRE, ','); };

var decode = decodeURIComponent;

function resolveQuery (
  query,
  extraQuery,
  _parseQuery
) {
  if ( extraQuery === void 0 ) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "production" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    parsedQuery[key] = extraQuery[key];
  }
  return parsedQuery
}

function parseQuery (query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0
      ? decode(parts.join('='))
      : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res
}

function stringifyQuery (obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return ''
    }

    if (val === null) {
      return encode(key)
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&')
    }

    return encode(key) + '=' + encode(val)
  }).filter(function (x) { return x.length > 0; }).join('&') : null;
  return res ? ("?" + res) : ''
}

/*  */


var trailingSlashRE = /\/?$/;

function createRoute (
  record,
  location,
  redirectedFrom,
  router
) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;

  var query = location.query || {};
  try {
    query = clone(query);
  } catch (e) {}

  var route = {
    name: location.name || (record && record.name),
    meta: (record && record.meta) || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: query,
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route)
}

function clone (value) {
  if (Array.isArray(value)) {
    return value.map(clone)
  } else if (value && typeof value === 'object') {
    var res = {};
    for (var key in value) {
      res[key] = clone(value[key]);
    }
    return res
  } else {
    return value
  }
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch (record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res
}

function getFullPath (
  ref,
  _stringifyQuery
) {
  var path = ref.path;
  var query = ref.query; if ( query === void 0 ) query = {};
  var hash = ref.hash; if ( hash === void 0 ) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash
}

function isSameRoute (a, b) {
  if (b === START) {
    return a === b
  } else if (!b) {
    return false
  } else if (a.path && b.path) {
    return (
      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query)
    )
  } else if (a.name && b.name) {
    return (
      a.name === b.name &&
      a.hash === b.hash &&
      isObjectEqual(a.query, b.query) &&
      isObjectEqual(a.params, b.params)
    )
  } else {
    return false
  }
}

function isObjectEqual (a, b) {
  if ( a === void 0 ) a = {};
  if ( b === void 0 ) b = {};

  // handle null value #1566
  if (!a || !b) { return a === b }
  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if (typeof aVal === 'object' && typeof bVal === 'object') {
      return isObjectEqual(aVal, bVal)
    }
    return String(aVal) === String(bVal)
  })
}

function isIncludedRoute (current, target) {
  return (
    current.path.replace(trailingSlashRE, '/').indexOf(
      target.path.replace(trailingSlashRE, '/')
    ) === 0 &&
    (!target.hash || current.hash === target.hash) &&
    queryIncludes(current.query, target.query)
  )
}

function queryIncludes (current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false
    }
  }
  return true
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render (h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null
            ? 'router-link-active'
            : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null
            ? 'router-link-exact-active'
            : globalExactActiveClass;
    var activeClass = this.activeClass == null
            ? activeClassFallback
            : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null
            ? exactActiveClassFallback
            : this.exactActiveClass;
    var compareTarget = location.path
      ? createRoute(null, location, null, router)
      : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact
      ? classes[exactActiveClass]
      : isIncludedRoute(current, compareTarget);

    var handler = function (e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) { on[e] = handler; });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default)
  }
};

function guardEvent (e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) { return }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) { return }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) { return }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true
}

function findAnchor (children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child
      }
    }
  }
}

var _Vue;

function install (Vue) {
  if (install.installed && _Vue === Vue) { return }
  install.installed = true;

  _Vue = Vue;

  var isDef = function (v) { return v !== undefined; };

  var registerInstance = function (vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate () {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed () {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get () { return this._routerRoot._router }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get () { return this._routerRoot._route }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath (
  relative,
  base,
  append
) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/')
}

function parsePath (path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  }
}

function cleanPath (path) {
  return path.replace(/\/\//g, '/')
}

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options);
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*  */

// $flow-disable-line
var regexpCompileCache = Object.create(null);

function fillParams (
  path,
  params,
  routeMsg
) {
  try {
    var filler =
      regexpCompileCache[path] ||
      (regexpCompileCache[path] = pathToRegexp_1.compile(path));
    return filler(params || {}, { pretty: true })
  } catch (e) {
    if ("production" !== 'production') {
      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
    }
    return ''
  }
}

/*  */

function createRouteMap (
  routes,
  oldPathList,
  oldPathMap,
  oldNameMap
) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  // $flow-disable-line
  var pathMap = oldPathMap || Object.create(null);
  // $flow-disable-line
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  }
}

function addRouteRecord (
  pathList,
  pathMap,
  nameMap,
  route,
  parent,
  matchAs
) {
  var path = route.path;
  var name = route.name;
  if ("production" !== 'production') {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(
      typeof route.component !== 'string',
      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
      "string id. Use an actual component instead."
    );
  }

  var pathToRegexpOptions = route.pathToRegexpOptions || {};
  var normalizedPath = normalizePath(
    path,
    parent,
    pathToRegexpOptions.strict
  );

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null
      ? {}
      : route.components
        ? route.props
        : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if ("production" !== 'production') {
      if (route.name && !route.redirect && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
        warn(
          false,
          "Named Route '" + (route.name) + "' has a default child route. " +
          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
          "the default child route will not be rendered. Remove the name from " +
          "this route and use the name of the default child route for named " +
          "links instead."
        );
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs
        ? cleanPath((matchAs + "/" + (child.path)))
        : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias)
      ? route.alias
      : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(
        pathList,
        pathMap,
        nameMap,
        aliasRoute,
        parent,
        record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ("production" !== 'production' && !matchAs) {
      warn(
        false,
        "Duplicate named routes definition: " +
        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
      );
    }
  }
}

function compileRouteRegex (path, pathToRegexpOptions) {
  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);
  if ("production" !== 'production') {
    var keys = Object.create(null);
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], ("Duplicate param keys in route with path: \"" + path + "\""));
      keys[key.name] = true;
    });
  }
  return regex
}

function normalizePath (path, parent, strict) {
  if (!strict) { path = path.replace(/\/$/, ''); }
  if (path[0] === '/') { return path }
  if (parent == null) { return path }
  return cleanPath(((parent.path) + "/" + path))
}

/*  */


function normalizeLocation (
  raw,
  current,
  append,
  router
) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, ("path " + (current.path)));
    } else if ("production" !== 'production') {
      warn(false, "relative params navigation requires a current route.");
    }
    return next
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = (current && current.path) || '/';
  var path = parsedPath.path
    ? resolvePath(parsedPath.path, basePath, append || next.append)
    : basePath;

  var query = resolveQuery(
    parsedPath.query,
    next.query,
    router && router.options.parseQuery
  );

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  }
}

function assign (a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a
}

/*  */


function createMatcher (
  routes,
  router
) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes (routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match (
    raw,
    currentRoute,
    redirectedFrom
  ) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if ("production" !== 'production') {
        warn(record, ("Route with name '" + name + "' does not exist"));
      }
      if (!record) { return _createRoute(null, location) }
      var paramNames = record.regex.keys
        .filter(function (key) { return !key.optional; })
        .map(function (key) { return key.name; });

      if (typeof location.params !== 'object') {
        location.params = {};
      }

      if (currentRoute && typeof currentRoute.params === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
        return _createRoute(record, location, redirectedFrom)
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom)
        }
      }
    }
    // no match
    return _createRoute(null, location)
  }

  function redirect (
    record,
    location
  ) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function'
        ? originalRedirect(createRoute(record, location, null, router))
        : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || typeof redirect !== 'object') {
      if ("production" !== 'production') {
        warn(
          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
        );
      }
      return _createRoute(null, location)
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if ("production" !== 'production') {
        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location)
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location)
    } else {
      if ("production" !== 'production') {
        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
      }
      return _createRoute(null, location)
    }
  }

  function alias (
    record,
    location,
    matchAs
  ) {
    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location)
    }
    return _createRoute(null, location)
  }

  function _createRoute (
    record,
    location,
    redirectedFrom
  ) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location)
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs)
    }
    return createRoute(record, location, redirectedFrom, router)
  }

  return {
    match: match,
    addRoutes: addRoutes
  }
}

function matchRoute (
  regex,
  path,
  params
) {
  var m = path.match(regex);

  if (!m) {
    return false
  } else if (!params) {
    return true
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true
}

function resolveRecordPath (path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true)
}

/*  */


var positionStore = Object.create(null);

function setupScroll () {
  // Fix for #1585 for Firefox
  window.history.replaceState({ key: getStateKey() }, '');
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll (
  router,
  to,
  from,
  isPop
) {
  if (!router.app) {
    return
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return
  }

  if ("production" !== 'production') {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);

    if (!shouldScroll) {
      return
    }

    if (typeof shouldScroll.then === 'function') {
      shouldScroll.then(function (shouldScroll) {
        scrollToPosition((shouldScroll), position);
      }).catch(function (err) {
        if ("production" !== 'production') {
          assert(false, err.toString());
        }
      });
    } else {
      scrollToPosition(shouldScroll, position);
    }
  });
}

function saveScrollPosition () {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition () {
  var key = getStateKey();
  if (key) {
    return positionStore[key]
  }
}

function getElementPosition (el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}

function isValidPosition (obj) {
  return isNumber(obj.x) || isNumber(obj.y)
}

function normalizePosition (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  }
}

function normalizeOffset (obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  }
}

function isNumber (v) {
  return typeof v === 'number'
}

function scrollToPosition (shouldScroll, position) {
  var isObject = typeof shouldScroll === 'object';
  if (isObject && typeof shouldScroll.selector === 'string') {
    var el = document.querySelector(shouldScroll.selector);
    if (el) {
      var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};
      offset = normalizeOffset(offset);
      position = getElementPosition(el, offset);
    } else if (isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }
  } else if (isObject && isValidPosition(shouldScroll)) {
    position = normalizePosition(shouldScroll);
  }

  if (position) {
    window.scrollTo(position.x, position.y);
  }
}

/*  */

var supportsPushState = inBrowser && (function () {
  var ua = window.navigator.userAgent;

  if (
    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
    ua.indexOf('Mobile Safari') !== -1 &&
    ua.indexOf('Chrome') === -1 &&
    ua.indexOf('Windows Phone') === -1
  ) {
    return false
  }

  return window.history && 'pushState' in window.history
})();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now
  ? window.performance
  : Date;

var _key = genKey();

function genKey () {
  return Time.now().toFixed(3)
}

function getStateKey () {
  return _key
}

function setStateKey (key) {
  _key = key;
}

function pushState (url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState (url) {
  pushState(url, true);
}

/*  */

function runQueue (queue, fn, cb) {
  var step = function (index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents (matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (isESModule(resolvedDef)) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function'
            ? resolvedDef
            : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "production" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason)
              ? reason
              : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) { next(); }
  }
}

function flatMapComponents (
  matched,
  fn
) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) { return fn(
      m.components[key],
      m.instances[key],
      m, key
    ); })
  }))
}

function flatten (arr) {
  return Array.prototype.concat.apply([], arr)
}

var hasSymbol =
  typeof Symbol === 'function' &&
  typeof Symbol.toStringTag === 'symbol';

function isESModule (obj) {
  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once (fn) {
  var called = false;
  return function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    if (called) { return }
    called = true;
    return fn.apply(this, args)
  }
}

/*  */

var History = function History (router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen (cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady (cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError (errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
    var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) { cb(route); });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
    var this$1 = this;

  var current = this.current;
  var abort = function (err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) { cb(err); });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (
    isSameRoute(route, current) &&
    // in the case the route map has been dynamically appended to
    route.matched.length === current.matched.length
  ) {
    this.ensureURL();
    return abort()
  }

  var ref = resolveQueue(this.current.matched, route.matched);
    var updated = ref.updated;
    var deactivated = ref.deactivated;
    var activated = ref.activated;

  var queue = [].concat(
    // in-component leave guards
    extractLeaveGuards(deactivated),
    // global before hooks
    this.router.beforeHooks,
    // in-component update hooks
    extractUpdateHooks(updated),
    // in-config enter guards
    activated.map(function (m) { return m.beforeEnter; }),
    // async components
    resolveAsyncComponents(activated)
  );

  this.pending = route;
  var iterator = function (hook, next) {
    if (this$1.pending !== route) {
      return abort()
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (
          typeof to === 'string' ||
          (typeof to === 'object' && (
            typeof to.path === 'string' ||
            typeof to.name === 'string'
          ))
        ) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if (typeof to === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function () { return this$1.current === route; };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort()
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) { cb(); });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute (route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase (base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = (baseEl && baseEl.getAttribute('href')) || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '')
}

function resolveQueue (
  current,
  next
) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  }
}

function extractGuards (
  records,
  name,
  bind,
  reverse
) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard)
        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
        : bind(guard, instance, match, key)
    }
  });
  return flatten(reverse ? guards.reverse() : guards)
}

function extractGuard (
  def,
  key
) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key]
}

function extractLeaveGuards (deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
}

function extractUpdateHooks (updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
}

function bindGuard (guard, instance) {
  if (instance) {
    return function boundRouteGuard () {
      return guard.apply(instance, arguments)
    }
  }
}

function extractEnterGuards (
  activated,
  cbs,
  isValid
) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid)
  })
}

function bindEnterGuard (
  guard,
  match,
  key,
  cbs,
  isValid
) {
  return function routeEnterGuard (to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    })
  }
}

function poll (
  cb, // somehow flow cannot infer this is a function
  instances,
  key,
  isValid
) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */


var HTML5History = (function (History$$1) {
  function HTML5History (router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    var initLocation = getLocation(this.base);
    window.addEventListener('popstate', function (e) {
      var current = this$1.current;

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      var location = getLocation(this$1.base);
      if (this$1.current === START && location === initLocation) {
        return
      }

      this$1.transitionTo(location, function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if ( History$$1 ) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go (n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL (push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
    return getLocation(this.base)
  };

  return HTML5History;
}(History));

function getLocation (base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash
}

/*  */


var HashHistory = (function (History$$1) {
  function HashHistory (router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return
    }
    ensureSlash();
  }

  if ( History$$1 ) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners () {
    var this$1 = this;

    var router = this.router;
    var expectScroll = router.options.scrollBehavior;
    var supportsScroll = supportsPushState && expectScroll;

    if (supportsScroll) {
      setupScroll();
    }

    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {
      var current = this$1.current;
      if (!ensureSlash()) {
        return
      }
      this$1.transitionTo(getHash(), function (route) {
        if (supportsScroll) {
          handleScroll(this$1.router, route, current, true);
        }
        if (!supportsPushState) {
          replaceHash(route.fullPath);
        }
      });
    });
  };

  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go (n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL (push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    return getHash()
  };

  return HashHistory;
}(History));

function checkFallback (base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(
      cleanPath(base + '/#' + location)
    );
    return true
  }
}

function ensureSlash () {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true
  }
  replaceHash('/' + path);
  return false
}

function getHash () {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1)
}

function getUrl (path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  return (base + "#" + path)
}

function pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path));
  } else {
    window.location.hash = path;
  }
}

function replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path));
  } else {
    window.location.replace(getUrl(path));
  }
}

/*  */


var AbstractHistory = (function (History$$1) {
  function AbstractHistory (router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go (n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/'
  };

  AbstractHistory.prototype.ensureURL = function ensureURL () {
    // noop
  };

  return AbstractHistory;
}(History));

/*  */

var VueRouter = function VueRouter (options) {
  if ( options === void 0 ) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break
    default:
      if ("production" !== 'production') {
        assert(false, ("invalid mode: " + mode));
      }
  }
};

var prototypeAccessors = { currentRoute: { configurable: true } };

VueRouter.prototype.match = function match (
  raw,
  current,
  redirectedFrom
) {
  return this.matcher.match(raw, current, redirectedFrom)
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current
};

VueRouter.prototype.init = function init (app /* Vue component instance */) {
    var this$1 = this;

  "production" !== 'production' && assert(
    install.installed,
    "not installed. Make sure to call `Vue.use(VueRouter)` " +
    "before creating root instance."
  );

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function () {
      history.setupListeners();
    };
    history.transitionTo(
      history.getCurrentLocation(),
      setupHashListener,
      setupHashListener
    );
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach (fn) {
  return registerHook(this.beforeHooks, fn)
};

VueRouter.prototype.beforeResolve = function beforeResolve (fn) {
  return registerHook(this.resolveHooks, fn)
};

VueRouter.prototype.afterEach = function afterEach (fn) {
  return registerHook(this.afterHooks, fn)
};

VueRouter.prototype.onReady = function onReady (cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError (errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push (location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go (n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back () {
  this.go(-1);
};

VueRouter.prototype.forward = function forward () {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
  var route = to
    ? to.matched
      ? to
      : this.resolve(to).route
    : this.currentRoute;
  if (!route) {
    return []
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key]
    })
  }))
};

VueRouter.prototype.resolve = function resolve (
  to,
  current,
  append
) {
  var location = normalizeLocation(
    to,
    current || this.history.current,
    append,
    this
  );
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  }
};

VueRouter.prototype.addRoutes = function addRoutes (routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties( VueRouter.prototype, prototypeAccessors );

function registerHook (list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) { list.splice(i, 1); }
  }
}

function createHref (base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path
}

VueRouter.install = install;
VueRouter.version = '3.0.1';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

module.exports = VueRouter;

},{}],16:[function(require,module,exports){
var inserted = exports.cache = {}

function noop () {}

exports.insert = function (css) {
  if (inserted[css]) return noop
  inserted[css] = true

  var elem = document.createElement('style')
  elem.setAttribute('type', 'text/css')

  if ('textContent' in elem) {
    elem.textContent = css
  } else {
    elem.styleSheet.cssText = css
  }

  document.getElementsByTagName('head')[0].appendChild(elem)
  return function () {
    document.getElementsByTagName('head')[0].removeChild(elem)
    inserted[css] = false
  }
}

},{}],17:[function(require,module,exports){
module.exports = XMLHttpRequest;

},{}],18:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".no-scroll[data-v-c52d0722] {\n  overflow: hidden;\n}\n.md-layout[data-v-c52d0722] {\n  height: 100%;\n}\n.left-container[data-v-c52d0722] {\n  height: calc(100vh - 64px) !important;\n}\n.admin-left-content[data-v-c52d0722] {\n  height: calc(100vh - 128px) !important;\n  overflow: auto;\n}\n.admin-item-list[data-v-c52d0722] {\n  border: 1px solid #9e9e9e;\n  border-radius: 20px;\n}\n.admin-selected[data-v-c52d0722] {\n  background-color: brown;\n}\n.admin-item-list .md-list-item-content {\n  padding-left: 5px;\n}\n.flip-list-move {\n  transition: transform 0.2s;\n}\n.flip-list-enter-active,\n.flip-list-leave-active {\n  transition: opacity 0.2s;\n}\n.flip-list-enter,\n.flip-list-leave-to {\n  opacity: 0;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventBus = require("../event-bus");

exports.default = {
  name: "AdminCategory",
  components: {},
  props: [],
  data: function data() {
    return {
      current_list: [],
      selected: {}
    };
  },

  methods: {
    btoa: function (_btoa) {
      function btoa(_x) {
        return _btoa.apply(this, arguments);
      }

      btoa.toString = function () {
        return _btoa.toString();
      };

      return btoa;
    }(function (str) {
      return btoa(str);
    }),
    deleteItem: function deleteItem(item, id) {
      if (confirm("confim delete !") == true) {
        this.current_list.splice(id, 1);
        if (this.selected == item) {
          this.selected = {};
        }
        _eventBus.EventBus.$emit("admin-select-item", this.selected);
        _eventBus.EventBus.$emit("update-list");
      }
    },
    selectItem: function selectItem(item) {
      _eventBus.EventBus.$emit("admin-select-item", item);
    },
    upInLst: function upInLst(id) {
      var list = this.current_list;
      var b = list[id];
      list[id] = list[id - 1];
      list[id - 1] = b;
      this.$forceUpdate();
      _eventBus.EventBus.$emit("update-list");
    },
    downInLst: function downInLst(id) {
      var list = this.current_list;
      var b = list[id];
      list[id] = list[id + 1];
      list[id + 1] = b;
      this.$forceUpdate();
      _eventBus.EventBus.$emit("update-list");
    },
    getListen: function getListen() {
      var _this = this;

      _eventBus.EventBus.$on("admin-select-item", function (item) {
        _this.selected = item;
      });
      _eventBus.EventBus.$on("admin-select-list", function (list) {
        _this.current_list = list;
      });
    }
  },
  mounted: function mounted() {
    this.getListen();
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-content',{staticClass:"left-container no-scroll"},[_c('md-toolbar',{staticClass:"app-header"},[_c('h3',[_vm._v("Category")]),_vm._v(" "),_c('div',{staticClass:"md-toolbar-section-end color_black"},[_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.$emit('codeIO-data')}}},[_c('md-tooltip',[_vm._v("Open Json")]),_vm._v(" "),_c('md-icon',[_vm._v("assignment_turned_in")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.$emit('reload-data')}}},[_c('md-tooltip',[_vm._v("Reload from model")]),_vm._v(" "),_c('md-icon',[_vm._v("sync")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.$emit('save-data')}}},[_c('md-tooltip',[_vm._v("Save in model")]),_vm._v(" "),_c('md-icon',[_vm._v("save")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.$emit('admin-create-item')}}},[_c('md-tooltip',[_vm._v("Add Category")]),_vm._v(" "),_c('md-icon',[_vm._v("add")])],1)],1)]),_vm._v(" "),_c('md-content',{staticClass:"md-scrollbar admin-left-content "},[(_vm.current_list.length == 0)?_c('md-empty-state',{attrs:{"md-icon":"cancel","md-label":"Nothing in Category"}},[_c('md-button',{staticClass:"md-primary md-raised",on:{"click":function($event){_vm.$emit('admin-create-item')}}},[_vm._v("Create a category")])],1):_c('transition-group',{staticClass:"md-list-no-padding",attrs:{"name":"flip-list","tag":"md-list"}},_vm._l((_vm.current_list),function(item,id){return _c('md-list-item',{key:item.id,staticClass:"admin-item-list",class:{ 'admin-selected': item == _vm.selected }},[_c('div',[_c('md-button',{staticClass:"md-icon-button md-dense no-margin",attrs:{"disabled":id == 0},on:{"click":function($event){_vm.upInLst(id,item)}}},[_c('md-icon',[_vm._v("expand_less")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button md-dense no-margin",attrs:{"disabled":_vm.current_list.length - 1 == id},on:{"click":function($event){_vm.downInLst(id,item)}}},[_c('md-icon',[_vm._v("expand_more")])],1)],1),_vm._v(" "),_c('div',{staticClass:"md-list-item-text"},[_c('span',[_vm._v("label: "+_vm._s(item.label))]),_vm._v(" "),_c('span',[_vm._v("type : "+_vm._s(item.type))]),_vm._v(" "),_c('p',[_vm._v("target_url: "+_vm._s(item.target_url)+"\n            "),(item.target_url && item.target_url.length > 10)?_c('md-tooltip',[_vm._v(_vm._s(item.target_url))]):_vm._e()],1)]),_vm._v(" "),(item.target_url && item.target_url.length > 0)?_c('md-button',{staticClass:"md-icon-button ",attrs:{"to":_vm.btoa(item.target_url)}},[_c('md-icon',[_vm._v("open_in_new")])],1):_vm._e(),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button ",on:{"click":function($event){_vm.deleteItem(item, id)}}},[_c('md-icon',[_vm._v("delete_forever")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button ",on:{"click":function($event){_vm.selectItem(item)}}},[_c('md-icon',[_vm._v("keyboard_arrow_right")])],1)],1)}))],1)],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-c52d0722"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-c52d0722", __vue__options__)
  } else {
    hotAPI.reload("data-v-c52d0722", __vue__options__)
  }
})()}

},{"../event-bus":37,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],19:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".no-margin[data-v-ff5b5fe4] {\n  margin: 0 !important;\n}\n.admin-item-list[data-v-ff5b5fe4] {\n  border: 1px solid white;\n  border-radius: 20px;\n}\n.admin-selected[data-v-ff5b5fe4] {\n  background-color: brown;\n}\n.category-content-edit[data-v-ff5b5fe4] {\n  padding-bottom: 5px;\n  padding-top: 5px;\n}\n.category-content-edit .md-card-content[data-v-ff5b5fe4] {\n  padding-bottom: 0px;\n  padding-top: 0px;\n}\n.category-content-edit .md-field[data-v-ff5b5fe4] {\n  margin-bottom: 10px;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventBus = require("../event-bus");

var _CreateChild = require("./Modals/CreateChild.vue");

var _CreateChild2 = _interopRequireDefault(_CreateChild);

var _EditChild = require("./Modals/EditChild.vue");

var _EditChild2 = _interopRequireDefault(_EditChild);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "AdminCategoryChildren",
  components: { CreateChildModal: _CreateChild2.default, EditChildModal: _EditChild2.default },
  props: [],
  data: function data() {
    return {
      selected: {},
      childSelected: {},
      openModalAdd: false,
      openModalEdit: false
    };
  },


  methods: {
    deleteItem: function deleteItem(item, id) {
      if (confirm("confim delete !") == true) {
        this.selected.children.splice(id, 1);
        _eventBus.EventBus.$emit("update-children");
      }
    },
    btoa: function (_btoa) {
      function btoa(_x) {
        return _btoa.apply(this, arguments);
      }

      btoa.toString = function () {
        return _btoa.toString();
      };

      return btoa;
    }(function (str) {
      return btoa(str);
    }),
    onNewChild: function onNewChild(child) {
      if (!this.selected.children) this.selected.children = [];
      this.selected.children.push(child);
      this.openModalAdd = false;
      _eventBus.EventBus.$emit("update-children");
    },
    openEditChild: function openEditChild(item) {
      this.childSelected = item;
      this.openModalEdit = true;
    },
    onEditChild: function onEditChild(child) {
      this.childSelected.label = child.label;
      this.childSelected.target_url = child.target_url;
      this.openModalEdit = false;
      _eventBus.EventBus.$emit("update-children");
    },
    upInLst: function upInLst(id) {
      var list = this.selected.children;
      var b = list[id];
      list[id] = list[id - 1];
      list[id - 1] = b;
      this.$forceUpdate();
      _eventBus.EventBus.$emit("update-children");
    },
    downInLst: function downInLst(id) {
      var list = this.selected.children;
      var b = list[id];
      list[id] = list[id + 1];
      list[id + 1] = b;
      this.$forceUpdate();
      _eventBus.EventBus.$emit("update-children");
    }
  },
  mounted: function mounted() {
    var _this = this;

    _eventBus.EventBus.$on("admin-select-item", function (selected) {
      _this.selected = selected;
    });
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-content',[_c('CreateChildModal',{attrs:{"openModalAdd":_vm.openModalAdd,"value":_vm.selected},on:{"closeModal":function($event){_vm.openModalAdd = false},"input":_vm.onNewChild}}),_vm._v(" "),_c('EditChildModal',{attrs:{"openModalEdit":_vm.openModalEdit,"value":_vm.childSelected},on:{"closeModal":function($event){_vm.openModalEdit = false},"input":_vm.onEditChild}}),_vm._v(" "),_c('md-toolbar',{staticClass:"app-header"},[_c('h3',[_vm._v("Category Content Children")]),_vm._v(" "),_c('div',{staticClass:"md-toolbar-section-end color_black"},[(_vm.selected.type === 'item')?_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.openModalAdd = true}}},[_c('md-tooltip',[_vm._v("Add Child")]),_vm._v(" "),_c('md-icon',[_vm._v("add")])],1):_vm._e()],1)]),_vm._v(" "),(_vm.selected.children)?_c('md-content',{staticClass:"my_content"},[_c('transition-group',{staticClass:"md-list-no-padding",attrs:{"name":"flip-list","tag":"md-list"}},_vm._l((_vm.selected.children),function(item,id){return _c('md-list-item',{key:item.label,staticClass:"admin-item-list",class:{ 'admin-selected': item == _vm.selected }},[_c('div',[_c('md-button',{staticClass:"md-icon-button md-dense no-margin",attrs:{"disabled":id == 0},on:{"click":function($event){_vm.upInLst(id)}}},[_c('md-icon',[_vm._v("expand_less")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button md-dense no-margin",attrs:{"disabled":_vm.selected.children.length - 1 == id},on:{"click":function($event){_vm.downInLst(id)}}},[_c('md-icon',[_vm._v("expand_more")])],1)],1),_vm._v(" "),_c('div',{staticClass:"md-list-item-text"},[_c('span',[_vm._v("label: "+_vm._s(item.label))]),_vm._v(" "),_c('p',[_vm._v("target_url: "+_vm._s(item.target_url))])]),_vm._v(" "),(item.target_url && item.target_url.length > 0)?_c('md-button',{staticClass:"md-icon-button ",attrs:{"to":_vm.btoa(item.target_url)}},[_c('md-icon',[_vm._v("open_in_new")])],1):_vm._e(),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button ",on:{"click":function($event){_vm.deleteItem(item, id)}}},[_c('md-icon',[_vm._v("delete_forever")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button ",on:{"click":function($event){_vm.openEditChild(item)}}},[_c('md-icon',[_vm._v("edit")])],1)],1)}))],1):_vm._e()],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-ff5b5fe4"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ff5b5fe4", __vue__options__)
  } else {
    hotAPI.reload("data-v-ff5b5fe4", __vue__options__)
  }
})()}

},{"../event-bus":37,"./Modals/CreateChild.vue":25,"./Modals/EditChild.vue":26,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],20:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".slide-fade-enter-active {\n  transition: all 0.3s ease;\n}\n.slide-fade-leave-active {\n  transition: all 0.3s cubic-bezier(1, 0.5, 0.8, 1);\n}\n.slide-fade-enter,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n.category-content-container[data-v-78ec70ba] {\n  height: calc(100vh - 64px) !important;\n  overflow: auto;\n}\n.my_content[data-v-78ec70ba] {\n  border: 1px solid red;\n}\n.admin-item-list[data-v-78ec70ba] {\n  border: 1px solid white;\n  border-radius: 20px;\n}\n.admin-selected[data-v-78ec70ba] {\n  background-color: brown;\n}\n.category-content-edit[data-v-78ec70ba] {\n  padding-bottom: 5px;\n  padding-top: 5px;\n}\n.category-content-edit .md-card-content[data-v-78ec70ba] {\n  padding-bottom: 0px;\n  padding-top: 0px;\n}\n.category-content-edit .md-field[data-v-78ec70ba] {\n  margin-bottom: 10px;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AdminCategoryChildren = require("./AdminCategoryChildren.vue");

var _AdminCategoryChildren2 = _interopRequireDefault(_AdminCategoryChildren);

var _eventBus = require("../event-bus");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debounce = require("lodash.debounce");

exports.default = {
  name: "AdminCategoryContent",
  components: { AdminCategoryChildren: _AdminCategoryChildren2.default },
  props: [],
  data: function data() {
    return {
      selected: {},
      editContent: false
    };
  },

  computed: {
    selectedType: {
      get: function get() {
        return this.selected.type;
      },
      set: function set(result) {
        this.selected.type = result;
        this.onUpdateChildren();
      }
    },
    selectedLabel: {
      get: function get() {
        return this.selected.label;
      },
      set: function set(result) {
        this.selected.label = result;
        this.onUpdateChildren();
      }
    },
    selectedTarget_url: {
      get: function get() {
        return this.selected.target_url;
      },
      set: function set(result) {
        this.selected.target_url = result;
        this.onUpdateChildren();
      }
    }
  },
  methods: {
    btoa: function (_btoa) {
      function btoa(_x) {
        return _btoa.apply(this, arguments);
      }

      btoa.toString = function () {
        return _btoa.toString();
      };

      return btoa;
    }(function (str) {
      return btoa(str);
    }),
    toggleModal: function toggleModal() {
      this.$emit("admin-create-item");
    },
    onUpdateChildren: debounce(function () {
      _eventBus.EventBus.$emit("update-children");
    }, 1000)
  },
  mounted: function mounted() {
    var _this = this;

    _eventBus.EventBus.$on("admin-select-item", function (selected) {
      _this.selected = selected;
    });
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-content',{staticClass:"md-scrollbar category-content-container",attrs:{"md-dynamic-height":""}},[_c('md-toolbar',{staticClass:"app-header"},[_c('div',{staticClass:"md-list-item-text"},[_c('span',[_vm._v("label: "+_vm._s(_vm.selected.label))]),_vm._v(" "),_c('span',[_vm._v("type : "+_vm._s(_vm.selected.type))]),_vm._v(" "),_c('p',[_vm._v("target_url: "+_vm._s(_vm.selected.target_url)+"\n        "),(_vm.selected.target_url && _vm.selected.target_url.length > 10)?_c('md-tooltip',[_vm._v(_vm._s(_vm.selected.target_url))]):_vm._e()],1)]),_vm._v(" "),_c('div',{staticClass:"md-toolbar-section-end color_black"},[_c('h3',[_vm._v("Content")]),_vm._v(" "),_c('md-button',{staticClass:"md-icon-button",on:{"click":function($event){_vm.editContent = !_vm.editContent}}},[_c('md-tooltip',[_vm._v("Add Child")]),_vm._v(" "),_c('md-icon',[_vm._v("edit")])],1),_vm._v(" "),(_vm.selected.target_url && _vm.selected.target_url.length > 0)?_c('md-button',{staticClass:"md-icon-button ",attrs:{"to":_vm.btoa(_vm.selected.target_url)}},[_c('md-icon',[_vm._v("open_in_new")])],1):_vm._e()],1)]),_vm._v(" "),_c('transition',{attrs:{"name":"slide-fade"}},[(_vm.editContent)?_c('md-content',{staticClass:"category-content-edit",attrs:{"md-elevation":"1"}},[(!_vm.selected.type)?_c('md-card-content',[_c('md-empty-state',{attrs:{"md-icon":"cancel","md-label":"Nothing Selected"}})],1):_c('md-card-content',[_c('md-field',[_c('label',{attrs:{"for":"type"}},[_vm._v("Type")]),_vm._v(" "),_c('md-select',{model:{value:(_vm.selectedType),callback:function ($$v) {_vm.selectedType=$$v},expression:"selectedType"}},[_c('md-option',{attrs:{"value":"item"}},[_vm._v("item")]),_vm._v(" "),_c('md-option',{attrs:{"value":"subheader"}},[_vm._v("subheader")]),_vm._v(" "),_c('md-option',{attrs:{"value":"divider"}},[_vm._v("divider")])],1)],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("Label")]),_vm._v(" "),_c('md-input',{model:{value:(_vm.selectedLabel),callback:function ($$v) {_vm.selectedLabel=$$v},expression:"selectedLabel"}})],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("Target Url")]),_vm._v(" "),_c('md-input',{model:{value:(_vm.selectedTarget_url),callback:function ($$v) {_vm.selectedTarget_url=$$v},expression:"selectedTarget_url"}})],1)],1)],1):_vm._e()],1),_vm._v(" "),_c('AdminCategoryChildren',{on:{"update-children":_vm.onUpdateChildren}})],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-78ec70ba"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-78ec70ba", __vue__options__)
  } else {
    hotAPI.reload("data-v-78ec70ba", __vue__options__)
  }
})()}

},{"../event-bus":37,"./AdminCategoryChildren.vue":19,"lodash.debounce":1,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],21:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".layout-item[data-v-ec3230d0] {\n  height: calc(100vh - 64px) !important;\n  overflow: auto;\n  border: 1px solid #9e9e9e;\n}\n.layout-item-no-scroll[data-v-ec3230d0] {\n  height: calc(100vh - 64px) !important;\n  overflow: hidden;\n  border: 1px solid #9e9e9e;\n}\n\n/* .md-layout {\n} */")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AdminCategory = require("./AdminCategory.vue");

var _AdminCategory2 = _interopRequireDefault(_AdminCategory);

var _AdminCategoryContent = require("./AdminCategoryContent.vue");

var _AdminCategoryContent2 = _interopRequireDefault(_AdminCategoryContent);

var _MainContent = require("../MainContent/MainContent.vue");

var _MainContent2 = _interopRequireDefault(_MainContent);

var _CreateCategory = require("./Modals/CreateCategory.vue");

var _CreateCategory2 = _interopRequireDefault(_CreateCategory);

var _CodeIO = require("./Modals/CodeIO.vue");

var _CodeIO2 = _interopRequireDefault(_CodeIO);

var _eventBus = require("../event-bus");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id = 0;

exports.default = {
  name: "AdminContent",
  components: {
    AdminCategory: _AdminCategory2.default,
    AdminCategoryContent: _AdminCategoryContent2.default,
    MainContent: _MainContent2.default,
    CreateCategoryModal: _CreateCategory2.default,
    CodeIO: _CodeIO2.default
  },
  data: function data() {
    return {
      list: [],
      selectedItem: {},
      openCreateCategoryModal: false,
      openCodeIO: false
    };
  },

  methods: {
    onItemSelected: function onItemSelected(item) {
      this.selectedItem = item;
    },
    onUpdateList: function onUpdateList(list) {
      this.list = list;
      this.selectedItem = {};
      _eventBus.EventBus.$emit("admin-select-list", this.list);
      _eventBus.EventBus.$emit("admin-select-item", this.selectedItem);
    },
    onUpdateChildren: function onUpdateChildren() {
      this.$forceUpdate();
    },
    onNewCategory: function onNewCategory(category) {
      this.list.push({
        label: category.label,
        type: category.type,
        target_url: category.target_url,
        id: ++id
      });
      _eventBus.EventBus.$emit("update-list");
    },
    onSave: function onSave() {
      var vm = this;
      window.spinal.spinalSystem.getModel().then(function (model) {
        model.set(vm.list);
        _eventBus.EventBus.$emit("UPDATE-MODEL", model);
      });
    },
    getMaxId: function getMaxId(lst) {
      var max = 0;
      for (var i = 0; i < lst.length; i++) {
        if (lst[i].id) max = lst[i].id > max ? lst[i].id : max;
      }
      return max;
    },
    onReload: function onReload() {
      var _this = this;

      var vm = this;
      window.spinal.spinalSystem.getModel().then(function (model) {
        vm.list = model.get();
        id = _this.getMaxId(vm.list);
        vm.selectedItem = {};
        _eventBus.EventBus.$emit("admin-select-list", vm.list);
        _eventBus.EventBus.$emit("admin-select-item", _this.selectedItem);
      });
    }
  },
  mounted: function mounted() {
    this.onReload();
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"md-layout"},[_c('CreateCategoryModal',{attrs:{"openModalAdd":_vm.openCreateCategoryModal,"value":_vm.list},on:{"closeModal":function($event){_vm.openCreateCategoryModal = false},"input":_vm.onNewCategory}}),_vm._v(" "),_c('CodeIO',{attrs:{"openCodeIO":_vm.openCodeIO,"list":_vm.list},on:{"closeModal":function($event){_vm.openCodeIO = false},"updateList":_vm.onUpdateList}}),_vm._v(" "),_c('AdminCategory',{staticClass:"md-layout-item md-size-33 layout-item-no-scroll",on:{"save-data":_vm.onSave,"reload-data":_vm.onReload,"codeIO-data":function($event){_vm.openCodeIO = true},"admin-create-item":function($event){_vm.openCreateCategoryModal = !_vm.openCreateCategoryModal}}}),_vm._v(" "),_c('AdminCategoryContent',{staticClass:"md-layout-item md-size-33 layout-item",on:{"update-children":_vm.onUpdateChildren}}),_vm._v(" "),_c('MainContent',{staticClass:"md-layout-item md-size-33 layout-item"})],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-ec3230d0"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ec3230d0", __vue__options__)
  } else {
    hotAPI.reload("data-v-ec3230d0", __vue__options__)
  }
})()}

},{"../MainContent/MainContent.vue":33,"../event-bus":37,"./AdminCategory.vue":18,"./AdminCategoryContent.vue":20,"./Modals/CodeIO.vue":22,"./Modals/CreateCategory.vue":24,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],22:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".md-dialog[data-v-535a8b84] {\n  min-width: 80vw;\n  min-height: 80vh;\n}\n.editor[data-v-535a8b84] {\n  height: calc(80vh - 150px);\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventBus = require("../../event-bus");

var _CodeMonaco = require("./CodeMonaco.js");

var _CodeMonaco2 = _interopRequireDefault(_CodeMonaco);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debounce = require("lodash.debounce");
exports.default = {
  name: "CodeIO",

  components: { MonacoEditor: _CodeMonaco2.default },

  props: ["openCodeIO", "list"],
  data: function data() {
    return {
      str_code: ""
    };
  },

  computed: {
    openModal: {
      get: function get() {
        return this.openCodeIO;
      },
      set: function set() {
        this.$emit("closeModal");
      }
    }
  },
  methods: {
    onCodeChange: function onCodeChange(editor) {
      console.log(editor.getValue());
    },
    onCancel: function onCancel() {
      this.$emit("closeModal");
    },
    save: function save() {
      try {
        var obj = JSON.parse(this.str_code);
        this.$emit("updateList", obj);
      } catch (error) {
        var modelMarkers = window.monaco.editor.getModelMarkers({}).map(function (m) {
          return "Error: (" + m.startLineNumber + "," + m.startColumn + ") " + m.message;
        }).join("\n");
        console.log(modelMarkers);

        alert(modelMarkers);
      }
    }
  },
  mounted: function mounted() {
    var _this = this;

    _eventBus.EventBus.$on(["admin-select-item", "update-children", "update-list"], debounce(function () {
      if (_this.list) _this.str_code = JSON.stringify(_this.list, null, 2);else _this.str_code = "";
    }, 500));
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-dialog',{attrs:{"md-active":_vm.openModal,"md-fullscreen":true},on:{"update:mdActive":function($event){_vm.openModal=$event}}},[_c('md-dialog-title',[_vm._v("Code IO")]),_vm._v(" "),_c('md-dialog-content',[_c('MonacoEditor',{staticClass:"editor",attrs:{"language":"json"},model:{value:(_vm.str_code),callback:function ($$v) {_vm.str_code=$$v},expression:"str_code"}})],1),_vm._v(" "),_c('md-dialog-actions',[_c('md-button',{staticClass:"md-raised md-accent",on:{"click":_vm.onCancel}},[_vm._v("\n       Cancel\n       "),_c('md-icon',[_vm._v("cancel")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-raised md-primary",on:{"click":_vm.save}},[_vm._v("\n       Save\n       "),_c('md-icon',[_vm._v("check")])],1)],1)],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-535a8b84"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-535a8b84", __vue__options__)
  } else {
    hotAPI.reload("data-v-535a8b84", __vue__options__)
  }
})()}

},{"../../event-bus":37,"./CodeMonaco.js":23,"lodash.debounce":1,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _nanoAssign = require("nano-assign");

var _nanoAssign2 = _interopRequireDefault(_nanoAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "MonacoEditor",

  props: {
    value: String,
    theme: {
      type: String,
      default: "vs-dark"
    },
    language: String,
    options: Object,
    placeholder: null,
    require: {
      type: Function,
      default: window.require
    }
  },

  model: {
    event: "change"
  },

  data: function data() {
    return {
      editorLoaded: false
    };
  },


  watch: {
    options: {
      deep: true,
      handler: function handler(options) {
        if (this.editor) {
          this.editor.updateOptions(options);
        }
      }
    },

    value: function value(newValue) {
      if (this.editor) {
        if (newValue !== this.editor.getValue()) {
          this.editor.setValue(newValue);
        }
      }
    },
    language: function language(newVal) {
      if (this.editor) {
        window.monaco.editor.setModelLanguage(this.editor.getModel(), newVal);
      }
    },
    theme: function theme(newVal) {
      if (this.editor) {
        window.monaco.editor.setTheme(newVal);
      }
    }
  },

  mounted: function mounted() {
    var _this = this;

    var options = {
      value: this.value,
      theme: this.theme,
      language: this.language,
      options: this.options
    };
    require("./../../../www/vs/language/json/monaco.contribution.js");
    this.editorLoaded = true;
    this.editor = window.monaco.editor.create(this.$el, options);
    this.$emit("editorMount", this.editor);
    this.editor.onContextMenu(function (event) {
      return _this.$emit("contextMenu", event);
    });
    this.editor.onDidBlurEditor(function () {
      return _this.$emit("blur");
    });
    this.editor.onDidBlurEditorText(function () {
      return _this.$emit("blurText");
    });
    this.editor.onDidChangeConfiguration(function (event) {
      return _this.$emit("configuration", event);
    });
    this.editor.onDidChangeCursorPosition(function (event) {
      return _this.$emit("position", event);
    });
    this.editor.onDidChangeCursorSelection(function (event) {
      return _this.$emit("selection", event);
    });
    this.editor.onDidChangeModel(function (event) {
      return _this.$emit("model", event);
    });
    this.editor.onDidChangeModelContent(function (event) {
      var value = _this.editor.getValue();
      if (_this.value !== value) {
        _this.$emit("change", value, event);
      }
    });
    this.editor.onDidChangeModelDecorations(function (event) {
      return _this.$emit("modelDecorations", event);
    });
    this.editor.onDidChangeModelLanguage(function (event) {
      return _this.$emit("modelLanguage", event);
    });
    this.editor.onDidChangeModelOptions(function (event) {
      return _this.$emit("modelOptions", event);
    });
    this.editor.onDidDispose(function (event) {
      return _this.$emit("afterDispose", event);
    });
    this.editor.onDidFocusEditor(function () {
      return _this.$emit("focus");
    });
    this.editor.onDidFocusEditorText(function () {
      return _this.$emit("focusText");
    });
    this.editor.onDidLayoutChange(function (event) {
      return _this.$emit("layout", event);
    });
    this.editor.onDidScrollChange(function (event) {
      return _this.$emit("scroll", event);
    });
    this.editor.onKeyDown(function (event) {
      return _this.$emit("keydown", event);
    });
    this.editor.onKeyUp(function (event) {
      return _this.$emit("keyup", event);
    });
    this.editor.onMouseDown(function (event) {
      return _this.$emit("mouseDown", event);
    });
    this.editor.onMouseLeave(function (event) {
      return _this.$emit("mouseLeave", event);
    });
    this.editor.onMouseMove(function (event) {
      return _this.$emit("mouseMove", event);
    });
    this.editor.onMouseUp(function (event) {
      return _this.$emit("mouseUp", event);
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.editor && this.editor.dispose();
  },


  methods: {
    getMonaco: function getMonaco() {
      return this.editor;
    },
    focus: function focus() {
      this.editor.focus();
    }
  },

  render: function render(h) {
    return h("div", null, [this.editorLoaded ? null : this.placeholder]);
  }
}; // eslint-disable-next-line no-unused-vars

},{"./../../../www/vs/language/json/monaco.contribution.js":40,"nano-assign":2}],24:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".md-menu-content {\n  z-index: 20;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "CreateCategoryModal",
  props: ["openModalAdd", "value"],
  data: function data() {
    return {
      errors: [],
      type: "item",
      label: "",
      url: ""
    };
  },

  computed: {
    openModal: {
      get: function get() {
        return this.openModalAdd;
      },
      set: function set() {
        this.$emit("closeModal");
      }
    }
  },
  methods: {
    checkForm: function checkForm() {
      if (this.type && this.type === "divider" || this.type && this.type === "subheader" && this.label || this.type && this.type === "item" && this.label) {
        this.check();
        return true;
      }
      this.errors = [];
      if (!this.type) this.errors.push("Type required.");
      if (!this.label) this.errors.push("Label required.");
    },
    isLabelRequired: function isLabelRequired() {
      return this.type === "item";
    },
    onCancel: function onCancel() {
      this.label = "";
      this.url = "";
      this.openModal = false;
    },
    check: function check() {
      this.$emit("input", {
        type: this.type,
        label: this.label,
        target_url: this.url
      });
      this.type = "item";
      this.label = "";
      this.url = "";
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-dialog',{attrs:{"md-active":_vm.openModal},on:{"update:mdActive":function($event){_vm.openModal=$event}}},[_c('md-dialog-title',[_vm._v("Add Category")]),_vm._v(" "),_c('form',{attrs:{"id":"app"},on:{"submit":function($event){$event.preventDefault();return _vm.checkForm($event)}}},[_c('md-dialog-content',[(_vm.errors.length)?_c('p',[_c('b',[_vm._v("Please correct the following error(s):")]),_vm._v(" "),_c('ul',_vm._l((_vm.errors),function(error){return _c('li',{key:error},[_vm._v(_vm._s(error))])}))]):_vm._e(),_vm._v(" "),_c('md-field',[_c('label',{attrs:{"for":"type"}},[_vm._v("Type")]),_vm._v(" "),_c('md-select',{model:{value:(_vm.type),callback:function ($$v) {_vm.type=$$v},expression:"type"}},[_c('md-option',{attrs:{"value":"item"}},[_vm._v("item")]),_vm._v(" "),_c('md-option',{attrs:{"value":"subheader"}},[_vm._v("subheader")]),_vm._v(" "),_c('md-option',{attrs:{"value":"divider"}},[_vm._v("divider")])],1)],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("Label")]),_vm._v(" "),_c('md-input',{attrs:{"required":_vm.type !== 'divider'},model:{value:(_vm.label),callback:function ($$v) {_vm.label=$$v},expression:"label"}})],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("URL")]),_vm._v(" "),_c('md-input',{model:{value:(_vm.url),callback:function ($$v) {_vm.url=$$v},expression:"url"}})],1)],1),_vm._v(" "),_c('md-dialog-actions',[_c('md-button',{staticClass:"md-raised md-accent",on:{"click":_vm.onCancel}},[_vm._v("\n        Cancel\n        "),_c('md-icon',[_vm._v("cancel")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-raised md-primary",attrs:{"type":"submit","value":"Submit"}},[_vm._v("\n        Save\n        "),_c('md-icon',[_vm._v("check")])],1)],1)],1)],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-47275bf6", __vue__options__)
  } else {
    hotAPI.reload("data-v-47275bf6", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],25:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "CreateChildModal",
  props: ["openModalAdd", "value"],
  data: function data() {
    return {
      errors: [],
      label: "",
      url: ""
    };
  },

  computed: {
    openModal: {
      get: function get() {
        return this.openModalAdd;
      },
      set: function set() {
        this.$emit("closeModal");
      }
    }
  },
  methods: {
    checkForm: function checkForm() {
      if (this.label && this.url) {
        this.check();
        return true;
      }
      this.errors = [];
      if (!this.label) this.errors.push("Label required.");
      if (!this.url) this.errors.push("URL required.");
    },
    onCancel: function onCancel() {
      this.label = "";
      this.url = "";
      this.openModal = false;
    },
    check: function check() {
      this.$emit("input", { label: this.label, target_url: this.url });
      this.label = "";
      this.url = "";
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-dialog',{attrs:{"md-active":_vm.openModal},on:{"update:mdActive":function($event){_vm.openModal=$event}}},[_c('md-dialog-title',[_vm._v("Add Children")]),_vm._v(" "),_c('form',{attrs:{"id":"app"},on:{"submit":function($event){$event.preventDefault();return _vm.checkForm($event)}}},[_c('md-dialog-content',[(_vm.errors.length)?_c('p',[_c('b',[_vm._v("Please correct the following error(s):")]),_vm._v(" "),_c('ul',_vm._l((_vm.errors),function(error){return _c('li',{key:error},[_vm._v(_vm._s(error))])}))]):_vm._e(),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("Label")]),_vm._v(" "),_c('md-input',{attrs:{"required":""},model:{value:(_vm.label),callback:function ($$v) {_vm.label=$$v},expression:"label"}})],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("URL")]),_vm._v(" "),_c('md-input',{attrs:{"required":""},model:{value:(_vm.url),callback:function ($$v) {_vm.url=$$v},expression:"url"}})],1)],1),_vm._v(" "),_c('md-dialog-actions',[_c('md-button',{staticClass:"md-raised md-accent",on:{"click":_vm.onCancel}},[_vm._v("\n        Cancel\n        "),_c('md-icon',[_vm._v("cancel")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-raised md-primary",attrs:{"type":"submit","value":"Submit"}},[_vm._v("\n        Save\n        "),_c('md-icon',[_vm._v("check")])],1)],1)],1)],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b78d92b6", __vue__options__)
  } else {
    hotAPI.reload("data-v-b78d92b6", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13}],26:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "EditChildModal",
  props: ["openModalEdit", "value"],
  data: function data() {
    return {
      errors: [],
      label: "",
      url: ""
    };
  },


  computed: {
    openModal: {
      get: function get() {
        return this.openModalEdit;
      },
      set: function set() {
        this.$emit("closeModal");
      }
    }
  },
  watch: {
    value: function value() {
      this.label = this.value.label;
      this.url = this.value.target_url;
    }
  },
  methods: {
    checkForm: function checkForm() {
      if (this.label && this.url) {
        this.check();
        return true;
      }
      this.errors = [];
      if (!this.label) this.errors.push("Label required.");
      if (!this.url) this.errors.push("URL required.");
    },
    onCancel: function onCancel() {
      this.openModal = false;
    },
    check: function check() {
      this.$emit("input", { label: this.label, target_url: this.url });
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-dialog',{attrs:{"md-active":_vm.openModal},on:{"update:mdActive":function($event){_vm.openModal=$event}}},[_c('md-dialog-title',[_vm._v("Edit Child")]),_vm._v(" "),_c('form',{attrs:{"id":"app"},on:{"submit":function($event){$event.preventDefault();return _vm.checkForm($event)}}},[_c('md-dialog-content',[(_vm.errors.length)?_c('p',[_c('b',[_vm._v("Please correct the following error(s):")]),_vm._v(" "),_c('ul',_vm._l((_vm.errors),function(error){return _c('li',{key:error},[_vm._v(_vm._s(error))])}))]):_vm._e(),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("Label")]),_vm._v(" "),_c('md-input',{attrs:{"required":""},model:{value:(_vm.label),callback:function ($$v) {_vm.label=$$v},expression:"label"}})],1),_vm._v(" "),_c('md-field',[_c('label',[_vm._v("URL")]),_vm._v(" "),_c('md-input',{attrs:{"required":""},model:{value:(_vm.url),callback:function ($$v) {_vm.url=$$v},expression:"url"}})],1)],1),_vm._v(" "),_c('md-dialog-actions',[_c('md-button',{staticClass:"md-raised md-accent",on:{"click":_vm.onCancel}},[_vm._v("\n        Cancel\n        "),_c('md-icon',[_vm._v("cancel")])],1),_vm._v(" "),_c('md-button',{staticClass:"md-raised md-primary",attrs:{"type":"submit","value":"Submit"}},[_vm._v("\n        Save\n        "),_c('md-icon',[_vm._v("check")])],1)],1)],1)],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-dec90ed2", __vue__options__)
  } else {
    hotAPI.reload("data-v-dec90ed2", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13}],27:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("#app .md-app[data-v-f2eccd2c] {\n  height: 100vh;\n  overflow: hidden;\n}\n.app-header[data-v-f2eccd2c] {\n  color: black;\n  background-color: #fff;\n}\n.md-app-content[data-v-f2eccd2c] {\n  height: calc(100vh - 64px) !important;\n  position: relative;\n  padding: 0;\n}\n.spinalLeftSideBar-container[data-v-f2eccd2c] {\n  overflow: hidden;\n}\n.md-app-container {\n  overflow: hidden;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SpinalHeader = require("./header/SpinalHeader.vue");

var _SpinalHeader2 = _interopRequireDefault(_SpinalHeader);

var _SpinalLeftSideBar = require("./LeftSideBar/SpinalLeftSideBar.vue");

var _SpinalLeftSideBar2 = _interopRequireDefault(_SpinalLeftSideBar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "app",
  data: function data() {
    return {
      menuVisible: true
    };
  },

  computed: {},
  created: function created() {},
  mounted: function mounted() {
    var vm = this;
  },


  components: {
    spinalLeftSideBar: _SpinalLeftSideBar2.default,
    spinalHeader: _SpinalHeader2.default
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"app"}},[_c('md-app',{attrs:{"md-waterfall":"","md-mode":"fixed"}},[_c('md-app-toolbar',{staticClass:"app-header"},[_c('spinalHeader',{on:{"openmenu":function($event){_vm.menuVisible = !_vm.menuVisible}}})],1),_vm._v(" "),_c('md-app-drawer',{staticClass:"spinalLeftSideBar-container",attrs:{"md-active":_vm.menuVisible,"md-persistent":"full"},on:{"update:mdActive":function($event){_vm.menuVisible=$event}}},[_c('spinalLeftSideBar',{on:{"openmenu":function($event){_vm.menuVisible = !_vm.menuVisible}}})],1),_vm._v(" "),_c('md-app-content',[_c('router-view',{staticClass:"view"})],1)],1)],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-f2eccd2c"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f2eccd2c", __vue__options__)
  } else {
    hotAPI.reload("data-v-f2eccd2c", __vue__options__)
  }
})()}

},{"./LeftSideBar/SpinalLeftSideBar.vue":28,"./header/SpinalHeader.vue":38,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],28:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".spinalLeftSideBar-container[data-v-284773d2] {\n  overflow: hidden;\n}\n.left-bar-content[data-v-284773d2] {\n  height: calc(100vh - 64px) !important;\n  overflow: auto;\n}\n.md-icon[data-v-284773d2] {\n  color: black;\n}\n.app-header[data-v-284773d2] {\n  color: black;\n  background-color: #fff;\n}\n.color_black .md-button[data-v-284773d2],\n.color_black .md-icon[data-v-284773d2],\n.color_black div[data-v-284773d2] {\n  color: black !important;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalCategoryContainer = require("./spinal-category-container.vue");

var _spinalCategoryContainer2 = _interopRequireDefault(_spinalCategoryContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "SpinalLeftSideBar",
  components: {
    spinalCategoryContainer: _spinalCategoryContainer2.default
  },

  data: function data() {
    return {};
  },
  created: function created() {},

  methods: {
    toggleMenu: function toggleMenu() {
      this.$emit("openmenu");
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"spinalLeftSideBar-container"},[_c('md-toolbar',{staticClass:"app-header",attrs:{"md-elevation":"0"}},[_c('h3',[_vm._v("Navigation")]),_vm._v(" "),_c('div',{staticClass:"md-toolbar-section-end color_black"},[_c('md-button',{staticClass:"md-icon-button md-dense",on:{"click":_vm.toggleMenu}},[_c('md-icon',[_vm._v("keyboard_arrow_left")])],1)],1)]),_vm._v(" "),_c('md-content',{staticClass:"md-scrollbar left-bar-content"},[_c('spinalCategoryContainer')],1)],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-284773d2"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-284773d2", __vue__options__)
  } else {
    hotAPI.reload("data-v-284773d2", __vue__options__)
  }
})()}

},{"./spinal-category-container.vue":29,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],29:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("#side-bar-list {\n  padding-top: 0;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalCategory = require("./spinal-category.vue");

var _spinalCategory2 = _interopRequireDefault(_spinalCategory);

var _eventBus = require("../event-bus");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "spinalCategoryContainer",
  components: { spinalCategory: _spinalCategory2.default },
  data: function data() {
    return {
      list: []
    };
  },

  methods: {},
  mounted: function mounted() {
    var vm = this;
    _eventBus.EventBus.$on("UPDATE-MODEL", function (model) {
      vm.list = model.get();
    });
    window.spinal.spinalSystem.getModel().then(function (model) {
      _eventBus.EventBus.$emit("UPDATE-MODEL", model);
    });
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-list',{attrs:{"id":"side-bar-list"}},_vm._l((_vm.list),function(item){return _c('spinalCategory',{key:item.label,attrs:{"item":item}})}))}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d243c0fe", __vue__options__)
  } else {
    hotAPI.reload("data-v-d243c0fe", __vue__options__)
  }
})()}

},{"../event-bus":37,"./spinal-category.vue":32,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],30:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".md-list-item-text {\n  color: inherit !important;\n  text-decoration: none !important;\n}\n.md-list-no-padding {\n  padding: 0;\n}\n.left-selected {\n  background-color: #4d7db3;\n  text-decoration: none !important;\n}\n.left-selected > a > div {\n  color: white !important;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "spinalCategoryExpand",
  props: ["item"],
  data: function data() {
    return {};
  },

  methods: {
    btoa: function (_btoa) {
      function btoa(_x) {
        return _btoa.apply(this, arguments);
      }

      btoa.toString = function () {
        return _btoa.toString();
      };

      return btoa;
    }(function (str) {
      return btoa(str);
    })
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(this.item.children && this.item.children.length > 0)?_c('md-list-item',{staticClass:"md-elevation-0",class:{ 'left-selected': _vm.btoa(_vm.item.target_url) == _vm.$route.params.id },attrs:{"md-expand":""}},[_c('router-link',{staticClass:"md-list-item-text",attrs:{"to":_vm.btoa(_vm.item.target_url)}},[_c('span',[_vm._v(_vm._s(_vm.item.label))])]),_vm._v(" "),_c('md-list',{staticClass:"md-list-no-padding",attrs:{"slot":"md-expand"},slot:"md-expand"},_vm._l((_vm.item.children),function(it){return _c('md-list-item',{key:it.label,staticClass:"md-inset md-elevation-0",class:{ 'left-selected': _vm.btoa(it.target_url) == _vm.$route.params.id },attrs:{"to":_vm.btoa(it.target_url)}},[_vm._v("\n        "+_vm._s(it.label)+"\n      ")])}))],1):_c('md-list-item',{class:{ 'left-selected': _vm.btoa(_vm.item.target_url) == _vm.$route.params.id },attrs:{"to":_vm.btoa(_vm.item.target_url)}},[_c('span',{staticClass:"md-list-item-text"},[_vm._v(_vm._s(_vm.item.label))])])],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-384d2c57", __vue__options__)
  } else {
    hotAPI.reload("data-v-384d2c57", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],31:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "spinalCategorySubHeader",
  props: ["item"],
  data: function data() {
    return {};
  },

  methods: {}
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('md-subheader',[_vm._v("\n  "+_vm._s(_vm.item.label.toUpperCase())+"\n")])}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4684f039", __vue__options__)
  } else {
    hotAPI.reload("data-v-4684f039", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13}],32:[function(require,module,exports){
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalCategorySubheader = require("./spinal-category-type/spinal-category-subheader.vue");

var _spinalCategorySubheader2 = _interopRequireDefault(_spinalCategorySubheader);

var _spinalCategoryItem = require("./spinal-category-type/spinal-category-item.vue");

var _spinalCategoryItem2 = _interopRequireDefault(_spinalCategoryItem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "spinalCategoryContainer",
  props: ["item"],
  components: { spinalCategorySubHeader: _spinalCategorySubheader2.default, spinalCategoryItem: _spinalCategoryItem2.default },
  data: function data() {
    return {};
  },

  methods: {
    test: function test() {
      console.log("click test");
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.item.type == 'item')?_c('spinalCategoryItem',{attrs:{"item":_vm.item}}):_vm._e(),_vm._v(" "),(_vm.item.type == 'subheader')?_c('spinalCategorySubHeader',{attrs:{"item":_vm.item}}):_vm._e(),_vm._v(" "),(_vm.item.type == 'divider')?_c('md-divider',{staticClass:"md-inset"}):_vm._e()],1)}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6a6708cd", __vue__options__)
  } else {
    hotAPI.reload("data-v-6a6708cd", __vue__options__)
  }
})()}

},{"./spinal-category-type/spinal-category-item.vue":30,"./spinal-category-type/spinal-category-subheader.vue":31,"vue":"vue","vue-hot-reload-api":13}],33:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert("#main-content-iframe {\n  width: 100%;\n  height: 100%;\n  background-color: white;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "app",
  data: function data() {
    return {
      target_url: ""
    };
  },

  watch: {
    $route: function $route() {
      if (this.$route.params.id) {
        this.target_url = atob(this.$route.params.id);
      }
    }
  },
  mounted: function mounted() {
    if (this.$route.params.id) {
      this.target_url = atob(this.$route.params.id);
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('iframe',{attrs:{"id":"main-content-iframe","src":_vm.target_url}})}
__vue__options__.staticRenderFns = []
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-d6521bcc", __vue__options__)
  } else {
    hotAPI.reload("data-v-d6521bcc", __vue__options__)
  }
})()}

},{"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

require("spinal-core-connectorjs");

var _q = require("q");

var Q = _interopRequireWildcard(_q);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function getParameterByName(name, url) {
  if (!url) url = window.location.href;
  name = name.replace(/[[\]]/g, "\\$&");
  var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
      results = regex.exec(url);
  if (!results) return null;
  if (!results[2]) return "";
  return decodeURIComponent(results[2].replace(/\+/g, " "));
}

var SpinalSystem = function () {
  function SpinalSystem() {
    _classCallCheck(this, SpinalSystem);

    this.user = {
      username: "admin",
      password: "JHGgcz45JKilmzknzelf65ddDadggftIO98P"
    };
    this.promiseModel = null;
    this.promiseinit = null;
    this.modelsDictionary = {};
    this.modelsPathDictionary = {};
  }

  _createClass(SpinalSystem, [{
    key: "init",
    value: function init() {
      var _this = this;

      if (this.promiseinit) return this.promiseinit.promise;
      this.promiseinit = Q.defer();
      this.getUser();
      if (this.user.username) {
        window.SpinalUserManager.get_user_id("http://" + window.location.host, this.user.username, this.user.password, function (response) {
          var id = parseInt(response);
          _this.conn = window.spinalCore.connect("http://" + id + ":" + _this.user.password + "@" + window.location.host + "/");
          _this.promiseinit.resolve();
        }, function () {
          _this.promiseinit.reject();
          _this.promiseinit = null;
        });
      } else {
        this.promiseinit.reject();
        this.promiseinit = null;
      }
      return this.promiseinit.promise;
    }
  }, {
    key: "getPath",
    value: function getPath() {
      var path = getParameterByName("path");
      if (path) return atob(path);
      return undefined;
    }
  }, {
    key: "getUser",
    value: function getUser() {
      return this.user;
    }
  }, {
    key: "getModel",
    value: function getModel() {
      var _this2 = this;

      if (this.promiseModel) {
        return this.promiseModel.promise;
      }
      this.promiseModel = Q.defer();
      this.init().then(function () {
        var path = "/doc/doc_file";
        window.spinalCore.load(_this2.conn, path, function (docFile) {
          _this2.model = docFile;
          _this2.promiseModel.resolve(_this2.model);
        }, function () {
          _this2.model = new window.Lst();
          window.spinalCore.store(_this2.conn, _this2.model, path, function () {
            _this2.promiseModel.resolve(_this2.model);
          }, function () {
            console.error(new Error("Imposible to store the file, check the connetion to the hub"));
            this.promiseModel.reject();
            this.promiseModel = null;
          });
        });
      }, function (err) {
        console.error(err);
        _this2.promiseModel.reject();
        _this2.promiseModel = null;
      });
      return this.promiseModel.promise;
    }
  }, {
    key: "_waitModelRdyRec",
    value: function _waitModelRdyRec(model, promise) {
      var _this3 = this;

      if (!model._server_id || window.FileSystem._tmp_objects[model._server_id]) {
        setTimeout(function () {
          _this3._waitModelRdyRec(model, promise);
        }, 100);
      } else promise.resolve(model);
    }
  }, {
    key: "waitModelRdy",
    value: function waitModelRdy(model) {
      var defer = Q.defer();
      this._waitModelRdyRec(model, defer);

      return defer.promise;
    }
  }, {
    key: "loadModelPtr",
    value: function loadModelPtr(model) {
      var _this4 = this;

      if (this.modelsDictionary[model._server_id]) {
        return this.modelsDictionary[model._server_id].promise;
      }
      this.modelsDictionary[model._server_id] = Q.defer();
      try {
        model.load(function (m) {
          _this4.modelsDictionary[model._server_id].resolve(m);
        });
      } catch (error) {
        var promise = this.modelsDictionary[model._server_id];
        this.modelsDictionary[model._server_id] = undefined;
        promise.reject();
      }
      return this.modelsDictionary[model._server_id].promise;
    }
  }, {
    key: "signOut",
    value: function signOut() {
      window.localStorage.setItem("spinalhome_cfg", "");
    }
  }, {
    key: "load",
    value: function load(path) {
      var _this5 = this;

      if (this.modelsPathDictionary[path]) {
        return this.modelsPathDictionary[path].promise;
      }
      this.modelsPathDictionary[path] = Q.defer();

      window.spinalCore.load(this.conn, path, function (m) {
        _this5.modelsPathDictionary[path].resolve(m);
      }, function () {
        console.error("Failed to load model in : " + path);
        var promise = _this5.modelsPathDictionary[path];
        _this5.modelsPathDictionary[path] = undefined;
        promise.reject();
      });

      return this.modelsPathDictionary[path].promise;
    }
  }]);

  return SpinalSystem;
}();

exports.default = SpinalSystem;

},{"q":5,"spinal-core-connectorjs":9}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _SpinalSystem = require("./SpinalSystem");

var _SpinalSystem2 = _interopRequireDefault(_SpinalSystem);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.spinal = {};

window.spinal.spinalSystem = new _SpinalSystem2.default();

exports.default = {
  install: function install(Vue) {
    Vue.prototype.$spinalSystem = window.spinal.spinalSystem;
  },

  spinalSystem: window.spinal.spinalSystem
};

},{"./SpinalSystem":34}],36:[function(require,module,exports){

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventBus = undefined;

var _vue = require("vue");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventBus = exports.EventBus = new _vue2.default();

},{"vue":"vue"}],38:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".md-button[data-v-25a71525],\n.md-icon[data-v-25a71525],\ndiv[data-v-25a71525] {\n  color: black !important;\n}")
;(function(){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinal = require("../SpinalSystem/spinal");

var _spinal2 = _interopRequireDefault(_spinal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "spinalHeader",
  data: function data() {
    return {
      fullPath: "",
      path: "",
      username: ""
    };
  },

  methods: {
    toggleMenu: function toggleMenu() {
      this.$emit("openmenu");
    }
  },
  created: function created() {
    var vm = this;
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"md-toolbar-row"},[_c('div',{staticClass:"md-toolbar-section-start"},[(!_vm.menuVisible)?_c('md-button',{staticClass:"md-icon-button",on:{"click":_vm.toggleMenu}},[_c('md-icon',[_vm._v("menu")])],1):_vm._e(),_vm._v(" "),_c('img',{staticStyle:{"height":"42px","margin-top":"4px"},attrs:{"src":"dist/assets/img/SpinalBIMViewerLogo.png","alt":"SpinalBIM Viewer"}})],1),_vm._v(" "),_c('div',{staticClass:"md-toolbar-section-end"})])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-25a71525"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-25a71525", __vue__options__)
  } else {
    hotAPI.reload("data-v-25a71525", __vue__options__)
  }
})()}

},{"../SpinalSystem/spinal":35,"vue":"vue","vue-hot-reload-api":13,"vueify/lib/insert-css":16}],39:[function(require,module,exports){
"use strict";

var _vue = require("vue");

var _vue2 = _interopRequireDefault(_vue);

var _App = require("./App.vue");

var _App2 = _interopRequireDefault(_App);

var _vueMaterial = require("vue-material");

var _vueMaterial2 = _interopRequireDefault(_vueMaterial);

var _spinal = require("./SpinalSystem/spinal");

var _spinal2 = _interopRequireDefault(_spinal);

var _vueRouter = require("vue-router");

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _MainContent = require("./MainContent/MainContent.vue");

var _MainContent2 = _interopRequireDefault(_MainContent);

var _AdminContent = require("./AdminContent/AdminContent.vue");

var _AdminContent2 = _interopRequireDefault(_AdminContent);

require("./app.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

var router = new _vueRouter2.default({
  routes: [{
    path: "/page/:id",
    component: _MainContent2.default
  }, {
    path: "/admin",
    component: _AdminContent2.default
  }, {
    path: "/admin/:id",
    component: _AdminContent2.default
  }, {
    path: "*",
    redirect: "/page/404"
  }]
});

_vue2.default.use(_spinal2.default);

_vue2.default.use(_vueMaterial2.default);
window.spinalApp = new _vue2.default({
  router: router,
  el: "#app",
  render: function render(h) {
    return h(_App2.default);
  }
});

},{"./AdminContent/AdminContent.vue":21,"./App.vue":27,"./MainContent/MainContent.vue":33,"./SpinalSystem/spinal":35,"./app.css":36,"vue":"vue","vue-material":14,"vue-router":15}],40:[function(require,module,exports){
"use strict";

/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-json version: 2.1.1(0e6ea95f4f4e093db9201c502e8d401391803233)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-json/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
define("vs/language/json/monaco.contribution", ["require", "exports"], function (t, e) {
  "use strict";
  Object.defineProperty(e, "__esModule", { value: !0 });var o = monaco.Emitter,
      n = function () {
    function e(e, n) {
      this._onDidChange = new o(), this._languageId = e, this.setDiagnosticsOptions(n);
    }return Object.defineProperty(e.prototype, "onDidChange", { get: function get() {
        return this._onDidChange.event;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "languageId", { get: function get() {
        return this._languageId;
      }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "diagnosticsOptions", { get: function get() {
        return this._diagnosticsOptions;
      }, enumerable: !0, configurable: !0 }), e.prototype.setDiagnosticsOptions = function (e) {
      this._diagnosticsOptions = e || Object.create(null), this._onDidChange.fire(this);
    }, e;
  }(),
      i = new (e.LanguageServiceDefaultsImpl = n)("json", { validate: !0, allowComments: !0, schemas: [] });monaco.languages.json = { jsonDefaults: i }, monaco.languages.register({ id: "json", extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc"], aliases: ["JSON", "json"], mimetypes: ["application/json"] }), monaco.languages.onLanguage("json", function () {
    monaco.Promise.wrap(new Promise(function (e, n) {
      t(["./jsonMode"], e, n);
    })).then(function (e) {
      return e.setupMode(i);
    });
  });
});

},{}]},{},[39])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmRlYm91bmNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm8tYXNzaWduL2Rpc3QvbmFuby1hc3NpZ24uY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xL3EuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zcGluYWwtY29yZS1jb25uZWN0b3Jqcy9saWIvc3BpbmFsY29yZS5ub2RlLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92dWUtbWF0ZXJpYWwvZGlzdC92dWUtbWF0ZXJpYWwuanMiLCJub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Z1ZWlmeS9saWIvaW5zZXJ0LWNzcy5qcyIsIm5vZGVfbW9kdWxlcy94aHIyL2xpYi9icm93c2VyLmpzIiwic3JjL0FkbWluQ29udGVudC9BZG1pbkNhdGVnb3J5LnZ1ZT82ZDY5OTMzNyIsInNyYy9BZG1pbkNvbnRlbnQvQWRtaW5DYXRlZ29yeUNoaWxkcmVuLnZ1ZT8yNDc3MWIyYiIsInNyYy9BZG1pbkNvbnRlbnQvQWRtaW5DYXRlZ29yeUNvbnRlbnQudnVlPzc0NjBlMmRiIiwic3JjL0FkbWluQ29udGVudC9BZG1pbkNvbnRlbnQudnVlP2IwY2NiODY4Iiwic3JjL0FkbWluQ29udGVudC9Nb2RhbHMvQ29kZUlPLnZ1ZT8zMTgxMGZhYSIsInNyYy9BZG1pbkNvbnRlbnQvTW9kYWxzL0NvZGVNb25hY28uanMiLCJzcmMvQWRtaW5Db250ZW50L01vZGFscy9DcmVhdGVDYXRlZ29yeS52dWU/ZDc3NjRiYzIiLCJzcmMvQWRtaW5Db250ZW50L01vZGFscy9DcmVhdGVDaGlsZC52dWU/NzQ3MjFhYzAiLCJzcmMvQWRtaW5Db250ZW50L01vZGFscy9FZGl0Q2hpbGQudnVlPzA0ZTFhYjUzIiwic3JjL0FwcC52dWU/MWI1NWJjMzMiLCJzcmMvTGVmdFNpZGVCYXIvU3BpbmFsTGVmdFNpZGVCYXIudnVlPzQwZmYxYmIyIiwic3JjL0xlZnRTaWRlQmFyL3NwaW5hbC1jYXRlZ29yeS1jb250YWluZXIudnVlPzFmY2YzNDNiIiwic3JjL0xlZnRTaWRlQmFyL3NwaW5hbC1jYXRlZ29yeS10eXBlL3NwaW5hbC1jYXRlZ29yeS1pdGVtLnZ1ZT9mMTM5OTJjYSIsInNyYy9MZWZ0U2lkZUJhci9zcGluYWwtY2F0ZWdvcnktdHlwZS9zcGluYWwtY2F0ZWdvcnktc3ViaGVhZGVyLnZ1ZT82N2FkOGIxZSIsInNyYy9MZWZ0U2lkZUJhci9zcGluYWwtY2F0ZWdvcnkudnVlPzg4MjcwNmYwIiwic3JjL01haW5Db250ZW50L01haW5Db250ZW50LnZ1ZT85M2UyYTQzNiIsInNyYy9TcGluYWxTeXN0ZW0vU3BpbmFsU3lzdGVtLmpzIiwic3JjL1NwaW5hbFN5c3RlbS9zcGluYWwuanMiLCJzcmMvYXBwLmNzcyIsInNyYy9ldmVudC1idXMuanMiLCJzcmMvaGVhZGVyL1NwaW5hbEhlYWRlci52dWU/ZjRiZGQ5ZjYiLCJzcmMvbWFpbi5qcyIsInd3dy92cy9sYW5ndWFnZS9qc29uL21vbmFjby5jb250cmlidXRpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1aEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5dzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqa0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTs7Ozs7Ozs7Ozs7QUN1RkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeENBO0FBMENBO0FBQ0E7QUFDQTtBQXREQTs7OztBQTFGQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNzRUE7O0FBQ0E7Ozs7QUFDQTs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQTJDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNURBOzs7O0FBekVBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQytEQTs7OztBQUNBOzs7O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQW5CQTtBQTZCQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXREQTs7OztBQW5FQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN3QkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0NBO0FBK0NBO0FBQ0E7QUFDQTtBQWxFQTs7OztBQWhDQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNzQ0E7O0FBR0E7Ozs7OztBQUZBOztBQUtBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFXQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUdBOztBQVFBO0FBQ0E7QUFDQTtBQTVCQTtBQThCQTtBQUFBOztBQUNBO0FBR0E7QUFFQTtBQUVBO0FBekVBOzs7O0FBM0NBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0NBOzs7Ozs7a0JBRWU7QUFDYixRQUFNLGNBRE87O0FBR2IsU0FBTztBQUNMLFdBQU8sTUFERjtBQUVMLFdBQU87QUFDTCxZQUFNLE1BREQ7QUFFTCxlQUFTO0FBRkosS0FGRjtBQU1MLGNBQVUsTUFOTDtBQU9MLGFBQVMsTUFQSjtBQVFMLGlCQUFhLElBUlI7QUFTTCxhQUFTO0FBQ1AsWUFBTSxRQURDO0FBRVAsZUFBUyxPQUFPO0FBRlQ7QUFUSixHQUhNOztBQWtCYixTQUFPO0FBQ0wsV0FBTztBQURGLEdBbEJNOztBQXNCYixNQXRCYSxrQkFzQk47QUFDTCxXQUFPO0FBQ0wsb0JBQWM7QUFEVCxLQUFQO0FBR0QsR0ExQlk7OztBQTRCYixTQUFPO0FBQ0wsYUFBUztBQUNQLFlBQU0sSUFEQztBQUVQLGFBRk8sbUJBRUMsT0FGRCxFQUVVO0FBQ2YsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixlQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTBCLE9BQTFCO0FBQ0Q7QUFDRjtBQU5NLEtBREo7O0FBVUwsU0FWSyxpQkFVQyxRQVZELEVBVVc7QUFDZCxVQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLFlBQUksYUFBYSxLQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQWpCLEVBQXlDO0FBQ3ZDLGVBQUssTUFBTCxDQUFZLFFBQVosQ0FBcUIsUUFBckI7QUFDRDtBQUNGO0FBQ0YsS0FoQkk7QUFrQkwsWUFsQkssb0JBa0JJLE1BbEJKLEVBa0JZO0FBQ2YsVUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDZixlQUFPLE1BQVAsQ0FBYyxNQUFkLENBQXFCLGdCQUFyQixDQUFzQyxLQUFLLE1BQUwsQ0FBWSxRQUFaLEVBQXRDLEVBQThELE1BQTlEO0FBQ0Q7QUFDRixLQXRCSTtBQXdCTCxTQXhCSyxpQkF3QkMsTUF4QkQsRUF3QlM7QUFDWixVQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNmLGVBQU8sTUFBUCxDQUFjLE1BQWQsQ0FBcUIsUUFBckIsQ0FBOEIsTUFBOUI7QUFDRDtBQUNGO0FBNUJJLEdBNUJNOztBQTJEYixTQTNEYSxxQkEyREg7QUFBQTs7QUFDUixRQUFNLFVBQVU7QUFDZCxhQUFPLEtBQUssS0FERTtBQUVkLGFBQU8sS0FBSyxLQUZFO0FBR2QsZ0JBQVUsS0FBSyxRQUhEO0FBSWQsZUFBUyxLQUFLO0FBSkEsS0FBaEI7QUFNQSxZQUFRLHdEQUFSO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsU0FBSyxNQUFMLEdBQWMsT0FBTyxNQUFQLENBQWMsTUFBZCxDQUFxQixNQUFyQixDQUE0QixLQUFLLEdBQWpDLEVBQXNDLE9BQXRDLENBQWQ7QUFDQSxTQUFLLEtBQUwsQ0FBVyxhQUFYLEVBQTBCLEtBQUssTUFBL0I7QUFDQSxTQUFLLE1BQUwsQ0FBWSxhQUFaLENBQTBCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxhQUFYLEVBQTBCLEtBQTFCLENBQVQ7QUFBQSxLQUExQjtBQUNBLFNBQUssTUFBTCxDQUFZLGVBQVosQ0FBNEI7QUFBQSxhQUFNLE1BQUssS0FBTCxDQUFXLE1BQVgsQ0FBTjtBQUFBLEtBQTVCO0FBQ0EsU0FBSyxNQUFMLENBQVksbUJBQVosQ0FBZ0M7QUFBQSxhQUFNLE1BQUssS0FBTCxDQUFXLFVBQVgsQ0FBTjtBQUFBLEtBQWhDO0FBQ0EsU0FBSyxNQUFMLENBQVksd0JBQVosQ0FBcUM7QUFBQSxhQUNuQyxNQUFLLEtBQUwsQ0FBVyxlQUFYLEVBQTRCLEtBQTVCLENBRG1DO0FBQUEsS0FBckM7QUFHQSxTQUFLLE1BQUwsQ0FBWSx5QkFBWixDQUFzQztBQUFBLGFBQ3BDLE1BQUssS0FBTCxDQUFXLFVBQVgsRUFBdUIsS0FBdkIsQ0FEb0M7QUFBQSxLQUF0QztBQUdBLFNBQUssTUFBTCxDQUFZLDBCQUFaLENBQXVDO0FBQUEsYUFDckMsTUFBSyxLQUFMLENBQVcsV0FBWCxFQUF3QixLQUF4QixDQURxQztBQUFBLEtBQXZDO0FBR0EsU0FBSyxNQUFMLENBQVksZ0JBQVosQ0FBNkI7QUFBQSxhQUFTLE1BQUssS0FBTCxDQUFXLE9BQVgsRUFBb0IsS0FBcEIsQ0FBVDtBQUFBLEtBQTdCO0FBQ0EsU0FBSyxNQUFMLENBQVksdUJBQVosQ0FBb0MsaUJBQVM7QUFDM0MsVUFBTSxRQUFRLE1BQUssTUFBTCxDQUFZLFFBQVosRUFBZDtBQUNBLFVBQUksTUFBSyxLQUFMLEtBQWUsS0FBbkIsRUFBMEI7QUFDeEIsY0FBSyxLQUFMLENBQVcsUUFBWCxFQUFxQixLQUFyQixFQUE0QixLQUE1QjtBQUNEO0FBQ0YsS0FMRDtBQU1BLFNBQUssTUFBTCxDQUFZLDJCQUFaLENBQXdDO0FBQUEsYUFDdEMsTUFBSyxLQUFMLENBQVcsa0JBQVgsRUFBK0IsS0FBL0IsQ0FEc0M7QUFBQSxLQUF4QztBQUdBLFNBQUssTUFBTCxDQUFZLHdCQUFaLENBQXFDO0FBQUEsYUFDbkMsTUFBSyxLQUFMLENBQVcsZUFBWCxFQUE0QixLQUE1QixDQURtQztBQUFBLEtBQXJDO0FBR0EsU0FBSyxNQUFMLENBQVksdUJBQVosQ0FBb0M7QUFBQSxhQUNsQyxNQUFLLEtBQUwsQ0FBVyxjQUFYLEVBQTJCLEtBQTNCLENBRGtDO0FBQUEsS0FBcEM7QUFHQSxTQUFLLE1BQUwsQ0FBWSxZQUFaLENBQXlCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxjQUFYLEVBQTJCLEtBQTNCLENBQVQ7QUFBQSxLQUF6QjtBQUNBLFNBQUssTUFBTCxDQUFZLGdCQUFaLENBQTZCO0FBQUEsYUFBTSxNQUFLLEtBQUwsQ0FBVyxPQUFYLENBQU47QUFBQSxLQUE3QjtBQUNBLFNBQUssTUFBTCxDQUFZLG9CQUFaLENBQWlDO0FBQUEsYUFBTSxNQUFLLEtBQUwsQ0FBVyxXQUFYLENBQU47QUFBQSxLQUFqQztBQUNBLFNBQUssTUFBTCxDQUFZLGlCQUFaLENBQThCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLEtBQXJCLENBQVQ7QUFBQSxLQUE5QjtBQUNBLFNBQUssTUFBTCxDQUFZLGlCQUFaLENBQThCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxRQUFYLEVBQXFCLEtBQXJCLENBQVQ7QUFBQSxLQUE5QjtBQUNBLFNBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0I7QUFBQSxhQUFTLE1BQUssS0FBTCxDQUFXLFNBQVgsRUFBc0IsS0FBdEIsQ0FBVDtBQUFBLEtBQXRCO0FBQ0EsU0FBSyxNQUFMLENBQVksT0FBWixDQUFvQjtBQUFBLGFBQVMsTUFBSyxLQUFMLENBQVcsT0FBWCxFQUFvQixLQUFwQixDQUFUO0FBQUEsS0FBcEI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxXQUFaLENBQXdCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxXQUFYLEVBQXdCLEtBQXhCLENBQVQ7QUFBQSxLQUF4QjtBQUNBLFNBQUssTUFBTCxDQUFZLFlBQVosQ0FBeUI7QUFBQSxhQUFTLE1BQUssS0FBTCxDQUFXLFlBQVgsRUFBeUIsS0FBekIsQ0FBVDtBQUFBLEtBQXpCO0FBQ0EsU0FBSyxNQUFMLENBQVksV0FBWixDQUF3QjtBQUFBLGFBQVMsTUFBSyxLQUFMLENBQVcsV0FBWCxFQUF3QixLQUF4QixDQUFUO0FBQUEsS0FBeEI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCO0FBQUEsYUFBUyxNQUFLLEtBQUwsQ0FBVyxTQUFYLEVBQXNCLEtBQXRCLENBQVQ7QUFBQSxLQUF0QjtBQUNELEdBN0dZO0FBK0diLGVBL0dhLDJCQStHRztBQUNkLFNBQUssTUFBTCxJQUFlLEtBQUssTUFBTCxDQUFZLE9BQVosRUFBZjtBQUNELEdBakhZOzs7QUFtSGIsV0FBUztBQUNQLGFBRE8sdUJBQ0s7QUFDVixhQUFPLEtBQUssTUFBWjtBQUNELEtBSE07QUFLUCxTQUxPLG1CQUtDO0FBQ04sV0FBSyxNQUFMLENBQVksS0FBWjtBQUNEO0FBUE0sR0FuSEk7O0FBNkhiLFFBN0hhLGtCQTZITixDQTdITSxFQTZISDtBQUNSLFdBQU8sRUFBRSxLQUFGLEVBQVMsSUFBVCxFQUFlLENBQUMsS0FBSyxZQUFMLEdBQW9CLElBQXBCLEdBQTJCLEtBQUssV0FBakMsQ0FBZixDQUFQO0FBQ0Q7QUEvSFksQyxFQUhmOzs7Ozs7Ozs7Ozs7QUNtREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBREE7QUFVQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQS9CQTtBQXJCQTs7OztBQWxEQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXBCQTs7Ozs7QUE1Q0E7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFEQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUEzQkE7Ozs7O0FBNUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN5QkE7Ozs7QUFDQTs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFDQTtBQVVBO0FBR0E7QUFDQTtBQUlBOzs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQTNCQTs7OztBQTlCQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNzQkE7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBVkE7Ozs7QUF2QkE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDV0E7Ozs7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTs7OztBQWRBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFIQTtBQU5BOzs7O0FBakNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFOQTs7Ozs7QUFUQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2NBOzs7O0FBQ0E7Ozs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQVBBOzs7OztBQWpCQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDU0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTs7OztBQVJBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFDQTs7SUFBWSxDOzs7Ozs7QUFFWixTQUFTLGtCQUFULENBQTRCLElBQTVCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUksQ0FBQyxHQUFMLEVBQVUsTUFBTSxPQUFPLFFBQVAsQ0FBZ0IsSUFBdEI7QUFDVixTQUFPLEtBQUssT0FBTCxDQUFhLFFBQWIsRUFBdUIsTUFBdkIsQ0FBUDtBQUNBLE1BQUksUUFBUSxJQUFJLE1BQUosQ0FBVyxTQUFTLElBQVQsR0FBZ0IsbUJBQTNCLENBQVo7QUFBQSxNQUNFLFVBQVUsTUFBTSxJQUFOLENBQVcsR0FBWCxDQURaO0FBRUEsTUFBSSxDQUFDLE9BQUwsRUFBYyxPQUFPLElBQVA7QUFDZCxNQUFJLENBQUMsUUFBUSxDQUFSLENBQUwsRUFBaUIsT0FBTyxFQUFQO0FBQ2pCLFNBQU8sbUJBQW1CLFFBQVEsQ0FBUixFQUFXLE9BQVgsQ0FBbUIsS0FBbkIsRUFBMEIsR0FBMUIsQ0FBbkIsQ0FBUDtBQUNEOztJQUVLLFk7QUFDSiwwQkFBYztBQUFBOztBQUNaLFNBQUssSUFBTCxHQUFZO0FBQ1YsZ0JBQVUsT0FEQTtBQUVWLGdCQUFVO0FBRkEsS0FBWjtBQUlBLFNBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFNBQUssZ0JBQUwsR0FBd0IsRUFBeEI7QUFDQSxTQUFLLG9CQUFMLEdBQTRCLEVBQTVCO0FBQ0Q7Ozs7MkJBRU07QUFBQTs7QUFDTCxVQUFJLEtBQUssV0FBVCxFQUFzQixPQUFPLEtBQUssV0FBTCxDQUFpQixPQUF4QjtBQUN0QixXQUFLLFdBQUwsR0FBbUIsRUFBRSxLQUFGLEVBQW5CO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsVUFBSSxLQUFLLElBQUwsQ0FBVSxRQUFkLEVBQXdCO0FBQ3RCLGVBQU8saUJBQVAsQ0FBeUIsV0FBekIsQ0FDRSxZQUFZLE9BQU8sUUFBUCxDQUFnQixJQUQ5QixFQUVFLEtBQUssSUFBTCxDQUFVLFFBRlosRUFHRSxLQUFLLElBQUwsQ0FBVSxRQUhaLEVBSUUsb0JBQVk7QUFDVixjQUFJLEtBQUssU0FBUyxRQUFULENBQVQ7QUFDQSxnQkFBSyxJQUFMLEdBQVksT0FBTyxVQUFQLENBQWtCLE9BQWxCLGFBQ0EsRUFEQSxTQUNNLE1BQUssSUFBTCxDQUFVLFFBRGhCLFNBQzRCLE9BQU8sUUFBUCxDQUFnQixJQUQ1QyxPQUFaO0FBR0EsZ0JBQUssV0FBTCxDQUFpQixPQUFqQjtBQUNELFNBVkgsRUFXRSxZQUFNO0FBQ0osZ0JBQUssV0FBTCxDQUFpQixNQUFqQjtBQUNBLGdCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDRCxTQWRIO0FBZ0JELE9BakJELE1BaUJPO0FBQ0wsYUFBSyxXQUFMLENBQWlCLE1BQWpCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0Q7QUFDRCxhQUFPLEtBQUssV0FBTCxDQUFpQixPQUF4QjtBQUNEOzs7OEJBRVM7QUFDUixVQUFJLE9BQU8sbUJBQW1CLE1BQW5CLENBQVg7QUFDQSxVQUFJLElBQUosRUFBVSxPQUFPLEtBQUssSUFBTCxDQUFQO0FBQ1YsYUFBTyxTQUFQO0FBQ0Q7Ozs4QkFFUztBQUNSLGFBQU8sS0FBSyxJQUFaO0FBQ0Q7OzsrQkFFVTtBQUFBOztBQUNULFVBQUksS0FBSyxZQUFULEVBQXVCO0FBQ3JCLGVBQU8sS0FBSyxZQUFMLENBQWtCLE9BQXpCO0FBQ0Q7QUFDRCxXQUFLLFlBQUwsR0FBb0IsRUFBRSxLQUFGLEVBQXBCO0FBQ0EsV0FBSyxJQUFMLEdBQVksSUFBWixDQUNFLFlBQU07QUFDSixZQUFJLE9BQU8sZUFBWDtBQUNBLGVBQU8sVUFBUCxDQUFrQixJQUFsQixDQUNFLE9BQUssSUFEUCxFQUVFLElBRkYsRUFHRSxtQkFBVztBQUNULGlCQUFLLEtBQUwsR0FBYSxPQUFiO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixPQUFLLEtBQS9CO0FBQ0QsU0FOSCxFQU9FLFlBQU07QUFDSixpQkFBSyxLQUFMLEdBQWEsSUFBSSxPQUFPLEdBQVgsRUFBYjtBQUNBLGlCQUFPLFVBQVAsQ0FBa0IsS0FBbEIsQ0FDRSxPQUFLLElBRFAsRUFFRSxPQUFLLEtBRlAsRUFHRSxJQUhGLEVBSUUsWUFBTTtBQUNKLG1CQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEIsT0FBSyxLQUEvQjtBQUNELFdBTkgsRUFPRSxZQUFXO0FBQ1Qsb0JBQVEsS0FBUixDQUNFLElBQUksS0FBSixDQUNFLDZEQURGLENBREY7QUFLQSxpQkFBSyxZQUFMLENBQWtCLE1BQWxCO0FBQ0EsaUJBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNELFdBZkg7QUFpQkQsU0ExQkg7QUE0QkQsT0EvQkgsRUFnQ0UsZUFBTztBQUNMLGdCQUFRLEtBQVIsQ0FBYyxHQUFkO0FBQ0EsZUFBSyxZQUFMLENBQWtCLE1BQWxCO0FBQ0EsZUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0QsT0FwQ0g7QUFzQ0EsYUFBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBekI7QUFDRDs7O3FDQUVnQixLLEVBQU8sTyxFQUFTO0FBQUE7O0FBQy9CLFVBQUksQ0FBQyxNQUFNLFVBQVAsSUFBcUIsT0FBTyxVQUFQLENBQWtCLFlBQWxCLENBQStCLE1BQU0sVUFBckMsQ0FBekIsRUFBMkU7QUFDekUsbUJBQVcsWUFBTTtBQUNmLGlCQUFLLGdCQUFMLENBQXNCLEtBQXRCLEVBQTZCLE9BQTdCO0FBQ0QsU0FGRCxFQUVHLEdBRkg7QUFHRCxPQUpELE1BSU8sUUFBUSxPQUFSLENBQWdCLEtBQWhCO0FBQ1I7OztpQ0FDWSxLLEVBQU87QUFDbEIsVUFBSSxRQUFRLEVBQUUsS0FBRixFQUFaO0FBQ0EsV0FBSyxnQkFBTCxDQUFzQixLQUF0QixFQUE2QixLQUE3Qjs7QUFFQSxhQUFPLE1BQU0sT0FBYjtBQUNEOzs7aUNBQ1ksSyxFQUFPO0FBQUE7O0FBQ2xCLFVBQUksS0FBSyxnQkFBTCxDQUFzQixNQUFNLFVBQTVCLENBQUosRUFBNkM7QUFDM0MsZUFBTyxLQUFLLGdCQUFMLENBQXNCLE1BQU0sVUFBNUIsRUFBd0MsT0FBL0M7QUFDRDtBQUNELFdBQUssZ0JBQUwsQ0FBc0IsTUFBTSxVQUE1QixJQUEwQyxFQUFFLEtBQUYsRUFBMUM7QUFDQSxVQUFJO0FBQ0YsY0FBTSxJQUFOLENBQVcsYUFBSztBQUNkLGlCQUFLLGdCQUFMLENBQXNCLE1BQU0sVUFBNUIsRUFBd0MsT0FBeEMsQ0FBZ0QsQ0FBaEQ7QUFDRCxTQUZEO0FBR0QsT0FKRCxDQUlFLE9BQU8sS0FBUCxFQUFjO0FBQ2QsWUFBSSxVQUFVLEtBQUssZ0JBQUwsQ0FBc0IsTUFBTSxVQUE1QixDQUFkO0FBQ0EsYUFBSyxnQkFBTCxDQUFzQixNQUFNLFVBQTVCLElBQTBDLFNBQTFDO0FBQ0EsZ0JBQVEsTUFBUjtBQUNEO0FBQ0QsYUFBTyxLQUFLLGdCQUFMLENBQXNCLE1BQU0sVUFBNUIsRUFBd0MsT0FBL0M7QUFDRDs7OzhCQUNTO0FBQ1IsYUFBTyxZQUFQLENBQW9CLE9BQXBCLENBQTRCLGdCQUE1QixFQUE4QyxFQUE5QztBQUNEOzs7eUJBQ0ksSSxFQUFNO0FBQUE7O0FBQ1QsVUFBSSxLQUFLLG9CQUFMLENBQTBCLElBQTFCLENBQUosRUFBcUM7QUFDbkMsZUFBTyxLQUFLLG9CQUFMLENBQTBCLElBQTFCLEVBQWdDLE9BQXZDO0FBQ0Q7QUFDRCxXQUFLLG9CQUFMLENBQTBCLElBQTFCLElBQWtDLEVBQUUsS0FBRixFQUFsQzs7QUFFQSxhQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FDRSxLQUFLLElBRFAsRUFFRSxJQUZGLEVBR0UsYUFBSztBQUNILGVBQUssb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0MsT0FBaEMsQ0FBd0MsQ0FBeEM7QUFDRCxPQUxILEVBTUUsWUFBTTtBQUNKLGdCQUFRLEtBQVIsQ0FBYywrQkFBK0IsSUFBN0M7QUFDQSxZQUFJLFVBQVUsT0FBSyxvQkFBTCxDQUEwQixJQUExQixDQUFkO0FBQ0EsZUFBSyxvQkFBTCxDQUEwQixJQUExQixJQUFrQyxTQUFsQztBQUNBLGdCQUFRLE1BQVI7QUFDRCxPQVhIOztBQWNBLGFBQU8sS0FBSyxvQkFBTCxDQUEwQixJQUExQixFQUFnQyxPQUF2QztBQUNEOzs7Ozs7a0JBR1ksWTs7Ozs7Ozs7O0FDcktmOzs7Ozs7QUFFQSxPQUFPLE1BQVAsR0FBZ0IsRUFBaEI7O0FBRUEsT0FBTyxNQUFQLENBQWMsWUFBZCxHQUE2QixJQUFJLHNCQUFKLEVBQTdCOztrQkFFZTtBQUNiLFNBRGEsbUJBQ0wsR0FESyxFQUNBO0FBQ1gsUUFBSSxTQUFKLENBQWMsYUFBZCxHQUE4QixPQUFPLE1BQVAsQ0FBYyxZQUE1QztBQUNELEdBSFk7O0FBSWIsZ0JBQWMsT0FBTyxNQUFQLENBQWM7QUFKZixDOzs7QUNOZjs7Ozs7Ozs7O0FDQUE7Ozs7OztBQUNPLElBQU0sOEJBQVcsSUFBSSxhQUFKLEVBQWpCOzs7Ozs7Ozs7Ozs7QUN1QlA7Ozs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTEE7QUFPQTtBQUNBO0FBTUE7QUF4QkE7Ozs7QUEzQkE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQTJCQTs7OztBQTFCQSxjQUFJLEdBQUosQ0FBUSxtQkFBUjs7QUFFQSxJQUFNLFNBQVMsSUFBSSxtQkFBSixDQUFjO0FBQzNCLFVBQVEsQ0FDTjtBQUNFLFVBQU0sV0FEUjtBQUVFLGVBQVc7QUFGYixHQURNLEVBS047QUFDRSxVQUFNLFFBRFI7QUFFRSxlQUFXO0FBRmIsR0FMTSxFQVNOO0FBQ0UsVUFBTSxZQURSO0FBRUUsZUFBVztBQUZiLEdBVE0sRUFjTjtBQUNFLFVBQU0sR0FEUjtBQUVFLGNBQVU7QUFGWixHQWRNO0FBRG1CLENBQWQsQ0FBZjs7QUFzQkEsY0FBSSxHQUFKLENBQVEsZ0JBQVI7O0FBSUEsY0FBSSxHQUFKLENBQVEscUJBQVI7QUFDQSxPQUFPLFNBQVAsR0FBbUIsSUFBSSxhQUFKLENBQVE7QUFDekIsZ0JBRHlCO0FBRXpCLE1BQUksTUFGcUI7QUFHekIsVUFBUTtBQUFBLFdBQUssRUFBRSxhQUFGLENBQUw7QUFBQTtBQUhpQixDQUFSLENBQW5COzs7OztBQ3BDQTs7Ozs7O0FBTUEsT0FBTyxzQ0FBUCxFQUE4QyxDQUFDLFNBQUQsRUFBVyxTQUFYLENBQTlDLEVBQW9FLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYTtBQUFDO0FBQWEsU0FBTyxjQUFQLENBQXNCLENBQXRCLEVBQXdCLFlBQXhCLEVBQXFDLEVBQUMsT0FBTSxDQUFDLENBQVIsRUFBckMsRUFBaUQsSUFBSSxJQUFFLE9BQU8sT0FBYjtBQUFBLE1BQXFCLElBQUUsWUFBVTtBQUFDLGFBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxXQUFLLFlBQUwsR0FBa0IsSUFBSSxDQUFKLEVBQWxCLEVBQXdCLEtBQUssV0FBTCxHQUFpQixDQUF6QyxFQUEyQyxLQUFLLHFCQUFMLENBQTJCLENBQTNCLENBQTNDO0FBQXlFLFlBQU8sT0FBTyxjQUFQLENBQXNCLEVBQUUsU0FBeEIsRUFBa0MsYUFBbEMsRUFBZ0QsRUFBQyxLQUFJLGVBQVU7QUFBQyxlQUFPLEtBQUssWUFBTCxDQUFrQixLQUF6QjtBQUErQixPQUEvQyxFQUFnRCxZQUFXLENBQUMsQ0FBNUQsRUFBOEQsY0FBYSxDQUFDLENBQTVFLEVBQWhELEdBQWdJLE9BQU8sY0FBUCxDQUFzQixFQUFFLFNBQXhCLEVBQWtDLFlBQWxDLEVBQStDLEVBQUMsS0FBSSxlQUFVO0FBQUMsZUFBTyxLQUFLLFdBQVo7QUFBd0IsT0FBeEMsRUFBeUMsWUFBVyxDQUFDLENBQXJELEVBQXVELGNBQWEsQ0FBQyxDQUFyRSxFQUEvQyxDQUFoSSxFQUF3UCxPQUFPLGNBQVAsQ0FBc0IsRUFBRSxTQUF4QixFQUFrQyxvQkFBbEMsRUFBdUQsRUFBQyxLQUFJLGVBQVU7QUFBQyxlQUFPLEtBQUssbUJBQVo7QUFBZ0MsT0FBaEQsRUFBaUQsWUFBVyxDQUFDLENBQTdELEVBQStELGNBQWEsQ0FBQyxDQUE3RSxFQUF2RCxDQUF4UCxFQUFnWSxFQUFFLFNBQUYsQ0FBWSxxQkFBWixHQUFrQyxVQUFTLENBQVQsRUFBVztBQUFDLFdBQUssbUJBQUwsR0FBeUIsS0FBRyxPQUFPLE1BQVAsQ0FBYyxJQUFkLENBQTVCLEVBQWdELEtBQUssWUFBTCxDQUFrQixJQUFsQixDQUF1QixJQUF2QixDQUFoRDtBQUE2RSxLQUEzZixFQUE0ZixDQUFuZ0I7QUFBcWdCLEdBQXptQixFQUF2QjtBQUFBLE1BQW1vQixJQUFFLEtBQUksRUFBRSwyQkFBRixHQUE4QixDQUFsQyxFQUFxQyxNQUFyQyxFQUE0QyxFQUFDLFVBQVMsQ0FBQyxDQUFYLEVBQWEsZUFBYyxDQUFDLENBQTVCLEVBQThCLFNBQVEsRUFBdEMsRUFBNUMsQ0FBcm9CLENBQTR0QixPQUFPLFNBQVAsQ0FBaUIsSUFBakIsR0FBc0IsRUFBQyxjQUFhLENBQWQsRUFBdEIsRUFBdUMsT0FBTyxTQUFQLENBQWlCLFFBQWpCLENBQTBCLEVBQUMsSUFBRyxNQUFKLEVBQVcsWUFBVyxDQUFDLE9BQUQsRUFBUyxVQUFULEVBQW9CLFdBQXBCLEVBQWdDLFNBQWhDLEVBQTBDLFdBQTFDLEVBQXNELFVBQXRELENBQXRCLEVBQXdGLFNBQVEsQ0FBQyxNQUFELEVBQVEsTUFBUixDQUFoRyxFQUFnSCxXQUFVLENBQUMsa0JBQUQsQ0FBMUgsRUFBMUIsQ0FBdkMsRUFBa04sT0FBTyxTQUFQLENBQWlCLFVBQWpCLENBQTRCLE1BQTVCLEVBQW1DLFlBQVU7QUFBQyxXQUFPLE9BQVAsQ0FBZSxJQUFmLENBQW9CLElBQUksT0FBSixDQUFZLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYTtBQUFDLFFBQUUsQ0FBQyxZQUFELENBQUYsRUFBaUIsQ0FBakIsRUFBbUIsQ0FBbkI7QUFBc0IsS0FBaEQsQ0FBcEIsRUFBdUUsSUFBdkUsQ0FBNEUsVUFBUyxDQUFULEVBQVc7QUFBQyxhQUFPLEVBQUUsU0FBRixDQUFZLENBQVosQ0FBUDtBQUFzQixLQUE5RztBQUFnSCxHQUE5SixDQUFsTjtBQUFrWCxDQUE5dEMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iLCIvKiFcbiAqIG5hbm8tYXNzaWduIHYxLjAuMFxuICogKGMpIDIwMTctcHJlc2VudCBlZ29pc3QgPDB4MTQyODU3QGdtYWlsLmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5kZXggPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiwgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgZm9yICh2YXIgcCBpbiBhcmd1bWVudHNbaV0pIHsgb2JqW3BdID0gYXJndW1lbnRzJDFbaV1bcF07IH1cbiAgfVxuICByZXR1cm4gb2JqXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGV4O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvLyB2aW06dHM9NDpzdHM9NDpzdz00OlxuLyohXG4gKlxuICogQ29weXJpZ2h0IDIwMDktMjAxNyBLcmlzIEtvd2FsIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUXG4gKiBsaWNlbnNlIGZvdW5kIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9ibG9iL3YxL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcblxuICAgIC8vIFJlcXVpcmVKU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuXG4gICAgLy8gU0VTIChTZWN1cmUgRWNtYVNjcmlwdClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKCFzZXMub2soKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VzLm1ha2VRID0gZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuXG4gICAgLy8gPHNjcmlwdD5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gUHJlZmVyIHdpbmRvdyBvdmVyIHNlbGYgZm9yIGFkZC1vbiBzY3JpcHRzLiBVc2Ugc2VsZiBmb3JcbiAgICAgICAgLy8gbm9uLXdpbmRvd2VkIGNvbnRleHRzLlxuICAgICAgICB2YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHNlbGY7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBgd2luZG93YCBvYmplY3QsIHNhdmUgdGhlIHByZXZpb3VzIFEgZ2xvYmFsXG4gICAgICAgIC8vIGFuZCBpbml0aWFsaXplIFEgYXMgYSBnbG9iYWwuXG4gICAgICAgIHZhciBwcmV2aW91c1EgPSBnbG9iYWwuUTtcbiAgICAgICAgZ2xvYmFsLlEgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGEgbm9Db25mbGljdCBmdW5jdGlvbiBzbyBRIGNhbiBiZSByZW1vdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGdsb2JhbCBuYW1lc3BhY2UuXG4gICAgICAgIGdsb2JhbC5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBnbG9iYWwuUSA9IHByZXZpb3VzUTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBlbnZpcm9ubWVudCB3YXMgbm90IGFudGljaXBhdGVkIGJ5IFEuIFBsZWFzZSBmaWxlIGEgYnVnLlwiKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuICAgIC8vIHF1ZXVlIGZvciBsYXRlIHRhc2tzLCB1c2VkIGJ5IHVuaGFuZGxlZCByZWplY3Rpb24gdHJhY2tpbmdcbiAgICB2YXIgbGF0ZXJRdWV1ZSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgdGFzaywgZG9tYWluO1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pO1xuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxhdGVyUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICB0YXNrID0gbGF0ZXJRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJ1blNpbmdsZSh0YXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmbHVzaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBydW5zIGEgc2luZ2xlIGZ1bmN0aW9uIGluIHRoZSBhc3luYyBxdWV1ZVxuICAgIGZ1bmN0aW9uIHJ1blNpbmdsZSh0YXNrLCBkb21haW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHRUaWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHByb2Nlc3MudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBFbnN1cmUgUSBpcyBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudCwgd2l0aCBhIGBwcm9jZXNzLm5leHRUaWNrYC5cbiAgICAgICAgLy8gVG8gc2VlIHRocm91Z2ggZmFrZSBOb2RlIGVudmlyb25tZW50czpcbiAgICAgICAgLy8gKiBNb2NoYSB0ZXN0IHJ1bm5lciAtIGV4cG9zZXMgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgXG4gICAgICAgIC8vICogQnJvd3NlcmlmeSAtIGV4cG9zZXMgYSBgcHJvY2Vzcy5uZXhUaWNrYCBmdW5jdGlvbiB0aGF0IHVzZXNcbiAgICAgICAgLy8gICBgc2V0VGltZW91dGAuIEluIHRoaXMgY2FzZSBgc2V0SW1tZWRpYXRlYCBpcyBwcmVmZXJyZWQgYmVjYXVzZVxuICAgICAgICAvLyAgICBpdCBpcyBmYXN0ZXIuIEJyb3dzZXJpZnkncyBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHNcbiAgICAgICAgLy8gICBcIltvYmplY3QgT2JqZWN0XVwiLCB3aGlsZSBpbiBhIHJlYWwgTm9kZSBlbnZpcm9ubWVudFxuICAgICAgICAvLyAgIGBwcm9jZXNzLnRvU3RyaW5nKClgIHlpZWxkcyBcIltvYmplY3QgcHJvY2Vzc11cIi5cbiAgICAgICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgU2FmYXJpIFZlcnNpb24gNi4wLjUgKDg1MzYuMzAuMSkgaW50ZXJtaXR0ZW50bHkgY2Fubm90IGNyZWF0ZVxuICAgICAgICAvLyB3b3JraW5nIG1lc3NhZ2UgcG9ydHMgdGhlIGZpcnN0IHRpbWUgYSBwYWdlIGxvYWRzLlxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gcmVxdWVzdFBvcnRUaWNrO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXF1ZXN0UG9ydFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPcGVyYSByZXF1aXJlcyB1cyB0byBwcm92aWRlIGEgbWVzc2FnZSBwYXlsb2FkLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAvLyB3aGV0aGVyIHdlIHVzZSBpdC5cbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICByZXF1ZXN0UG9ydFRpY2soKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9sZCBicm93c2Vyc1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBydW5zIGEgdGFzayBhZnRlciBhbGwgb3RoZXIgdGFza3MgaGF2ZSBiZWVuIHJ1blxuICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nIHRoYXQgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgYWxsIGB0aGVuYGQgdGFza3MgaGF2ZSBiZWVuIHJ1bi5cbiAgICBuZXh0VGljay5ydW5BZnRlciA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIGxhdGVyUXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzICoqbWlnaHQqKiBoYXZlIHRoZSBuaWNlIHNpZGUtZWZmZWN0IG9mIHJlZHVjaW5nIHRoZSBzaXplIG9mXG4vLyB0aGUgbWluaWZpZWQgY29kZSBieSByZWR1Y2luZyB4LmNhbGwoKSB0byBtZXJlbHkgeCgpXG4vLyBTZWUgTWFyayBNaWxsZXLigJlzIGV4cGxhbmF0aW9uIG9mIHdoYXQgdGhpcyBkb2VzLlxuLy8gaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9Y29udmVudGlvbnM6c2FmZV9tZXRhX3Byb2dyYW1taW5nXG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuLy8gVGhpcyBpcyBlcXVpdmFsZW50LCBidXQgc2xvd2VyOlxuLy8gdW5jdXJyeVRoaXMgPSBGdW5jdGlvbl9iaW5kLmJpbmQoRnVuY3Rpb25fYmluZC5jYWxsKTtcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VuY3Vycnl0aGlzXG5cbnZhciBhcnJheV9zbGljZSA9IHVuY3VycnlUaGlzKEFycmF5LnByb3RvdHlwZS5zbGljZSk7XG5cbnZhciBhcnJheV9yZWR1Y2UgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUucmVkdWNlIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgYmFzaXMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICAvLyBjb25jZXJuaW5nIHRoZSBpbml0aWFsIHZhbHVlLCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBzZWVrIHRvIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgYXJyYXksIGFjY291bnRpbmdcbiAgICAgICAgICAgIC8vIGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCBpcyBpcyBhIHNwYXJzZSBhcnJheVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2lzID0gdGhpc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVkdWNlXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgdGhlIGFycmF5IGlzIHNwYXJzZVxuICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBiYXNpcyA9IGNhbGxiYWNrKGJhc2lzLCB0aGlzW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpcztcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfaW5kZXhPZiA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBub3QgYSB2ZXJ5IGdvb2Qgc2hpbSwgYnV0IGdvb2QgZW5vdWdoIGZvciBvdXIgb25lIHVzZSBvZiBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4pO1xuXG52YXIgYXJyYXlfbWFwID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLm1hcCB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGNvbGxlY3QgPSBbXTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHNlbGYsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgY29sbGVjdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpc3AsIHZhbHVlLCBpbmRleCwgc2VsZikpO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICByZXR1cm4gY29sbGVjdDtcbiAgICB9XG4pO1xuXG52YXIgb2JqZWN0X2NyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICAgIGZ1bmN0aW9uIFR5cGUoKSB7IH1cbiAgICBUeXBlLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3IFR5cGUoKTtcbn07XG5cbnZhciBvYmplY3RfZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgIG9ialtwcm9wXSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBvYmplY3RfaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxudmFyIG9iamVjdF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0X2hhc093blByb3BlcnR5KG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgb2JqZWN0X3RvU3RyaW5nID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBPYmplY3QodmFsdWUpO1xufVxuXG4vLyBnZW5lcmF0b3IgcmVsYXRlZCBzaGltc1xuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgZnVuY3Rpb24gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuZnVuY3Rpb24gaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICAgIG9iamVjdF90b1N0cmluZyhleGNlcHRpb24pID09PSBcIltvYmplY3QgU3RvcEl0ZXJhdGlvbl1cIiB8fFxuICAgICAgICBleGNlcHRpb24gaW5zdGFuY2VvZiBRUmV0dXJuVmFsdWVcbiAgICApO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaGVscGVyIGFuZCBRLnJldHVybiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpblxuLy8gU3BpZGVyTW9ua2V5LlxudmFyIFFSZXR1cm5WYWx1ZTtcbmlmICh0eXBlb2YgUmV0dXJuVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBSZXR1cm5WYWx1ZTtcbn0gZWxzZSB7XG4gICAgUVJldHVyblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjayAmJiAoIWVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fIHx8IGVycm9yLl9fbWluaW11bVN0YWNrQ291bnRlcl9fID4gcC5zdGFja0NvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcIl9fbWluaW11bVN0YWNrQ291bnRlcl9fXCIsIHt2YWx1ZTogcC5zdGFja0NvdW50ZXIsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgdmFyIHN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgICAgICBvYmplY3RfZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwic3RhY2tcIiwge3ZhbHVlOiBzdGFjaywgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGFzc2ltaWxhdGUgdGhlbmFibGVzXG4gICAgaWYgKGlzUHJvbWlzZUFsaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVsZmlsbCh2YWx1ZSk7XG4gICAgfVxufVxuUS5yZXNvbHZlID0gUTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHRhc2sgaW4gYSBmdXR1cmUgdHVybiBvZiB0aGUgZXZlbnQgbG9vcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRhc2tcbiAqL1xuUS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4vKipcbiAqIENvbnRyb2xzIHdoZXRoZXIgb3Igbm90IGxvbmcgc3RhY2sgdHJhY2VzIHdpbGwgYmUgb25cbiAqL1xuUS5sb25nU3RhY2tTdXBwb3J0ID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGNvdW50ZXIgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHN0b3BwaW5nIHBvaW50IGZvciBidWlsZGluZ1xuICogbG9uZyBzdGFjayB0cmFjZXMuIEluIG1ha2VTdGFja1RyYWNlTG9uZyB3ZSB3YWxrIGJhY2t3YXJkcyB0aHJvdWdoXG4gKiB0aGUgbGlua2VkIGxpc3Qgb2YgcHJvbWlzZXMsIG9ubHkgc3RhY2tzIHdoaWNoIHdlcmUgY3JlYXRlZCBiZWZvcmVcbiAqIHRoZSByZWplY3Rpb24gYXJlIGNvbmNhdGVuYXRlZC5cbiAqL1xudmFyIGxvbmdTdGFja0NvdW50ZXIgPSAxO1xuXG4vLyBlbmFibGUgbG9uZyBzdGFja3MgaWYgUV9ERUJVRyBpcyBzZXRcbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52LlFfREVCVUcpIHtcbiAgICBRLmxvbmdTdGFja1N1cHBvcnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFByb21pc2UucHJvbWlzZURpc3BhdGNoLmFwcGx5KHJlc29sdmVkUHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZFxuICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICAgICAgcHJvbWlzZS5zdGFja0NvdW50ZXIgPSBsb25nU3RhY2tDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOT1RFOiB3ZSBkbyB0aGUgY2hlY2tzIGZvciBgcmVzb2x2ZWRQcm9taXNlYCBpbiBlYWNoIG1ldGhvZCwgaW5zdGVhZCBvZlxuICAgIC8vIGNvbnNvbGlkYXRpbmcgdGhlbSBpbnRvIGBiZWNvbWVgLCBzaW5jZSBvdGhlcndpc2Ugd2UnZCBjcmVhdGUgbmV3XG4gICAgLy8gcHJvbWlzZXMgd2l0aCB0aGUgbGluZXMgYGJlY29tZSh3aGF0ZXZlcih2YWx1ZSkpYC4gU2VlIGUuZy4gR0gtMjUyLlxuXG4gICAgZnVuY3Rpb24gYmVjb21lKG5ld1Byb21pc2UpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBpZiAoUS5sb25nU3RhY2tTdXBwb3J0ICYmIGhhc1N0YWNrcykge1xuICAgICAgICAgICAgLy8gT25seSBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBuZXcgcHJvbWlzZSBpZiBsb25nIHN0YWNrc1xuICAgICAgICAgICAgLy8gYXJlIGVuYWJsZWQgdG8gcmVkdWNlIG1lbW9yeSB1c2FnZVxuICAgICAgICAgICAgcHJvbWlzZS5zb3VyY2UgPSBuZXdQcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZlcnJlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgTm9kZS1zdHlsZSBjYWxsYmFjayB0aGF0IHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIGRlZmVycmVkXG4gKiBwcm9taXNlLlxuICogQHJldHVybnMgYSBub2RlYmFja1xuICovXG5kZWZlci5wcm90b3R5cGUubWFrZU5vZGVSZXNvbHZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLnJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZShhcnJheV9zbGljZShhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVzb2x2ZXIge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBub3RoaW5nIGFuZCBhY2NlcHRzXG4gKiB0aGUgcmVzb2x2ZSwgcmVqZWN0LCBhbmQgbm90aWZ5IGZ1bmN0aW9ucyBmb3IgYSBkZWZlcnJlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IG1heSBiZSByZXNvbHZlZCB3aXRoIHRoZSBnaXZlbiByZXNvbHZlIGFuZCByZWplY3RcbiAqIGZ1bmN0aW9ucywgb3IgcmVqZWN0ZWQgYnkgYSB0aHJvd24gZXhjZXB0aW9uIGluIHJlc29sdmVyXG4gKi9cblEuUHJvbWlzZSA9IHByb21pc2U7IC8vIEVTNlxuUS5wcm9taXNlID0gcHJvbWlzZTtcbmZ1bmN0aW9uIHByb21pc2UocmVzb2x2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgIH0gY2F0Y2ggKHJlYXNvbikge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbnByb21pc2UucmFjZSA9IHJhY2U7IC8vIEVTNlxucHJvbWlzZS5hbGwgPSBhbGw7IC8vIEVTNlxucHJvbWlzZS5yZWplY3QgPSByZWplY3Q7IC8vIEVTNlxucHJvbWlzZS5yZXNvbHZlID0gUTsgLy8gRVM2XG5cbi8vIFhYWCBleHBlcmltZW50YWwuICBUaGlzIG1ldGhvZCBpcyBhIHdheSB0byBkZW5vdGUgdGhhdCBhIGxvY2FsIHZhbHVlIGlzXG4vLyBzZXJpYWxpemFibGUgYW5kIHNob3VsZCBiZSBpbW1lZGlhdGVseSBkaXNwYXRjaGVkIHRvIGEgcmVtb3RlIHVwb24gcmVxdWVzdCxcbi8vIGluc3RlYWQgb2YgcGFzc2luZyBhIHJlZmVyZW5jZS5cblEucGFzc0J5Q29weSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIElmIHR3byBwcm9taXNlcyBldmVudHVhbGx5IGZ1bGZpbGwgdG8gdGhlIHNhbWUgdmFsdWUsIHByb21pc2VzIHRoYXQgdmFsdWUsXG4gKiBidXQgb3RoZXJ3aXNlIHJlamVjdHMuXG4gKiBAcGFyYW0geCB7QW55Kn1cbiAqIEBwYXJhbSB5IHtBbnkqfVxuICogQHJldHVybnMge0FueSp9IGEgcHJvbWlzZSBmb3IgeCBhbmQgeSBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgYnV0IGEgcmVqZWN0aW9uXG4gKiBvdGhlcndpc2UuXG4gKlxuICovXG5RLmpvaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIHJldHVybiBRKHgpLmpvaW4oeSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgICByZXR1cm4gUShbdGhpcywgdGhhdF0pLnNwcmVhZChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICAgICAgLy8gVE9ETzogXCI9PT1cIiBzaG91bGQgYmUgT2JqZWN0LmlzIG9yIGVxdWl2XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIHNldHRsZWQuXG4gKiBAcGFyYW0gYW5zd2VycyB7QXJyYXlbQW55Kl19IHByb21pc2VzIHRvIHJhY2VcbiAqIEByZXR1cm5zIHtBbnkqfSB0aGUgZmlyc3QgcHJvbWlzZSB0byBiZSBzZXR0bGVkXG4gKi9cblEucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGFuc3dlclBzKSB7XG4gICAgcmV0dXJuIHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24gKGFuc3dlclApIHtcbiAgICAgICAgLy8gICAgIFEoYW5zd2VyUCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgLy8gVXNlIHRoaXMgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhbnN3ZXJQcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgUShhbnN3ZXJQc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnJhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihRLnJhY2UpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgUHJvbWlzZSB3aXRoIGEgcHJvbWlzZSBkZXNjcmlwdG9yIG9iamVjdCBhbmQgb3B0aW9uYWwgZmFsbGJhY2tcbiAqIGZ1bmN0aW9uLiAgVGhlIGRlc2NyaXB0b3IgY29udGFpbnMgbWV0aG9kcyBsaWtlIHdoZW4ocmVqZWN0ZWQpLCBnZXQobmFtZSksXG4gKiBzZXQobmFtZSwgdmFsdWUpLCBwb3N0KG5hbWUsIGFyZ3MpLCBhbmQgZGVsZXRlKG5hbWUpLCB3aGljaCBhbGxcbiAqIHJldHVybiBlaXRoZXIgYSB2YWx1ZSwgYSBwcm9taXNlIGZvciBhIHZhbHVlLCBvciBhIHJlamVjdGlvbi4gIFRoZSBmYWxsYmFja1xuICogYWNjZXB0cyB0aGUgb3BlcmF0aW9uIG5hbWUsIGEgcmVzb2x2ZXIsIGFuZCBhbnkgZnVydGhlciBhcmd1bWVudHMgdGhhdCB3b3VsZFxuICogaGF2ZSBiZWVuIGZvcndhcmRlZCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIGFib3ZlIGhhZCBhIG1ldGhvZCBiZWVuXG4gKiBwcm92aWRlZCB3aXRoIHRoZSBwcm9wZXIgbmFtZS4gIFRoZSBBUEkgbWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCB0aGUgbmF0dXJlXG4gKiBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LCBhcGFydCBmcm9tIHRoYXQgaXQgaXMgdXNhYmxlIHdoZXJlZXZlciBwcm9taXNlcyBhcmVcbiAqIGJvdWdodCBhbmQgc29sZC5cbiAqL1xuUS5tYWtlUHJvbWlzZSA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGRlc2NyaXB0b3IsIGZhbGxiYWNrLCBpbnNwZWN0KSB7XG4gICAgaWYgKGZhbGxiYWNrID09PSB2b2lkIDApIHtcbiAgICAgICAgZmFsbGJhY2sgPSBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiUHJvbWlzZSBkb2VzIG5vdCBzdXBwb3J0IG9wZXJhdGlvbjogXCIgKyBvcFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpbnNwZWN0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7c3RhdGU6IFwidW5rbm93blwifTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yW29wXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlc2NyaXB0b3Jbb3BdLmFwcGx5KHByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFjay5jYWxsKHByb21pc2UsIG9wLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByb21pc2UuaW5zcGVjdCA9IGluc3BlY3Q7XG5cbiAgICAvLyBYWFggZGVwcmVjYXRlZCBgdmFsdWVPZmAgYW5kIGBleGNlcHRpb25gIHN1cHBvcnRcbiAgICBpZiAoaW5zcGVjdCkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgIHByb21pc2UuZXhjZXB0aW9uID0gaW5zcGVjdGVkLnJlYXNvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb21pc2UudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IFByb21pc2VdXCI7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgZG9uZSA9IGZhbHNlOyAgIC8vIGVuc3VyZSB0aGUgdW50cnVzdGVkIHByb21pc2UgbWFrZXMgYXQgbW9zdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2FsbCB0byBvbmUgb2YgdGhlIGNhbGxiYWNrc1xuXG4gICAgZnVuY3Rpb24gX2Z1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmdWxmaWxsZWQgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0ZWQoZXhjZXB0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVqZWN0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGV4Y2VwdGlvbiwgc2VsZik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RlZChleGNlcHRpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAobmV3RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXdFeGNlcHRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcHJvZ3Jlc3NlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2dyZXNzZWQgPT09IFwiZnVuY3Rpb25cIiA/IHByb2dyZXNzZWQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5RLnRhcCA9IGZ1bmN0aW9uIChwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRhcChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFdvcmtzIGFsbW9zdCBsaWtlIFwiZmluYWxseVwiLCBidXQgbm90IGNhbGxlZCBmb3IgcmVqZWN0aW9ucy5cbiAqIE9yaWdpbmFsIHJlc29sdXRpb24gdmFsdWUgaXMgcGFzc2VkIHRocm91Z2ggY2FsbGJhY2sgdW5hZmZlY3RlZC5cbiAqIENhbGxiYWNrIG1heSByZXR1cm4gYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBhd2FpdGVkIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7US5Qcm9taXNlfVxuICogQGV4YW1wbGVcbiAqIGRvU29tZXRoaW5nKClcbiAqICAgLnRoZW4oLi4uKVxuICogICAudGFwKGNvbnNvbGUubG9nKVxuICogICAudGhlbiguLi4pO1xuICovXG5Qcm9taXNlLnByb3RvdHlwZS50YXAgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IFEoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKHZhbHVlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBQcm9taXNlO1xufVxuXG5RLmlzUHJvbWlzZUFsaWtlID0gaXNQcm9taXNlQWxpa2U7XG5mdW5jdGlvbiBpc1Byb21pc2VBbGlrZShvYmplY3QpIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwZW5kaW5nIHByb21pc2UsIG1lYW5pbmcgbm90XG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuXG4gKi9cblEuaXNQZW5kaW5nID0gaXNQZW5kaW5nO1xuZnVuY3Rpb24gaXNQZW5kaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHZhbHVlIG9yIGZ1bGZpbGxlZFxuICogcHJvbWlzZS5cbiAqL1xuUS5pc0Z1bGZpbGxlZCA9IGlzRnVsZmlsbGVkO1xuZnVuY3Rpb24gaXNGdWxmaWxsZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuICFpc1Byb21pc2Uob2JqZWN0KSB8fCBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc0Z1bGZpbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cblEuaXNSZWplY3RlZCA9IGlzUmVqZWN0ZWQ7XG5mdW5jdGlvbiBpc1JlamVjdGVkKG9iamVjdCkge1xuICAgIHJldHVybiBpc1Byb21pc2Uob2JqZWN0KSAmJiBvYmplY3QuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInJlamVjdGVkXCI7XG59O1xuXG4vLy8vIEJFR0lOIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLy8gVGhpcyBwcm9taXNlIGxpYnJhcnkgY29uc3VtZXMgZXhjZXB0aW9ucyB0aHJvd24gaW4gaGFuZGxlcnMgc28gdGhleSBjYW4gYmVcbi8vIGhhbmRsZWQgYnkgYSBzdWJzZXF1ZW50IHByb21pc2UuICBUaGUgZXhjZXB0aW9ucyBnZXQgYWRkZWQgdG8gdGhpcyBhcnJheSB3aGVuXG4vLyB0aGV5IGFyZSBjcmVhdGVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZXkgYXJlIGhhbmRsZWQuICBOb3RlIHRoYXQgaW4gRVM2IG9yXG4vLyBzaGltbWVkIGVudmlyb25tZW50cywgdGhpcyB3b3VsZCBuYXR1cmFsbHkgYmUgYSBgU2V0YC5cbnZhciB1bmhhbmRsZWRSZWFzb25zID0gW107XG52YXIgdW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucyA9IFtdO1xudmFyIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpIHtcbiAgICB1bmhhbmRsZWRSZWFzb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuaGFuZGxlZFJlamVjdGlvblwiLCByZWFzb24sIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW50cmFja1JlamVjdGlvbihwcm9taXNlKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdCA9IGFycmF5X2luZGV4T2YodW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgaWYgKGF0ICE9PSAtMSkge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MuZW1pdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrLnJ1bkFmdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXRSZXBvcnQgPSBhcnJheV9pbmRleE9mKHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucywgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGF0UmVwb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJyZWplY3Rpb25IYW5kbGVkXCIsIHVuaGFuZGxlZFJlYXNvbnNbYXRdLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0ZWRVbmhhbmRsZWRSZWplY3Rpb25zLnNwbGljZShhdFJlcG9ydCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXQsIDEpO1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnNwbGljZShhdCwgMSk7XG4gICAgfVxufVxuXG5RLnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucyA9IHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucztcblxuUS5nZXRVbmhhbmRsZWRSZWFzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIHRoYXQgY29uc3VtZXJzIGNhbid0IGludGVyZmVyZSB3aXRoIG91ciBpbnRlcm5hbCBzdGF0ZS5cbiAgICByZXR1cm4gdW5oYW5kbGVkUmVhc29ucy5zbGljZSgpO1xufTtcblxuUS5zdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG4gICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gZmFsc2U7XG59O1xuXG5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKTtcblxuLy8vLyBFTkQgVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSByZWplY3RlZCBwcm9taXNlLlxuICogQHBhcmFtIHJlYXNvbiB2YWx1ZSBkZXNjcmliaW5nIHRoZSBmYWlsdXJlXG4gKi9cblEucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICAgIHZhciByZWplY3Rpb24gPSBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoZSBlcnJvciBoYXMgYmVlbiBoYW5kbGVkXG4gICAgICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB1bnRyYWNrUmVqZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkID8gcmVqZWN0ZWQocmVhc29uKSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiByZWFzb24gfTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGUgcmVhc29uIGhhcyBub3QgYmVlbiBoYW5kbGVkLlxuICAgIHRyYWNrUmVqZWN0aW9uKHJlamVjdGlvbiwgcmVhc29uKTtcblxuICAgIHJldHVybiByZWplY3Rpb247XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZ1bGZpbGxlZCBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2VcbiAqL1xuUS5mdWxmaWxsID0gZnVsZmlsbDtcbmZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZ2V0XCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwic2V0XCI6IGZ1bmN0aW9uIChuYW1lLCByaHMpIHtcbiAgICAgICAgICAgIHZhbHVlW25hbWVdID0gcmhzO1xuICAgICAgICB9LFxuICAgICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInBvc3RcIjogZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIC8vIE1hcmsgTWlsbGVyIHByb3Bvc2VzIHRoYXQgcG9zdCB3aXRoIG5vIG5hbWUgc2hvdWxkIGFwcGx5IGFcbiAgICAgICAgICAgIC8vIHByb21pc2VkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwgfHwgbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYXBwbHlcIjogZnVuY3Rpb24gKHRoaXNwLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpc3AsIGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBcImtleXNcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdF9rZXlzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIHZvaWQgMCwgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwiZnVsZmlsbGVkXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZW5hYmxlcyB0byBRIHByb21pc2VzLlxuICogQHBhcmFtIHByb21pc2UgdGhlbmFibGUgcHJvbWlzZVxuICogQHJldHVybnMgYSBRIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlKHByb21pc2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgICAgICAvLyBVbnRpbCBWOCAzLjE5IC8gQ2hyb21pdW0gMjkgaXMgcmVsZWFzZWQsIFNwaWRlck1vbmtleSBpcyB0aGUgb25seVxuICAgICAgICAgICAgLy8gZW5naW5lIHRoYXQgaGFzIGEgZGVwbG95ZWQgYmFzZSBvZiBicm93c2VycyB0aGF0IHN1cHBvcnQgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIFNNJ3MgZ2VuZXJhdG9ycyB1c2UgdGhlIFB5dGhvbi1pbnNwaXJlZCBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgICAgIC8vIG91dGRhdGVkIEVTNiBkcmFmdHMuICBXZSB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgRVM2LCBidXQgd2UnZCBhbHNvXG4gICAgICAgICAgICAvLyBsaWtlIHRvIG1ha2UgaXQgcG9zc2libGUgdG8gdXNlIGdlbmVyYXRvcnMgaW4gZGVwbG95ZWQgYnJvd3NlcnMsIHNvXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIHN1cHBvcnQgUHl0aG9uLXN0eWxlIGdlbmVyYXRvcnMuICBBdCBzb21lIHBvaW50IHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHRoaXMgYmxvY2suXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU3RvcEl0ZXJhdGlvbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIEVTNiBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBRKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LnZhbHVlLCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTcGlkZXJNb25rZXkgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShleGNlcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBwZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytwZW5kaW5nQ291bnQ7XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLXBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAocGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2Ugb2YgYW4gYXJyYXkuIFByaW9yIHJlamVjdGVkIHByb21pc2VzIGFyZVxuICogaWdub3JlZC4gIFJlamVjdHMgb25seSBpZiBhbGwgcHJvbWlzZXMgYXJlIHJlamVjdGVkLlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IGNvbnRhaW5pbmcgdmFsdWVzIG9yIHByb21pc2VzIGZvciB2YWx1ZXNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHJlc29sdmVkIHByb21pc2UsXG4gKiBvciBhIHJlamVjdGVkIHByb21pc2UgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqL1xuUS5hbnkgPSBhbnk7XG5cbmZ1bmN0aW9uIGFueShwcm9taXNlcykge1xuICAgIGlmIChwcm9taXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFEucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZlcnJlZCA9IFEuZGVmZXIoKTtcbiAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50LCBpbmRleCkge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2VzW2luZGV4XTtcblxuICAgICAgICBwZW5kaW5nQ291bnQrKztcblxuICAgICAgICB3aGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzKTtcbiAgICAgICAgZnVuY3Rpb24gb25GdWxmaWxsZWQocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZWplY3RlZChlcnIpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDb3VudC0tO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZWplY3Rpb24gPSBlcnIgfHwgbmV3IEVycm9yKFwiXCIgKyBlcnIpO1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uLm1lc3NhZ2UgPSAoXCJRIGNhbid0IGdldCBmdWxmaWxsbWVudCB2YWx1ZSBmcm9tIGFueSBwcm9taXNlLCBhbGwgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInByb21pc2VzIHdlcmUgcmVqZWN0ZWQuIExhc3QgZXJyb3IgbWVzc2FnZTogXCIgKyByZWplY3Rpb24ubWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocmVqZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvZ3Jlc3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgdW5kZWZpbmVkKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFueSh0aGlzKTtcbn07XG5cbi8qKlxuICogV2FpdHMgZm9yIGFsbCBwcm9taXNlcyB0byBiZSBzZXR0bGVkLCBlaXRoZXIgZnVsZmlsbGVkIG9yXG4gKiByZWplY3RlZC4gIFRoaXMgaXMgZGlzdGluY3QgZnJvbSBgYWxsYCBzaW5jZSB0aGF0IHdvdWxkIHN0b3BcbiAqIHdhaXRpbmcgYXQgdGhlIGZpcnN0IHJlamVjdGlvbi4gIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5XG4gKiBgYWxsUmVzb2x2ZWRgIHdpbGwgbmV2ZXIgYmUgcmVqZWN0ZWQuXG4gKiBAcGFyYW0gcHJvbWlzZXMgYSBwcm9taXNlIGZvciBhbiBhcnJheSAob3IgYW4gYXJyYXkpIG9mIHByb21pc2VzXG4gKiAob3IgdmFsdWVzKVxuICogQHJldHVybiBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHByb21pc2VzXG4gKi9cblEuYWxsUmVzb2x2ZWQgPSBkZXByZWNhdGUoYWxsUmVzb2x2ZWQsIFwiYWxsUmVzb2x2ZWRcIiwgXCJhbGxTZXR0bGVkXCIpO1xuZnVuY3Rpb24gYWxsUmVzb2x2ZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHByb21pc2VzID0gYXJyYXlfbWFwKHByb21pc2VzLCBRKTtcbiAgICAgICAgcmV0dXJuIHdoZW4oYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB3aGVuKHByb21pc2UsIG5vb3AsIG5vb3ApO1xuICAgICAgICB9KSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbFJlc29sdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXNvbHZlZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQHNlZSBQcm9taXNlI2FsbFNldHRsZWRcbiAqL1xuUS5hbGxTZXR0bGVkID0gYWxsU2V0dGxlZDtcbmZ1bmN0aW9uIGFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUShwcm9taXNlcykuYWxsU2V0dGxlZCgpO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzIGludG8gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGVpciBzdGF0ZXMgKGFzXG4gKiByZXR1cm5lZCBieSBgaW5zcGVjdGApIHdoZW4gdGhleSBoYXZlIGFsbCBzZXR0bGVkLlxuICogQHBhcmFtIHtBcnJheVtBbnkqXX0gdmFsdWVzIGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIHtBcnJheVtTdGF0ZV19IGFuIGFycmF5IG9mIHN0YXRlcyBmb3IgdGhlIHJlc3BlY3RpdmUgdmFsdWVzLlxuICovXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxTZXR0bGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiBhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFEocHJvbWlzZSk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZWdhcmRsZXNzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLmluc3BlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVnYXJkbGVzcywgcmVnYXJkbGVzcyk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIGZhaWx1cmUgb2YgYSBwcm9taXNlLCBnaXZpbmcgYW4gb3BvcnR1bml0eSB0byByZWNvdmVyXG4gKiB3aXRoIGEgY2FsbGJhY2suICBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpcyBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICogcHJvbWlzZSBpcyBmdWxmaWxsZWQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpZiB0aGVcbiAqIGdpdmVuIHByb21pc2UgaXMgcmVqZWN0ZWRcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGJhY2tcbiAqL1xuUS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9iamVjdCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYWlsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChyZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgbGlzdGVuZXIgdGhhdCBjYW4gcmVzcG9uZCB0byBwcm9ncmVzcyBub3RpZmljYXRpb25zIGZyb20gYVxuICogcHJvbWlzZSdzIG9yaWdpbmF0aW5nIGRlZmVycmVkLiBUaGlzIGxpc3RlbmVyIHJlY2VpdmVzIHRoZSBleGFjdCBhcmd1bWVudHNcbiAqIHBhc3NlZCB0byBgYGRlZmVycmVkLm5vdGlmeWBgLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIHJlY2VpdmUgYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm5zIHRoZSBnaXZlbiBwcm9taXNlLCB1bmNoYW5nZWRcbiAqL1xuUS5wcm9ncmVzcyA9IHByb2dyZXNzO1xuZnVuY3Rpb24gcHJvZ3Jlc3Mob2JqZWN0LCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucHJvZ3Jlc3MgPSBmdW5jdGlvbiAocHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhbiBvcHBvcnR1bml0eSB0byBvYnNlcnZlIHRoZSBzZXR0bGluZyBvZiBhIHByb21pc2UsXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIHByb21pc2UgaXMgZnVsZmlsbGVkIG9yIHJlamVjdGVkLiAgRm9yd2FyZHNcbiAqIHRoZSByZXNvbHV0aW9uIHRvIHRoZSByZXR1cm5lZCBwcm9taXNlIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGRvbmUuXG4gKiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIHByb21pc2UgdG8gZGVmZXIgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gb2JzZXJ2ZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW5cbiAqIHByb21pc2UsIHRha2VzIG5vIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2Ugd2hlblxuICogYGBmaW5gYCBpcyBkb25lLlxuICovXG5RLmZpbiA9IC8vIFhYWCBsZWdhY3lcblFbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpW1wiZmluYWxseVwiXShjYWxsYmFjayk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5maW4gPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjay5hcHBseSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3QgYXBwbHkgZmluYWxseSBjYWxsYmFja1wiKTtcbiAgICB9XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgYG5leHRUaWNrYGluZyB2aWEgYW4gdW5uZWNlc3NhcnkgYHdoZW5gLlxuICAgIHZhciBwcm9taXNlID0gZnVsZmlsbGVkIHx8IHJlamVjdGVkIHx8IHByb2dyZXNzID9cbiAgICAgICAgdGhpcy50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSA6XG4gICAgICAgIHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgICBvblVuaGFuZGxlZEVycm9yID0gcHJvY2Vzcy5kb21haW4uYmluZChvblVuaGFuZGxlZEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4odm9pZCAwLCBvblVuaGFuZGxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogQ2F1c2VzIGEgcHJvbWlzZSB0byBiZSByZWplY3RlZCBpZiBpdCBkb2VzIG5vdCBnZXQgZnVsZmlsbGVkIGJlZm9yZVxuICogc29tZSBtaWxsaXNlY29uZHMgdGltZSBvdXQuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHMgdGltZW91dFxuICogQHBhcmFtIHtBbnkqfSBjdXN0b20gZXJyb3IgbWVzc2FnZSBvciBFcnJvciBvYmplY3QgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgZXJyb3IpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRpbWVvdXQobXMsIGVycm9yKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIGVycm9yKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZXJyb3IgfHwgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvciB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIik7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgfVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyb3IpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUSBjYW4ndCB3cmFwIGFuIHVuZGVmaW5lZCBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cblEubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlEubm9Db25mbGljdCBvbmx5IHdvcmtzIHdoZW4gUSBpcyB1c2VkIGFzIGEgZ2xvYmFsXCIpO1xufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLypcbiogQ29weXJpZ2h0IDIwMTUgU3BpbmFsQ29tIC0gd3d3LnNwaW5hbGNvbS5jb21cbipcbiogVGhpcyBmaWxlIGlzIHBhcnQgb2YgU3BpbmFsQ29yZS5cbipcbiogUGxlYXNlIHJlYWQgYWxsIG9mIHRoZSBmb2xsb3dpbmcgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2YgdGhlIEZyZWUgU29mdHdhcmVcbiogbGljZW5zZSBBZ3JlZW1lbnQgKFwiQWdyZWVtZW50XCIpIGNhcmVmdWxseS5cbipcbiogVGhpcyBBZ3JlZW1lbnQgaXMgYSBsZWdhbGx5IGJpbmRpbmcgY29udHJhY3QgYmV0d2VlbiB0aGUgTGljZW5zZWUgKGFzIGRlZmluZWRcbiogYmVsb3cpIGFuZCBTcGluYWxDb20gdGhhdCBzZXRzIGZvcnRoIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyB0aGF0IGdvdmVyblxuKiB5b3VyIHVzZSBvZiB0aGUgUHJvZ3JhbS4gQnkgaW5zdGFsbGluZyBhbmQvb3IgdXNpbmcgdGhlIFByb2dyYW0sIHlvdSBhZ3JlZSB0b1xuKiBhYmlkZSBieSBhbGwgdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIHN0YXRlZCBvciByZWZlcmVuY2VkIGhlcmVpbi5cbipcbiogSWYgeW91IGRvIG5vdCBhZ3JlZSB0byBhYmlkZSBieSB0aGVzZSB0ZXJtcyBhbmQgY29uZGl0aW9ucywgZG8gbm90XG4qIGRlbW9uc3RyYXRlIHlvdXIgYWNjZXB0YW5jZSBhbmQgZG8gbm90IGluc3RhbGwgb3IgdXNlIHRoZSBQcm9ncmFtLlxuKlxuKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBsaWNlbnNlIGFsb25nIHdpdGggdGhpcyBmaWxlLiBJZiBub3QsXG4qIHNlZSA8aHR0cDovL3Jlc291cmNlcy5zcGluYWxjb20uY29tL2xpY2Vuc2VzLnBkZj4uXG4qL1xuXG4vLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuMTIuN1xudmFyIF9pbmRleF9jdXJyZW50X3BvcHVwLCBhZGRfY2xhc3MsIGdldF9sZWZ0LCBnZXRfdG9wLCBuZXdfYWxlcnRfbXNnLCBuZXdfZG9tX2VsZW1lbnQsIHJlbV9jbGFzcywgcm9vdCwgc3BpbmFsX25ld19wb3B1cCwgdXJsLFxuICBpbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICBiaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxudXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LnNwaW5hbENvcmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHNwaW5hbENvcmUoKSB7fVxuXG4gIHNwaW5hbENvcmUuX2RlZiA9IHt9O1xuXG4gIHNwaW5hbENvcmUuY29ubmVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgYXV0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0gdXJsLnBhcnNlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wYXRoLnNsaWNlKC0xKVswXSAhPT0gXCIvXCIpIHtcbiAgICAgIG9wdGlvbnMucGF0aCArPSBcIi9cIjtcbiAgICB9XG4gICAgRmlsZVN5c3RlbS5faG9tZV9kaXIgPSBvcHRpb25zLnBhdGg7XG4gICAgRmlsZVN5c3RlbS5fdXJsID0gb3B0aW9ucy5ob3N0bmFtZTtcbiAgICBGaWxlU3lzdGVtLl9wb3J0ID0gb3B0aW9ucy5wb3J0O1xuICAgIGlmIChvcHRpb25zLmF1dGggIT09IG51bGwpIHtcbiAgICAgIGF1dGggPSBvcHRpb25zLmF1dGguc3BsaXQoXCI6XCIpO1xuICAgICAgRmlsZVN5c3RlbS5fdXNlcmlkID0gYXV0aFswXTtcbiAgICAgIGlmIChhdXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgRmlsZVN5c3RlbS5fcGFzc3dvcmQgPSBhdXRoWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBGaWxlU3lzdGVtLl91c2VyaWQgPSA2NDQ7XG4gICAgICBGaWxlU3lzdGVtLl9wYXNzd29yZCA9IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRmlsZVN5c3RlbTtcbiAgfTtcblxuICBzcGluYWxDb3JlLnN0b3JlID0gZnVuY3Rpb24oZnMsIG1vZGVsLCBwYXRoLCBjYWxsYmFja19zdWNjZXNzLCBjYWxsYmFja19lcnJvcikge1xuICAgIHZhciBmaWxlX25hbWUsIGxzdDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrX2Vycm9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYWxsYmFja19lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJNb2RlbCBjb3VsZCBub3QgYmUgc3RvcmVkLiBZb3UgY2FuIHBhc3MgYSBjYWxsYmFjayB0byBoYW5kbGUgdGhpcyBlcnJvci5cIik7XG4gICAgICB9O1xuICAgIH1cbiAgICBsc3QgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICBmaWxlX25hbWUgPSBsc3QucG9wKCk7XG4gICAgaWYgKGxzdFswXSA9PT0gXCJcIikge1xuICAgICAgbHN0LnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgcGF0aCA9IGxzdC5qb2luKFwiL1wiKTtcbiAgICByZXR1cm4gZnMubG9hZF9vcl9tYWtlX2RpcihGaWxlU3lzdGVtLl9ob21lX2RpciArIHBhdGgsIGZ1bmN0aW9uKGRpciwgZXJyKSB7XG4gICAgICB2YXIgZmlsZTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX2Vycm9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlID0gZGlyLmRldGVjdChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHgubmFtZS5nZXQoKSA9PT0gZmlsZV9uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZpbGUgIT0gbnVsbCkge1xuICAgICAgICAgIGRpci5yZW1vdmUoZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlyLmFkZF9maWxlKGZpbGVfbmFtZSwgbW9kZWwsIHtcbiAgICAgICAgICBtb2RlbF90eXBlOiBcIk1vZGVsXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdWNjZXNzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc3BpbmFsQ29yZS5yZWdpc3Rlcl9tb2RlbHMgPSBmdW5jdGlvbihtb2RlbExpc3QpIHtcbiAgICB2YXIga2V5LCBsZW4sIG0sIHEsIHJlc3VsdHMsIHJlc3VsdHMxLCB2YWx1ZTtcbiAgICBpZiAobW9kZWxMaXN0ICYmIG1vZGVsTGlzdCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBtb2RlbExpc3QgPSBbbW9kZWxMaXN0XTtcbiAgICB9XG4gICAgaWYgKG1vZGVsTGlzdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSBtb2RlbExpc3QubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgbSA9IG1vZGVsTGlzdFtxXTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHNwaW5hbENvcmUuX2RlZlttLm5hbWVdID0gbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAoa2V5IGluIG1vZGVsTGlzdCkge1xuICAgICAgICB2YWx1ZSA9IG1vZGVsTGlzdFtrZXldO1xuICAgICAgICByZXN1bHRzMS5wdXNoKHNwaW5hbENvcmUuX2RlZltrZXldID0gdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHMxO1xuICAgIH1cbiAgfTtcblxuICBzcGluYWxDb3JlLmxvYWQgPSBmdW5jdGlvbihmcywgcGF0aCwgY2FsbGJhY2tfc3VjY2VzcywgY2FsbGJhY2tfZXJyb3IpIHtcbiAgICB2YXIgZmlsZV9uYW1lLCBsc3Q7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFja19lcnJvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY2FsbGJhY2tfZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiTW9kZWwgY291bGQgbm90IGJlIGxvYWRlZC4gWW91IGNhbiBwYXNzIGEgY2FsbGJhY2sgdG8gaGFuZGxlIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgbHN0ID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgZmlsZV9uYW1lID0gbHN0LnBvcCgpO1xuICAgIGlmIChsc3RbMF0gPT09IFwiXCIpIHtcbiAgICAgIGxzdC5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIHBhdGggPSBsc3Quam9pbihcIi9cIik7XG4gICAgcmV0dXJuIGZzLmxvYWRfb3JfbWFrZV9kaXIoRmlsZVN5c3RlbS5faG9tZV9kaXIgKyBwYXRoLCBmdW5jdGlvbihjdXJyZW50X2RpciwgZXJyKSB7XG4gICAgICB2YXIgZmlsZTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX2Vycm9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlID0gY3VycmVudF9kaXIuZGV0ZWN0KGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5uYW1lLmdldCgpID09PSBmaWxlX25hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmlsZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbGUubG9hZChmdW5jdGlvbihkYXRhLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrX2Vycm9yKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tfc3VjY2VzcyhkYXRhLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFja19lcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc3BpbmFsQ29yZS5sb2FkX3R5cGUgPSBmdW5jdGlvbihmcywgdHlwZSwgY2FsbGJhY2tfc3VjY2VzcywgY2FsbGJhY2tfZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrX2Vycm9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjYWxsYmFja19lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5sb2coXCJNb2RlbCBvZiB0aGlzIHR5cGUgY291bGQgbm90IGJlIGxvYWRlZC4gXCIgKyBcIllvdSBjYW4gcGFzcyBhIGNhbGxiYWNrIHRvIGhhbmRsZSB0aGlzIGVycm9yLlwiKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmcy5sb2FkX3R5cGUodHlwZSwgZnVuY3Rpb24oZGF0YSwgZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja19lcnJvcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX3N1Y2Nlc3MoZGF0YSwgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBzcGluYWxDb3JlLmxvYWRfcmlnaHQgPSBmdW5jdGlvbihmcywgcHRyLCBjYWxsYmFja19zdWNjZXNzLCBjYWxsYmFja19lcnJvcikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2tfZXJyb3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNhbGxiYWNrX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcIk1vZGVsIFJpZ2h0IGNvdWxkIG5vdCBiZSBsb2FkZWQuXCIgKyBcIiBZb3UgY2FuIHBhc3MgYSBjYWxsYmFjayB0byBoYW5kbGUgdGhpcyBlcnJvci5cIik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnMubG9hZF9yaWdodChwdHIsIGZ1bmN0aW9uKGRhdGEsIGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tfZXJyb3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja19zdWNjZXNzKGRhdGEsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc3BpbmFsQ29yZS5zaGFyZV9tb2RlbCA9IGZ1bmN0aW9uKGZzLCBwdHIsIGZpbGVfbmFtZSwgcmlnaHRfZmxhZywgdGFyZ2V0TmFtZSkge1xuICAgIHJldHVybiBmcy5zaGFyZV9tb2RlbChwdHIsIGZpbGVfbmFtZSwgcmlnaHRfZmxhZywgdGFyZ2V0TmFtZSk7XG4gIH07XG5cbiAgc3BpbmFsQ29yZS5yaWdodF9mbGFnID0ge1xuICAgIEFEOiAxLFxuICAgIFdSOiAyLFxuICAgIFJEOiA0XG4gIH07XG5cbiAgc3BpbmFsQ29yZS5leHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgdmFyIGNoaWxkX25hbWUsIGN0b3IsIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICB2YWx1ZSA9IHBhcmVudFtrZXldO1xuICAgICAgY2hpbGRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgfTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnN1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgXHRmb3IgKHZhciBpPTE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJnc1tpLTFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgY2hpbGQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KGFyZ3VtZW50c1swXSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsICE9PSBudWxsID8gZ2xvYmFsIDogd2luZG93O1xuICAgIGNoaWxkX25hbWUgPSAvXmZ1bmN0aW9uXFxzKyhbXFx3XFwkXSspXFxzKlxcKC8uZXhlYyhjaGlsZC50b1N0cmluZygpKVsxXTtcbiAgICByZXR1cm4gcm9vdFtjaGlsZF9uYW1lXSA9IGNoaWxkO1xuICB9O1xuXG4gIHJldHVybiBzcGluYWxDb3JlO1xuXG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNwaW5hbENvcmU7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290Lk1vZGVsUHJvY2Vzc01hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIE1vZGVsUHJvY2Vzc01hbmFnZXIoKSB7fVxuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2NvdW50ZXIgPSAwO1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX21vZGxpc3QgPSB7fTtcblxuICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9uX3Byb2Nlc3NlcyA9IHt9O1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2N1cl9taWQgPSAwO1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2N1cl9wcm9jZXNzX2lkID0gMDtcblxuICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl90aW1lb3V0ID0gdm9pZCAwO1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2ZvcmNlX20gPSBmYWxzZTtcblxuICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9zeW5jaHJvID0gdm9pZCAwO1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIubmV3X2Zyb21fc3RhdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgbCwgbGVuLCBsc3QsIG1hcCwgbWlkLCBxLCBzO1xuICAgIG1hcCA9IHt9O1xuICAgIGxzdCA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICBtaWQgPSBsc3Quc2hpZnQoKTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSBsc3QubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGwgPSBsc3RbcV07XG4gICAgICBpZiAoIWwubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcyA9IGwuc3BsaXQoXCIgXCIpO1xuICAgICAgbWFwW3NbMF1dID0ge1xuICAgICAgICB0eXBlOiBzWzFdLFxuICAgICAgICBkYXRhOiBzWzJdLFxuICAgICAgICBidWZmOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGV2YWwoXCJ2YXIgX19uZXdfXyA9IG5ldyBcIiArIG1hcFttaWRdLnR5cGUgKyBcIjtcIik7XG4gICAgX19uZXdfXy5fc2V0X3N0YXRlKG1hcFttaWRdLmRhdGEsIG1hcCk7XG4gICAgcmV0dXJuIF9fbmV3X187XG4gIH07XG5cbiAgTW9kZWxQcm9jZXNzTWFuYWdlci5sb2FkID0gZnVuY3Rpb24oZmlsZW5hbWUsIGZ1bmMpIHtcbiAgICBpZiAoIU1vZGVsUHJvY2Vzc01hbmFnZXIuc3luY2hyb25pemVyKSB7XG4gICAgICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9zeW5jaHJvID0gbmV3IFN5bmNocm9uaXplcjtcbiAgICB9XG4gICAgcmV0dXJuIE1vZGVsUHJvY2Vzc01hbmFnZXIuX3N5bmNocm8ubG9hZChmaWxlbmFtZSwgZnVuYyk7XG4gIH07XG5cbiAgTW9kZWxQcm9jZXNzTWFuYWdlci5jb252ID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2IGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAodiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXR1cm4gbmV3IExzdCh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cih2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gbmV3IFZhbCh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIG5ldyBCb29sKHYpO1xuICAgIH1cbiAgICBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmV0dXJuIG5ldyBNb2RlbCh2KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPYmoodik7XG4gIH07XG5cbiAgTW9kZWxQcm9jZXNzTWFuYWdlci5nZXRfb2JqZWN0X2NsYXNzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGFycjtcbiAgICBpZiAob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIH1cbiAgICBpZiAob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IudG9TdHJpbmcpIHtcbiAgICAgIGFyciA9IG9iai5jb25zdHJ1Y3Rvci50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvblxccyooXFx3KykvKTtcbiAgICAgIGlmICghYXJyKSB7XG4gICAgICAgIGFyciA9IG9iai5jb25zdHJ1Y3Rvci50b1N0cmluZygpLm1hdGNoKC9jbGFzc1xccyooXFx3KykvKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnIgJiYgYXJyLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gYXJyWzFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9nZXRfYXR0cmlidXRlX25hbWVzID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBrZXksIHJlc3VsdHMsIHZhbDtcbiAgICBpZiAobSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICByZXR1cm4gbS5fYXR0cmlidXRlX25hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgIHZhbCA9IG1ba2V5XTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH07XG5cbiAgTW9kZWxQcm9jZXNzTWFuYWdlci5fbmV3X21vZGVsX2Zyb21fc3RhdGUgPSBmdW5jdGlvbihtaWQsIG1hcCkge1xuICAgIHZhciBpbmZvO1xuICAgIGluZm8gPSBtYXBbbWlkXTtcbiAgICBldmFsKFwiaW5mby5idWZmID0gbmV3IFwiICsgaW5mby50eXBlICsgXCI7XCIpO1xuICAgIGluZm8uYnVmZi5fc2V0X3N0YXRlKGluZm8uZGF0YSwgbWFwKTtcbiAgICByZXR1cm4gaW5mby5idWZmO1xuICB9O1xuXG4gIE1vZGVsUHJvY2Vzc01hbmFnZXIuX25lZWRfc3luY19wcm9jZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoTW9kZWxQcm9jZXNzTWFuYWdlci5fdGltZW91dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gTW9kZWxQcm9jZXNzTWFuYWdlci5fdGltZW91dCA9IHNldFRpbWVvdXQoTW9kZWxQcm9jZXNzTWFuYWdlci5fc3luY19wcm9jZXNzZXMsIDEpO1xuICAgIH1cbiAgfTtcblxuICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9zeW5jX3Byb2Nlc3NlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCwgbGVuLCBtb2RlbCwgcHJvY2VzcywgcHJvY2Vzc2VzLCBxLCByZWYsIHJlZjEsIHJlZjI7XG4gICAgcHJvY2Vzc2VzID0ge307XG4gICAgcmVmID0gTW9kZWxQcm9jZXNzTWFuYWdlci5fbW9kbGlzdDtcbiAgICBmb3IgKGlkIGluIHJlZikge1xuICAgICAgbW9kZWwgPSByZWZbaWRdO1xuICAgICAgcmVmMSA9IG1vZGVsLl9wcm9jZXNzZXM7XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYxLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIHByb2Nlc3MgPSByZWYxW3FdO1xuICAgICAgICBwcm9jZXNzZXNbcHJvY2Vzcy5wcm9jZXNzX2lkXSA9IHtcbiAgICAgICAgICB2YWx1ZTogcHJvY2VzcyxcbiAgICAgICAgICBmb3JjZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVmMiA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuX25fcHJvY2Vzc2VzO1xuICAgIGZvciAoaWQgaW4gcmVmMikge1xuICAgICAgcHJvY2VzcyA9IHJlZjJbaWRdO1xuICAgICAgcHJvY2Vzc2VzW2lkXSA9IHtcbiAgICAgICAgdmFsdWU6IHByb2Nlc3MsXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl90aW1lb3V0ID0gdm9pZCAwO1xuICAgIE1vZGVsUHJvY2Vzc01hbmFnZXIuX21vZGxpc3QgPSB7fTtcbiAgICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9uX3Byb2Nlc3NlcyA9IHt9O1xuICAgIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2NvdW50ZXIgKz0gMjtcbiAgICBmb3IgKGlkIGluIHByb2Nlc3Nlcykge1xuICAgICAgcHJvY2VzcyA9IHByb2Nlc3Nlc1tpZF07XG4gICAgICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9mb3JjZV9tID0gcHJvY2Vzcy5mb3JjZTtcbiAgICAgIHByb2Nlc3MudmFsdWUub25jaGFuZ2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2ZvcmNlX20gPSBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gTW9kZWxQcm9jZXNzTWFuYWdlcjtcblxufSkoKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuU3BpbmFsVXNlck1hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFNwaW5hbFVzZXJNYW5hZ2VyKCkge31cblxuICBTcGluYWxVc2VyTWFuYWdlci5nZXRfdXNlcl9pZCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHVzZXJfbmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3NfY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKSB7XG4gICAgdmFyIGdldF9jbWQ7XG4gICAgaWYgKGVycm9yX2NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIGVycm9yX2NhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0X2NtZCA9ICcvZ2V0X3VzZXJfaWQ/dT0nICsgdXNlcl9uYW1lICsgJyZwPScgKyBwYXNzd29yZDtcbiAgICByZXR1cm4gdGhpcy5zZW5kX3hocihvcHRpb25zLCBnZXRfY21kLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHBhcnNlSW50KHJlc3BvbnNlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF91c2VyX2lkJywgcmVzcG9uc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NfY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF91c2VyX2lkJywgc3RhdHVzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTcGluYWxVc2VyTWFuYWdlci5nZXRfYWRtaW5faWQgPSBmdW5jdGlvbihvcHRpb25zLCBhZG1pbl9uYW1lLCBwYXNzd29yZCwgc3VjY2Vzc19jYWxsYmFjaywgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZ2V0X2NtZDtcbiAgICBpZiAoZXJyb3JfY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgZXJyb3JfY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXRfY21kID0gJy9nZXRfYWRtaW5faWQ/dT0nICsgYWRtaW5fbmFtZSArICcmcD0nICsgcGFzc3dvcmQ7XG4gICAgcmV0dXJuIHRoaXMuc2VuZF94aHIob3B0aW9ucywgZ2V0X2NtZCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGlmIChwYXJzZUludChyZXNwb25zZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBTcGluYWxVc2VyTWFuYWdlci5faWZfZXJyb3IoZXJyb3JfY2FsbGJhY2ssICdnZXRfYWRtaW5faWQnLCByZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VjY2Vzc19jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICByZXR1cm4gU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yKGVycm9yX2NhbGxiYWNrLCAnZ2V0X2FkbWluX2lkJywgc3RhdHVzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTcGluYWxVc2VyTWFuYWdlci5uZXdfYWNjb3VudCA9IGZ1bmN0aW9uKG9wdGlvbnMsIHVzZXJfbmFtZSwgcGFzc3dvcmQsIHN1Y2Nlc3NfY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKSB7XG4gICAgdmFyIGdldF9jbWQ7XG4gICAgaWYgKGVycm9yX2NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIGVycm9yX2NhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0X2NtZCA9ICcvZ2V0X25ld19hY2NvdW50P2U9JyArIHVzZXJfbmFtZSArICcmcD0nICsgcGFzc3dvcmQgKyAnJmNwPScgKyBwYXNzd29yZDtcbiAgICByZXR1cm4gdGhpcy5zZW5kX3hocihvcHRpb25zLCBnZXRfY21kLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHBhcnNlSW50KHJlc3BvbnNlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9uZXdfYWNjb3VudCcsIHN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VjY2Vzc19jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICByZXR1cm4gU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yKGVycm9yX2NhbGxiYWNrLCAnZ2V0X25ld19hY2NvdW50Jywgc3RhdHVzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTcGluYWxVc2VyTWFuYWdlci5jaGFuZ2VfcGFzc3dvcmQgPSBmdW5jdGlvbihvcHRpb25zLCB1c2VyX2lkLCBwYXNzd29yZCwgbmV3X3Bhc3N3b3JkLCBzdWNjZXNzX2NhbGxiYWNrLCBlcnJvcl9jYWxsYmFjaykge1xuICAgIHZhciBnZXRfY21kO1xuICAgIGlmIChlcnJvcl9jYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICBlcnJvcl9jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGdldF9jbWQgPSAnL2dldF9jaGFuZ2VfdXNlcl9wYXNzd29yZD9lPScgKyB1c2VyX2lkICsgJyZvcD0nICsgcGFzc3dvcmQgKyAnJm5wPScgKyBuZXdfcGFzc3dvcmQgKyAnJmNwPScgKyBuZXdfcGFzc3dvcmQ7XG4gICAgcmV0dXJuIHRoaXMuc2VuZF94aHIob3B0aW9ucywgZ2V0X2NtZCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIGlmIChwYXJzZUludChyZXNwb25zZSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBTcGluYWxVc2VyTWFuYWdlci5faWZfZXJyb3IoZXJyb3JfY2FsbGJhY2ssICdnZXRfY2hhbmdlX3VzZXJfcGFzc3dvcmQnLCBzdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NfY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9jaGFuZ2VfdXNlcl9wYXNzd29yZCcsIHN0YXR1cyk7XG4gICAgfSk7XG4gIH07XG5cbiAgU3BpbmFsVXNlck1hbmFnZXIuZGVsZXRlX2FjY291bnQgPSBmdW5jdGlvbihvcHRpb25zLCB1c2VyX2lkLCBwYXNzd29yZCwgc3VjY2Vzc19jYWxsYmFjaywgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZ2V0X2NtZDtcbiAgICBpZiAoZXJyb3JfY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgZXJyb3JfY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXRfY21kID0gJy9nZXRfZGVsZXRlX2FjY291bnQ/ZT0nICsgdXNlcl9uYW1lICsgJyZpPScgKyB1c2VyX2lkICsgJyZwPScgKyBwYXNzd29yZDtcbiAgICByZXR1cm4gdGhpcy5zZW5kX3hocihvcHRpb25zLCBnZXRfY21kLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHBhcnNlSW50KHJlc3BvbnNlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9kZWxldGVfYWNjb3VudCcsIHN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VjY2Vzc19jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICByZXR1cm4gU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yKGVycm9yX2NhbGxiYWNrLCAnZ2V0X2RlbGV0ZV9hY2NvdW50Jywgc3RhdHVzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTcGluYWxVc2VyTWFuYWdlci5jaGFuZ2VfcGFzc3dvcmRfYnlfYWRtaW4gPSBmdW5jdGlvbihvcHRpb25zLCB1c2VybmFtZSwgcGFzc3dvcmQsIGFkbWluX2lkLCBhZG1pbl9wYXNzd29yZCwgc3VjY2Vzc19jYWxsYmFjaywgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZ2V0X2NtZDtcbiAgICBpZiAoZXJyb3JfY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgICAgZXJyb3JfY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbiAgICBnZXRfY21kID0gJy9nZXRfY2hhbmdlX3VzZXJfcGFzc3dvcmRfYnlfYWRtaW4/dT0nICsgdXNlcm5hbWUgKyAnJm5wPScgKyBwYXNzd29yZCArICcmYT0nICsgYWRtaW5faWQgKyAnJmFwPScgKyBhZG1pbl9wYXNzd29yZDtcbiAgICByZXR1cm4gdGhpcy5zZW5kX3hocihvcHRpb25zLCBnZXRfY21kLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHBhcnNlSW50KHJlc3BvbnNlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9jaGFuZ2VfdXNlcl9wYXNzd29yZF9ieV9hZG1pbicsIHN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VjY2Vzc19jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICByZXR1cm4gU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yKGVycm9yX2NhbGxiYWNrLCAnZ2V0X2NoYW5nZV91c2VyX3Bhc3N3b3JkX2J5X2FkbWluJywgc3RhdHVzKTtcbiAgICB9KTtcbiAgfTtcblxuICBTcGluYWxVc2VyTWFuYWdlci5kZWxldGVfYWNjb3VudF9ieV9hZG1pbiA9IGZ1bmN0aW9uKG9wdGlvbnMsIHVzZXJuYW1lLCBhZG1pbl9pZCwgYWRtaW5fcGFzc3dvcmQsIHN1Y2Nlc3NfY2FsbGJhY2ssIGVycm9yX2NhbGxiYWNrKSB7XG4gICAgdmFyIGdldF9jbWQ7XG4gICAgaWYgKGVycm9yX2NhbGxiYWNrID09IG51bGwpIHtcbiAgICAgIGVycm9yX2NhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0X2NtZCA9ICcvZ2V0X2RlbGV0ZV9hY2NvdW50X2J5X2FkbWluP3U9JyArIHVzZXJuYW1lICsgJyZhPScgKyBhZG1pbl9pZCArICcmYXA9JyArIGFkbWluX3Bhc3N3b3JkO1xuICAgIHJldHVybiB0aGlzLnNlbmRfeGhyKG9wdGlvbnMsIGdldF9jbWQsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocGFyc2VJbnQocmVzcG9uc2UpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yKGVycm9yX2NhbGxiYWNrLCAnZ2V0X2RlbGV0ZV9hY2NvdW50X2J5X2FkbWluJywgc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzX2NhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIHJldHVybiBTcGluYWxVc2VyTWFuYWdlci5faWZfZXJyb3IoZXJyb3JfY2FsbGJhY2ssICdnZXRfZGVsZXRlX2FjY291bnRfYnlfYWRtaW4nLCBzdGF0dXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNwaW5hbFVzZXJNYW5hZ2VyLmNoYW5nZV9hY2NvdW50X3JpZ2h0c19ieV9hZG1pbiA9IGZ1bmN0aW9uKG9wdGlvbnMsIHVzZXJuYW1lLCByaWdodCwgYWRtaW5faWQsIGFkbWluX3Bhc3N3b3JkLCBzdWNjZXNzX2NhbGxiYWNrLCBlcnJvcl9jYWxsYmFjaykge1xuICAgIHZhciBnZXRfY21kO1xuICAgIGlmIChlcnJvcl9jYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICBlcnJvcl9jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIGdldF9jbWQgPSAnL2dldF9jaGFuZ2VfYWNjb3VudF9yaWdodHNfYnlfYWRtaW4/dT0nICsgdXNlcm5hbWUgKyAnJnJpPScgKyByaWdodCArICcmYT0nICsgYWRtaW5faWQgKyAnJmFwPScgKyBhZG1pbl9wYXNzd29yZDtcbiAgICByZXR1cm4gdGhpcy5zZW5kX3hocihvcHRpb25zLCBnZXRfY21kLCBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgaWYgKHBhcnNlSW50KHJlc3BvbnNlKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9jaGFuZ2VfYWNjb3VudF9yaWdodHNfYnlfYWRtaW4nLCBzdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NfY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyLl9pZl9lcnJvcihlcnJvcl9jYWxsYmFjaywgJ2dldF9jaGFuZ2VfYWNjb3VudF9yaWdodHNfYnlfYWRtaW4nLCBzdGF0dXMpO1xuICAgIH0pO1xuICB9O1xuXG4gIFNwaW5hbFVzZXJNYW5hZ2VyLnNlbmRfeGhyID0gZnVuY3Rpb24ob3B0aW9ucywgZ2V0X2NtZCwgc3VjY2Vzc19jYWxsYmFjaywgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgcGF0aCwgeGhyX29iamVjdDtcbiAgICBwYXRoID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0gdXJsLnBhcnNlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBGaWxlU3lzdGVtLl91cmwgPSBvcHRpb25zLmhvc3RuYW1lO1xuICAgIEZpbGVTeXN0ZW0uX3BvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgaWYgKEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPT09IFwiTm9kZVwiIHx8IEZpbGVTeXN0ZW0uaXNfY29yZG92YSkge1xuICAgICAgaWYgKEZpbGVTeXN0ZW0uX3BvcnQpIHtcbiAgICAgICAgcGF0aCA9IFwiaHR0cDovL1wiICsgRmlsZVN5c3RlbS5fdXJsICsgXCI6XCIgKyBGaWxlU3lzdGVtLl9wb3J0ICsgZ2V0X2NtZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBcImh0dHA6Ly9cIiArIEZpbGVTeXN0ZW0uX3VybCArIGdldF9jbWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIkJyb3dzZXJcIikge1xuICAgICAgcGF0aCA9IGdldF9jbWQ7XG4gICAgfVxuICAgIHhocl9vYmplY3QgPSBGaWxlU3lzdGVtLl9teV94bWxfaHR0cF9yZXF1ZXN0KCk7XG4gICAgeGhyX29iamVjdC5vcGVuKCdHRVQnLCBwYXRoLCB0cnVlKTtcbiAgICB4aHJfb2JqZWN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCAmJiB0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzX2NhbGxiYWNrKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIHJldHVybiBlcnJvcl9jYWxsYmFjayh0aGlzLnN0YXR1cyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geGhyX29iamVjdC5zZW5kKCk7XG4gIH07XG5cbiAgU3BpbmFsVXNlck1hbmFnZXIuX2lmX2Vycm9yID0gZnVuY3Rpb24oZXJyb3JfY2FsbGJhY2ssIGZ1biwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyb3JfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlcnJvcl9jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZygnRXJyb3Igb24gJyArIGZ1biArICcgYW5kIHRoZSBlcnJvcl9jYWxsYmFjayB3YXMgbm90IHNldC4nKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFNwaW5hbFVzZXJNYW5hZ2VyO1xuXG59KSgpO1xuXG5yb290ID0gdHlwZW9mIF9yb290X29iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdztcblxucm9vdC5Nb2RlbCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTW9kZWwoYXR0cikge1xuICAgIHRoaXMuX2F0dHJpYnV0ZV9uYW1lcyA9IFtdO1xuICAgIHRoaXMubW9kZWxfaWQgPSBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9jdXJfbWlkO1xuICAgIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2N1cl9taWQgKz0gMTtcbiAgICB0aGlzLl9wcm9jZXNzZXMgPSBbXTtcbiAgICB0aGlzLl9wYXJlbnRzID0gW107XG4gICAgdGhpcy5fZGF0ZV9sYXN0X21vZGlmaWNhdGlvbiA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuX2NvdW50ZXIgKyAyO1xuICAgIGlmIChhdHRyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NldChhdHRyKTtcbiAgICB9XG4gIH1cblxuICBNb2RlbC5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge307XG5cbiAgTW9kZWwucHJvdG90eXBlLmhhc19iZWVuX21vZGlmaWVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVfbGFzdF9tb2RpZmljYXRpb24gPiBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9jb3VudGVyIC0gMiB8fCBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9mb3JjZV9tO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5oYXNfYmVlbl9kaXJlY3RseV9tb2RpZmllZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlX2xhc3RfbW9kaWZpY2F0aW9uID4gTW9kZWxQcm9jZXNzTWFuYWdlci5fY291bnRlciAtIDEgfHwgTW9kZWxQcm9jZXNzTWFuYWdlci5fZm9yY2VfbTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKGYsIG9uY2hhbmdlX2NvbnN0cnVjdGlvbikge1xuICAgIGlmIChvbmNoYW5nZV9jb25zdHJ1Y3Rpb24gPT0gbnVsbCkge1xuICAgICAgb25jaGFuZ2VfY29uc3RydWN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGYgaW5zdGFuY2VvZiBQcm9jZXNzKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzZXMucHVzaChmKTtcbiAgICAgIGYuX21vZGVscy5wdXNoKHRoaXMpO1xuICAgICAgaWYgKG9uY2hhbmdlX2NvbnN0cnVjdGlvbikge1xuICAgICAgICBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9uX3Byb2Nlc3Nlc1tmLnByb2Nlc3NfaWRdID0gZjtcbiAgICAgICAgcmV0dXJuIE1vZGVsUHJvY2Vzc01hbmFnZXIuX25lZWRfc3luY19wcm9jZXNzZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBCaW5kUHJvY2Vzcyh0aGlzLCBvbmNoYW5nZV9jb25zdHJ1Y3Rpb24sIGYpO1xuICAgIH1cbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBsZW4sIHEsIHJlZiwgcmVzdWx0cywgdjtcbiAgICBpZiAoZiBpbnN0YW5jZW9mIFByb2Nlc3MpIHtcbiAgICAgIHRoaXMuX3Byb2Nlc3Nlcy5zcGxpY2UodGhpcy5fcHJvY2Vzc2VzLmluZGV4T2YoZiksIDEpO1xuICAgICAgcmV0dXJuIGYuX21vZGVscy5zcGxpY2UoZi5fbW9kZWxzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB0aGlzLl9wcm9jZXNzZXM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgdiA9IHJlZltxXTtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBCaW5kUHJvY2VzcyAmJiB2LmYgPT09IGYpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy51bmJpbmQodikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW4sIG5hbWUsIHEsIHJlZiwgcmVzO1xuICAgIHJlcyA9IHt9O1xuICAgIHJlZiA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIG5hbWUgPSByZWZbcV07XG4gICAgICByZXNbbmFtZV0gPSB0aGlzW25hbWVdLmdldCgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9zZXQodmFsdWUpKSB7XG4gICAgICB0aGlzLl9zaWduYWxfY2hhbmdlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5zZXRfc3RhdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgbCwgbGVuLCBsc3QsIG1hcCwgbWlkLCBxLCBzO1xuICAgIG1hcCA9IHt9O1xuICAgIGxzdCA9IHN0ci5zcGxpdChcIlxcblwiKTtcbiAgICBtaWQgPSBsc3Quc2hpZnQoKTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSBsc3QubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGwgPSBsc3RbcV07XG4gICAgICBpZiAoIWwubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcyA9IGwuc3BsaXQoXCIgXCIpO1xuICAgICAgbWFwW3NbMF1dID0ge1xuICAgICAgICB0eXBlOiBzWzFdLFxuICAgICAgICBkYXRhOiBzWzJdLFxuICAgICAgICBidWZmOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfVxuICAgIG1hcFttaWRdLmJ1ZmYgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9zZXRfc3RhdGUobWFwW21pZF0uZGF0YSwgbWFwKTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuZ2V0X3N0YXRlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBmbW0sIGlkLCBvYmosIHJlcztcbiAgICBpZiAoZGF0ZSA9PSBudWxsKSB7XG4gICAgICBkYXRlID0gLTE7XG4gICAgfVxuICAgIGZtbSA9IHt9O1xuICAgIHRoaXMuX2dldF9mbGF0X21vZGVsX21hcChmbW0sIGRhdGUpO1xuICAgIHJlcyA9IHRoaXMubW9kZWxfaWQudG9TdHJpbmcoKTtcbiAgICBpZiAodGhpcy5fZGF0ZV9sYXN0X21vZGlmaWNhdGlvbiA+IGRhdGUpIHtcbiAgICAgIGZvciAoaWQgaW4gZm1tKSB7XG4gICAgICAgIG9iaiA9IGZtbVtpZF07XG4gICAgICAgIHJlcyArPSBcIlxcblwiICsgb2JqLm1vZGVsX2lkICsgXCIgXCIgKyBNb2RlbFByb2Nlc3NNYW5hZ2VyLmdldF9vYmplY3RfY2xhc3Mob2JqKSArIFwiIFwiICsgb2JqLl9nZXRfc3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuYWRkX2F0dHIgPSBmdW5jdGlvbihuLCBwLCBzaWduYWxfY2hhbmdlKSB7XG4gICAgdmFyIGtleSwgcmVzdWx0cywgdmFsO1xuICAgIGlmIChzaWduYWxfY2hhbmdlID09IG51bGwpIHtcbiAgICAgIHNpZ25hbF9jaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdGhpc1tuXSA9IHA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpc1tuXSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJhdHRyaWJ1dGUgXCIgKyBuICsgXCIgYWxyZWFkeSBleGlzdHMgaW4gXCIpICsgKFwiXCIgKyAoTW9kZWxQcm9jZXNzTWFuYWdlci5nZXRfb2JqZWN0X2NsYXNzKHRoaXMpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBNb2RlbFByb2Nlc3NNYW5hZ2VyLmNvbnYocCk7XG4gICAgICAgIGlmIChpbmRleE9mLmNhbGwocC5fcGFyZW50cywgdGhpcykgPCAwKSB7XG4gICAgICAgICAgcC5fcGFyZW50cy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZV9uYW1lcy5wdXNoKG4pO1xuICAgICAgICB0aGlzW25dID0gcDtcbiAgICAgICAgaWYgKHNpZ25hbF9jaGFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsX2NoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoa2V5IGluIG4pIHtcbiAgICAgICAgdmFsID0gbltrZXldO1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5hZGRfYXR0cihrZXksIHZhbCwgc2lnbmFsX2NoYW5nZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLnJlbV9hdHRyID0gZnVuY3Rpb24obmFtZSwgc2lnbmFsX2NoYW5nZSkge1xuICAgIHZhciBjLCBpO1xuICAgIGlmIChzaWduYWxfY2hhbmdlID09IG51bGwpIHtcbiAgICAgIHNpZ25hbF9jaGFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBjID0gdGhpc1tuYW1lXTtcbiAgICBpZiAoYykge1xuICAgICAgaSA9IGMuX3BhcmVudHMuaW5kZXhPZih0aGlzKTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgYy5fcGFyZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlmIChjLl9wYXJlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIGkgPSB0aGlzLl9hdHRyaWJ1dGVfbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlX25hbWVzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWxfY2hhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduYWxfY2hhbmdlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5tb2RfYXR0ciA9IGZ1bmN0aW9uKG4sIHApIHtcbiAgICBpZiAodGhpc1tuXSAhPT0gcCkge1xuICAgICAgdGhpcy5yZW1fYXR0cihuKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZF9hdHRyKG4sIHApO1xuICAgIH1cbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuc2V0X2F0dHIgPSBmdW5jdGlvbihvKSB7XG4gICAgdmFyIGssIGxlbiwgcSwgciwgcmVzdWx0cywgdG9fcmVtLCB2O1xuICAgIGZvciAoayBpbiBvKSB7XG4gICAgICB2ID0gb1trXTtcbiAgICAgIHRoaXMubW9kX2F0dHIoaywgdik7XG4gICAgfVxuICAgIHRvX3JlbSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4sIHEsIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlZiA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgICBrID0gcmVmW3FdO1xuICAgICAgICBpZiAob1trXSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSB0b19yZW0ubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIHIgPSB0b19yZW1bcV07XG4gICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1fYXR0cihyKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oZm9yX2Rpc3BsYXkpIHtcbiAgICBpZiAoZm9yX2Rpc3BsYXkgPT0gbnVsbCkge1xuICAgICAgZm9yX2Rpc3BsYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5kaW0gPSBmdW5jdGlvbihmb3JfZGlzcGxheSkge1xuICAgIGlmIChmb3JfZGlzcGxheSA9PSBudWxsKSB7XG4gICAgICBmb3JfZGlzcGxheSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaXplKGZvcl9kaXNwbGF5KS5sZW5ndGg7XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIga2V5LCBsZW4sIGxlbjEsIHEsIHJlZiwgcmVmMSwgdSwgdmFsLCB5O1xuICAgIGlmICh0aGlzID09PSBtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG0uX2F0dHJpYnV0ZV9uYW1lcyAhPSBudWxsKSB7XG4gICAgICB1ID0ge307XG4gICAgICByZWYgPSBtLl9hdHRyaWJ1dGVfbmFtZXM7XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAga2V5ID0gcmVmW3FdO1xuICAgICAgICB2YWwgPSBtW2tleV07XG4gICAgICAgIGlmICh0aGlzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXNba2V5XS5lcXVhbHModmFsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVmMSA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICAgIGZvciAoeSA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgeSA8IGxlbjE7IHkrKykge1xuICAgICAgICBrZXkgPSByZWYxW3ldO1xuICAgICAgICBpZiAodVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5nZXRfcGFyZW50c190aGF0X2NoZWNrID0gZnVuY3Rpb24oZnVuY190b19jaGVjaykge1xuICAgIHZhciByZXMsIHZpc2l0ZWQ7XG4gICAgcmVzID0gW107XG4gICAgdmlzaXRlZCA9IHt9O1xuICAgIHRoaXMuX2dldF9wYXJlbnRzX3RoYXRfY2hlY2tfcmVjKHJlcywgdmlzaXRlZCwgZnVuY190b19jaGVjayk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuZGVlcF9jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleSwgbGVuLCBvLCBxLCByZWY7XG4gICAgbyA9IHt9O1xuICAgIHJlZiA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGtleSA9IHJlZltxXTtcbiAgICAgIG9ba2V5XSA9IHRoaXNba2V5XS5kZWVwX2NvcHkoKTtcbiAgICB9XG4gICAgZXZhbChcInZhciBfX25ld19fID0gbmV3IFwiICsgKE1vZGVsUHJvY2Vzc01hbmFnZXIuZ2V0X29iamVjdF9jbGFzcyh0aGlzKSkgKyBcIjtcIik7XG4gICAgX19uZXdfXy5zZXRfYXR0cihvKTtcbiAgICByZXR1cm4gX19uZXdfXztcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUucmVhbF9jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSwgbGVuLCBxLCByZWY7XG4gICAgaWYgKHRoaXMuaGFzX2JlZW5fZGlyZWN0bHlfbW9kaWZpZWQoKSAmJiAhdGhpcy5fYXR0cmlidXRlX25hbWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlZiA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGEgPSByZWZbcV07XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY29zbWV0aWNfYXR0cmlidXRlID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmNvc21ldGljX2F0dHJpYnV0ZShhKSA6IHZvaWQgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzW2FdLnJlYWxfY2hhbmdlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuY29zbWV0aWNfYXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuX2dldF9zdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lLCBzdHI7XG4gICAgc3RyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbiwgcSwgcmVmLCByZXN1bHRzO1xuICAgICAgcmVmID0gdGhpcy5fYXR0cmlidXRlX25hbWVzO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIG5hbWUgPSByZWZbcV07XG4gICAgICAgIHJlc3VsdHMucHVzaChuYW1lICsgXCI6XCIgKyB0aGlzW25hbWVdLm1vZGVsX2lkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHN0ci5qb2luKFwiLFwiKTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuX2dldF9mc19kYXRhID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG5hbWUsIG9iaiwgc3RyO1xuICAgIEZpbGVTeXN0ZW0uc2V0X3NlcnZlcl9pZF9pZl9uZWNlc3Nhcnkob3V0LCB0aGlzKTtcbiAgICBzdHIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuLCBxLCByZWYsIHJlc3VsdHM7XG4gICAgICByZWYgPSB0aGlzLl9hdHRyaWJ1dGVfbmFtZXM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgbmFtZSA9IHJlZltxXTtcbiAgICAgICAgb2JqID0gdGhpc1tuYW1lXTtcbiAgICAgICAgRmlsZVN5c3RlbS5zZXRfc2VydmVyX2lkX2lmX25lY2Vzc2FyeShvdXQsIG9iaik7XG4gICAgICAgIHJlc3VsdHMucHVzaChuYW1lICsgXCI6XCIgKyBvYmouX3NlcnZlcl9pZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9KS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiBvdXQubW9kICs9IFwiQyBcIiArIHRoaXMuX3NlcnZlcl9pZCArIFwiIFwiICsgKHN0ci5qb2luKFwiLFwiKSkgKyBcIiBcIjtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGNoYW5nZSwga2V5LCBsZW4sIGxlbjEsIHEsIHJlZiwgcmVmMSwgdXNlZCwgdmFsLCB5O1xuICAgIGNoYW5nZSA9IGZhbHNlO1xuICAgIHVzZWQgPSB7fTtcbiAgICByZWYgPSBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9nZXRfYXR0cmlidXRlX25hbWVzKHZhbHVlKTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGtleSA9IHJlZltxXTtcbiAgICAgIHVzZWRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIHJlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuMSwgcmVmMSwgcmVzdWx0cywgejtcbiAgICAgIHJlZjEgPSB0aGlzLl9hdHRyaWJ1dGVfbmFtZXM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHogPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IHogPCBsZW4xOyB6KyspIHtcbiAgICAgICAga2V5ID0gcmVmMVt6XTtcbiAgICAgICAgaWYgKCF1c2VkW2tleV0pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgICBmb3IgKHkgPSAwLCBsZW4xID0gcmVmMS5sZW5ndGg7IHkgPCBsZW4xOyB5KyspIHtcbiAgICAgIGtleSA9IHJlZjFbeV07XG4gICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgdGhpcy5yZW1fYXR0cihrZXksIGZhbHNlKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHZhbCA9IHZhbHVlW2tleV07XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRoaXNba2V5XS5jb25zdHJ1Y3RvciA9PT0gdmFsLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjaGFuZ2UgfD0gdGhpc1trZXldLnNldCh2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tb2RfYXR0cihrZXksIHZhbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFkZF9hdHRyKGtleSwgdmFsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuX3NpZ25hbF9jaGFuZ2UgPSBmdW5jdGlvbihjaGFuZ2VfbGV2ZWwpIHtcbiAgICB2YXIgbGVuLCBwLCBxLCByZWY7XG4gICAgaWYgKGNoYW5nZV9sZXZlbCA9PSBudWxsKSB7XG4gICAgICBjaGFuZ2VfbGV2ZWwgPSAyO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlX2xldmVsID09PSAyICYmICh0aGlzLl9zZXJ2ZXJfaWQgIT0gbnVsbCkpIHtcbiAgICAgIEZpbGVTeXN0ZW0uc2lnbmFsX2NoYW5nZSh0aGlzKTtcbiAgICB9XG4gICAgTW9kZWxQcm9jZXNzTWFuYWdlci5fbW9kbGlzdFt0aGlzLm1vZGVsX2lkXSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2RhdGVfbGFzdF9tb2RpZmljYXRpb24gPD0gTW9kZWxQcm9jZXNzTWFuYWdlci5fY291bnRlcikge1xuICAgICAgdGhpcy5fZGF0ZV9sYXN0X21vZGlmaWNhdGlvbiA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuX2NvdW50ZXIgKyBjaGFuZ2VfbGV2ZWw7XG4gICAgICByZWYgPSB0aGlzLl9wYXJlbnRzO1xuICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIHAgPSByZWZbcV07XG4gICAgICAgIHAuX3NpZ25hbF9jaGFuZ2UoMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNb2RlbFByb2Nlc3NNYW5hZ2VyLl9uZWVkX3N5bmNfcHJvY2Vzc2VzKCk7XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLl9zZXRfc3RhdGUgPSBmdW5jdGlvbihzdHIsIG1hcCkge1xuICAgIHZhciBhdHRyLCBpbnIsIGtfaWQsIGxlbiwgbGVuMSwgcSwgcmVmLCByZWYxLCByZXN1bHRzLCBzcGwsIHUsIHk7XG4gICAgdSA9IHt9O1xuICAgIGlmIChzdHIubGVuZ3RoKSB7XG4gICAgICByZWYgPSBzdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIHNwbCA9IHJlZltxXTtcbiAgICAgICAgaW5yID0gc3BsLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgYXR0ciA9IGluclswXTtcbiAgICAgICAga19pZCA9IGluclsxXTtcbiAgICAgICAgdVthdHRyXSA9IHRydWU7XG4gICAgICAgIGlmIChtYXBba19pZF0uYnVmZiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRoaXNbYXR0cl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGRfYXR0cihhdHRyLCBtYXBba19pZF0uYnVmZik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXBba19pZF0uYnVmZiAhPT0gdGhpc1thdHRyXSkge1xuICAgICAgICAgICAgdGhpcy5tb2RfYXR0cihhdHRyLCBtYXBba19pZF0uYnVmZik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbYXR0cl0gPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuYWRkX2F0dHIoYXR0ciwgTW9kZWxQcm9jZXNzTWFuYWdlci5fbmV3X21vZGVsX2Zyb21fc3RhdGUoa19pZCwgbWFwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXNbYXR0cl0uX3NldF9zdGF0ZV9pZl9zYW1lX3R5cGUoa19pZCwgbWFwKSkge1xuICAgICAgICAgIHRoaXMubW9kX2F0dHIoYXR0ciwgTW9kZWxQcm9jZXNzTWFuYWdlci5fbmV3X21vZGVsX2Zyb21fc3RhdGUoa19pZCwgbWFwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVmMSA9IHRoaXMuX2F0dHJpYnV0ZV9uYW1lcztcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yICh5ID0gMCwgbGVuMSA9IHJlZjEubGVuZ3RoOyB5IDwgbGVuMTsgeSsrKSB7XG4gICAgICBhdHRyID0gcmVmMVt5XTtcbiAgICAgIGlmICghdVthdHRyXSkge1xuICAgICAgICByZXN1bHRzLnB1c2godGhpcy5yZW1fYXR0cihhdHRyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgTW9kZWwucHJvdG90eXBlLl9nZXRfcGFyZW50c190aGF0X2NoZWNrX3JlYyA9IGZ1bmN0aW9uKHJlcywgdmlzaXRlZCwgZnVuY190b19jaGVjaykge1xuICAgIHZhciBsZW4sIHAsIHEsIHJlZiwgcmVzdWx0cztcbiAgICBpZiAodmlzaXRlZFt0aGlzLm1vZGVsX2lkXSA9PSBudWxsKSB7XG4gICAgICB2aXNpdGVkW3RoaXMubW9kZWxfaWRdID0gdHJ1ZTtcbiAgICAgIGlmIChmdW5jX3RvX2NoZWNrKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiByZXMucHVzaCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZiA9IHRoaXMuX3BhcmVudHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgICAgcCA9IHJlZltxXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2gocC5fZ2V0X3BhcmVudHNfdGhhdF9jaGVja19yZWMocmVzLCB2aXNpdGVkLCBmdW5jX3RvX2NoZWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5fc2V0X3N0YXRlX2lmX3NhbWVfdHlwZSA9IGZ1bmN0aW9uKG1pZCwgbWFwKSB7XG4gICAgdmFyIGRhdDtcbiAgICBkYXQgPSBtYXBbbWlkXTtcbiAgICBpZiAoTW9kZWxQcm9jZXNzTWFuYWdlci5nZXRfb2JqZWN0X2NsYXNzKHRoaXMpID09PSBkYXQudHlwZSkge1xuICAgICAgZGF0LmJ1ZmYgPSB0aGlzO1xuICAgICAgdGhpcy5fc2V0X3N0YXRlKGRhdC5kYXRhLCBtYXApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBNb2RlbC5wcm90b3R5cGUuX2dldF9mbGF0X21vZGVsX21hcCA9IGZ1bmN0aW9uKG1hcCwgZGF0ZSkge1xuICAgIHZhciBsZW4sIG5hbWUsIG9iaiwgcSwgcmVmLCByZXN1bHRzO1xuICAgIG1hcFt0aGlzLm1vZGVsX2lkXSA9IHRoaXM7XG4gICAgcmVmID0gdGhpcy5fYXR0cmlidXRlX25hbWVzO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIG5hbWUgPSByZWZbcV07XG4gICAgICBvYmogPSB0aGlzW25hbWVdO1xuICAgICAgaWYgKG1hcFtvYmoubW9kZWxfaWRdID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9iai5fZGF0ZV9sYXN0X21vZGlmaWNhdGlvbiA+IGRhdGUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gob2JqLl9nZXRfZmxhdF9tb2RlbF9tYXAobWFwLCBkYXRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICByZXR1cm4gTW9kZWw7XG5cbn0pKCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290Lk9iaiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChPYmosIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIE9iaihkYXRhKSB7XG4gICAgT2JqLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NldChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBPYmoucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZjtcbiAgICByZXR1cm4gKHJlZiA9IHRoaXMuX2RhdGEpICE9IG51bGwgPyByZWYudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgfTtcblxuICBPYmoucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBPYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXRhID09PSBvYmouX2RhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kYXRhID09PSBvYmo7XG4gIH07XG5cbiAgT2JqLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfTtcblxuICBPYmoucHJvdG90eXBlLl9nZXRfZnNfZGF0YSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIEZpbGVTeXN0ZW0uc2V0X3NlcnZlcl9pZF9pZl9uZWNlc3Nhcnkob3V0LCB0aGlzKTtcbiAgICByZXR1cm4gb3V0Lm1vZCArPSBcIkMgXCIgKyB0aGlzLl9zZXJ2ZXJfaWQgKyBcIiBcIiArICh0aGlzLnRvU3RyaW5nKCkpICsgXCIgXCI7XG4gIH07XG5cbiAgT2JqLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgT2JqLnByb3RvdHlwZS5fZ2V0X3N0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG5cbiAgT2JqLnByb3RvdHlwZS5fc2V0X3N0YXRlID0gZnVuY3Rpb24oc3RyLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoc3RyKTtcbiAgfTtcblxuICByZXR1cm4gT2JqO1xuXG59KShNb2RlbCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkNob2ljZSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChDaG9pY2UsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIENob2ljZShkYXRhLCBpbml0aWFsX2xpc3QpIHtcbiAgICBpZiAoaW5pdGlhbF9saXN0ID09IG51bGwpIHtcbiAgICAgIGluaXRpYWxfbGlzdCA9IFtdO1xuICAgIH1cbiAgICBDaG9pY2UuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hZGRfYXR0cih7XG4gICAgICBudW06IDAsXG4gICAgICBsc3Q6IGluaXRpYWxfbGlzdFxuICAgIH0pO1xuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIHRoaXMubnVtLnNldChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBDaG9pY2UucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIENob2ljZS5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9ubHN0KClbdGhpcy5udW0uZ2V0KCldO1xuICB9O1xuXG4gIENob2ljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlZjtcbiAgICByZXR1cm4gKHJlZiA9IHRoaXMuaXRlbSgpKSAhPSBudWxsID8gcmVmLmdldCgpIDogdm9pZCAwO1xuICB9O1xuXG4gIENob2ljZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0gdGhpcy5pdGVtKCkpICE9IG51bGwgPyByZWYudG9TdHJpbmcoKSA6IHZvaWQgMDtcbiAgfTtcblxuICBDaG9pY2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYSBpbnN0YW5jZW9mIENob2ljZSkge1xuICAgICAgcmV0dXJuIENob2ljZS5fX3N1cGVyX18uZXF1YWxzLmNhbGwodGhpcywgYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9ubHN0KClbdGhpcy5udW0uZ2V0KCldLmVxdWFscyhhKTtcbiAgICB9XG4gIH07XG5cbiAgQ2hvaWNlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaSwgaiwgbGVuLCBxLCByZWY7XG4gICAgcmVmID0gdGhpcy5fbmxzdCgpO1xuICAgIGZvciAoaiA9IHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBqID0gKytxKSB7XG4gICAgICBpID0gcmVmW2pdO1xuICAgICAgaWYgKGkuZXF1YWxzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW0uc2V0KGopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5udW0uc2V0KHZhbHVlKTtcbiAgfTtcblxuICBDaG9pY2UucHJvdG90eXBlLl9ubHN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGwsIGxlbiwgcSwgcmVmLCByZXN1bHRzO1xuICAgIHJlZiA9IHRoaXMubHN0O1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGwgPSByZWZbcV07XG4gICAgICBpZiAodGhpcy5maWx0ZXIobCkpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICByZXR1cm4gQ2hvaWNlO1xuXG59KShNb2RlbCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkJvb2wgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoQm9vbCwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gQm9vbChkYXRhKSB7XG4gICAgQm9vbC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9kYXRhID0gZmFsc2U7XG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2V0KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIEJvb2wucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNldCghdGhpcy5fZGF0YSk7XG4gIH07XG5cbiAgQm9vbC5wcm90b3R5cGUudG9Cb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG5cbiAgQm9vbC5wcm90b3R5cGUuZGVlcF9jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBCb29sKHRoaXMuX2RhdGEpO1xuICB9O1xuXG4gIEJvb2wucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBuO1xuICAgIGlmIChuIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgIG4gPSB2YWx1ZS50b0Jvb2xlYW4oKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHtcbiAgICAgIG4gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgICAgbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSBCb29sZWFuKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RhdGEgIT09IG4pIHtcbiAgICAgIHRoaXMuX2RhdGEgPSBuO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBCb29sLnByb3RvdHlwZS5fZ2V0X2ZzX2RhdGEgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBGaWxlU3lzdGVtLnNldF9zZXJ2ZXJfaWRfaWZfbmVjZXNzYXJ5KG91dCwgdGhpcyk7XG4gICAgcmV0dXJuIG91dC5tb2QgKz0gXCJDIFwiICsgdGhpcy5fc2VydmVyX2lkICsgXCIgXCIgKyAoMSAqIEJvb2xlYW4odGhpcy5fZGF0YSkpICsgXCIgXCI7XG4gIH07XG5cbiAgcmV0dXJuIEJvb2w7XG5cbn0pKE9iaik7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkNvbnN0T3JOb3RNb2RlbCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChDb25zdE9yTm90TW9kZWwsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIENvbnN0T3JOb3RNb2RlbChib29sLCBtb2RlbCwgY2hlY2tfZGlzYWJsZWQpIHtcbiAgICBpZiAoY2hlY2tfZGlzYWJsZWQgPT0gbnVsbCkge1xuICAgICAgY2hlY2tfZGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBDb25zdE9yTm90TW9kZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hZGRfYXR0cih7XG4gICAgICBib29sOiBib29sLFxuICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgY2hlY2tfZGlzYWJsZWQ6IGNoZWNrX2Rpc2FibGVkXG4gICAgfSk7XG4gIH1cblxuICBDb25zdE9yTm90TW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWY7XG4gICAgcmV0dXJuIChyZWYgPSB0aGlzLm1vZGVsKSAhPSBudWxsID8gcmVmLmdldCgpIDogdm9pZCAwO1xuICB9O1xuXG4gIENvbnN0T3JOb3RNb2RlbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0gdGhpcy5tb2RlbCkgIT0gbnVsbCA/IHJlZi5zZXQodmFsdWUpIDogdm9pZCAwO1xuICB9O1xuXG4gIENvbnN0T3JOb3RNb2RlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAocmVmID0gdGhpcy5tb2RlbCkgIT0gbnVsbCA/IHJlZi50b1N0cmluZygpIDogdm9pZCAwO1xuICB9O1xuXG4gIHJldHVybiBDb25zdE9yTm90TW9kZWw7XG5cbn0pKE1vZGVsKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuQ29uc3RyYWluZWRWYWwgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoQ29uc3RyYWluZWRWYWwsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIENvbnN0cmFpbmVkVmFsKHZhbHVlLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cbiAgICBDb25zdHJhaW5lZFZhbC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFkZF9hdHRyKHtcbiAgICAgIHZhbDogdmFsdWUgfHwgMCxcbiAgICAgIF9taW46IHBhcmFtcy5taW4gIT0gbnVsbCA/IHBhcmFtcy5taW4gOiAwLFxuICAgICAgX21heDogcGFyYW1zLm1heCAhPSBudWxsID8gcGFyYW1zLm1heCA6IDEwMFxuICAgIH0pO1xuICAgIHRoaXMuYWRkX2F0dHIoe1xuICAgICAgX2RpdjogcGFyYW1zLmRpdiAhPSBudWxsID8gcGFyYW1zLmRpdiA6IHRoaXMuX21heCAtIHRoaXMuX21pblxuICAgIH0pO1xuICB9XG5cbiAgQ29uc3RyYWluZWRWYWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZhbC5nZXQoKTtcbiAgfTtcblxuICBDb25zdHJhaW5lZFZhbC5wcm90b3R5cGUucmF0aW8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMudmFsLmdldCgpIC0gdGhpcy5fbWluLmdldCgpKSAvIHRoaXMuZGVsdGEoKTtcbiAgfTtcblxuICBDb25zdHJhaW5lZFZhbC5wcm90b3R5cGUuZGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4LmdldCgpIC0gdGhpcy5fbWluLmdldCgpO1xuICB9O1xuXG4gIENvbnN0cmFpbmVkVmFsLnByb3RvdHlwZS5zZXRfcGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdGhpcy5fbWluLnNldChwYXJhbXMubWluICE9IG51bGwgPyBwYXJhbXMubWluIDogMCk7XG4gICAgdGhpcy5fbWF4LnNldChwYXJhbXMubWF4ICE9IG51bGwgPyBwYXJhbXMubWF4IDogMTAwKTtcbiAgICByZXR1cm4gdGhpcy5fZGl2LnNldChwYXJhbXMuZGl2ICE9IG51bGwgPyBwYXJhbXMuZGl2IDogdGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgfTtcblxuICBDb25zdHJhaW5lZFZhbC5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDb25zdHJhaW5lZFZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsLl9zZXQodmFsdWUuZ2V0KCkpO1xuICAgIH1cbiAgICByZXMgPSB0aGlzLnZhbC5zZXQodmFsdWUpO1xuICAgIHRoaXMuX2NoZWNrX3ZhbCgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQ29uc3RyYWluZWRWYWwucHJvdG90eXBlLl9jaGVja192YWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZCwgbSwgbiwgciwgcywgdjtcbiAgICB2ID0gdGhpcy52YWwuZ2V0KCk7XG4gICAgbSA9IHRoaXMuX21pbi5nZXQoKTtcbiAgICBuID0gdGhpcy5fbWF4LmdldCgpO1xuICAgIGQgPSB0aGlzLl9kaXYuZ2V0KCk7XG4gICAgaWYgKHYgPCBtKSB7XG4gICAgICB0aGlzLnZhbC5zZXQobSk7XG4gICAgfVxuICAgIGlmICh2ID4gbikge1xuICAgICAgdGhpcy52YWwuc2V0KG4pO1xuICAgIH1cbiAgICBpZiAoZCkge1xuICAgICAgcyA9IChuIC0gbSkgLyBkO1xuICAgICAgciA9IG0gKyBNYXRoLnJvdW5kKCh0aGlzLnZhbC5nZXQoKSAtIG0pIC8gcykgKiBzO1xuICAgICAgcmV0dXJuIHRoaXMudmFsLnNldChyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENvbnN0cmFpbmVkVmFsO1xuXG59KShNb2RlbCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkxzdCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChMc3QsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIExzdChkYXRhKSB7XG4gICAgdmFyIGQsIGksIHEsIHJlZiwgcztcbiAgICBMc3QuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHMgPSB0aGlzLnN0YXRpY19sZW5ndGgoKTtcbiAgICBpZiAocyA+PSAwKSB7XG4gICAgICBkID0gdGhpcy5kZWZhdWx0X3ZhbHVlKCk7XG4gICAgICBmb3IgKGkgPSBxID0gMCwgcmVmID0gczsgMCA8PSByZWYgPyBxIDwgcmVmIDogcSA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytxIDogLS1xKSB7XG4gICAgICAgIHRoaXMucHVzaChkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2V0KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIExzdC5wcm90b3R5cGUuc3RhdGljX2xlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmRlZmF1bHRfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmJhc2VfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgbGVuLCBxLCByZWYsIHJlc3VsdHM7XG4gICAgcmVmID0gdGhpcztcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBpID0gcmVmW3FdO1xuICAgICAgcmVzdWx0cy5wdXNoKGkuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW2xlbmd0aF07XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsLCB4O1xuICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgbCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxlbiwgcSwgcmVmLCByZXN1bHRzO1xuICAgICAgICByZWYgPSB0aGlzO1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgICAgIHggPSByZWZbcV07XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIGwuam9pbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihsc3QpIHtcbiAgICB2YXIgaSwgcSwgcmVmO1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gbHN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBxID0gMCwgcmVmID0gdGhpcy5sZW5ndGg7IDAgPD0gcmVmID8gcSA8IHJlZiA6IHEgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrcSA6IC0tcSkge1xuICAgICAgaWYgKCF0aGlzW2ldLmVxdWFscyhsc3RbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24odmFsdWUsIGZvcmNlKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0aWNfc2l6ZV9jaGVjayhmb3JjZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYiA9IHRoaXMuYmFzZV90eXBlKCk7XG4gICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBiKSkge1xuICAgICAgICB2YWx1ZSA9IG5ldyBiKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBNb2RlbFByb2Nlc3NNYW5hZ2VyLmNvbnYodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaW5kZXhPZi5jYWxsKHZhbHVlLl9wYXJlbnRzLCB0aGlzKSA8IDApIHtcbiAgICAgIHZhbHVlLl9wYXJlbnRzLnB1c2godGhpcyk7XG4gICAgfVxuICAgIHRoaXNbdGhpcy5sZW5ndGhdID0gdmFsdWU7XG4gICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmFsX2NoYW5nZSgpO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9sZDtcbiAgICBpZiAodGhpcy5fc3RhdGljX3NpemVfY2hlY2soZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoIC09IDE7XG4gICAgb2xkID0gdGhpc1t0aGlzLmxlbmd0aF07XG4gICAgdGhpcy5yZW1fYXR0cih0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIG9sZDtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdHM7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucG9wKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIGIsIGksIHEsIHJlZjtcbiAgICBpZiAodGhpcy5fc3RhdGljX3NpemVfY2hlY2soZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGIgPSB0aGlzLmJhc2VfdHlwZSgpO1xuICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBiKSkge1xuICAgICAgICBlbGVtZW50ID0gbmV3IGIoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBNb2RlbFByb2Nlc3NNYW5hZ2VyLmNvbnYoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChpbmRleE9mLmNhbGwoZWxlbWVudC5fcGFyZW50cywgdGhpcykgPCAwKSB7XG4gICAgICBlbGVtZW50Ll9wYXJlbnRzLnB1c2godGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgZm9yIChpID0gcSA9IHJlZiA9IHRoaXMubGVuZ3RoIC0gMTsgcmVmIDw9IDAgPyBxIDw9IDAgOiBxID49IDA7IGkgPSByZWYgPD0gMCA/ICsrcSA6IC0tcSkge1xuICAgICAgICB0aGlzW2kgKyAxXSA9IHRoaXNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXNbMF0gPSBlbGVtZW50O1xuICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgdGhpcy5fc2lnbmFsX2NoYW5nZSgpO1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHI7XG4gICAgciA9IHRoaXNbMF07XG4gICAgdGhpcy5zcGxpY2UoMCwgMSk7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IHRoaXMuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9O1xuXG4gIExzdC5wcm90b3R5cGUucmVtb3ZlX3JlZiA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB2YXIgaTtcbiAgICBpID0gdGhpcy5pbmRleE9mX3JlZihpdGVtKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBpLCBsZW4sIHEsIHJlZiwgcmVzdWx0cztcbiAgICByZWYgPSB0aGlzO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGkgPSByZWZbcV07XG4gICAgICBpZiAoZihpKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBpLCBsZW4sIHEsIHJlZjtcbiAgICByZWYgPSB0aGlzO1xuICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgaSA9IHJlZltxXTtcbiAgICAgIGlmIChmKGkpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuc29ydGVkID0gZnVuY3Rpb24oZnVuX3NvcnQpIHtcbiAgICB2YXIgaXQsIGxlbiwgbmV3X2FycmF5LCBxLCByZWY7XG4gICAgbmV3X2FycmF5ID0gbmV3IEFycmF5O1xuICAgIHJlZiA9IHRoaXM7XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBpdCA9IHJlZltxXTtcbiAgICAgIG5ld19hcnJheS5wdXNoKGl0KTtcbiAgICB9XG4gICAgbmV3X2FycmF5LnNvcnQoZnVuX3NvcnQpO1xuICAgIHJldHVybiBuZXdfYXJyYXk7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIGksIGxlbiwgcSwgcmVmO1xuICAgIHJlZiA9IHRoaXM7XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBpID0gcmVmW3FdO1xuICAgICAgaWYgKGYoaSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGksIHEsIHJlZjtcbiAgICBmb3IgKGkgPSBxID0gMCwgcmVmID0gdGhpcy5sZW5ndGg7IDAgPD0gcmVmID8gcSA8IHJlZiA6IHEgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrcSA6IC0tcSkge1xuICAgICAgaWYgKHRoaXNbaV0uZXF1YWxzKHYpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5pbmRleE9mX3JlZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgaSwgcSwgcmVmO1xuICAgIGZvciAoaSA9IHEgPSAwLCByZWYgPSB0aGlzLmxlbmd0aDsgMCA8PSByZWYgPyBxIDwgcmVmIDogcSA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytxIDogLS1xKSB7XG4gICAgICBpZiAodGhpc1tpXSA9PT0gdikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZih2KSA+PSAwO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuY29udGFpbnNfcmVmID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB0aGlzLmluZGV4T2ZfcmVmKHYpID49IDA7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGk7XG4gICAgaSA9IHRoaXMuaW5kZXhPZih2KTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLnNwbGljZShpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIExzdC5wcm90b3R5cGUudG9nZ2xlX3JlZiA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgaTtcbiAgICBpID0gdGhpcy5pbmRleE9mX3JlZih2KTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLnNwbGljZShpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgdmFyIGksIHEsIHJlZiwgcmVmMSwgdGFiO1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChiZWdpbiA8IDApIHtcbiAgICAgIGJlZ2luID0gMDtcbiAgICB9XG4gICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgdGFiID0gbmV3IExzdDtcbiAgICBmb3IgKGkgPSBxID0gcmVmID0gYmVnaW4sIHJlZjEgPSBlbmQ7IHJlZiA8PSByZWYxID8gcSA8IHJlZjEgOiBxID4gcmVmMTsgaSA9IHJlZiA8PSByZWYxID8gKytxIDogLS1xKSB7XG4gICAgICB0YWIucHVzaCh0aGlzW2ldLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhYjtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uKG5ld190YWIsIGZvcmNlKSB7XG4gICAgdmFyIGVsLCBsZW4sIHE7XG4gICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgIGZvcmNlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdGF0aWNfc2l6ZV9jaGVjayhmb3JjZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld190YWIubGVuZ3RoKSB7XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSBuZXdfdGFiLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIGVsID0gbmV3X3RhYltxXTtcbiAgICAgICAgdGhpcy5wdXNoKGVsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBMc3QucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uKGluZGV4LCBuKSB7XG4gICAgdmFyIGksIHEsIHJlZiwgcmVmMSwgcmVmMiwgcmVmMywgcmVmNCwgcmVmNSwgeSwgejtcbiAgICBpZiAobiA9PSBudWxsKSB7XG4gICAgICBuID0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YXRpY19zaXplX2NoZWNrKGZhbHNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGkgPSBxID0gcmVmID0gaW5kZXgsIHJlZjEgPSBNYXRoLm1pbihpbmRleCArIG4sIHRoaXMubGVuZ3RoKTsgcmVmIDw9IHJlZjEgPyBxIDwgcmVmMSA6IHEgPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK3EgOiAtLXEpIHtcbiAgICAgIHRoaXMucmVtX2F0dHIoaSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHkgPSByZWYyID0gaW5kZXgsIHJlZjMgPSB0aGlzLmxlbmd0aCAtIG47IHJlZjIgPD0gcmVmMyA/IHkgPCByZWYzIDogeSA+IHJlZjM7IGkgPSByZWYyIDw9IHJlZjMgPyArK3kgOiAtLXkpIHtcbiAgICAgIHRoaXNbaV0gPSB0aGlzW2kgKyBuXTtcbiAgICB9XG4gICAgZm9yIChpID0geiA9IHJlZjQgPSB0aGlzLmxlbmd0aCAtIG4sIHJlZjUgPSB0aGlzLmxlbmd0aDsgcmVmNCA8PSByZWY1ID8geiA8IHJlZjUgOiB6ID4gcmVmNTsgaSA9IHJlZjQgPD0gcmVmNSA/ICsreiA6IC0teikge1xuICAgICAgZGVsZXRlIHRoaXNbaV07XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoIC09IG47XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hbF9jaGFuZ2UoKTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKGluZGV4LCBsaXN0KSB7XG4gICAgdmFyIGksIGwsIGxlbiwgbGVuMSwgbywgcSwgcmVzdWx0cywgeTtcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGwgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCAtIGluZGV4LCAwKTtcbiAgICAgIG8gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBxLCByZWYsIHJlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gcSA9IDAsIHJlZiA9IGw7IDAgPD0gcmVmID8gcSA8IHJlZiA6IHEgPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsrcSA6IC0tcSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnBvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICBvLnJldmVyc2UoKTtcbiAgICAgIGZvciAocSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgbCA9IGxpc3RbcV07XG4gICAgICAgIHRoaXMucHVzaChsKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoeSA9IDAsIGxlbjEgPSBvLmxlbmd0aDsgeSA8IGxlbjE7IHkrKykge1xuICAgICAgICBsID0gb1t5XTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucHVzaChsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5zZXRfb3JfcHVzaCA9IGZ1bmN0aW9uKGluZGV4LCB2YWwpIHtcbiAgICBpZiAoaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kX2F0dHIoaW5kZXgsIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2godmFsKTtcbiAgICB9XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciByZXN1bHRzO1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiBzaXplKSB7XG4gICAgICByZXN1bHRzLnB1c2godGhpcy5wb3AoKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uKHNlcCkge1xuICAgIHJldHVybiB0aGlzLmdldCgpLmpvaW4oc2VwKTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmRlZXBfY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBxLCByZWYsIHJlcztcbiAgICByZXMgPSBuZXcgTHN0O1xuICAgIGZvciAoaSA9IHEgPSAwLCByZWYgPSB0aGlzLmxlbmd0aDsgMCA8PSByZWYgPyBxIDwgcmVmIDogcSA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytxIDogLS1xKSB7XG4gICAgICByZXMucHVzaCh0aGlzW2ldLmRlZXBfY29weSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUucmVhbF9jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSwgbGVuLCBxLCByZWY7XG4gICAgaWYgKHRoaXMuaGFzX2JlZW5fZGlyZWN0bHlfbW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlZiA9IHRoaXM7XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBhID0gcmVmW3FdO1xuICAgICAgaWYgKGEucmVhbF9jaGFuZ2UoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIExzdC5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGNoYW5nZSwgcCwgcSwgcmVmLCBzO1xuICAgIGNoYW5nZSA9IHRoaXMubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGg7XG4gICAgcyA9IHRoaXMuc3RhdGljX2xlbmd0aCgpO1xuICAgIGlmIChzID49IDAgJiYgY2hhbmdlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwicmVzaXppbmcgYSBzdGF0aWMgYXJyYXkgKHR5cGUgXCIgKyAoKE1vZGVsUHJvY2Vzc01hbmFnZXIuZ2V0X29iamVjdF9jbGFzcyh0aGlzKSkgKyBcIikgaXMgZm9yYmlkZGVuXCIpKTtcbiAgICB9XG4gICAgZm9yIChwID0gcSA9IDAsIHJlZiA9IHZhbHVlLmxlbmd0aDsgMCA8PSByZWYgPyBxIDwgcmVmIDogcSA+IHJlZjsgcCA9IDAgPD0gcmVmID8gKytxIDogLS1xKSB7XG4gICAgICBpZiAocCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGNoYW5nZSB8PSB0aGlzW3BdLnNldCh2YWx1ZVtwXSk7XG4gICAgICB9IGVsc2UgaWYgKHMgPCAwKSB7XG4gICAgICAgIHRoaXMucHVzaCh2YWx1ZVtwXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzIDwgMCkge1xuICAgICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLl9nZXRfZmxhdF9tb2RlbF9tYXAgPSBmdW5jdGlvbihtYXAsIGRhdGUpIHtcbiAgICB2YXIgbGVuLCBvYmosIHEsIHJlZiwgcmVzdWx0cztcbiAgICBtYXBbdGhpcy5tb2RlbF9pZF0gPSB0aGlzO1xuICAgIHJlZiA9IHRoaXM7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgb2JqID0gcmVmW3FdO1xuICAgICAgaWYgKG1hcFtvYmoubW9kZWxfaWRdID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9iai5fZGF0ZV9sYXN0X21vZGlmaWNhdGlvbiA+IGRhdGUpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gob2JqLl9nZXRfZmxhdF9tb2RlbF9tYXAobWFwLCBkYXRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLl9nZXRfZnNfZGF0YSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIHZhciBvYmosIHN0cjtcbiAgICBGaWxlU3lzdGVtLnNldF9zZXJ2ZXJfaWRfaWZfbmVjZXNzYXJ5KG91dCwgdGhpcyk7XG4gICAgc3RyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbiwgcSwgcmVmLCByZXN1bHRzO1xuICAgICAgcmVmID0gdGhpcztcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgICBvYmogPSByZWZbcV07XG4gICAgICAgIEZpbGVTeXN0ZW0uc2V0X3NlcnZlcl9pZF9pZl9uZWNlc3Nhcnkob3V0LCBvYmopO1xuICAgICAgICByZXN1bHRzLnB1c2gob2JqLl9zZXJ2ZXJfaWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSkuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gb3V0Lm1vZCArPSBcIkMgXCIgKyB0aGlzLl9zZXJ2ZXJfaWQgKyBcIiBcIiArIChzdHIuam9pbihcIixcIikpICsgXCIgXCI7XG4gIH07XG5cbiAgTHN0LnByb3RvdHlwZS5fZ2V0X3N0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiwgc3RyO1xuICAgIHN0ciA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZW4sIHEsIHJlZiwgcmVzdWx0cztcbiAgICAgIHJlZiA9IHRoaXM7XG4gICAgICByZXN1bHRzID0gW107XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgb2JqID0gcmVmW3FdO1xuICAgICAgICByZXN1bHRzLnB1c2gob2JqLm1vZGVsX2lkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHN0ci5qb2luKFwiLFwiKTtcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLl9zZXRfc3RhdGUgPSBmdW5jdGlvbihzdHIsIG1hcCkge1xuICAgIHZhciBhdHRyLCBrX2lkLCBsX2lkLCBxLCByZWYsIHJlZjEsIHJlZjIsIHJlc3VsdHMsIHk7XG4gICAgbF9pZCA9IHN0ci5zcGxpdChcIixcIikuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4Lmxlbmd0aDtcbiAgICB9KTtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiBsX2lkLmxlbmd0aCkge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgZm9yIChhdHRyID0gcSA9IDAsIHJlZiA9IHRoaXMubGVuZ3RoOyAwIDw9IHJlZiA/IHEgPCByZWYgOiBxID4gcmVmOyBhdHRyID0gMCA8PSByZWYgPyArK3EgOiAtLXEpIHtcbiAgICAgIGtfaWQgPSBsX2lkW2F0dHJdO1xuICAgICAgaWYgKG1hcFtrX2lkXS5idWZmICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1hcFtrX2lkXS5idWZmICE9PSB0aGlzW2F0dHJdKSB7XG4gICAgICAgICAgdGhpcy5tb2RfYXR0cihhdHRyLCBtYXBba19pZF0uYnVmZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXNbYXR0cl0uX3NldF9zdGF0ZV9pZl9zYW1lX3R5cGUoa19pZCwgbWFwKSkge1xuICAgICAgICB0aGlzLm1vZF9hdHRyKGF0dHIsIE1vZGVsUHJvY2Vzc01hbmFnZXIuX25ld19tb2RlbF9mcm9tX3N0YXRlKGtfaWQsIG1hcCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChhdHRyID0geSA9IHJlZjEgPSB0aGlzLmxlbmd0aCwgcmVmMiA9IGxfaWQubGVuZ3RoOyByZWYxIDw9IHJlZjIgPyB5IDwgcmVmMiA6IHkgPiByZWYyOyBhdHRyID0gcmVmMSA8PSByZWYyID8gKyt5IDogLS15KSB7XG4gICAgICBrX2lkID0gbF9pZFthdHRyXTtcbiAgICAgIGlmIChtYXBba19pZF0uYnVmZiAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnB1c2gobWFwW2tfaWRdLmJ1ZmYpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnB1c2goTW9kZWxQcm9jZXNzTWFuYWdlci5fbmV3X21vZGVsX2Zyb21fc3RhdGUoa19pZCwgbWFwKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBMc3QucHJvdG90eXBlLl9zdGF0aWNfc2l6ZV9jaGVjayA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGljX2xlbmd0aCgpID49IDAgJiYgIWZvcmNlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwicmVzaXppbmcgYSBzdGF0aWMgYXJyYXkgKHR5cGUgXCIgKyAoKE1vZGVsUHJvY2Vzc01hbmFnZXIuZ2V0X29iamVjdF9jbGFzcyh0aGlzKSkgKyBcIikgaXMgZm9yYmlkZGVuXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIExzdDtcblxufSkoTW9kZWwpO1xuXG5yb290ID0gdHlwZW9mIF9yb290X29iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdztcblxucm9vdC5WYWwgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoVmFsLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBWYWwoZGF0YSkge1xuICAgIFZhbC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9kYXRhID0gMDtcbiAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9zZXQoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgVmFsLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoIXRoaXMuX2RhdGEpO1xuICB9O1xuXG4gIFZhbC5wcm90b3R5cGUudG9Cb29sZWFuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZGF0YSk7XG4gIH07XG5cbiAgVmFsLnByb3RvdHlwZS5kZWVwX2NvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFZhbCh0aGlzLl9kYXRhKTtcbiAgfTtcblxuICBWYWwucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodikge1xuICAgICAgdGhpcy5fZGF0YSArPSB2O1xuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbF9jaGFuZ2UoKTtcbiAgICB9XG4gIH07XG5cbiAgVmFsLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAodmFsdWUuc2xpY2UoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICBuID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgICAgbiA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkRvbid0IGtub3cgaG93IHRvIHRyYW5zZm9ybSBcIiArIHZhbHVlICsgXCIgdG8gYSBWYWxcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG4gPSAxICogdmFsdWU7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFZhbCkge1xuICAgICAgbiA9IHZhbHVlLl9kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBuID0gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kYXRhICE9PSBuKSB7XG4gICAgICB0aGlzLl9kYXRhID0gbjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIFZhbDtcblxufSkoT2JqKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuVmVjID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFZlYywgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gVmVjKGRhdGEpIHtcbiAgICBWZWMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgZGF0YSk7XG4gIH1cblxuICBWZWMucHJvdG90eXBlLmJhc2VfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWYWw7XG4gIH07XG5cbiAgVmVjLnByb3RvdHlwZS5fdW5kZXJseWluZ19mc190eXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiTHN0XCI7XG4gIH07XG5cbiAgcmV0dXJuIFZlYztcblxufSkoTHN0KTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuU3RyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFN0ciwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gU3RyKGRhdGEpIHtcbiAgICBTdHIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fZGF0YSA9IFwiXCI7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NldChkYXRhKTtcbiAgICB9XG4gIH1cblxuICBTdHIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKHN0ciwgc3BhY2UpIHtcbiAgICB2YXIgaSwgbDtcbiAgICBpZiAoc3BhY2UgPT0gbnVsbCkge1xuICAgICAgc3BhY2UgPSBcIiBcIjtcbiAgICB9XG4gICAgbCA9IHRoaXMuX2RhdGEuc3BsaXQoc3BhY2UpO1xuICAgIGkgPSBsLmluZGV4T2Yoc3RyKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGwucHVzaChzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0KGwuam9pbihcIiBcIikpO1xuICB9O1xuXG4gIFN0ci5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5pbmRleE9mKHN0cikgPj0gMDtcbiAgfTtcblxuICBTdHIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhID09PSBzdHIudG9TdHJpbmcoKTtcbiAgfTtcblxuICBTdHIucHJvdG90eXBlLmVuZHNfd2l0aCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBsO1xuICAgIGwgPSB0aGlzLl9kYXRhLm1hdGNoKHN0ciArIFwiJFwiKTtcbiAgICByZXR1cm4gKGwgIT0gbnVsbCA/IGwubGVuZ3RoIDogdm9pZCAwKSAmJiBsWzBdID09PSBzdHI7XG4gIH07XG5cbiAgU3RyLnByb3RvdHlwZS5kZWVwX2NvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFN0cih0aGlzLl9kYXRhICsgXCJcIik7XG4gIH07XG5cbiAgU3RyLnByb3RvdHlwZS5fZ2V0X2ZzX2RhdGEgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBGaWxlU3lzdGVtLnNldF9zZXJ2ZXJfaWRfaWZfbmVjZXNzYXJ5KG91dCwgdGhpcyk7XG4gICAgcmV0dXJuIG91dC5tb2QgKz0gXCJDIFwiICsgdGhpcy5fc2VydmVyX2lkICsgXCIgXCIgKyAoZW5jb2RlVVJJKHRoaXMuX2RhdGEpKSArIFwiIFwiO1xuICB9O1xuXG4gIFN0ci5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG47XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXQoXCJcIik7XG4gICAgfVxuICAgIG4gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLl9kYXRhICE9PSBuKSB7XG4gICAgICB0aGlzLl9kYXRhID0gbjtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFN0ci5wcm90b3R5cGUuX2dldF9zdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlbmNvZGVVUkkodGhpcy5fZGF0YSk7XG4gIH07XG5cbiAgU3RyLnByb3RvdHlwZS5fc2V0X3N0YXRlID0gZnVuY3Rpb24oc3RyLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpO1xuICB9O1xuXG4gIHJldHVybiBTdHI7XG5cbn0pKE9iaik7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlR5cGVkQXJyYXkgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoVHlwZWRBcnJheSwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gVHlwZWRBcnJheShzaXplLCBkYXRhKSB7XG4gICAgdmFyIEI7XG4gICAgVHlwZWRBcnJheS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICBzaXplID0gW107XG4gICAgfVxuICAgIGlmICghc2l6ZS5sZW5ndGgpIHtcbiAgICAgIHNpemUgPSBbc2l6ZV07XG4gICAgfVxuICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgIEIgPSB0aGlzLmJhc2VfdHlwZSgpO1xuICAgICAgZGF0YSA9IG5ldyBCKHRoaXMubmJfaXRlbXMoKSk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgVHlwZWRBcnJheS5wcm90b3R5cGUuYmFzZV90eXBlID0gZnVuY3Rpb24oKSB7fTtcblxuICBUeXBlZEFycmF5LnByb3RvdHlwZS5kaW0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZS5sZW5ndGg7XG4gIH07XG5cbiAgVHlwZWRBcnJheS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICBpZiAoZCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2l6ZVtkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICB9O1xuXG4gIFR5cGVkQXJyYXkucHJvdG90eXBlLnNldF92YWwgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICBpbmRleCA9IHRoaXMuX2dldF9pbmRleChpbmRleCk7XG4gICAgaWYgKHRoaXMuX2RhdGFbaW5kZXhdICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZGF0YVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9zaWduYWxfY2hhbmdlKCk7XG4gICAgfVxuICB9O1xuXG4gIFR5cGVkQXJyYXkucHJvdG90eXBlLm5iX2l0ZW1zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksIGxlbiwgcSwgcmVmLCB0b3Q7XG4gICAgdG90ID0gdGhpcy5fc2l6ZVswXSB8fCAwO1xuICAgIHJlZiA9IHRoaXMuX3NpemUuc2xpY2UoMSk7XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBpID0gcmVmW3FdO1xuICAgICAgdG90ICo9IGk7XG4gICAgfVxuICAgIHJldHVybiB0b3Q7XG4gIH07XG5cbiAgVHlwZWRBcnJheS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSwgaiwgbCwgbGVuLCBtLCBvLCBxLCByZWYsIHJlZjEsIHJlcywgcywgdiwgeTtcbiAgICBtID0gMTtcbiAgICByZXMgPSBcIlwiO1xuICAgIGwgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuLCBxLCByZWYsIHJlc3VsdHM7XG4gICAgICByZWYgPSB0aGlzLl9zaXplO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIHMgPSByZWZbcV07XG4gICAgICAgIG8gPSBtO1xuICAgICAgICBtICo9IHM7XG4gICAgICAgIHJlc3VsdHMucHVzaChvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gICAgcmVmID0gdGhpcy5fZGF0YTtcbiAgICBmb3IgKGkgPSBxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgaSA9ICsrcSkge1xuICAgICAgdiA9IHJlZltpXTtcbiAgICAgIHJlcyArPSB2O1xuICAgICAgZm9yIChqID0geSA9IHJlZjEgPSBsLmxlbmd0aCAtIDE7IHJlZjEgPD0gMCA/IHkgPD0gMCA6IHkgPj0gMDsgaiA9IHJlZjEgPD0gMCA/ICsreSA6IC0teSkge1xuICAgICAgICBpZiAoaSAlIGxbal0gPT09IGxbal0gLSAxKSB7XG4gICAgICAgICAgcmVzICs9IFtcIiBcIiwgXCJcXG5cIiwgXCJcXG5cXG5cIl1bal07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBUeXBlZEFycmF5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuLCBxLCByZWYsIHY7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFR5cGVkQXJyYXkpIHtcbiAgICAgIGlmICh0aGlzLl9zaXplLmxlbmd0aCAhPT0gb2JqLl9zaXplLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZWYgPSB0aGlzLl9zaXplO1xuICAgICAgZm9yIChpID0gcSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IGkgPSArK3EpIHtcbiAgICAgICAgdiA9IHJlZltpXTtcbiAgICAgICAgaWYgKHYgIT09IG9iai5fc2l6ZVtpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2RhdGEgPT09IG9iai5fZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEgPT09IG9iajtcbiAgfTtcblxuICBUeXBlZEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVt0aGlzLl9nZXRfaW5kZXgoaW5kZXgpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICB9O1xuXG4gIFR5cGVkQXJyYXkucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKG5ld19zaXplKSB7XG4gICAgdmFyIEIsIGxlbiwgbiwgcSwgcywgdG90O1xuICAgIHRvdCA9IDE7XG4gICAgZm9yIChxID0gMCwgbGVuID0gbmV3X3NpemUubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIHMgPSBuZXdfc2l6ZVtxXTtcbiAgICAgIHRvdCAqPSBzO1xuICAgIH1cbiAgICBCID0gdGhpcy5iYXNlX3R5cGUoKTtcbiAgICBuID0gbmV3IEIodG90KTtcbiAgICBuLnNldCh0aGlzLl9kYXRhKTtcbiAgICB0aGlzLl9kYXRhID0gbjtcbiAgICB0aGlzLl9zaXplID0gbmV3X3NpemU7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hbF9jaGFuZ2UoKTtcbiAgfTtcblxuICBUeXBlZEFycmF5LnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIEI7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX3NldF9zdGF0ZShzdHIsIHt9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGF0YSAhPT0gc3RyIHx8IHRoaXMuX3NpemUubGVuZ3RoICE9PSAxIHx8IHRoaXMuX3NpemVbMF0gIT09IHN0ci5sZW5ndGgpIHtcbiAgICAgIEIgPSB0aGlzLmJhc2VfdHlwZSgpO1xuICAgICAgdGhpcy5fZGF0YSA9IG5ldyBCKHN0cik7XG4gICAgICB0aGlzLl9zaXplID0gW3N0ci5sZW5ndGhdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBUeXBlZEFycmF5LnByb3RvdHlwZS5fZ2V0X2luZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICB2YXIgaSwgbSwgbywgcSwgcmVmO1xuICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgIG8gPSAwO1xuICAgICAgbSA9IDE7XG4gICAgICBmb3IgKGkgPSBxID0gMCwgcmVmID0gaW5kZXgubGVuZ3RoOyAwIDw9IHJlZiA/IHEgPCByZWYgOiBxID4gcmVmOyBpID0gMCA8PSByZWYgPyArK3EgOiAtLXEpIHtcbiAgICAgICAgbyArPSBtICogaW5kZXhbaV07XG4gICAgICAgIG0gKj0gdGhpcy5fc2l6ZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgVHlwZWRBcnJheS5wcm90b3R5cGUuX2dldF9mc19kYXRhID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgRmlsZVN5c3RlbS5zZXRfc2VydmVyX2lkX2lmX25lY2Vzc2FyeShvdXQsIHRoaXMpO1xuICAgIHJldHVybiBvdXQubW9kICs9IFwiQyBcIiArIHRoaXMuX3NlcnZlcl9pZCArIFwiIFwiICsgKHRoaXMuX2dldF9zdGF0ZSgpKSArIFwiIFwiO1xuICB9O1xuXG4gIFR5cGVkQXJyYXkucHJvdG90eXBlLl9nZXRfc3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZCwgbGVuLCBsZW4xLCBxLCByZWYsIHJlZjEsIHJlcywgcywgeTtcbiAgICByZXMgPSBcIlwiO1xuICAgIHJlcyArPSB0aGlzLl9zaXplLmxlbmd0aDtcbiAgICByZWYgPSB0aGlzLl9zaXplO1xuICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgcyA9IHJlZltxXTtcbiAgICAgIHJlcyArPSBcIixcIiArIHM7XG4gICAgfVxuICAgIHJlZjEgPSB0aGlzLl9kYXRhO1xuICAgIGZvciAoeSA9IDAsIGxlbjEgPSByZWYxLmxlbmd0aDsgeSA8IGxlbjE7IHkrKykge1xuICAgICAgZCA9IHJlZjFbeV07XG4gICAgICByZXMgKz0gXCIsXCIgKyBkO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFR5cGVkQXJyYXkucHJvdG90eXBlLl9zZXRfc3RhdGUgPSBmdW5jdGlvbihzdHIsIG1hcCkge1xuICAgIHZhciBCLCBsLCBuLCBxLCByZWYsIHJlc3VsdHMsIHMsIHY7XG4gICAgbCA9IHN0ci5zcGxpdChcIixcIik7XG4gICAgcyA9IHBhcnNlSW50KGxbMF0pO1xuICAgIHRoaXMuX3NpemUgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcSwgcmVmLCByZXN1bHRzO1xuICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yICh2ID0gcSA9IDAsIHJlZiA9IHM7IDAgPD0gcmVmID8gcSA8IHJlZiA6IHEgPiByZWY7IHYgPSAwIDw9IHJlZiA/ICsrcSA6IC0tcSkge1xuICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnQobFt2ICsgMV0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgQiA9IHRoaXMuYmFzZV90eXBlKCk7XG4gICAgbiA9IHRoaXMubmJfaXRlbXMoKTtcbiAgICB0aGlzLl9kYXRhID0gbmV3IEIobik7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAodiA9IHEgPSAwLCByZWYgPSBuOyAwIDw9IHJlZiA/IHEgPCByZWYgOiBxID4gcmVmOyB2ID0gMCA8PSByZWYgPyArK3EgOiAtLXEpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh0aGlzLl9kYXRhW3ZdID0gcGFyc2VGbG9hdChsW3MgKyAxICsgdl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgcmV0dXJuIFR5cGVkQXJyYXk7XG5cbn0pKE1vZGVsKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuVHlwZWRBcnJheV9GbG9hdDMyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFR5cGVkQXJyYXlfRmxvYXQzMiwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gVHlwZWRBcnJheV9GbG9hdDMyKHNpemUsIGRhdGEpIHtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICBzaXplID0gW107XG4gICAgfVxuICAgIFR5cGVkQXJyYXlfRmxvYXQzMi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBzaXplLCBkYXRhKTtcbiAgfVxuXG4gIFR5cGVkQXJyYXlfRmxvYXQzMi5wcm90b3R5cGUuYmFzZV90eXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgfTtcblxuICBUeXBlZEFycmF5X0Zsb2F0MzIucHJvdG90eXBlLmRlZXBfY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVHlwZWRBcnJheV9GbG9hdDMyKHRoaXMuX3NpemUsIHRoaXMuX2RhdGEpO1xuICB9O1xuXG4gIHJldHVybiBUeXBlZEFycmF5X0Zsb2F0MzI7XG5cbn0pKFR5cGVkQXJyYXkpO1xuXG5yb290ID0gdHlwZW9mIF9yb290X29iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdztcblxucm9vdC5UeXBlZEFycmF5X0Zsb2F0NjQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoVHlwZWRBcnJheV9GbG9hdDY0LCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBUeXBlZEFycmF5X0Zsb2F0NjQoc2l6ZSwgZGF0YSkge1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgIHNpemUgPSBbXTtcbiAgICB9XG4gICAgVHlwZWRBcnJheV9GbG9hdDY0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNpemUsIGRhdGEpO1xuICB9XG5cbiAgVHlwZWRBcnJheV9GbG9hdDY0LnByb3RvdHlwZS5iYXNlX3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICB9O1xuXG4gIFR5cGVkQXJyYXlfRmxvYXQ2NC5wcm90b3R5cGUuZGVlcF9jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlZEFycmF5X0Zsb2F0NjQodGhpcy5fc2l6ZSwgdGhpcy5fZGF0YSk7XG4gIH07XG5cbiAgcmV0dXJuIFR5cGVkQXJyYXlfRmxvYXQ2NDtcblxufSkoVHlwZWRBcnJheSk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlR5cGVkQXJyYXlfSW50MzIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoVHlwZWRBcnJheV9JbnQzMiwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gVHlwZWRBcnJheV9JbnQzMihzaXplLCBkYXRhKSB7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkge1xuICAgICAgc2l6ZSA9IFtdO1xuICAgIH1cbiAgICBUeXBlZEFycmF5X0ludDMyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNpemUsIGRhdGEpO1xuICB9XG5cbiAgVHlwZWRBcnJheV9JbnQzMi5wcm90b3R5cGUuYmFzZV90eXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEludDMyQXJyYXk7XG4gIH07XG5cbiAgVHlwZWRBcnJheV9JbnQzMi5wcm90b3R5cGUuZGVlcF9jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlZEFycmF5X0ludDMyKHRoaXMuX3NpemUsIHRoaXMuX2RhdGEpO1xuICB9O1xuXG4gIHJldHVybiBUeXBlZEFycmF5X0ludDMyO1xuXG59KShUeXBlZEFycmF5KTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuVXNlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChVc2VyLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBVc2VyKCkge1xuICAgIFVzZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICByZXR1cm4gVXNlcjtcblxufSkoTW9kZWwpO1xuXG5yb290ID0gdHlwZW9mIF9yb290X29iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdztcblxucm9vdC5GaWxlU3lzdGVtID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3Rfbm9kZTtcblxuICBGaWxlU3lzdGVtLnBvcHVwID0gMDtcblxuICBGaWxlU3lzdGVtLmRlYnVnID0gZmFsc2U7XG5cbiAgRmlsZVN5c3RlbS5fY3VyX3RtcF9zZXJ2ZXJfaWQgPSAwO1xuXG4gIEZpbGVTeXN0ZW0uX3NpZ19zZXJ2ZXIgPSB0cnVlO1xuXG4gIEZpbGVTeXN0ZW0uX2Rpc3AgPSBmYWxzZTtcblxuICBGaWxlU3lzdGVtLl91c2VyaWQgPSBcIjY0NFwiO1xuXG4gIEZpbGVTeXN0ZW0uX3RpbWVvdXRfcmVjb25uZWN0ID0gMzAwMDA7XG5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEZpbGVTeXN0ZW0uaXNfY29yZG92YSA9IGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwOi8vJykgPT09IC0xICYmIGRvY3VtZW50LlVSTC5pbmRleE9mKCdodHRwczovLycpID09PSAtMTtcbiAgfSBlbHNlIHtcbiAgICBGaWxlU3lzdGVtLmlzX2NvcmRvdmEgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIFhNTEh0dHBSZXF1ZXN0X25vZGUgPSByZXF1aXJlKCd4aHIyJyk7XG4gICAgRmlsZVN5c3RlbS5fWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdF9ub2RlO1xuICB9XG5cbiAgRmlsZVN5c3RlbS5fb2JqZWN0c190b19zZW5kID0ge307XG5cbiAgRmlsZVN5c3RlbS5fdGltZXJfc2VuZCA9IHZvaWQgMDtcblxuICBGaWxlU3lzdGVtLl90aW1lcl9jaGFuID0gdm9pZCAwO1xuXG4gIEZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrcyA9IDA7XG5cbiAgRmlsZVN5c3RlbS5fY2FsbGJhY2tzID0ge307XG5cbiAgRmlsZVN5c3RlbS5fdHlwZV9jYWxsYmFja3MgPSBbXTtcblxuICBGaWxlU3lzdGVtLl9uYl9pbnN0cyA9IDA7XG5cbiAgRmlsZVN5c3RlbS5faW5zdHMgPSB7fTtcblxuICBGaWxlU3lzdGVtLl9maWxlc190b191cGxvYWQgPSB7fTtcblxuICBGaWxlU3lzdGVtLl9wdHJfdG9fdXBkYXRlID0ge307XG5cbiAgRmlsZVN5c3RlbS5fdG1wX29iamVjdHMgPSB7fTtcblxuICBGaWxlU3lzdGVtLl9vYmplY3RzID0ge307XG5cbiAgRmlsZVN5c3RlbS5fdXJsID0gXCIxMjcuMC4wLjFcIjtcblxuICBGaWxlU3lzdGVtLl9wb3J0ID0gXCI4ODg4XCI7XG5cbiAgRmlsZVN5c3RlbS51cmxfY29tID0gXCIvc2NlZW4vX1wiO1xuXG4gIEZpbGVTeXN0ZW0udXJsX3VwbG9hZCA9IFwiL3NjZWVuL3VwbG9hZFwiO1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPSBcIk5vZGVcIjtcbiAgfSBlbHNlIHtcbiAgICBGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID0gXCJCcm93c2VyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBGaWxlU3lzdGVtKCkge1xuICAgIHRoaXMuX2RhdGFfdG9fc2VuZCA9IFwiXCI7XG4gICAgdGhpcy5fc2Vzc2lvbl9udW0gPSAtMjtcbiAgICB0aGlzLl9udW1faW5zdCA9IEZpbGVTeXN0ZW0uX25iX2luc3RzKys7XG4gICAgdGhpcy5tYWtlX2NoYW5uZWxfZXJyb3JfdGltZXIgPSAwO1xuICAgIEZpbGVTeXN0ZW0uX2luc3RzW3RoaXMuX251bV9pbnN0XSA9IHRoaXM7XG4gICAgaWYgKEZpbGVTeXN0ZW0uX3VzZXJpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnNlbmQoXCJVIFwiICsgRmlsZVN5c3RlbS5fdXNlcmlkICsgXCIgXCIgKyBGaWxlU3lzdGVtLl9wYXNzd29yZCArIFwiIFwiKTtcbiAgICB9XG4gICAgdGhpcy5zZW5kKFwiUyBcIiArIHRoaXMuX251bV9pbnN0ICsgXCIgXCIpO1xuICB9XG5cbiAgRmlsZVN5c3RlbS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgRmlsZVN5c3RlbS5fc2VuZF9jaGFuKCk7XG4gICAgdGhpcy5zZW5kKFwiTCBcIiArIEZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrcyArIFwiIFwiICsgKGVuY29kZVVSSShwYXRoKSkgKyBcIiBcIik7XG4gICAgRmlsZVN5c3RlbS5fY2FsbGJhY2tzW0ZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrc10gPSBjYWxsYmFjaztcbiAgICByZXR1cm4gRmlsZVN5c3RlbS5fbmJfY2FsbGJhY2tzKys7XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5wcm90b3R5cGUubG9hZF90eXBlID0gZnVuY3Rpb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICBGaWxlU3lzdGVtLl9zZW5kX2NoYW4oKTtcbiAgICB0aGlzLnNlbmQoXCJSIDAgXCIgKyB0eXBlICsgXCIgXCIpO1xuICAgIHJldHVybiBGaWxlU3lzdGVtLl90eXBlX2NhbGxiYWNrcy5wdXNoKFt0eXBlLCBjYWxsYmFja10pO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0ucHJvdG90eXBlLmxvYWRfb3JfbWFrZV9kaXIgPSBmdW5jdGlvbihkaXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZChkaXIsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlcywgZXJyKSB7XG4gICAgICAgIHZhciBsc3QsIG5pciwgb2lyLCB2O1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGRpciA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygwLCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsc3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBsZW4sIHEsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICAgICAgcmVmID0gZGlyLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgICAgICAgICAgdiA9IHJlZltxXTtcbiAgICAgICAgICAgICAgICBpZiAodi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgbmlyID0gbHN0LnBvcCgpO1xuICAgICAgICAgICAgb2lyID0gXCIvXCIgKyBsc3Quam9pbihcIi9cIik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubG9hZF9vcl9tYWtlX2RpcihvaXIsIGZ1bmN0aW9uKG5fcmVzLCBuX2Vycikge1xuICAgICAgICAgICAgICB2YXIgbl9kaXI7XG4gICAgICAgICAgICAgIGlmIChuX2Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygwLCBuX2Vycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbl9kaXIgPSBuZXcgRGlyZWN0b3J5O1xuICAgICAgICAgICAgICAgIG5fcmVzLmFkZF9maWxlKG5pciwgbl9kaXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuX2Rpciwgbl9lcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlcywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSh0aGlzKSk7XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5wcm90b3R5cGUubG9hZF9wdHIgPSBmdW5jdGlvbihwdHIsIGNhbGxiYWNrKSB7XG4gICAgRmlsZVN5c3RlbS5fc2VuZF9jaGFuKCk7XG4gICAgdGhpcy5zZW5kKFwibCBcIiArIEZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrcyArIFwiIFwiICsgcHRyICsgXCIgXCIpO1xuICAgIEZpbGVTeXN0ZW0uX2NhbGxiYWNrc1tGaWxlU3lzdGVtLl9uYl9jYWxsYmFja3NdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIEZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrcysrO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0ucHJvdG90eXBlLmxvYWRfcmlnaHQgPSBmdW5jdGlvbihwdHIsIGNhbGxiYWNrKSB7XG4gICAgRmlsZVN5c3RlbS5fc2VuZF9jaGFuKCk7XG4gICAgdGhpcy5zZW5kKFwiciBcIiArIHB0ciArIFwiIFwiICsgRmlsZVN5c3RlbS5fbmJfY2FsbGJhY2tzICsgXCIgXCIpO1xuICAgIEZpbGVTeXN0ZW0uX2NhbGxiYWNrc1tGaWxlU3lzdGVtLl9uYl9jYWxsYmFja3NdID0gY2FsbGJhY2s7XG4gICAgcmV0dXJuIEZpbGVTeXN0ZW0uX25iX2NhbGxiYWNrcysrO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0ucHJvdG90eXBlLnNoYXJlX21vZGVsID0gZnVuY3Rpb24ocHRyLCBmaWxlX25hbWUsIHNoYXJlX3R5cGUsIHRhcmdldE5hbWUpIHtcbiAgICBGaWxlU3lzdGVtLl9zZW5kX2NoYW4oKTtcbiAgICByZXR1cm4gdGhpcy5zZW5kKFwiaCBcIiArIHB0ci5fc2VydmVyX2lkICsgXCIgXCIgKyBzaGFyZV90eXBlICsgXCIgXCIgKyAoZW5jb2RlVVJJKHRhcmdldE5hbWUpKSArIFwiIFwiICsgKGVuY29kZVVSSShmaWxlX25hbWUpKSArIFwiIFwiKTtcbiAgfTtcblxuICBGaWxlU3lzdGVtLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuX2RhdGFfdG9fc2VuZCArPSBkYXRhO1xuICAgIGlmIChGaWxlU3lzdGVtLl90aW1lcl9zZW5kID09IG51bGwpIHtcbiAgICAgIHJldHVybiBGaWxlU3lzdGVtLl90aW1lcl9zZW5kID0gc2V0VGltZW91dChGaWxlU3lzdGVtLl90aW1lb3V0X3NlbmRfZnVuYywgMSk7XG4gICAgfVxuICB9O1xuXG4gIEZpbGVTeXN0ZW0ucHJvdG90eXBlLm1ha2VfY2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXRoLCB4aHJfb2JqZWN0O1xuICAgIHBhdGggPSBcIlwiO1xuICAgIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIk5vZGVcIiB8fCBGaWxlU3lzdGVtLmlzX2NvcmRvdmEpIHtcbiAgICAgIGlmIChGaWxlU3lzdGVtLl9wb3J0KSB7XG4gICAgICAgIHBhdGggPSBcImh0dHA6Ly9cIiArIEZpbGVTeXN0ZW0uX3VybCArIFwiOlwiICsgRmlsZVN5c3RlbS5fcG9ydCArIEZpbGVTeXN0ZW0udXJsX2NvbSArIChcIj9zPVwiICsgdGhpcy5fc2Vzc2lvbl9udW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IFwiaHR0cDovL1wiICsgRmlsZVN5c3RlbS5fdXJsICsgRmlsZVN5c3RlbS51cmxfY29tICsgKFwiP3M9XCIgKyB0aGlzLl9zZXNzaW9uX251bSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIkJyb3dzZXJcIikge1xuICAgICAgcGF0aCA9IEZpbGVTeXN0ZW0udXJsX2NvbSArIChcIj9zPVwiICsgdGhpcy5fc2Vzc2lvbl9udW0pO1xuICAgIH1cbiAgICB4aHJfb2JqZWN0ID0gRmlsZVN5c3RlbS5fbXlfeG1sX2h0dHBfcmVxdWVzdCgpO1xuICAgIHhocl9vYmplY3Qub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XG4gICAgeGhyX29iamVjdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfZnMsIF93O1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCAmJiB0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIF9mcyA9IEZpbGVTeXN0ZW0uZ2V0X2luc3QoKTtcbiAgICAgICAgaWYgKF9mcy5tYWtlX2NoYW5uZWxfZXJyb3JfdGltZXIgIT09IDApIHtcbiAgICAgICAgICBfZnMub25Db25uZWN0aW9uRXJyb3IoMCk7XG4gICAgICAgIH1cbiAgICAgICAgX2ZzLm1ha2VfY2hhbm5lbF9lcnJvcl90aW1lciA9IDA7XG4gICAgICAgIGlmIChGaWxlU3lzdGVtLl9kaXNwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJjaGFuIC0+XCIsIHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBfdyA9IGZ1bmN0aW9uKHNpZCwgb2JqKSB7XG4gICAgICAgICAgdmFyIF9vYmosIGMsIGxlbiwgbW9kX1IsIHEsIHJlZiwgcmVzdWx0cztcbiAgICAgICAgICBfb2JqID0gRmlsZVN5c3RlbS5fY3JlYXRlX21vZGVsX2J5X25hbWUob2JqKTtcbiAgICAgICAgICBpZiAoKHNpZCAhPSBudWxsKSAmJiAoX29iaiAhPSBudWxsKSkge1xuICAgICAgICAgICAgX29iai5fc2VydmVyX2lkID0gc2lkO1xuICAgICAgICAgICAgRmlsZVN5c3RlbS5fb2JqZWN0c1tzaWRdID0gX29iajtcbiAgICAgICAgICAgIHJlZiA9IEZpbGVTeXN0ZW0uX3R5cGVfY2FsbGJhY2tzO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgICAgICAgIGMgPSByZWZbcV07XG4gICAgICAgICAgICAgIG1vZF9SID0gcm9vdFtjWzBdXSB8fCBzcGluYWxDb3JlLl9kZWZbY1swXV07XG4gICAgICAgICAgICAgIGlmIChfb2JqIGluc3RhbmNlb2YgbW9kX1IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY1sxXShfb2JqKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRmlsZVN5c3RlbS5fc2lnX3NlcnZlciA9IGZhbHNlO1xuICAgICAgICBldmFsKHRoaXMucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uX3NpZ19zZXJ2ZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDQgJiYgdGhpcy5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzZXJ2ZXIgd2l0aCByZXF1ZXN0IDogXCIgKyBwYXRoICsgXCIuXCIpO1xuICAgICAgICBfZnMgPSBGaWxlU3lzdGVtLmdldF9pbnN0KCk7XG4gICAgICAgIGlmIChfZnMubWFrZV9jaGFubmVsX2Vycm9yX3RpbWVyID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcnlpbmcgdG8gcmVjb25uZWN0LlwiKTtcbiAgICAgICAgICBfZnMubWFrZV9jaGFubmVsX2Vycm9yX3RpbWVyID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KF9mcy5tYWtlX2NoYW5uZWwuYmluZChfZnMpLCAxMDAwKTtcbiAgICAgICAgICByZXR1cm4gX2ZzLm9uQ29ubmVjdGlvbkVycm9yKDEpO1xuICAgICAgICB9IGVsc2UgaWYgKCgobmV3IERhdGUoKSkgLSBfZnMubWFrZV9jaGFubmVsX2Vycm9yX3RpbWVyKSA8IEZpbGVTeXN0ZW0uX3RpbWVvdXRfcmVjb25uZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoX2ZzLm1ha2VfY2hhbm5lbC5iaW5kKF9mcyksIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBfZnMub25Db25uZWN0aW9uRXJyb3IoMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0ICYmIHRoaXMuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uZ2V0X2luc3QoKS5vbkNvbm5lY3Rpb25FcnJvcigzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB4aHJfb2JqZWN0LnNlbmQoKTtcbiAgfTtcblxuICBGaWxlU3lzdGVtLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25FcnJvciA9IGZ1bmN0aW9uKGVycm9yX2NvZGUpIHtcbiAgICB2YXIgbXNnO1xuICAgIG1zZyA9IFwiXCI7XG4gICAgaWYgKGVycm9yX2NvZGUgPT09IDApIHtcbiAgICAgIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIkJyb3dzZXJcIiB8fCBGaWxlU3lzdGVtLmlzX2NvcmRvdmEpIHtcbiAgICAgICAgRmlsZVN5c3RlbS5wb3B1cC5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlY29ubmVjdGVkIHRvIHRoZSBzZXJ2ZXIuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyb3JfY29kZSA9PT0gMSkge1xuICAgICAgaWYgKEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPT09IFwiQnJvd3NlclwiIHx8IEZpbGVTeXN0ZW0uaXNfY29yZG92YSkge1xuICAgICAgICBtc2cgPSBcIkRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzZXJ2ZXIsIHRyeWluZyB0byByZWNvbm5lY3QuLi5cIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEaXNjb25uZWN0ZWQgZnJvbSB0aGUgc2VydmVyLCB0cnlpbmcgdG8gcmVjb25uZWN0Li4uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyb3JfY29kZSA9PT0gMiB8fCBlcnJvcl9jb2RlID09PSAzIHx8IGVycm9yX2NvZGUgPT09IDQpIHtcbiAgICAgIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIkJyb3dzZXJcIiB8fCBGaWxlU3lzdGVtLmlzX2NvcmRvdmEpIHtcbiAgICAgICAgbXNnID0gXCJEaXNjb25uZWN0ZWQgZnJvbSB0aGUgc2VydmVyLCBwbGVhc2UgcmVmcmVzaCB0aGUgd2luZG93LlwiO1xuICAgICAgfSBlbHNlIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIk5vZGVcIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlci5cIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzZXJ2ZXIuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobXNnICE9PSBcIlwiKSB7XG4gICAgICBpZiAoRmlsZVN5c3RlbS5wb3B1cCA9PT0gMCkge1xuICAgICAgICBGaWxlU3lzdGVtLnBvcHVwID0gbmV3IG5ld19hbGVydF9tc2coe1xuICAgICAgICAgIHBhcmVudDogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJCT0RZXCIpWzBdLFxuICAgICAgICAgIG1zZzogbXNnLFxuICAgICAgICAgIGJ0bjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eHQ6ICdyZWxvYWQgcGFnZScsXG4gICAgICAgICAgICAgIGNsaWNrOiB3aW5kb3cubG9jYXRpb24ucmVsb2FkLmJpbmQod2luZG93LmxvY2F0aW9uKSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmNWI1NydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdHh0OiAnY2xvc2UnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzQ4ZmUyJyxcbiAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGaWxlU3lzdGVtLnBvcHVwLmhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBGaWxlU3lzdGVtLnBvcHVwLnNob3coKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcl9jb2RlID09PSAyIHx8IGVycm9yX2NvZGUgPT09IDMgfHwgZXJyb3JfY29kZSA9PT0gNCkge1xuICAgICAgICBGaWxlU3lzdGVtLnBvcHVwLnNob3dfYnRuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBGaWxlU3lzdGVtLnBvcHVwLmhpZGVfYnRuKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gRmlsZVN5c3RlbS5wb3B1cC5zZXRNc2cobXNnKTtcbiAgICB9XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5nZXRfaW5zdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpLCBrLCByZWY7XG4gICAgcmVmID0gRmlsZVN5c3RlbS5faW5zdHM7XG4gICAgZm9yIChrIGluIHJlZikge1xuICAgICAgaSA9IHJlZltrXTtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpbGVTeXN0ZW07XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5zZXRfc2VydmVyX2lkX2lmX25lY2Vzc2FyeSA9IGZ1bmN0aW9uKG91dCwgb2JqKSB7XG4gICAgdmFyIG5jbDtcbiAgICBpZiAob2JqLl9zZXJ2ZXJfaWQgPT0gbnVsbCkge1xuICAgICAgb2JqLl9zZXJ2ZXJfaWQgPSBGaWxlU3lzdGVtLl9nZXRfbmV3X3RtcF9zZXJ2ZXJfaWQoKTtcbiAgICAgIEZpbGVTeXN0ZW0uX3RtcF9vYmplY3RzW29iai5fc2VydmVyX2lkXSA9IG9iajtcbiAgICAgIG5jbCA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuZ2V0X29iamVjdF9jbGFzcyhvYmopO1xuICAgICAgaWYgKG9iai5fdW5kZXJseWluZ19mc190eXBlICE9IG51bGwpIHtcbiAgICAgICAgb3V0Lm1vZCArPSBcIlQgXCIgKyBvYmouX3NlcnZlcl9pZCArIFwiIFwiICsgbmNsICsgXCIgXCI7XG4gICAgICAgIG5jbCA9IG9iai5fdW5kZXJseWluZ19mc190eXBlKCk7XG4gICAgICB9XG4gICAgICBvdXQuY3JlICs9IFwiTiBcIiArIG9iai5fc2VydmVyX2lkICsgXCIgXCIgKyBuY2wgKyBcIiBcIjtcbiAgICAgIHJldHVybiBvYmouX2dldF9mc19kYXRhKG91dCk7XG4gICAgfVxuICB9O1xuXG4gIEZpbGVTeXN0ZW0uc2lnbmFsX2NoYW5nZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICBpZiAoRmlsZVN5c3RlbS5fc2lnX3NlcnZlcikge1xuICAgICAgRmlsZVN5c3RlbS5fb2JqZWN0c190b19zZW5kW20ubW9kZWxfaWRdID0gbTtcbiAgICAgIGlmIChGaWxlU3lzdGVtLl90aW1lcl9jaGFuICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KEZpbGVTeXN0ZW0uX3RpbWVyX2NoYW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uX3RpbWVyX2NoYW4gPSBzZXRUaW1lb3V0KEZpbGVTeXN0ZW0uX3RpbWVvdXRfY2hhbl9mdW5jLCAyNTApO1xuICAgIH1cbiAgfTtcblxuICBGaWxlU3lzdGVtLl90bXBfaWRfdG9fcmVhbCA9IGZ1bmN0aW9uKHRtcF9pZCwgcmVzKSB7XG4gICAgdmFyIGZzLCBwYXRoLCBwdHIsIHRtcCwgeGhyX29iamVjdDtcbiAgICB0bXAgPSBGaWxlU3lzdGVtLl90bXBfb2JqZWN0c1t0bXBfaWRdO1xuICAgIGlmICh0bXAgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2codG1wX2lkKTtcbiAgICB9XG4gICAgRmlsZVN5c3RlbS5fb2JqZWN0c1tyZXNdID0gdG1wO1xuICAgIHRtcC5fc2VydmVyX2lkID0gcmVzO1xuICAgIGRlbGV0ZSBGaWxlU3lzdGVtLl90bXBfb2JqZWN0c1t0bXBfaWRdO1xuICAgIHB0ciA9IEZpbGVTeXN0ZW0uX3B0cl90b191cGRhdGVbdG1wX2lkXTtcbiAgICBpZiAocHRyICE9IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBGaWxlU3lzdGVtLl9wdHJfdG9fdXBkYXRlW3RtcF9pZF07XG4gICAgICBwdHIuZGF0YS52YWx1ZSA9IHJlcztcbiAgICB9XG4gICAgaWYgKChGaWxlU3lzdGVtLl9maWxlc190b191cGxvYWRbdG1wX2lkXSAhPSBudWxsKSAmJiAodG1wLmZpbGUgIT0gbnVsbCkpIHtcbiAgICAgIGRlbGV0ZSBGaWxlU3lzdGVtLl9maWxlc190b191cGxvYWRbdG1wX2lkXTtcbiAgICAgIGZzID0gRmlsZVN5c3RlbS5nZXRfaW5zdCgpO1xuICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICBpZiAoRmlsZVN5c3RlbS5DT05ORUNUT1JfVFlQRSA9PT0gXCJOb2RlXCIgfHwgRmlsZVN5c3RlbS5pc19jb3Jkb3ZhKSB7XG4gICAgICAgIGlmIChGaWxlU3lzdGVtLl9wb3J0KSB7XG4gICAgICAgICAgcGF0aCA9IFwiaHR0cDovL1wiICsgRmlsZVN5c3RlbS5fdXJsICsgXCI6XCIgKyBGaWxlU3lzdGVtLl9wb3J0ICsgRmlsZVN5c3RlbS51cmxfY29tICsgKFwiP3M9XCIgKyBmcy5fc2Vzc2lvbl9udW0gKyBcIiZwPVwiICsgdG1wLl9zZXJ2ZXJfaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBcImh0dHA6Ly9cIiArIEZpbGVTeXN0ZW0uX3VybCArIEZpbGVTeXN0ZW0udXJsX2NvbSArIChcIj9zPVwiICsgZnMuX3Nlc3Npb25fbnVtICsgXCImcD1cIiArIHRtcC5fc2VydmVyX2lkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChGaWxlU3lzdGVtLkNPTk5FQ1RPUl9UWVBFID09PSBcIkJyb3dzZXJcIikge1xuICAgICAgICBwYXRoID0gRmlsZVN5c3RlbS51cmxfY29tICsgKFwiP3M9XCIgKyBmcy5fc2Vzc2lvbl9udW0gKyBcIiZwPVwiICsgdG1wLl9zZXJ2ZXJfaWQpO1xuICAgICAgfVxuICAgICAgeGhyX29iamVjdCA9IEZpbGVTeXN0ZW0uX215X3htbF9odHRwX3JlcXVlc3QoKTtcbiAgICAgIHhocl9vYmplY3Qub3BlbignUFVUJywgcGF0aCwgdHJ1ZSk7XG4gICAgICB4aHJfb2JqZWN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3c7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDQgJiYgdGhpcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgIF93ID0gZnVuY3Rpb24oc2lkLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBfb2JqO1xuICAgICAgICAgICAgX29iaiA9IEZpbGVTeXN0ZW0uX2NyZWF0ZV9tb2RlbF9ieV9uYW1lKG9iaik7XG4gICAgICAgICAgICBpZiAoKHNpZCAhPSBudWxsKSAmJiAoX29iaiAhPSBudWxsKSkge1xuICAgICAgICAgICAgICBfb2JqLl9zZXJ2ZXJfaWQgPSBzaWQ7XG4gICAgICAgICAgICAgIHJldHVybiBGaWxlU3lzdGVtLl9vYmplY3RzW3NpZF0gPSBfb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGV2YWwodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyX29iamVjdC5zZW5kKHRtcC5maWxlKTtcbiAgICAgIGRlbGV0ZSB0bXAuZmlsZTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbGVTeXN0ZW0uc2lnbmFsX2NoYW5nZShGaWxlU3lzdGVtLl9vYmplY3RzW3Jlc10pO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0uX2NyZWF0ZV9tb2RlbF9ieV9uYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3BpbmFsQ29yZS5fZGVmW25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBzcGluYWxDb3JlLl9kZWZbbmFtZV0oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByb290W25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKEZpbGVTeXN0ZW0uZGVidWcgPT09IHRydWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiR290IE1vZGVsIHR5cGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmcm9tIGh1YiBidXQgbm8gcmVnaXN0ZXJlZC5cIik7XG4gICAgICB9XG4gICAgICByb290W25hbWVdID0gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uIFwiICsgbmFtZSArIFwiICgpe1wiICsgbmFtZSArIFwiLnN1cGVyKHRoaXMpO31cIikoKTtcbiAgICAgIEZpbGVTeXN0ZW0uZXh0ZW5kKHJvb3RbbmFtZV0sIE1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyByb290W25hbWVdKCk7XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5leHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7XG4gICAgdmFyIGNoaWxkX25hbWUsIGN0b3IsIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICB2YWx1ZSA9IHBhcmVudFtrZXldO1xuICAgICAgY2hpbGRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgfTtcbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnN1cGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgXHRmb3IgKHZhciBpPTE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgYXJnc1tpLTFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgY2hpbGQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KGFyZ3VtZW50c1swXSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsICE9PSBudWxsID8gZ2xvYmFsIDogd2luZG93O1xuICAgIGNoaWxkX25hbWUgPSAvXmZ1bmN0aW9uXFxzKyhbXFx3XFwkXSspXFxzKlxcKC8uZXhlYyhjaGlsZC50b1N0cmluZygpKVsxXTtcbiAgICByZXR1cm4gcm9vdFtjaGlsZF9uYW1lXSA9IGNoaWxkO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0uX2dldF9uZXdfdG1wX3NlcnZlcl9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIEZpbGVTeXN0ZW0uX2N1cl90bXBfc2VydmVyX2lkKys7XG4gICAgaWYgKEZpbGVTeXN0ZW0uX2N1cl90bXBfc2VydmVyX2lkICUgNCA9PT0gMCkge1xuICAgICAgRmlsZVN5c3RlbS5fY3VyX3RtcF9zZXJ2ZXJfaWQrKztcbiAgICB9XG4gICAgcmV0dXJuIEZpbGVTeXN0ZW0uX2N1cl90bXBfc2VydmVyX2lkO1xuICB9O1xuXG4gIEZpbGVTeXN0ZW0uX3NlbmRfY2hhbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmLCBrLCBvdXQsIHJlZiwgcmVzdWx0cztcbiAgICBvdXQgPSBGaWxlU3lzdGVtLl9nZXRfY2hhbl9kYXRhKCk7XG4gICAgcmVmID0gRmlsZVN5c3RlbS5faW5zdHM7XG4gICAgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoayBpbiByZWYpIHtcbiAgICAgIGYgPSByZWZba107XG4gICAgICByZXN1bHRzLnB1c2goZi5zZW5kKG91dCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBGaWxlU3lzdGVtLl90aW1lb3V0X2NoYW5fZnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgIEZpbGVTeXN0ZW0uX3NlbmRfY2hhbigpO1xuICAgIHJldHVybiBkZWxldGUgRmlsZVN5c3RlbS5fdGltZXJfY2hhbjtcbiAgfTtcblxuICBGaWxlU3lzdGVtLl9nZXRfY2hhbl9kYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1vZGVsLCBuLCBvdXQsIHJlZjtcbiAgICBvdXQgPSB7XG4gICAgICBjcmU6IFwiXCIsXG4gICAgICBtb2Q6IFwiXCJcbiAgICB9O1xuICAgIHJlZiA9IEZpbGVTeXN0ZW0uX29iamVjdHNfdG9fc2VuZDtcbiAgICBmb3IgKG4gaW4gcmVmKSB7XG4gICAgICBtb2RlbCA9IHJlZltuXTtcbiAgICAgIG1vZGVsLl9nZXRfZnNfZGF0YShvdXQpO1xuICAgIH1cbiAgICBGaWxlU3lzdGVtLl9vYmplY3RzX3RvX3NlbmQgPSB7fTtcbiAgICByZXR1cm4gb3V0LmNyZSArIG91dC5tb2Q7XG4gIH07XG5cbiAgRmlsZVN5c3RlbS5fdGltZW91dF9zZW5kX2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZiwgaywgb3V0LCBwYXRoLCByZWYsIHJlZjEsIHhocl9vYmplY3Q7XG4gICAgb3V0ID0gRmlsZVN5c3RlbS5fZ2V0X2NoYW5fZGF0YSgpO1xuICAgIHJlZiA9IEZpbGVTeXN0ZW0uX2luc3RzO1xuICAgIGZvciAoayBpbiByZWYpIHtcbiAgICAgIGYgPSByZWZba107XG4gICAgICBmLl9kYXRhX3RvX3NlbmQgKz0gb3V0O1xuICAgIH1cbiAgICByZWYxID0gRmlsZVN5c3RlbS5faW5zdHM7XG4gICAgZm9yIChrIGluIHJlZjEpIHtcbiAgICAgIGYgPSByZWYxW2tdO1xuICAgICAgaWYgKCFmLl9kYXRhX3RvX3NlbmQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGYuX3Nlc3Npb25fbnVtID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmLl9zZXNzaW9uX251bSA9PT0gLTIpIHtcbiAgICAgICAgZi5fc2Vzc2lvbl9udW0gPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYuX2RhdGFfdG9fc2VuZCA9IChcInMgXCIgKyBmLl9zZXNzaW9uX251bSArIFwiIFwiKSArIGYuX2RhdGFfdG9fc2VuZDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgaWYgKEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPT09IFwiTm9kZVwiIHx8IEZpbGVTeXN0ZW0uaXNfY29yZG92YSkge1xuICAgICAgICBpZiAoRmlsZVN5c3RlbS5fcG9ydCkge1xuICAgICAgICAgIHBhdGggPSBcImh0dHA6Ly9cIiArIEZpbGVTeXN0ZW0uX3VybCArIFwiOlwiICsgRmlsZVN5c3RlbS5fcG9ydCArIEZpbGVTeXN0ZW0udXJsX2NvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoID0gXCJodHRwOi8vXCIgKyBGaWxlU3lzdGVtLl91cmwgKyBGaWxlU3lzdGVtLnVybF9jb207XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRmlsZVN5c3RlbS5DT05ORUNUT1JfVFlQRSA9PT0gXCJCcm93c2VyXCIpIHtcbiAgICAgICAgcGF0aCA9IEZpbGVTeXN0ZW0udXJsX2NvbTtcbiAgICAgIH1cbiAgICAgIHhocl9vYmplY3QgPSBGaWxlU3lzdGVtLl9teV94bWxfaHR0cF9yZXF1ZXN0KCk7XG4gICAgICB4aHJfb2JqZWN0Lm9wZW4oJ1BPU1QnLCBwYXRoLCB0cnVlKTtcbiAgICAgIHhocl9vYmplY3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfYywgX3csIGMsIGxlbiwgcSwgcmVzdWx0cztcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCAmJiB0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgaWYgKEZpbGVTeXN0ZW0uX2Rpc3ApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVzcCAtPlwiLCB0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jID0gW107XG4gICAgICAgICAgX3cgPSBmdW5jdGlvbihzaWQsIG9iaikge1xuICAgICAgICAgICAgdmFyIF9vYmosIGMsIGxlbiwgbW9kX1IsIHEsIHJlZjIsIHJlc3VsdHM7XG4gICAgICAgICAgICBfb2JqID0gRmlsZVN5c3RlbS5fY3JlYXRlX21vZGVsX2J5X25hbWUob2JqKTtcbiAgICAgICAgICAgIGlmICgoc2lkICE9IG51bGwpICYmIChfb2JqICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgIF9vYmouX3NlcnZlcl9pZCA9IHNpZDtcbiAgICAgICAgICAgICAgRmlsZVN5c3RlbS5fb2JqZWN0c1tzaWRdID0gX29iajtcbiAgICAgICAgICAgICAgcmVmMiA9IEZpbGVTeXN0ZW0uX3R5cGVfY2FsbGJhY2tzO1xuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZjIubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgICAgICAgICAgICBjID0gcmVmMltxXTtcbiAgICAgICAgICAgICAgICBtb2RfUiA9IHJvb3RbY1swXV0gfHwgc3BpbmFsQ29yZS5fZGVmW2NbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChfb2JqIGluc3RhbmNlb2YgbW9kX1IpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChjWzFdKF9vYmopKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgRmlsZVN5c3RlbS5fc2lnX3NlcnZlciA9IGZhbHNlO1xuICAgICAgICAgIGV2YWwodGhpcy5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIEZpbGVTeXN0ZW0uX3NpZ19zZXJ2ZXIgPSB0cnVlO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKHEgPSAwLCBsZW4gPSBfYy5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgICAgICAgYyA9IF9jW3FdO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKEZpbGVTeXN0ZW0uX2NhbGxiYWNrc1tjWzBdXShGaWxlU3lzdGVtLl9vYmplY3RzW2NbMV1dLCBjWzJdKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCAmJiAodGhpcy5zdGF0dXMgPT09IDAgfHwgdGhpcy5zdGF0dXMgPT09IDUwMCkpIHtcbiAgICAgICAgICByZXR1cm4gRmlsZVN5c3RlbS5nZXRfaW5zdCgpLm9uQ29ubmVjdGlvbkVycm9yKDQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKEZpbGVTeXN0ZW0uX2Rpc3ApIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJzZW50IC0+XCIsIGYuX2RhdGFfdG9fc2VuZCArIFwiRSBcIik7XG4gICAgICB9XG4gICAgICB4aHJfb2JqZWN0LnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3BsYWluJyk7XG4gICAgICB4aHJfb2JqZWN0LnNlbmQoZi5fZGF0YV90b19zZW5kICsgXCJFIFwiKTtcbiAgICAgIGYuX2RhdGFfdG9fc2VuZCA9IFwiXCI7XG4gICAgfVxuICAgIEZpbGVTeXN0ZW0uX29iamVjdHNfdG9fc2VuZCA9IHt9O1xuICAgIHJldHVybiBkZWxldGUgRmlsZVN5c3RlbS5fdGltZXJfc2VuZDtcbiAgfTtcblxuICBGaWxlU3lzdGVtLl9teV94bWxfaHR0cF9yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPT09IFwiQnJvd3NlclwiKSB7XG4gICAgICBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7XG4gICAgICB9XG4gICAgICBpZiAod2luZG93LkFjdGl2ZVhPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsZXJ0KCdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IFhNTEhUVFBSZXF1ZXN0IG9iamVjdHMuLi4nKTtcbiAgICB9IGVsc2UgaWYgKEZpbGVTeXN0ZW0uQ09OTkVDVE9SX1RZUEUgPT09IFwiTm9kZVwiKSB7XG4gICAgICByZXR1cm4gbmV3IEZpbGVTeXN0ZW0uX1hNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhcInlvdSBtdXN0IGRlZmluZSBDT05ORUNUT1JfVFlQRVwiKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZpbGVTeXN0ZW07XG5cbn0pKCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkRpcmVjdG9yeSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChEaXJlY3RvcnksIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIERpcmVjdG9yeSgpIHtcbiAgICBEaXJlY3RvcnkuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICBEaXJlY3RvcnkucHJvdG90eXBlLmJhc2VfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGaWxlO1xuICB9O1xuXG4gIERpcmVjdG9yeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZiwgbGVuLCBxLCByZWY7XG4gICAgcmVmID0gdGhpcztcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBxIDwgbGVuOyBxKyspIHtcbiAgICAgIGYgPSByZWZbcV07XG4gICAgICBpZiAoZi5uYW1lLmVxdWFscyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfTtcblxuICBEaXJlY3RvcnkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBmO1xuICAgIGYgPSB0aGlzLmZpbmQobmFtZSk7XG4gICAgaWYgKGYpIHtcbiAgICAgIHJldHVybiBmLmxvYWQoY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodm9pZCAwLCBcImZpbGUgZG9lcyBub3QgZXhpc3RcIik7XG4gICAgfVxuICB9O1xuXG4gIERpcmVjdG9yeS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmLCBsZW4sIHEsIHJlZjtcbiAgICByZWYgPSB0aGlzO1xuICAgIGZvciAocSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IHEgPCBsZW47IHErKykge1xuICAgICAgZiA9IHJlZltxXTtcbiAgICAgIGlmIChmLm5hbWUuZXF1YWxzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgRGlyZWN0b3J5LnByb3RvdHlwZS5hZGRfZmlsZSA9IGZ1bmN0aW9uKG5hbWUsIG9iaiwgcGFyYW1zKSB7XG4gICAgdmFyIG8sIHJlcztcbiAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgIHBhcmFtcyA9IHt9O1xuICAgIH1cbiAgICBvID0gdGhpcy5maW5kKG5hbWUpO1xuICAgIGlmIChvICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICByZXMgPSBuZXcgRmlsZShuYW1lLCBvYmosIHBhcmFtcyk7XG4gICAgdGhpcy5wdXNoKHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBEaXJlY3RvcnkucHJvdG90eXBlLmFkZF90aWZmX2ZpbGUgPSBmdW5jdGlvbihuYW1lLCBvYmosIHRpZmZfb2JqLCBwYXJhbXMpIHtcbiAgICB2YXIgbywgcmVzO1xuICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zID0ge307XG4gICAgfVxuICAgIG8gPSB0aGlzLmZpbmQobmFtZSk7XG4gICAgaWYgKG8gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHJlcyA9IG5ldyBUaWZmRmlsZShuYW1lLCBvYmosIHRpZmZfb2JqLCBwYXJhbXMpO1xuICAgIHRoaXMucHVzaChyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgRGlyZWN0b3J5LnByb3RvdHlwZS5mb3JjZV9hZGRfZmlsZSA9IGZ1bmN0aW9uKG5hbWUsIG9iaiwgcGFyYW1zKSB7XG4gICAgdmFyIG5hbWVfZmlsZSwgbnVtLCBvLCByZXM7XG4gICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMgPSB7fTtcbiAgICB9XG4gICAgbnVtID0gMDtcbiAgICBuYW1lX2ZpbGUgPSBuYW1lO1xuICAgIG8gPSB0aGlzLmZpbmQobmFtZV9maWxlKTtcbiAgICBpZiAobyAhPSBudWxsKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBuYW1lX2ZpbGUgPSBuYW1lICsgXCJfXCIgKyBudW07XG4gICAgICAgIG8gPSB0aGlzLmZpbmQobmFtZV9maWxlKTtcbiAgICAgICAgaWYgKG8gIT0gbnVsbCkge1xuICAgICAgICAgIG51bSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlcyA9IG5ldyBGaWxlKG5hbWVfZmlsZSwgb2JqLCBwYXJhbXMpO1xuICAgIHRoaXMucHVzaChyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgRGlyZWN0b3J5LnByb3RvdHlwZS5nZXRfZmlsZV9pbmZvID0gZnVuY3Rpb24oaW5mbykge1xuICAgIHJldHVybiBpbmZvLmljb24gPSBcImZvbGRlclwiO1xuICB9O1xuXG4gIHJldHVybiBEaXJlY3Rvcnk7XG5cbn0pKExzdCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LkZpbGUgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoRmlsZSwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gRmlsZShuYW1lLCBwdHJfb3JfbW9kZWwsIGluZm8pIHtcbiAgICB2YXIgY3BfaW5mbywga2V5LCB2YWw7XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChwdHJfb3JfbW9kZWwgPT0gbnVsbCkge1xuICAgICAgcHRyX29yX21vZGVsID0gMDtcbiAgICB9XG4gICAgaWYgKGluZm8gPT0gbnVsbCkge1xuICAgICAgaW5mbyA9IHt9O1xuICAgIH1cbiAgICBGaWxlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIGNwX2luZm8gPSB7fTtcbiAgICBmb3IgKGtleSBpbiBpbmZvKSB7XG4gICAgICB2YWwgPSBpbmZvW2tleV07XG4gICAgICBjcF9pbmZvW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIGlmIChwdHJfb3JfbW9kZWwgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgaWYgKGNwX2luZm8ubW9kZWxfdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNwX2luZm8ubW9kZWxfdHlwZSA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuZ2V0X29iamVjdF9jbGFzcyhwdHJfb3JfbW9kZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwdHJfb3JfbW9kZWwuZ2V0X2ZpbGVfaW5mbyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHB0cl9vcl9tb2RlbC5nZXRfZmlsZV9pbmZvKGNwX2luZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZF9hdHRyKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBhZG1pbnM6IG5ldyBMc3QsXG4gICAgICB1c2VyczogbmV3IExzdCxcbiAgICAgIF9jcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLFxuICAgICAgX3B0cjogbmV3IFB0cihwdHJfb3JfbW9kZWwpLFxuICAgICAgX2luZm86IGNwX2luZm9cbiAgICB9KTtcbiAgfVxuXG4gIEZpbGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9wdHIubG9hZChjYWxsYmFjayk7XG4gIH07XG5cbiAgcmV0dXJuIEZpbGU7XG5cbn0pKE1vZGVsKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuUGF0aCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChQYXRoLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBQYXRoKGZpbGUxKSB7XG4gICAgdmFyIHNpemU7XG4gICAgdGhpcy5maWxlID0gZmlsZTE7XG4gICAgUGF0aC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICBzaXplID0gdGhpcy5maWxlICE9IG51bGwgPyB0aGlzLmZpbGUuZmlsZVNpemUgIT0gbnVsbCA/IHRoaXMuZmlsZS5maWxlU2l6ZSA6IHRoaXMuZmlsZS5zaXplIDogMDtcbiAgICB0aGlzLmFkZF9hdHRyKHtcbiAgICAgIHJlbWFpbmluZzogc2l6ZSxcbiAgICAgIHRvX3VwbG9hZDogc2l6ZVxuICAgIH0pO1xuICB9XG5cbiAgUGF0aC5wcm90b3R5cGUuZ2V0X2ZpbGVfaW5mbyA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICBpbmZvLnJlbWFpbmluZyA9IHRoaXMucmVtYWluaW5nO1xuICAgIHJldHVybiBpbmZvLnRvX3VwbG9hZCA9IHRoaXMudG9fdXBsb2FkO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLl9nZXRfZnNfZGF0YSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIFBhdGguX19zdXBlcl9fLl9nZXRfZnNfZGF0YS5jYWxsKHRoaXMsIG91dCk7XG4gICAgaWYgKCh0aGlzLmZpbGUgIT0gbnVsbCkgJiYgdGhpcy5fc2VydmVyX2lkICYgMykge1xuICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uX2ZpbGVzX3RvX3VwbG9hZFt0aGlzLl9zZXJ2ZXJfaWRdID0gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBhdGg7XG5cbn0pKE1vZGVsKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuUHRyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFB0ciwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gUHRyKG1vZGVsKSB7XG4gICAgUHRyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuX3NldChtb2RlbCk7XG4gIH1cblxuICBQdHIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciByZWY7XG4gICAgaWYgKHRoaXMuZGF0YS5tb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5kYXRhLm1vZGVsLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAocmVmID0gRmlsZVN5c3RlbS5nZXRfaW5zdCgpKSAhPSBudWxsID8gcmVmLmxvYWRfcHRyKHRoaXMuZGF0YS52YWx1ZSwgY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcblxuICBQdHIucHJvdG90eXBlLl9nZXRfZnNfZGF0YSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIEZpbGVTeXN0ZW0uc2V0X3NlcnZlcl9pZF9pZl9uZWNlc3Nhcnkob3V0LCB0aGlzKTtcbiAgICBpZiAodGhpcy5kYXRhLm1vZGVsICE9IG51bGwpIHtcbiAgICAgIEZpbGVTeXN0ZW0uc2V0X3NlcnZlcl9pZF9pZl9uZWNlc3Nhcnkob3V0LCB0aGlzLmRhdGEubW9kZWwpO1xuICAgICAgb3V0Lm1vZCArPSBcIkMgXCIgKyB0aGlzLl9zZXJ2ZXJfaWQgKyBcIiBcIiArIHRoaXMuZGF0YS5tb2RlbC5fc2VydmVyX2lkICsgXCIgXCI7XG4gICAgICB0aGlzLmRhdGEudmFsdWUgPSB0aGlzLmRhdGEubW9kZWwuX3NlcnZlcl9pZDtcbiAgICAgIGlmICh0aGlzLmRhdGEubW9kZWwuX3NlcnZlcl9pZCAmIDMpIHtcbiAgICAgICAgcmV0dXJuIEZpbGVTeXN0ZW0uX3B0cl90b191cGRhdGVbdGhpcy5kYXRhLm1vZGVsLl9zZXJ2ZXJfaWRdID0gdGhpcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG91dC5tb2QgKz0gXCJDIFwiICsgdGhpcy5fc2VydmVyX2lkICsgXCIgXCIgKyB0aGlzLmRhdGEudmFsdWUgKyBcIiBcIjtcbiAgICB9XG4gIH07XG5cbiAgUHRyLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmICh0eXBlb2YgbW9kZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJlcyA9IHRoaXMuZGF0YS52YWx1ZSAhPT0gbW9kZWw7XG4gICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgIHZhbHVlOiBtb2RlbFxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICByZXMgPSB0aGlzLmRhdGEudmFsdWUgIT09IG1vZGVsLl9zZXJ2ZXJfaWQ7XG4gICAgICB0aGlzLmRhdGEgPSB7XG4gICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgdmFsdWU6IG1vZGVsLl9zZXJ2ZXJfaWRcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgUHRyLnByb3RvdHlwZS5fZ2V0X3N0YXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH07XG5cbiAgUHRyLnByb3RvdHlwZS5fc2V0X3N0YXRlID0gZnVuY3Rpb24oc3RyLCBtYXApIHtcbiAgICByZXR1cm4gdGhpcy5zZXQoc3RyKTtcbiAgfTtcblxuICByZXR1cm4gUHRyO1xuXG59KShNb2RlbCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlJpZ2h0c0l0ZW0gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoUmlnaHRzSXRlbSwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gUmlnaHRzSXRlbSgpIHtcbiAgICBSaWdodHNJdGVtLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIFJpZ2h0c0l0ZW07XG5cbn0pKExzdCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlNlc3Npb25Nb2RlbCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gIGV4dGVuZChTZXNzaW9uTW9kZWwsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIFNlc3Npb25Nb2RlbCgpIHtcbiAgICBTZXNzaW9uTW9kZWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XG4gIH1cblxuICByZXR1cm4gU2Vzc2lvbk1vZGVsO1xuXG59KShNb2RlbCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlRpZmZGaWxlID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFRpZmZGaWxlLCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBUaWZmRmlsZShuYW1lLCBwdHJfb3JfbW9kZWwsIHB0cl90aWZmLCBpbmZvKSB7XG4gICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFwiXCI7XG4gICAgfVxuICAgIGlmIChwdHJfb3JfbW9kZWwgPT0gbnVsbCkge1xuICAgICAgcHRyX29yX21vZGVsID0gMDtcbiAgICB9XG4gICAgaWYgKHB0cl90aWZmID09IG51bGwpIHtcbiAgICAgIHB0cl90aWZmID0gMDtcbiAgICB9XG4gICAgaWYgKGluZm8gPT0gbnVsbCkge1xuICAgICAgaW5mbyA9IHt9O1xuICAgIH1cbiAgICBUaWZmRmlsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBuYW1lLCBwdHJfb3JfbW9kZWwsIGluZm8pO1xuICAgIHRoaXMuYWRkX2F0dHIoe1xuICAgICAgX3B0cl90aWZmOiBuZXcgUHRyKHB0cl90aWZmKSxcbiAgICAgIF9oYXNfYmVlbl9jb252ZXJ0ZWQ6IDBcbiAgICB9KTtcbiAgfVxuXG4gIFRpZmZGaWxlLnByb3RvdHlwZS5sb2FkX3RpZmYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9wdHJfdGlmZi5sb2FkKGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gVGlmZkZpbGU7XG5cbn0pKEZpbGUpO1xuXG5yb290ID0gdHlwZW9mIF9yb290X29iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHdpbmRvdztcblxucm9vdC5Vc2VyUmlnaHQgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoVXNlclJpZ2h0LCBzdXBlckNsYXNzKTtcblxuICBmdW5jdGlvbiBVc2VyUmlnaHQoKSB7XG4gICAgVXNlclJpZ2h0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgVXNlclJpZ2h0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29uc29sZS5sb2coXCJTZXQgYSBVc2VyUmlnaHQgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9O1xuXG4gIHJldHVybiBVc2VyUmlnaHQ7XG5cbn0pKE1vZGVsKTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuUmlnaHRTZXRMaXN0ID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgZXh0ZW5kKFJpZ2h0U2V0TGlzdCwgc3VwZXJDbGFzcyk7XG5cbiAgZnVuY3Rpb24gUmlnaHRTZXRMaXN0KCkge1xuICAgIFJpZ2h0U2V0TGlzdC5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgfVxuXG4gIHJldHVybiBSaWdodFNldExpc3Q7XG5cbn0pKExzdCk7XG5cbnJvb3QgPSB0eXBlb2YgX3Jvb3Rfb2JqID09PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93O1xuXG5yb290LlByb2Nlc3MgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFByb2Nlc3MobSwgb25jaGFuZ2VfY29uc3RydWN0aW9uKSB7XG4gICAgdmFyIGksIGxlbiwgcTtcbiAgICBpZiAob25jaGFuZ2VfY29uc3RydWN0aW9uID09IG51bGwpIHtcbiAgICAgIG9uY2hhbmdlX2NvbnN0cnVjdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc19pZCA9IE1vZGVsUHJvY2Vzc01hbmFnZXIuX2N1cl9wcm9jZXNzX2lkO1xuICAgIE1vZGVsUHJvY2Vzc01hbmFnZXIuX2N1cl9wcm9jZXNzX2lkICs9IDE7XG4gICAgdGhpcy5fbW9kZWxzID0gW107XG4gICAgaWYgKG0gaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgbS5iaW5kKHRoaXMsIG9uY2hhbmdlX2NvbnN0cnVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChtLmxlbmd0aCAhPSBudWxsKSB7XG4gICAgICBmb3IgKHEgPSAwLCBsZW4gPSBtLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICAgIGkgPSBtW3FdO1xuICAgICAgICBpLmJpbmQodGhpcywgb25jaGFuZ2VfY29uc3RydWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG0gIT0gbnVsbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlByb2Nlc3MgY29uc3RydWN0b3IgZG9lc24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aFwiLCBtKTtcbiAgICB9XG4gIH1cblxuICBQcm9jZXNzLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksIGxlbiwgbSwgcSwgcmVmLCByZXN1bHRzO1xuICAgIHJlZiA9IHRoaXMuX21vZGVscztcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBtID0gcmVmW3FdO1xuICAgICAgaSA9IG0uX3Byb2Nlc3Nlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICByZXN1bHRzLnB1c2gobS5fcHJvY2Vzc2VzLnNwbGljZShpLCAxKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgUHJvY2Vzcy5wcm90b3R5cGUub25jaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuXG4gIHJldHVybiBQcm9jZXNzO1xuXG59KSgpO1xuXG5yb290LmJpbmQgPSBmdW5jdGlvbihtLCBmKSB7XG4gIHZhciBpLCBsZW4sIHEsIHJlc3VsdHM7XG4gIGlmIChtIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICByZXR1cm4gbS5iaW5kKGYpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHEgPSAwLCBsZW4gPSBtLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBpID0gbVtxXTtcbiAgICAgIHJlc3VsdHMucHVzaChpLmJpbmQoZikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufTtcblxucm9vdCA9IHR5cGVvZiBfcm9vdF9vYmogPT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB3aW5kb3c7XG5cbnJvb3QuQmluZFByb2Nlc3MgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICBleHRlbmQoQmluZFByb2Nlc3MsIHN1cGVyQ2xhc3MpO1xuXG4gIGZ1bmN0aW9uIEJpbmRQcm9jZXNzKG1vZGVsLCBvbmNoYW5nZV9jb25zdHJ1Y3Rpb24sIGYxKSB7XG4gICAgdGhpcy5mID0gZjE7XG4gICAgQmluZFByb2Nlc3MuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbW9kZWwsIG9uY2hhbmdlX2NvbnN0cnVjdGlvbik7XG4gIH1cblxuICBCaW5kUHJvY2Vzcy5wcm90b3R5cGUub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mKCk7XG4gIH07XG5cbiAgcmV0dXJuIEJpbmRQcm9jZXNzO1xuXG59KShQcm9jZXNzKTtcblxubmV3X2RvbV9lbGVtZW50ID0gZnVuY3Rpb24ocGFyYW1zLCBub2RlTmFtZSkge1xuICB2YXIgaywgbiwgbmFtZSwgdiwgdmFsO1xuICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuICBpZiAobm9kZU5hbWUgPT0gbnVsbCkge1xuICAgIG5vZGVOYW1lID0gXCJkaXZcIjtcbiAgfVxuICBuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJhbXMubm9kZU5hbWUgfHwgbm9kZU5hbWUpO1xuICBmb3IgKG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgdmFsID0gcGFyYW1zW25hbWVdO1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInBhcmVudE5vZGVcIjpcbiAgICAgICAgdmFsLmFwcGVuZENoaWxkKG4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJub2RlTmFtZVwiOlxuICAgICAgICB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgIGZvciAoayBpbiB2YWwpIHtcbiAgICAgICAgICB2ID0gdmFsW2tdO1xuICAgICAgICAgIG4uc3R5bGVba10gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInR4dFwiOlxuICAgICAgICBuLmlubmVySFRNTCA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuW25hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmFkZF9jbGFzcyA9IGZ1bmN0aW9uKG9iaiwgc3JjKSB7XG4gIHZhciBvbGQsIHBfMTtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYWRkX2NsYXNzKG9iaiwgc3JjLnNwbGl0KFwiIFwiKSk7XG4gIH1cbiAgb2xkID0gKG9iai5jbGFzc05hbWUgfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuICBwXzEgPSBzcmMuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gaW5kZXhPZi5jYWxsKG9sZCwgeCkgPCAwO1xuICB9KTtcbiAgcmV0dXJuIG9iai5jbGFzc05hbWUgPSAob2xkLmNvbmNhdChwXzEpKS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xuICB9KS5qb2luKFwiIFwiKTtcbn07XG5cbnJlbV9jbGFzcyA9IGZ1bmN0aW9uKG9iaiwgc3JjKSB7XG4gIHZhciBvbGQ7XG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlbV9jbGFzcyhvYmosIHNyYy5zcGxpdChcIiBcIikpO1xuICB9XG4gIG9sZCA9IChvYmouY2xhc3NOYW1lIHx8IFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgcmV0dXJuIG9iai5jbGFzc05hbWUgPSAob2xkLmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGluZGV4T2YuY2FsbChzcmMsIHgpIDwgMDtcbiAgfSkpLmpvaW4oXCIgXCIpO1xufTtcblxuZ2V0X2xlZnQgPSBmdW5jdGlvbihsKSB7XG4gIGlmIChsLm9mZnNldFBhcmVudCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGwub2Zmc2V0TGVmdCArIGdldF9sZWZ0KGwub2Zmc2V0UGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbC5vZmZzZXRMZWZ0O1xuICB9XG59O1xuXG5nZXRfdG9wID0gZnVuY3Rpb24obCkge1xuICBpZiAobC5vZmZzZXRQYXJlbnQgIT0gbnVsbCkge1xuICAgIHJldHVybiBsLm9mZnNldFRvcCArIGdldF90b3AobC5vZmZzZXRQYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsLm9mZnNldFRvcDtcbiAgfVxufTtcblxubmV3X2FsZXJ0X21zZyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gbmV3X2FsZXJ0X21zZyhwYXJhbXMxKSB7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXMxICE9IG51bGwgPyBwYXJhbXMxIDoge307XG4gICAgdGhpcy5jcmVhdGVfZm9vdGVyID0gYmluZCh0aGlzLmNyZWF0ZV9mb290ZXIsIHRoaXMpO1xuICAgIHRoaXMucm90YXRhdGluZyA9IHRydWU7XG4gICAgdGhpcy5kZWcgPSA0MDtcbiAgICB0aGlzLmluX3JvdGF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgIG5vZGVOYW1lOiAnZGl2JyxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDM2LCA0MiwgNDgsIDAuMzgpJyxcbiAgICAgICAgekluZGV4OiAxMDAwMDAsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgIH0sXG4gICAgICBvbmNsaWNrOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKGV2dC50YXJnZXQgIT09IHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMub25jbG9zZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5wYXJhbXMub25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICBpZiAodHlwZW9mIGV2dC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV2dC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnBhcmFtcy5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wYXJhbXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuYmFja2dyb3VuZCk7XG4gICAgfVxuICAgIHRoaXMucG9wdXAgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgICAgbm9kZU5hbWU6ICdkaXYnLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgbWFyZ2luVG9wOiAnMzBweCcsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB3aWR0aDogJzgwJScsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNGRkYnLFxuICAgICAgICB6SW5kZXg6IDEwMDAwMSxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnMzBweCdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cCk7XG4gICAgdGhpcy5jcmVhdGVfY29udGVudCgpO1xuICAgIHRoaXMuY3JlYXRlX2Zvb3RlcigpO1xuICB9XG5cbiAgbmV3X2FsZXJ0X21zZy5wcm90b3R5cGUuY3JlYXRlX2hlYWRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaGVhZGVyID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMWEyMjI5XCIsXG4gICAgICAgIGNvbG9yOiAnI2ZmZidcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBvcHVwLmFwcGVuZENoaWxkKHRoaXMuaGVhZGVyKTtcbiAgICB0aGlzLnRpdGxlID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgIG5vZGVOYW1lOiAnc3BhbidcbiAgICB9KTtcbiAgICBpZiAodGhpcy5wYXJhbXMudGl0bGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy50aXRsZS5pbm5lckhUTUwgPSB0aGlzLnBhcmFtcy50aXRsZTtcbiAgICB9XG4gICAgdGhpcy50aXRsZV9jbG9zZSA9IG5ld19kb21fZWxlbWVudCh7XG4gICAgICBub2RlTmFtZTogJ3NwYW4nLFxuICAgICAgaW5uZXJIVE1MOiAneCcsXG4gICAgICBzdHlsZToge1xuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBmbG9hdDogJ3JpZ2h0JyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHJpZ2h0OiAnMTBweCcsXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICB9LFxuICAgICAgb25jbGljazogKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICBpZiAoZXZ0LnRhcmdldCAhPT0gX3RoaXMudGl0bGVfY2xvc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF90aGlzLnBhcmFtcy5vbmNsb3NlICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnBhcmFtcy5vbkNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV2dC5zdG9wUHJvcGFnYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGV2dC5wcmV2ZW50RGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmhlYWRlci5hcHBlbmRDaGlsZCh0aGlzLnRpdGxlKTtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZV9jbG9zZSk7XG4gIH07XG5cbiAgbmV3X2FsZXJ0X21zZy5wcm90b3R5cGUuY3JlYXRlX2NvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgY29sb3I6ICcjMDAwJyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHBhZGRpbmc6ICcxNXB4JyxcbiAgICAgICAgZm9udFNpemU6ICd4eC1sYXJnZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnBvcHVwLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy5pbWcgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgICAgbm9kZU5hbWU6ICdpbWcnLFxuICAgICAgc3JjOiBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaHlBRElBUFlQQVA3Ky90alkyUHo4L1ByNit2ajQrT1RrNVBiMjl2THk4dURnNFBUMDlNakl5T2pvNk9MaTRzYkd4dWJtNXRiVzFwS1NrdXJxNnQ3ZTNyeTh2TkRRME1yS3l0emMzUER3OE5UVTFNREF3TnJhMnU3dTdzTEN3dXpzN003T3pyNit2dExTMG9hR2hwQ1FrTXpNek1URXhMS3lzckN3c0tpb3FKeWNuSmlZbUtDZ29KU1VsS1NrcEtLaW9wYVdscXlzcktxcXFyYTJ0cHFhbXA2ZW5xYW1wcTZ1cnJTMHRMaTR1THE2dW9xS2lveU1qSHg4ZklTRWhJQ0FnSDUrZm9pSWlJNk9qbkp5Y25aMmRuQndjSHA2ZW9LQ2duUjBkR1ptWm5oNGVQLy8vMnhzYkdwcWFnQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0gvQzA1RlZGTkRRVkJGTWk0d0F3RUFBQUFoL3d0WVRWQWdSR0YwWVZoTlVFVS9lRFE1SWk4K0lEd3ZjbVJtT2tSbGMyTnlhWEIwYVc5dVBpQThMM0prWmpwU1JFWStJRHd2ZURwNGJYQnRaWFJoUGlBOGVIQmhZMnRsZENCbGJtUTlJbklpUHo0QUlma0VCUVVBRHdBc0FBQUFBTWdBeUFBQUIvK0FTWUtEaElXR2g0aUppb3VNalk2UGtKR1NrNVNWbHBlWW1acWJuSjJlbjZDaG9xT2twYWFucUttcXE2eXRycSt3c2JLenRMVzJ0N2k1dXJ1OHZiNi93TUhDdzhURnhzZkl5Y3JMek0zT3o5RFIwdFBVMWRiWDJObmEyOXpkM3QvZzRlTGo1T1htNStqcDZ1dnM3ZTd2OFBIeTgvVDE5dmY0K2ZyNy9QMysvd0FEQ2h4SXNLREJnd2dUS3N3Rm9LSERoeEFqU3B4SXNhTEZpeGd4Z3N2SXNlTkRBUmNpUkxnZ3dLUEpqQnRQcXB5WXdFS0Fsd0VzSkZoSkUyTEttalFGdUlUNTBrSkpuRFJ2QWoxNWdTZlBDME5YQ2szYU1ZSlJtQjJZbmx3cUZhUFRwd0VpVlBWSWRhV0JEUnNJTk1XYXRlTUFzR0tIZGpVNW9BQlByUm4vcno2RmE1V25nd0ZBMTVyZGVUUXVXYm9XaXhxMWtEYm9ONXdPc1Bxc2l4VXd4UUY4N2VMVXl6SHlXOFp6TVErZWZMaW1aWmdhQ2xPVWE5U3hSQUlheUZyZzdBMHgyUUFGTHBLK2JORXRXUWVzdStGRS9YcG14ZGt3VFVNODhEcDBibTVBRjd5VzhITWk4SmZDSFFxUThEbzYxODQxQjZRbXUrSDMzNG9iWGx2QWUzemIwUEJrTlRTUCtMenNSTWl2dStmRlhsTUFndGNMUm4rZm1KZ3NncVNVZVVSY2VxSTkxRjUwQ2J3V2dHL3p0WmFVYlZneDROeCtFQW5Bd0d1NEFVamZidHRoZFlCRUIwb2tHRllha0tmV2hqaTFGd0J6N0ZFb0hYVXVOcWdiVS9DUkZSVkVJZUlvM25veUlqZVJBQWRzOEdGSDZKRm9Za001T3NRYi8xbEljVFNBQXdoRXdPTkRheEVBWTB4TlltUWhoam8yQmxGL0VUckpBQWNUbE5uQWtCR3RkU1ZNRERCbzBZQmtHV0NnaXdtK0p1ZEZBblJRUVpsOFR0REFsQUIwMVFHR1IxSUU1bE1TT2pTaVVWa0NjT0Z0R0IwQVFwK1VTaUJSVjJzK3BjR05GUzJKRllNNlBiVllRM1VhYVJGcUgxQks2Wjlwb2doQWg4dWhPU0YzRHhrUW1RVjNObFRrVS9LOTV3QUpxcXFhd1pSZDNhY2dtN2xHRkNwV2pRSUFra2drUWJRb1Q1Yit1TUVJd1FhckFMR3VUcXVnQmdzQUNvQzNBYWpYa1FDd3dpVHJRd2xna0cyMkJYRHJZRVNESHN1VEJoc0FDdUZMR3F3YmFicXhSVFNBQkJtOEcreW9Ocm5ha0FHUDJ2dVNCUDRLQUNZREJYSkVRUC9ERHZBb2NRTUdxK3BCczFRcTNCQkltUjViUU1VQ0dGRG9TUU1rTU9VRkhuUk1LUW5oVmhTZ3N4R2srNjJVVzBrMFFBQXk5L21CQkN1M091K3BoOXFiYU0vU1lSdDBtUmk0YWJQSUVpWFFzTDI5TXMzQTB4TlVrUFZGTjFlNHdXZFlaY2cwQUJRRXpVRzgxeDN0Wk00bW45MVEyZ1ovVU9KVVZDT3Q0TmRiU1dBd0JmNXlGSFpGQnhnN21MaE1FVUNtcWdwd3F0TGdGUWt3OXIxU014MEJwUnd3Z0xqZ2ViOHRnUVVGSkNzM0FCdDR3RUVEeHZWbzN1aXNWd1Y1NjdDRDNYbnN0RnYwZXUwbkNVQkFBcnozN3Z2dnZoTndaRW9HRktDencveWVqTHRERWNDUVF3alFSeS85OU5UbkFBTmNHeGx3UFBMM1Z0eDZCRUJRTC83LytOTHJnTnRHKzNKUFZzQzF3MEQrKytPZklNQkcyNnNQR3U0Q1BBLy8vdEhuTU1CRzlyTVg3Z2pBdndKQzczK0hxVjhBTlRCQS9SbndmZjVEWHdCZnc3N1lDY0I5RDN6ZkNSRFlHazlORUNialdSNzRNamcrSUdRc0pXMVI0TEUwVUlDaXdXNEJ6aU5oLzA1d2wwQ2hTQUE0ektFT2Q2akQ1VWxFQUFNSW9oQ0hTTVFpQ3ZFbnQvTmg3WktveE5neHNZbXRlNkt5SW1BQkRiUXBkZ3l6Z0FSNHBqcHQ0RVJ5c09wWDZ3NFF4bnlWeDRzMFNVREpZcks1b1N6TEtBZ0lYRWVrU0lEMEdZVnZWZG5WVTVUM3VObE5VWVVWN0prZGphS0JDTGpRZG41OHlPVHNaVGFtRFZKVVpweGpJZ0dRQU1QWkMyUjU1TjRWT2VlMnh5VHQvMWhMazl2VkdPbTlTM1ZPQUhCRFhpRmhoMG9WM291TFUrdWt0TWlHb1lxMTdKQk9Nc0NVNnFnK0MwU0xJbnBobVByaXFLeUpsZklpd254Skl4MmlSdlV4UUhRaGt5VUFWS1NZU0VKa2xHTDB5QVhTdGN5UmJjQ1ZQSEZjTkdjRUVUMSthd0V1SkplNU9JSXVadjFvQWVCOENTYUxoYnhuVXVTTlJsblhzMGJDSTNLdENIRVhxNmNwWmVsS0NXQnlUclJ5aUsxNFFoaEZWaWN3YXlUa1FNbjVrSWp5cXdOdDFJNmRwUE1aaEpWS1U4ZDBTQWNVK0IralVWU2t0Y1RJSjluMEVIODJhcFNTdWNpVDRqTlJIMFdrWkp1OHlFZWZrcXdrVVZKQmxadElNcWtGcUNwZHlaY2RzYVJSbHVsVEFLejBKWnJqeUFYNElvRlNVaVpJQi85b1l6bUxVNkNtYWpTaFVoVVM0cVQ0STFvR1FKelRqQkVBNnFVWVhPSk5taXRSRVl1NmxKbWJQcFFwWkkySUJ4a0ZJclVDQUU0Z3hlc2tML0xJQUlRU29YV05DRXhoMGszRHdOVWtPNzBYTkpIa1Z3QVlRRUZ5Zk90SlZ6SWQvT2pIU3hOUmpuKzBpcExCVXNTY0lEeGtVejlTUHp4cTFxWTVhYTEzUURzUjFQYkVyYVY5TEVkRWl4VUViRzYxSDdHb2RTU3BXNHpzbFNlWnBTeHRKd0pZUW9ZMHQ1czF5Vk5oSTV2S1BxU3dqVzFiZEQxQ3k5VE5OckVVT1c1UHpwZ05uTkJ5dU15ekxtSTNVNU84T2xVeHBBV3Vzc2lXWGVKdWR5OVBPV2lMbGdzZVVlRldkc1hGeUV3dnloSDU5cFd4L3dYd2ZVMUNBTEFrV0xuZ3ZVaDhnOE9pb1FDZnpjQlJOSzFVTU13Njk5YkVwVTMwY0U0NlN0cXppVGlOdDVvczdVNU1rN05BcThSeVc0aU1aMHpqR3R2NHhqak9zWTUzek9NZSsvakhRQTZ5a0lkTTVDSWIrY2hJVHJLU2w4emtKanY1eVZDT3NwU25UT1VxVy9uS1dNNnlscmZNNVM1NytjdGdEck9ZeDB6bU1wdjV6R2hPYzBBQ0FRQWgrUVFGQlFBTkFDdzhBRElBWEFCbEFBQUgvNEFOZ29PRWhZYUhpSVlTaVl5TmpvK1FrWktUbEpXV2w1aVptcHVjblo2Zm9LR2lvNlNSQmFXRWk2aVJxcVVMaDYycnNyT1hzYUsydEltNHVieTl2ci9Bd2NMRHhNV2NyOGJKeXN2TXpjNnJ1OC9TbXdJSEd3Y0EwNW9DR3hJQjN4SUUycFlBQ1F6ZjZBSFJoY2pGN1l3RUR1bnpHOFRybEFJUkd2UHpFdG04OXk0SnVPQ04zendOL3lDZFloUndWTGx6QnZreFNEak8wSUFGRVNOZW9GaFJFRGNMR2ZscGlNQVIxRUpMSjk4SkFuQ2dZTWgwQmNSMUpFU2d3TXQrMkdZT3lyZnY1amNORzBwV0JBRFJaNEFGQTNRVzJtQTBBSU1FbVJvMk9Ebks1azBMRzVVZXNwcHhwSUJQVkhzeHplZ2dxZFpFQWx5bVF3RDFiS01EUGYrL1dRaWFTK29uQXdVc1NJaGcxcTNmdjRBRE54aEFvTERodzRnUEQvZzZjME1HR0RRaVM1NU11VEtNRFBYR2JYaFJ1YlBueVM4NmpNdnd1YlRuRCtNZ20xNHRHUWJqWndOWXk0NnNiY0NKMmF0aGpNWnRPc1ByWjV0NWV3NWQwZkZ0NFpFdmk1NzVHNS9nNTlBckxncUxTa09LSFR4S2JHZ2VIVVNRSWVDSEVQbHd3SmZkVEJkMmhGLy9BNFJNNkRqV3l4OGlnMEZmd0FKa3pKY3ZwTWIyVFZKUjkwbCsrODIzQXdkdC9jVkJnZnZwOE1CN3BrZ2lJQ2dFUU1EZ2ZqTVVjSjlTQ1pnZ3hJWDgyZkFmUXhMeUlrQUIrb0c0WGc4S0pGaktoQW94TWdBSUlhaTRIZ1FTY0xjSmpKa0lTRUFHUk5nSVhoQTI2TmdSTnpCOEo2U0lBcFB3Mk1CNUF6S3dncEE2R0ZsS0xGREM0d0VQS2hLeElUU0tkSklBRGg4eW1NT1g3TVJJVEQ0dEtEbmZCTkVKTW9BRUlzd1hBb1NwZEtKU0pIdFdRb0FDUFlRWGdwT0JKZURCQnhRa1lPVWtXZm95d0dKeFJ1b01vV3B1SmVtbG1HYXE2YWFaVXNycEw0MVNFdXFWcVBRNTZqRmdGbk1xSlo1KzZ1cXJzTWJxeUtwbjBScEtJQUFoK1FRRkJRQVhBQ3cvQURnQVdRQlpBQUFILzRBWGdvT0VoWWFIaUltS2h3NkxqbytRa1pLVGxJaU5sWmlabXB1Y25aNmZvS0dpbzZTbHBxZW9xYXFycksydW1KZXZzck8wdGJhM3VMbTZ1N3k5dnI2eHVNRy94TVdyRE1iSm5NUEt6WWpJbWRBWHpKWFN6dGZZemRUWnR0dWczdHk2NE9IazVlYWQxdWZxNit5L0FBSUQ4Zkx6OVBNQ0FNNEpEd29OL2Y3L0FBTldDSkFnV1lJS0FSTXEvRmZoZ0xFSEN5TXFmSURQSFQrSkdQMVZLQ1lnbzhkK0FvZ0p1UGd4WW9XUTdpQ1dqUGpBMk1HVkNodFdKS2FQSk13S0R3NmdOSVpQZ00rZlFJTUtEVG16bmRHanRkS2hLbEFqeFF3U0RwRmVzQUJCaEZVUktVWVlPSHBBeHRXdkxDd01hRmZocTFrUkpSYnNMQWZBeEZteks3ZzRSRDAxamhPQUVtL1B5cUJBd0J5RnZHOXBJQmdMcVM0aHBhTUd3QUQ4TmthRXRkY01jRmpCMkt5TEJnZUtaakljQ2tBRXZKVy96bmpRMXhUaVNLY0ZDWkRRSXZSWEdKeFJrOW8ySW9YcnF3MDBPd053WUVMVjJ5MGZwZTcyNHZhSmN3TUN6QWlkQW5JNEFncHNBMmJoWEJEbjJLZ0FiSWp4Kyt3SW93SUtuRGpid2hSMlF1Y1JEWGlBNHFxS0NGSUZFUWd3UWtQcCtLcXI0OStmYXJpazFPbnhKK0NBQkJabzREY0hKb2hmZ0hRcE9BcUR2d1FDQUNINUJBVUZBQkVBTERjQU1nQmhBR1lBQUFmL2dCR0NnNFNGaG9lSWhRYUZGb3VKajVDUmtwT1VsWmFYbUptYW01eWRsaDJlb2FLaW9LT21wNGlscUt1R3FwcXVsUVdza0JhbnNKVzFzNVM1cjdxK25yZTR2NFM4bzhHN3c3ckh5Y3lKeTgzUWhNL1JuTk9wajliUjJaWGJoaGZVcU4zZ3ZzZU80OG5pNTZ6cDZ1R2Y3WVBGdllYc29lemZuZlh3Z2dqNWxQMlVMc2lyaE1BY3BBU1VqdW1EQkZCZHczK3pGbTR5ZUdqZ0pvblZrR0hDNkVuV0k0dk9SbEY4OUhDZnlaT1QwbkVzaFBDUngwd3ZROFZFK1dqa3NKWDdjTkpNVnZJUnZsay9KZG5NSkZEU1RGUkhkNTdUaVNqcElLYlgxTFVFQjFMcHNLRFJxczV5YXJXcjE2OWd3Mm9DSUtDczJiTm96d0lRbTRoQUFRMEIvK0xLblV1M3JvWUNCTmdTSWdDM3J0Ky9jalhrMVJ1aEFPRERmN2wyN1l1NGNWd05hOWtDY0V3NWJtU3hBQmhYQmd5WnNPSE5od3RjRnNzWDlGOExnd203MVF6NkxvSFJoQUhJbmsyN3R1M1poSFByM3Qyc1ZvR2hxem9vaUlIamdRSFl2Q1U1S0dHaXVZa1lHZ2EwMHlxS1FBem4yRDg0YUFmMVVBRHM0RTBvd0pyOGtJTHc0RXRnT0c2cWFDVEZvU3FnRDMvRGduUlB3S2xabUk4K3d3SUJuTUJYaUlDZUNNQUJmK2hWUUY1S1NnMkFBWE1JWW1lRGNaWlFOeUFpK1UwaVFBY0lIT0ROZVJGaWh3TUM5ekZreVZSTlpTSUFBaWpzNENJTUl6a3dRWWpZY2RBQmNxY1FDSWtBRlBqZzRvOHRsRGpJQUJwY1IyTnpEeUN5SVA4NEYvVHc0NU1lQUdpSUFTQkFTQ01EbThCbklUMkhqUERra3prc0NjQUZEUnlaQVk3QUpJSlZNZkp3OE9XVE9FaDVpQUFGNEJCaURPb014T2FiUC9hdzNTTURCR0FEZ2grc29xTWtBN2pBcDRzbnBKYUlBUjVZQ1o0R2xXUTRpS1ZQUlNXSUJJdTZTS2trSFJ3STNnUkNKckpsSmdvUklnQU1uYnFBYVFRcjJ0bmNCRXNPZ2hDS2t0UjZTS3JTT0xtb0FuSkdNc0JiQlF5QUppZW5Dc0xySUFKODBHa0lHMkJ5TERQTFhxcERwekdVR2xhMWc0RFFxUStIVXVNVXQ0SU0wT0tpTFRpNnJhYUZNTkRwRGhnUVJxNGdBcGpRS1FTNFVvc3F1NFZjd0VPbkhBUUx6elB6MHV2bW9pRjBwd3kvaFJBZ1FxY21DSHhPdmx6dUNzbHFBKytHMjlGRkRCY2lRQXVkbmlDeFVnVVQ0b0NQZk9iUUc4Y1c3MmpEb2ptTXZES29IWHNUQXA4MXlNeEtzcTNVYkVnRmIrYXdnYzZzYUp4cHk4TGk4Q1FOSFJEdGk2NUlWNHhvQVNTUVVLeGVKYzg1Z05NaysxemUxNmJ3RExZaVlvOU55QVVkS0p4SklBQWgrUVFGQlFBTUFDdzZBRElBV0FCbUFBQUgvNEFNZ29PRWhZYUhpSUlKaG91SmpvK1FrWktUbEpXV2w1aVptcHVTRVp5Zm9KbWVvYVNsZ3FPbXBxaWlxYTJjcTY2V0M2bXdzYmFSdGJlNmlMbTd2b085djc3QndyckV4YmJIeUs3S3k3U0pzODdQaDQzU3F0YS96ZGlnMnNEYm1MWGQzNVBpNCtEVzFZOEg1THpZMGVQdjVvVHB0K1dYOXZLeCtJbjArYUh4L3BidFc2Y0xZRUJPL1VydE84andYOE5RQ1I5S1JMWndZaXVDRmpOcTNNaXhvOGVQSUVPS0hFbXlwTW1US0ZPcVhNbXlwVXVMRVM5YXdCREF3UUNWRjBEbzFJa2hnb0NUQXg3c0hCcmd3aytTQzRZcUJTRWhBWUNSRXBZdUxYQXpaRlNwU2gvNHJCUlRJRmFwQVE0ODdRaEF3MWVwQ0F5TWJSZFFRSUd6Uy84eExLamFxdXVrQXd2NkdiZ0tkK2VERGtjeFlWUmxRNFlNRkIvb0NnSndJVURmb1Jyc0ZpdUx3ckRsRzRFSEFZaUE0ZkZPQitZU3FMQk1Xc05hUWdQZWVnYlJ3WmVBQ3hsZXZPQXdtRUVBMHFSUHhFeGd3WE9BVjVFRUJBaHlwUGdSSXhZSWdjQk51b0lqeG83aFlqanQ2Z0p4NDhXTlZDdkEzTEtLMW80RUxPajhOUUIxUVFZM2NjQ09uY1FnQVNhNkcwNE1hUUNDcjdra0s1cFVnNzN4R29Rc0lKOWhCVVFDUUFKbUtXVmVLd0M5NEY5eEx4VHl3WUExRUNBSkFCc0lwVk1BQmdpeVRtMmxPUGhnaElRY01NT0FHRkR5V2dSRy9TS2lmeVJxTnNLQUxJRDRDQURuMmZJaWV6RU9Rc0FKQXlxUW1UODdZdGZqSUJZTU9FTzZSYm9VYWR5Umd4UW0zdzJLNWVNa2hMeFVKcDhFREYxNUJKU0RaRERnQ3gwRzVDV1lIcll3SUFnSG5aa0lBTXZKMThJRlpqNzRwU01EdkRBZ0I4dllTSWliamlBd0lBcE10Z0tvSXpjTStFR08xaHlhU0FkYU1rY0RrWGFpV1VnRDhwM0E2Q2JwVGVJb1B5eDBsd0dsSTBweUcyNDBpR1ZscFpJSW9FQ2tFNmk2YXFtdGNnYkNWblhTT3NtUXBQb0hvRWtaMk9tZVNSY1k0WjhSZm40VWxMSEdHYUVCU2dJWTBNRUhzbVZnRkk3WVpxdnR0dHgyeTIwZ0FDSDVCQVVGQUNJQUxEY0FNZ0JhQUdZQUFBZi9nQ0tDZzRTRmhvZUloUWFHaTRtT2o1Q1JrcE9VbFphWG1KbWFtNXlkbnArZ29hS2pwS1dtcDZpcG1BNnFyYTZ2c0xHeXM3UzF0cmVoRzZLNnRieTJ2cmlkck1Hb2pjVEh5SlVIeWN6TnY1YkFxc3ZPdE5HUHhvOEoxSlREcU5PUTNabldvdGpieE9PRTM3WHFrT3lTNVkvdW1QS3A0ZWFhNktUYTlhWDBzL0QzcWdYa1pDOFhxbnlIQUVaQ3lNemZRR1FNTzBVVXRlK2h4VWNUTDJyY3lMR2p4NDhnUTRvY1NiS2t5Wk1vVTZwY3liSWxLWVV2QzFpUUVFRkF5Z01hQXVnTW9DSGpSUUVXZGdwRmNBREFLNS9paENvTlVJREF5QUpMbFdxSXdBbnBLYWhSbFZxd09naW1yQTFab3lLb3lKRkIyS2hOUFViSWVWYm9WSnVuLzd4S0FtQmd3d0JEQkxDMjNXbmhRaWV5b0FCYzhEQ2hNQWE0aEJKSTJDdVVnZHhaRGdwTG5rRGhrSUFOYkJrSDZDQ0NxeWtDSHlaTExpaEl3SUxNZXgyU091RGh3d2NLNVFxSWxrekNLU0lDWmhramtLVGFrUzhBRENDRUdCNENRZ0ZDQ0daTHRtQTAwWUhGYlRXNFNpQ2MrSEFJdGpzckwveEJOWUFPcUpmdVRrUmFFd1hyMWtFUXFyQjl3dUZJRHNMbWV5eUl2cUFNNklsbklMU2gvUVRPa1JpQXdGSVNJRGFLUFIva045d0hoQUNBUVhzVjNNVmJVRHBKa0owSTJnQUdDVklKS2ppQklxRnRWMEJ6a1FCd3dBYTlqZEpoZmg4V0lrRjdIRnpveklyb3RVaklBQ1MwSjkweDh0Qm9uWTJFTE9CZmlyYjRTQnlRZ3doQTJLMTJGQmpJakpIRElUbklBZjVSUlEyVUlVZ3BDQUFQdEtlQWpLVjRKZ0tXV2dwQ1FBYnRJVURpVjQ2UTZVaHkyM0Znbnl4dUppSkFBKzBGc09ZckdoWlNaeUlSRE5uTW40Z0FRRUY3R0F5cVlKYnR3S2lvaDVBQUVNQjJKSmhTbmlTRUprSUFCOG85c0tjM21DNWFwaUd5aVNibm95eE9vc0ZrSU13cFVTV1p4c01BQW41ZEtTb2xSbjJhREpZTWx1VEJvcFdWZEVCMTFrSGc2a01TRUZ2Y2NTY1JjTUVJaFhuUTV5bUJBQUFoK1FRRkJRQU5BQ3hHQUhZQU9nQWlBQUFILzRBTmdvT0VoQUliQVFzRUFJeU5qbytRakFNR0FvV1dsNWdITTBPY0t3eVJvSThHQlFHbERnQ1lxWllETHB5dVJoU2hvUWNhcGJZRnFLcTZDcTY5U0FteWtBSzF0cllIdXFvSlBiMjlJNklhRkJRV0E0OEh4Y1VTQXNHZ0FpWE12UnlPRVRVMDVUUTFIWTZJMTdZUjI1RUxSdCt1Rm8wRTVPYmxOZFNNQnV5MkdoYTlhelJBeFR4T0l2Z0JzSkF2bndSSERQNlpHdGdvd01FaFFUUTRBdEhRSEFoSC9pUUdBRFp3UUk2TExBUXlvdEN4WEN4SERrUWkwUGFPdzBVa3B4eXhiUG1TSUxGL0c5NWQySEh4aHNLVkxXbjBiTlJCNUxSZ0FtcGM1SEVCMHM2T1N4dEpFT2xPVmdGNUJ6M1ExSmswS3lOckVnT0dHaURqb2dzRGtleXVOalRMaUpSRVhLQkFYQXp5TUc1WlVDRWxrbnhFNE1mRkV5b2Z5YzFIbDlFQ21XTVpDZmh3Y1VkWHZ6eEREUk1aVkIyUml4OGlLLzRiYXQyL3A1SlBYUHh4UU5aaWN4UjBiWlY0R1VHUWl4OWRrdzZWUUtSYUFTZ3V5a2lNR2VzMnUvOU9FU0E2endpQ2JhOWRiaVB3ODFvOUFqNE83b08rVzFZRWlSWUVFR0F4ejBkVjdwbTNDYkNRSE1DQUJkbVpLUkFOS3JyU2dhWnRvUmF3SURpbklEZlFWMTkzd1h4bml3Tkh1WWNBQnh4YzlvNTlqWUZDd0FZYkVPZUlBQUxxbGg1RkhGSUVZWWNndnFOQlV2V0VhQ0pnK09SVGc0VW5uaWlBQXltZTQyQ0xOTHJYV3pRYXdGVmpJQUFoK1FRRkJRQVZBQ3czQURJQVlBQm1BQUFILzRBVmdvT0VoWWFIaUltQ0VvcU5qbytRa1pLVGxKV1dsNWlabXB1Y25aNmZvS0dpbzZTbHBwZU1wNUNwcW9tc3JiQ3hsYSttdExLSHRyZTZ1N3k5amdpK3ZoMmd3OEdFeGNiSnlzdk16YzdQME5HaXVkS0p5TlhZdnRTZUI5bkEyYUxYZ3QrNzI2SGs1WmJpc2d5TjV1RHc4Wi9yclFqZGl1MlgrWjM3OHY3RzlQNEpGUGh1b01Ga0FUMGxiSFV2M2NHSEZRcUc2Z2V4b3NXTEdETnEzTWl4bzhlUElQbUZIT21JSXNtVEtGUFdxbURTVk11VUM4L2hVaWtvNWlhYk5FZEpUTFl6NTZlWFB1UDFUSFFBUVljQnhvWkthamdvZ1EwUlVGOHMwUGRybVlBWFVMT3UwQUR5UWRhdkxndzhCRnFCQUlxdlh3TVVHdUFBQVlJSUF2OE9BbWlBOWlzRlFnZEdOTmpiWUFSVGZ4dFcxTTFhWU5BQXZYejNqb2o3VDhEVHdTSk9NSzZ3SUhIaUNLMXdUa0lBV1FTRWZnd3M4eVhyQ1YwaGNrcFpkTDZCZEJBQzBYdE5lMklsdTFDM3Y0NG9kSFloN2pYczJncEZKVGdMV2NIa2NiQWJBSmZHb2JNSzNMNUZMNGNXUVREa0FBQU1SYmM4M1prQUU1MXJFRGkwUFRGdzByd2tkSVpRbUh6eTdvaHd3MnJSZVVKcjdlL0JBZkRRT2NXR1JPWHhCWjh5QjZUUTJRaUtCQmdiT0JOMDFvSllBT2FYWURJT1FORFpPd29xMTRoOHVqdzJXQW4zSVpMaGdNRU1ZT0JnSzB6VnlJaVlLSVhKQU1UVnhjRnhJa3BvaVl1V0FEREFEWU9od09GcE5rWWpRQWN4WnZWQWRyOEVPUWxGanBsczRDRUVDaUNaNUcvd0NPQUFCUlQ4RndtTDhRQWdKU1JjZGhRbVI1WEJocGxIaDRtMjJFY0FYSUNZWWo5aUpBQUJiU0hnd0FCZTVxbm5ubnoyNmVlZmVnWUNBQ0g1QkFVRkFBc0FMRFVBTWdCaUFHWUFBQWYvZ0F1Q2c0U0Zob2VJaVlRV2lvMk9qNUNSa3BPVWxaYVhtSm1hbTRZZG5KK2dtNTZocEtXZHBxaUhvNWlycWFHTW9hMlRzSzZRdEpheXRicVZ1WkszdTcrY3ZaSEJ1NlREeHNtS3lNcWNFcmpOMFk3TTB0SFVpUmZWcGRmYXh0emR1dC9ncnIzWjQ5NlQ0c0NpcCtlUDVwbnE4TzdDcGhmRnBRbVJ3K3FZei9TRjVrbjdWdzBmTkVVRXR4R3pwNnRBSTN3Q0JRMkx1SXRpSllzQU0xb0xKVUdmSW9lWFFINFM2UWlqUm5JblU2cVVacEpUeTFUM1ZocDZLVE5lelp1T1BCYkVxWXltSzRPcFNQSWNTclNvMGFOSWt5cGR5clNwMDZkUUcwYWRHcFNxMWF0S0JXZ1ZnQlZiaVJ3OFpsamdha3hvTkFJa2VPeFl1OE1IQnJKWS93VThFTUcyN2crZFZBVTRhRkczN3c0U1Z3L1k4T0czYnd1cUF4VDhLT3lYeFRrTFBoOEowTENDY2VFS3RTSnZFaENCaHVYQ0tKNG11TkhqYzE4Zk1RaWs3RGRneEdMVGRWc1VnTHNBZ0lFSUIyaHJBMHBJQUlJVXNPdUtlS0NhRUlFS0pwS1QwRnpJcktHRW1nakVDTTZXQndtOGd4b2szMTdDZVNQbW13WTBvTDdXUkFmZGdoQnNYeDlqd0Nid2lDSUtJRUEzK0F3RTdnOE51TEYrdlZBQkYwVFFRVVR3UlZlYWFVQ0FZSUFpRC9TM1hrSUdXQkRBaEFGWVVOdzAzMTB5QUJDZkZmRkJib29rWUlPRDI2MGlnSVFVVHNpYkxnSjhZQmtNRWFCbnlBZ2tKc2NCSVJla21HS0JvQkRBWVY4cFdQaElCRFdhVUVJckhlaElZZjgvbDBCWGlBTS83cEREQ0F0SzlrR1JJOUNXcEpJQk1BbEpUSUk0YWNnQUR6UkFuQ1FTRkJuREFZVnNxYVE4ay9BSUNRSDgxUmhBSjF4MmVSUUFHQlNKdzRXRHVLbWpsK2RjVUVLUnpnbWFJcUhqS0ZCa0EvbTFtZWN3M3JualFKRkhJcUxva3BWZzE4d0FWOVpJZ1l3TGJEb2hvOXBvb0thbmdVNUtsQUV4RktrQkFJbVlxaWRQQUZCUTVBZUE0c2tsTldKcVkyaVJEalJpS3pXc1ZnTUFjalVxTUkyck9Ba1FLNGtsdkhRc0ppdVNVcWVER0R4eTdTWFpnaUlBalE3ZTBLdW0wT0kwbW9NSVFQSnRTWWFFR3dvQUNUQnI1SjN1cG91aE8vZDBKTW03WFFHTWxjQlg1Y2lsbkVTZHFLUzhUVVdZb2dWVmRqVUlBQU5jME1FUWdBSUFvUEhHSEhmczhjY2doN3h4SUFBaCtRUUZCUUFVQUN3d0FEVUFad0JqQUFBSC80QVVnb09FaFlhSGlJbUNFWXFOam8rUWtaS1RnNHlVbDVpVUJwbUVscE9ibktHTm5wbWtvcWVvb2FhcHJLMlBxNjZ4c3BXenRiYXdoYUMydTVLNHZLZTZyTDYvdFFpWXc4VEpyOHJNbDhqTjBKM1J4TUhMMDllSXo5aVExWnphMjhuZnRPQ3pxK0xrcmFiZDZML243SWdIa2JqdW1jYnZ2T3VUOXZmT2pmdTc5UGhOQ3lpd29FRitCQ0VoaU5jb255T0huQ0N5a2hpTG9xdUVCeU5tM01peG84ZU5HRFY5L01Wd3BNbVRLRk9xWE1teWxZQUJCQXpJbkVtenBrMERCQVlJWUNuQWdBWWdTNDRJSFVxMHFORWxJdjZoSEtCQmlkR25VSWtxWWFBU0o1Q29XS0ZDR0ZBMWFOYXZRNVZZTkdnQXJGbWhZd3NTOEhvV3E1S2RLZjhIaUdpYkZjSktBUWljMG4wNnhFRlZRUVVnNk4xN1JBa0V2eW1yRFRCdzRJTGp4NUFqWHpod3dBRGNscGd6YTZZQVFGRG56WlFTTktEUndrYUJ6NkFkRFFEUlFvWnJHU2dRb0U2TkNBR00xN2hacEczWjRRYnUzekpBWU5zZHlrQ0RHY0IvMzZCTlNNQURGc21CNDJBT3VFYjA1QUZvQTdndzRYcHlHN1FKakVEdUhmY01CVndSaGdwQW83enlWUU1PRUpnOWNrRUo5N2hmSUVnL0NDK0kveFlRcDg4c0ExU0FBbjZ1dFFCQ053Qlk4TitESUZ6d2tRQVlJQWdiQnhJZTBnR0VEMkp3V1VZQURQQUNnallnZG9oekhENllvU0VoRVNLZ0lnT1E1eDBNRmhDZ2lBTXBQdGhCUTVDMEdNbHQxNm5nUVFMMDVZSkJqdjhsNEJId0FCNUVoOElIR3pnQ0FBSklncUJCa1FjTkFDUnVKaFRBbnlJSFZBbENTUlRNODR0U2luU3c1UWtCMlBnSUFBRlVLWnMwaC9qb0NKcDNZckJmTDFWaVVJMlpQRDFRNVFMMEFicFNBVlVHOE9FaTJiQmtnSmdyMHNtaVNPd0FJRUdWRml6S2FKMHJYU0Nta3B5R09nbVoyTUJaNVdtTmlucFNCSDI2cWFxa0pnMXdKSkxER0dvU29rZ0c4T1drcnhxQ0p6bVBWaGxwcjVzbVFtb3UxMUNKSkFLYUZtTHJrclBtU05Hemg3eklDNG81b2pwS3FpTk5tZU1EdTNMcjdFa0FHQ0FvaDFGYXcrdEpCQ2o3M3dMeWlMdnRQZVZHMElHcjZvNGJDU2pXc2tNdGRlT3NDL0RBQkJjc1VBUjJpaElJQUNINUJBVUZBQThBTERBQU1nQm5BR1lBQUFmL2dBK0NnNFNGaG9lSWlZTUpob3lLajVDUmtwT1VsWmFYbUptYW01eWRucCtnb2FLanBJVUVwWkNucUt1bERxeXZzTEd5czdTMXRyV3F0N3E3bUxtOHY1RVN3TU9DRzZMR3hJakl2TXZKenM4UHZwcU8wTlhKMHFJSDF0dmMzWlhOa3VDZTJJVGEyd3l5NkpQaW1nelUzb2JxaE1LODhvcm1ndmFYNUlQc2h2U2wzdkVDQ0UrUnYwSDRZdW1ibEJCU1Ewa0NGUzA4OUJCVHhZSVlFeDJzUlJBUkEzNnBKcllEZWM4U1NVNFJvMlZNdHBIU3laV2ZSQjVxMllrbW9aU2ViRDV3dFlxblE1aEFDUkh3T1pPVnpxQklyUjFOS3BHcDA2ZFFad0VRTUtDcTFhdFlzMW9WQU1BcGdBRUZUdVFJUWJhczJiTm9jNXdnV290dEpnRUYvM1NnblV2WHJJNElTUWtNT0ZHM0w5MFRBdHFDR2pEV3IrR3lPVjV5RzNDNE1ka0JTUWs3TnF5RHFRQytrL3ZDU01vQXdBSWdtZWtDNlpCWFVBUVloVU9IMEFHRGROQ1BoZ2drbUUyN3RtM2FCaFJIM2MyN0lJQ3V2VTBHSUpIQnc5Sk9NbTBKUUpCaGduUG5lRzBkRHdVZ1FvUG4yRGxBRG40SXdBRUsyTU5QUUdEMGtlNU9CQUo4RUIrZUF2ZENERGl3Rnc5aTJIUkpBRHBVbU0rK1FIbEp5V0dTQUFqOHNlZkJNMjVoTW9BRzZ4VVluZ2FCOFNhQUF5UTQyTjRCd04yMEhWQUFiTENmaGM4cEVFR0VoRGdRd0ltd1lSTGdBeDJCSW9BR0lENlhBUUxrTUhEaWpScGNWRkloQ2FMQ1FJek9CV0JBaG9SY2NPT1JHbmlpWS84bFN3b2l3SFVnR2tlaUlSWWNlYVNPRHpXSnlIa3JDdEJnZ1NRNE1LVWhFVmg1WkV2blBhS2xKRThXK0lFRUp5MW81bzBHVUlMVExCTHdoMEVDUkNKaTRwd0JyUGpBbWpsSkFpVjJJMnd3SmlJSkFIcGluWlhjV2NsQ0xTWnl3S0ZoTHBvSUFvNzIyQTRsQ1ZXcWlBQVJNREFpSlJzNHFrR2E2ekI1WHlaVkF1cmFlMlE2S3VwN0JHamdLS0dac0FwTEFZNTJobHdpbnQ3U0tLQWFRRW9ySVFKSTRPZ0N5eHFTS3FBV2JCanRBeTg2K2lwU0N6aUtnS2FjM1BwTHJydmlzc3VmY3hiUVo3U3htcmtxS3I3Q0FrQzdWa1ozYllseldnRHVzZ1BRZXlLdm0yeTd5Z0RvYWpEcnZZY1FzTUVHMXNLaVNyd0lSeHd4d0JKSExHa0Z4Y1VRRXdnQUlma0VCUVVBRFFBc01BQXlBR2NBWlFBQUIvK0FEWUtEaElXR2g0aUppUktLalk2UGtKR1NrNVNWbHBlWW1acWJuSjJlbjZDaG9xT2twYWFWQmFlUGpLcXJyWWtMaDZ5dnRMV2FzN1lOdUxtR3U3eS93TUhDdzhURnhzZkl3ckhKek0zT3o1RVgwTk9kQWdNRGxMN1VqUUlISGpnZUNjN1NwZ3c4UStnK0NnVGJpdHFPQ2VmbzgwQVcyTzJjT1BQN1EwRXRFUUpNa1hPMHJOU0FFUHo0Q2JraGJ0UTdYZ09FSkV6SXd3TzdUUTh6RGN3a1FNZkVpU3NZQkVUMGJxTWprN2tVZkp3WTVNU0drWVZRcWlwWUxVYVFsUW1KZkxpSUw1SUFDUkJ3SnZ3QjRoNmlWSmVRTnFDWnRGSUNCVVdFOHBOUkFHWlBSd0kyMkpBb0ZaMlJHZzJ2UGhwUVFFWFhlUkI0RW1PcWlVQUFqMmYvT1lpZGxJQ0RqNjRvcklaUzJraW1wNncxakFqTk81ZlNBQVl5Y0U0b2JJa0FpQjhUZlJ3NGxaSFhnUXc3OWhuQndKampoaEloZk1pb0RJcHY1OU9vVTdmU080azE0d2dmVHRDWVRidTI3ZHNuTW13QVpocFRCQmkzZ3d1dkRXTTNZd0VmaGlzWG5pRlg3MHl5bDB1bkRjUG8zT25ZWjNjV0VEMjdjaGdBT21md3ZseHU0VlFiZ0pNUC9zSnZ6d3NjMUsrbkFZT0QrMm05clJIWXo3Ky8vLzREaEtmYWdBUVdhS0JQRVVpZ1FRRmhxZkljTUJ0b0VNQ0VBV2d3MllHS0pDQUJoUnhLNEJxR0JCVEE0WWdCR0lmaElBSkVJQ0dKSEQ0NElBQWJiTWppaUM3U1Fob21DU0F3STR2M2RVYldqaXpXeUl1UUNLNElKSVVhUkNEZ3hJc1h5SGdraFFXb2xjeU5oeGpBd0pNY0luREFrb2NRcVlpWG93QVFBWllVV3ZCU2w1dWdCQ1luTUpKWjRRTFd0ZEpqTkk0QW9DT1dCUmpBWlNGVUVvTFNuS1lBWU9TT0VseXc1eVc0OUhrU20wNnlxRUVISDFiaWk2S3FkTERqQWxJZXBaRXhBRFE2SVFNSkhIcmlJQVE0V2Fpb2xMQUZpYXFWTkhrSkFBZHNjR0ZxZ0hwQzZhaTRjbEpycm1zMjRtS3Z1UVlyN0xERUZtdHNKc0FlKzh1dG56QmJpck9kcUFydEpxeSs0c3V1b0V6clNiTEtkdXZ0dDZkZ082QzJCWkw3U1NBQUlma0VCUVVBR2dBc01BQTRBR2NBV1FBQUIvK0FHb0tEaElXR2g0aUppb3VMRG95UGtKR1NrNVNWbG9pT2w1cWJuSjJlbjZDaG9xT2twYWFucUttcXE2eXRycSt3c2F1WnNyVzJ0N2k1dXJ1OGhnSUN2YkVKQVNNQkJNR3RFU29pekNnWUE4aXBCTXZNMVNjRndOR2xGZFhkSWhBeEZ3QzV0S1lDTGQ3ZUxnckgycUFDTHVucE13SFE3cDQwOHZJdjVmZVhEL3JrUVpod1lCdzVVUUFhQkpTWFlvUy9UUTVlTEV6WHdrSTJSQXcwWlJUVXo5TEdTUVFlekpqb3pVUUVndzhuQVRqUUlCNUpaaXN5dEVzNVNVQ0VHQytyd2JDbnErT21BUWp5NWFSQTh4SUJDakplbGtCSnlpZXNBeGxXVEZ4YVZKT0FCU1VXT3F6NjB3SUxlU2dTY08xa1lFVFNhaXNralBXMGtvUUtHU1hTbkpiNnVMYXUzYnU1eHYzYXk3ZXYzMThhbU5vVmNPQ0JnZ2FJRXl0ZXpGakJnd08xNUtvOFVJR3g1Y3VLSzRpOSt3Q3o1OHNQQkt1U1RFbkE0YytvRTFlNE9GWkE2dGVJV1k4OURkdHpoYnNBT3RmMkhNQnV4Z1NWZDF1dVlBQ3ZobUcwaFZjSVVId3RYVUVBQkF5WVRyMjZkZXFBald2ZnpyMjdxT2Vwd0hzZlQ3NjgrV2lrejZzdmxKNlFlRnZ0MTh1S0wzL1JlMGozYWViWFJMOStyLzMrQlNoZ0pmSDFOK0NCalZoaUlJSU1OdWpnZWdEaWw4aUNEMVpvNFlVWVp1Z0toUnAyeUIySHBvRG9JU2NpOGhJSUFDSDVCQVVGQUJBQUxEQUFNZ0JuQUdZQUFBZi9nQkNDZzRTRmhvZUlpWU1HaFJhTWlwQ1JrcE9VbFphWG1KbWFtNXlkbnBnZG42S2pnZ0lEQXA2aHBLdVJBd2djSEFVRG5hcXN0b1VDSFMwN3ZEczNzNXUxbGdXM2xMay92YjBqbk1LV0ZzV1NBakRKdlNFSHdkREZBc2pVdkRHb21jM08yWkRjM1Q0TG11S1Z6K1NJMHQyOUxlQ1g2KzZlQmZHOUQrSDNyQU1tOU8wUVFRQ1VQMVlkZUFqa1lEQ1J2WU9RQkhBUXlPTkN2VXdXSVNKS0lFS2dDWHFUSG1yVTlFQ2dEMktWN0QwYWVZbkFMbjBvZ0lWa1NhcUFENEVZVXRJY05TQ0dRQjBySTRrOE5QUVRBRXdiUWdqOEFGS1J1S0xRQUJBb0VFQ1dNUVVDZTBDRnNOWGZoUWttd3Q1QTBEU1JnUlVDWVpRbFNnbEJwUXZ0L3l3TkFCdTJMb2V0QVFUdWtFRElYdGRLYmpNRnFFdllSSWtSQ1NJUk9DRXdoY3hKZ1cxQnBWdTRybzBBanc4NTZDRXdMaUxQdER6WnFGeDVRb0cxZ2diY0VOaWdVVDl5QUQ2UUprMWl3OUZERjNMbzg4QldWRkJJa1JVaG1FMjZCSVhmcFR6RTQ1RjRKNmJCeEN2SDBKQVp3Z0FWMUh4Z1FKM0tVbGNBSFRoRUwrM0FrSUZwdkZTY3pvUlNWUHRLcm5DTUw2d2dJNkVEREM1d3A0UmNvNEVIbzgwWFZna1lWT2ZjSUg4cGNzRUlBdHExMzRHZUNCQ0JlQTJDeG9wOWt2VG55UUFTM0NCZ0JkbThSeE1BQm1CUXduZ0tISmdnSnhjb0VKMEcyYXhJamdPVUVYWkRRZGxZZU9BQUZzUkFXQW5sallRaFRmOU5jSU1DTW00aUl2K0VURGJwNUpOUWFnTEFsRlJXYWVXVlZFWXBwUUVGYUJEQWwyQ0dLZWFZR2hTQUkwdExhbUtBbDJPMjZTYVlHcHlwcFNRQVVQWG1uVzJtU1k2ZW1RREFKcDZBZnFuQmJYTkdBa0NnaUg1SmFLR0srSmtvb0RBeUtvbWRqNzdKcDZTQ0VFUEFuNVdLYVlHQm1Cb3lRSmVkd21sVnFJZWtDWUFBckxicTZxdXRRckFvcXJUV2F1dXR1RUx5VEFFYTNuSnBycUlrbVNPd2tzVkk3TEdJd0RVcGhCWU1PVXF2UXJiRnlxK0ZVS3VSdFRNaHkxVW5PaWFpSjdRUWRTdEpjSkkwNTYyU3lHSjdpYnFmT0t0dGlMcDZweEc1eFR3MHBHZmlHaUpzb1JaNkJtNm83TzYwNzcrQ0VDeUlYNFFZSEFtOW11VExEQ0pkTWF5SXc1QWtadTUzSk80NkJQRmJGOTFEY1Y4YnY2dFRieUpucTIvSmh1aUpjS3JuSHJ1eUpSZmorckxNcjUyTThzRk9oWHd6SkRPTEhMUE5RRzgwWjhDRjlMd3p5VVZ2OG5FeFMrdWNkTU5RTG0wMHJVMEhEYklremxaZERORTRJODF6b1JscjdQWFJWaU5JZHM1am42MjIwbXRYWW9EV2ExL1F3YjZqQkFJQUlma0VCUVVBQ2dBc05nQXhBRm9BWndBQUIvK0FDb0tEaElXR2g0aUdBaGNmTHk4ZkhRWUNpWlNWbHBlWWxnRkJSNTFIUmdFRG1hT2twWmdYbko2ZFFoZW1ycSt1R2FxcUhMQzJ0NVV2czU0MXVMNlZrNk13dTUyOXY4ZURBZ3NVSUJIQmx5ZkVSOGJJdmdBWE56TGFLQlhQbGRIRTFOVzIxelRhNXpJQm1PQzc0dU93SCtqbkxBblEwdTd2cGdEbTh0b045dUh5M2VMWGIwWUhTK3htNFJNNENrQzhmdHB1SUx6SEVGWUVGQkMxSWZoR3NhSXJBUnd5eW9BaEtsRkNWUXM5WWpyUVFpUUlTaWQ1cVh4RlFXU0xlb2hpRnB2cHlzQUxrYlZ5ZGp5MGdDY2xDU0pSUkJBYThCQk9vNGdHWk10WWdtazdxS1lpekJCcDRaRE9hVmhMQ1dnZzhnUUJRMTlUSmxwNkN3QUFVZ2YvV0lqMDhKWlFXa05zOHkyS3NNR2JKUXdpVmJTeU8xU2xnUUFnRWovb1VOY1NnUm9pUHhRYTFsU2xBTVNKTTJ0STBKZ1NncVJGQitraVpvSm5oTXlvRXlNb1NXbkFCSkVsbm5HUTl1OVNhRmdBTUtmT2pHR0JYME1kVklnc01DaEJLbFZDbnQ3S2l3Z0FodDI3QTF6b1hFaEFCWkVZQ0ZrNGZrU0loZDhDZFVOSGJVRjVvUVFuTW1vNFQ2TEdDdzRYd0pNeVgybkQrUEVGV0JQS0RiR0ZBWWEzWmJMQWZkQmhFQUYxQ2dndzFUa3pTSUJnV0Fya2xZQUdCRVkzWFNFRWZJQ1JERGN3OTBxQXh3aXd3UU1WcGliQmYrZEZRSjhwS3lJemdBUFBsWmhaQWZKQlNBb0FCaUFnbzJZUDJxZ0FpSlVBY0FDRk8zcm9vd0l0QXRNQnhJa2xTbkRrTHdNVTBPU1RScnFDb3dRRVZ2a2tMSXVJbDlrRE5XNzVpZ0FSeEpqWllHSlc4MklBRDBpUVpKcHd4aW5ubkhUV2FlZWRlT2FwNTU1ODl1bm5uNEFHS3VpZ2hCWnE2S0dVdklub29vdzI2dWlqSGlrSzZhTmEvbG5wTVpKT3F1bW1uR1lWNktXK2dQcG5wdmtBK1NpcHBFYUlDSE9weGdtaWxoNmE2aWVzamRMS3FLMkw0b3Fvcm9meWFxaXZoUUpMcUxDREVpdW9zWit1V3F1eXR6SXJwNnlZSUZzSnRFZEthNm16bG9pYXByV3pZdHVydDUyR3kyaXJ2V3BiVFNBQUlma0VCUVVBSXdBc053QXhBRm9BWndBQUIvK0FJNEtEaElXR2g0aUdCeDRUSHg0SEJJbVNrNVNWbHBVSUlpR2JJUkFJbDZDaG9wY0dtcHliRUFtanE2eXJGS2VuSUsyenRKTWZzSndadGJ1U0FDTytseE80bTdxOHhvUVhFZ2dIb01MRHhjZThCaFFUMVJNYXdjTWgwTkcwQmh6VzFnV1d6cmpjM2F3QUdPSFdHWkdVNWJEbjZLdmc3TlVhd0pMeHAvUDBvdmJ1ZlZBMWlWK3VmN1BXM2F0R1FSOGlnOFFRdGpxdzBGcUVndHI4U2J6MG9PS0VCZ0wyWmR6SXlrQUdqNThTUWR3bWFRUEpSQUFrZUhTbmN1UW9seHNKS1BENHdDR2hsUnBIT0hnNUtZTEhDUmNlMmpSa2dPZ2tBZFFxZWdocENLalRWUlE5WHF5NmxCQ3pxNU1DZUd3d2dPc3pzS05NZXBSZzFoellBeHYvRHZqc3hjRGpoNlkvdTFMNjJvcUFoQUNBTFNTMU5HQm5SUXdPclhiRFdTZ200TWNCRU9DbDFPRW80eEczenI3c0FMbnpVRW9DRkM2c1FPalZNRm1WUHJmYThMY3paQTBkNWhZNjhNRWpZd0ttVGtHWXZGR0RhOWNTK0NLeWdKSlFnZHlkQ3NnMmRQbVFjRWtJZnY4dXdMc1FnWURzVkF1YVZwc0N3VUhQTFZXZmRFRDZidzBMcUJvcXNEQkQyWC9hTFhFMjcxckRCdldsN3kzNDF4eVVBUWIwQWZmZElBT0k1c0VGeTRFU256RUh0QmJnWXdXOFE4Z0FGeENRSUNrU0NSQ0JidzhDcHNGV2FGSFMzeUVFT05EaFl3eUVLTW1Da3lRUTNZa2pIaE1qSXVOWnNvRUZIWTZqb2xlMGJCaWdqanNhUTBBQjlNM0lpNUhkQU9EaXNtOFdCTWtmam85cE1LQlRTUElTZ1FRV1VPZmtsbHgyNmVXWFlJWXA1cGhrbG1ubW1XaW1xZWFhYkxicDVwdHd4aW5ubkt2VVNPZVhWZDZwWXA2ejhLbW5SSDV5R1NnaGRvWTQ2SitJb2xsb29veWlFNTZNWmo0NmlxUWtoVWVwVTVkT2NpaFdiQzRxRVl2ZFpHck1qSjRPVW1vb3A0WUpLaVdyaGlLcUtKdjI2V3FzamRZYXFxMjQ1cW9ySWJUKzJldXV3QVlyN0xCZ3RvcVdzYmR1OUN1eHJDekw3TE8xdmdydG1hbnE2U3dyZ1FBQUlma0VCUVVBRFFBc1NBQXhBRG9BSWdBQUIvK0FEWUtEaElXR2d3QUdHaFFVR2drREFJZVNrNVNWaEJFMU5KbzBOUkVDbHFDaGt3U1ptNW8xQktLcXF4YW1waGFyc2FBVXJwc1VzcFdScWg2MW1yZXFBcCtIaVJzYkJMcWd2TDIvb1E0Zkh4SURoUU1GQWRZQkVjaVZ5clhNbFFJbFFVUGpLQXZDQXhiWDF4ZWgzSzdla3dJazQvUkRQZzdTRHVyWEZzTGJ2VFRnU2Rxd294NDlGZ1FFcE50bkxVSXlnQUlORFlCaGtGNlBWQXNaYWtqMWI1a2xDVVlxanZPUlNoOURhd1VzdVRNVmtaQ0JGQ0xIcWZoRVFNTkphd2s2ZHRzV2M0aVJsQTBBTExnWlFJTE9kNVFPOE9oWnc5OEFtemMzVUZwcGE5S0FHejEzc0NPMGdhZ0dmNGFvK3Bya0FFbFBEb1lFSUNDNllKTFlnSkxzQ05Eb21ZTmpvUU5lN1JaNjIxS0R1SmdCSkFHb2RwT0J0a0Y4RHhtQTBIT0d0TGhRVHg0NGxMaVFBQVU5aGJTZEJDQUNVUWxnQlZYbVdxUm5pZEFTTXpMc0VCYmlOQnM5ZmVTMDFQV21oc2VJWFJNcUlLU25nbEJxaVRyWXExc1FBUlU5Z2VpdGxJQm9BQU9FYUhrY0ZLQm5FRmlpQUpnOGlRQlpxMTVHQlEwQTBwTUY3bEExaVVJZlZNb1VLdXFaSGE3cVRGVHFJRXp1NVF2NjBQTUdhbEFLM1RRWklRUll3SWdGQm1pRG1VaEZyQ2NMWGhyOU4wa0NabFhrQVM2Q0RMYVBCZ09xUWtGdjljaHduaXdDYkZmQWNxSWc0TUk0UWJBd0c0YURDR0RBaUxFUUVJRUZHMGhvU0NBQUlma0VCUVVBRWdBc053QXhBRm9BV2dBQUIvK0FFb0tEaElXR2g0aUdBd3NJQ0E0RUFvbVNrNVNWbHBVSEl3MmJEU01YQUplaG9xT1dBNXFjbXlNRHBLeXRyQXVvcUJHdXRMV1RDTEdjRExhOHZZSzR1UTI3b1FDZ3ZzZUR3TG5EbGgwZUl3NlJ5TDdLc2N5VUpCQWkyeVViMDczVnFOZUpBQ0RiNXlJb0hkTGZydUc2bUNubzV6Y0R4dTJzNzV2amh3SWY4K2Rtck1MWFNwOHdTZzVXQU55R1lpQkJVZ2I1RlNKZ1l1RzJHQThMQmpzb0tZQkZFU3RtWlR5RTROWkdpWU1TcVBpWVlXU2lEcElpSmhKUTRhT01BeGxoUWp6NVVwNUZFQzd6OFR3MEFNZEhGZzZEaHBKNXFNQkhFU1dWam1JNkVjWkhHK3lrWHFJNkNNQ0RqeXQwYWwwNmxOQ0JHUjhiM0J0cmlhc0VBU1RtUHFJd3dFdnNON2NSRkZyRXdIWnFXUWtEYkh3OGtWUXJ6cllib3dwaThCRkNBWGRLSTJ3VStmYkV4eHRaU1hWUS9GREFLVlNxa24xTWNhRVc1NHlaUUI4VzVPR2pnclY5UlFtSTBHaEI0YThMWnhDSS9jMkF6M2tCZUxmVG9QZWNpY3lDN0JKRXNCclpnaHIwNkFySE4yQkRnZWJUc3lOU3JyMjc5Ky9ndzR0UC9wRDdRK3pqMDZ0Zno3NjkrL2Z3NDh1ZlQ3KysvZnY0OCt2Zno3Ky8vLzhBQnRpZmVkUUlXQW1CdmlCbzRJSU1OdWpnZzdHaHA5UnBFRlpvNFlVWUJxamdmb3BSeUdFaE9FbFkzNFlabG1qaWliNkllQmVESkM3WUlvb2tnYWNpTFRPT0VnZ0FJZmtFQlFVQURnQXNOd0F4QUZ3QVp3QUFCLytBRG9LRGhJV0doNGlHQWhjUkVSY0NBSW1TazVTVmxwY0dGZ0diQVJZR2w2Q2hvcUVDbXB5YkZnS2pxNnl0RjZlbkY2Mnp0SlVkc0p3ZHRidThoQkc0bTdxOXc3Uy93TUtXQnhvYXlNUzJsOGE0elpJQUdDVW0yQlVKa2M2ODBiRFRpUkxZNUNZM0I5MkVDNjNmcCtHSEJqSGw1QjZxNmNYQUFlK0dJUFBrT1BkcXRjdEZhY00xZnladzJBdklhbUN3U1FNVUlNUTJnaHZEVlE3MVRTb3cwVVFKV1JmRlRjcTRUeENCQ1IweFdBd3BpcVNrQUIxamZHS0pNVi9KQS9JbVdxRFowQ1lpQVI0NlpsaklNNVRMUXgwNm1vaFF0T2F4UXdNNGRLelExS20wUXd3NmxrQlh0YVhQUWdad3BPdzY2aWdoREIxdkVDRHJBS1FsczRML0x0am9pQUNVQVJBY01LeHRDbGZBaUk0Y2lFb3lVT0hIanNOQTF1MUtjT25XMDBFUnRKWWtSRUNEaThPWWQ0allLMGt4cjFmQTNEcVFPbkVFSlFFTGFHUmVIZGlCQkpxbVRxV0MzTkVHNDBTTGNQUll2VnJFQUY2VENXV1NQVk9RaG80QkJvL0l3WnMzRDg3M1JNZnQ0RWd3Z29rNGZoOGlZRUZHOCtZdUNDemFKWDNWZ0p6ekNod1NFT0hGOSs4anRMTTFWT0FnT1FXS0RtVGc4WjYzait5dFNIQ2JNeGMwUU00STBEbEFBQWdpOU1jYkNnVUlGdGQ4Z3dpUVFBY0dyQ1FBQXlvNHVKb09JTWlIU0hCa0dWQ0NEeDVpMXNNSHhWRW9pZ0FwcElnWkRCMUkyRXQ1eERRZzR3NHVTR0NqSlRoVzFVS0tQOFRuWWkxRDl0Y0QrUTRESGpsTEJ2M1JzTUNQc3pSWjFBRWhOQWVCQmxRNk9Zb0FHS0NJV1FnS0pPaGxMUUpJb0VJSUlzUVE1SmxvQ3RBbG5IVFdhZWVkZU9hcDU1NTg5dW5ubjRBR0t1aWdoQlpxNktHSUpxcm9vcE84eHVpamtOYnlacDJUK2xscHBOMlF5S2VtbU5KaVpWR09HbnFwcEhtT1dvbXA2WFJRSHFvWFZWb1NxNUlFQjJ1bm9IZ1cwS3liamhoU3FJTHd5b3V0RHV3ekRiQ3NpT2FySUl4OU9nbXJ3b0lDSzY2OU5QdW90SVRpU08yaTF5cWFyU1hLQm5Uc00waEJ1aTJpNHg1YTdpRGZIdG50SU9jaUsyaTdoTUk3cUx4c0VRc0t2WW5ZMjZvbCtFTExGcjdCemdjcndIOFM3S2ZCb3RLcThNS0lYTkFCcDkwRUFnQTdcIixcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGhlaWdodDogJzM1cHgnLFxuICAgICAgICBtYXJnaW5SaWdodDogJzIwcHgnXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fbG9vcF9zcGlubmVyXygpO1xuICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmltZyk7XG4gICAgdGhpcy5tc2cgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgICAgbm9kZU5hbWU6ICdzcGFuJ1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5tc2cpO1xuICB9O1xuXG4gIG5ld19hbGVydF9tc2cucHJvdG90eXBlLl9sb29wX3NwaW5uZXJfID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW5fcm90YXRpb24gPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pbl9yb3RhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5kZWcgPSAodGhpcy5kZWcgKyAzNjApICsgMTtcbiAgICB0aGlzLmltZy5zdHlsZS5XZWJraXRUcmFuc2l0aW9uRHVyYXRpb24gPSAnMi4ycyc7XG4gICAgdGhpcy5pbWcuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gXCJyb3RhdGUoXCIgKyB0aGlzLmRlZyArIFwiZGVnKVwiO1xuICAgIHRoaXMuaW1nLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9ICdsaW5lYXInO1xuICAgIGlmICh0aGlzLnJvdGF0YXRpbmcgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmluX3JvdGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29wX3NwaW5uZXJfKCk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW5fcm90YXRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgbmV3X2FsZXJ0X21zZy5wcm90b3R5cGUuY3JlYXRlX2Zvb3RlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiLCBidG4sIGQsIGxlbiwgcSwgcmVmLCByZXN1bHRzO1xuICAgIHRoaXMuZm9vdGVyID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgIGNvbG9yOiAnIzAwMCcsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICBwYWRkaW5nOiAnMTVweCcsXG4gICAgICAgIGhlaWdodDogJzEwMHB4J1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucG9wdXAuYXBwZW5kQ2hpbGQodGhpcy5mb290ZXIpO1xuICAgIHJlZiA9IHRoaXMucGFyYW1zLmJ0bjtcbiAgICByZXN1bHRzID0gW107XG4gICAgZm9yIChxID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgcSA8IGxlbjsgcSsrKSB7XG4gICAgICBidG4gPSByZWZbcV07XG4gICAgICBkID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB3aWR0aDogKDEwMCAvIHRoaXMucGFyYW1zLmJ0bi5sZW5ndGgpICsgXCIlXCIsXG4gICAgICAgICAgcGFkZGluZ1JpZ2h0OiAnNXB4JyxcbiAgICAgICAgICBwYWRkaW5nTGVmdDogJzVweCcsXG4gICAgICAgICAgZmxvYXQ6ICdsZWZ0J1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGIgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgICAgICBub2RlTmFtZTogJ2J1dHRvbicsXG4gICAgICAgIGlubmVySFRNTDogYnRuLnR4dCxcbiAgICAgICAgb25jbGljazogYnRuLmNsaWNrLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgICAgcGFkZGluZzogXCI2cHggMTJweFwiLFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogXCIwXCIsXG4gICAgICAgICAgZm9udFNpemU6IFwieC1sYXJnZVwiLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCIsXG4gICAgICAgICAgaGVpZ2h0OiAnNzBweCcsXG4gICAgICAgICAgbGluZUhlaWdodDogXCIxLjQyODU3MTQzXCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgICB0b3VjaEFjdGlvbjogXCJtYW5pcHVsYXRpb25cIixcbiAgICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuICAgICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYnRuLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBjb2xvcjogXCIjZmZmXCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmZvb3Rlci5hcHBlbmRDaGlsZChkKTtcbiAgICAgIHJlc3VsdHMucHVzaChkLmFwcGVuZENoaWxkKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgbmV3X2FsZXJ0X21zZy5wcm90b3R5cGUuaGlkZV9idG4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZvb3Rlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHJldHVybiB0aGlzLmltZy5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gIH07XG5cbiAgbmV3X2FsZXJ0X21zZy5wcm90b3R5cGUuc2hvd19idG4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZvb3Rlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICByZXR1cm4gdGhpcy5pbWcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBuZXdfYWxlcnRfbXNnLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcmV0dXJuIHRoaXMucm90YXRhdGluZyA9IGZhbHNlO1xuICB9O1xuXG4gIG5ld19hbGVydF9tc2cucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhY2tncm91bmQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgdGhpcy5yb3RhdGF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fbG9vcF9zcGlubmVyXygpO1xuICB9O1xuXG4gIG5ld19hbGVydF9tc2cucHJvdG90eXBlLnNldE1zZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgIHJldHVybiB0aGlzLm1zZy5pbm5lckhUTUwgPSBtc2c7XG4gIH07XG5cbiAgcmV0dXJuIG5ld19hbGVydF9tc2c7XG5cbn0pKCk7XG5cbl9pbmRleF9jdXJyZW50X3BvcHVwID0gMTAwMDA7XG5cbnNwaW5hbF9uZXdfcG9wdXAgPSBmdW5jdGlvbih0aXRsZSwgcGFyYW1zKSB7XG4gIHZhciBfZHJhZ19lbmRfZnVuYywgX2RyYWdfZXZ0X2Z1bmMsIGIsIGNsaWVudFgsIGNsaWVudFksIGNsb3NlX2VsZW1lbnQsIGV4dGVudGlvbiwgaGVpZ2h0LCBvbGRfeCwgb2xkX3ksIHJlcG9zLCByZXMsIHQsIHRvcF94LCB0b3BfeSwgdywgd2lkdGg7XG4gIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIGlmIChwYXJhbXMucG9wdXBfY2xvc2VyID09IG51bGwpIHtcbiAgICBiID0gbmV3X2RvbV9lbGVtZW50KHtcbiAgICAgIHBhcmVudE5vZGU6IGRvY3VtZW50LmJvZHksXG4gICAgICBpZDogXCJwb3B1cF9jbG9zZXJcIixcbiAgICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMub25jbG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcGFyYW1zLm9uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh3KTtcbiAgICAgIH0sXG4gICAgICBvbmRyb3A6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoIWV2dCkge1xuICAgICAgICAgIGV2dCA9IHdpbmRvdy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBldnQuc3RvcFByb3BhZ2F0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBldnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJhY2tncm91bmQ6IHBhcmFtcy5maXhlZF9vcGFjaXR5IHx8IFwiIzAwMFwiLFxuICAgICAgICBvcGFjaXR5OiBwYXJhbXMuZml4ZWRfb3BhY2l0eSB8fCAwLFxuICAgICAgICB6SW5kZXg6IF9pbmRleF9jdXJyZW50X3BvcHVwXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaWYgKChwYXJhbXMuZXZlbnQgIT0gbnVsbCkgJiYgcGFyYW1zLmV2ZW50LmNsaWVudFgpIHtcbiAgICBjbGllbnRYID0gcGFyYW1zLmV2ZW50LmNsaWVudFg7XG4gICAgY2xpZW50WSA9IHBhcmFtcy5ldmVudC5jbGllbnRZO1xuICB9IGVsc2Uge1xuICAgIGNsaWVudFggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSAxMDtcbiAgICBjbGllbnRZID0gd2luZG93LmlubmVySGVpZ2h0IC8gMiAtIDEwO1xuICB9XG4gIHRvcF94ID0gcGFyYW1zLnRvcF94IHx8IC0xMDAwO1xuICB0b3BfeSA9IHBhcmFtcy50b3BfeSB8fCAtMTAwMDtcbiAgb2xkX3ggPSAwO1xuICBvbGRfeSA9IDA7XG4gIHcgPSB2b2lkIDA7XG4gIGlmIChwYXJhbXMud2lkdGggIT0gbnVsbCkge1xuICAgIHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICB9XG4gIGlmIChwYXJhbXMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICB9XG4gIHJlcG9zID0gZnVuY3Rpb24oKSB7XG4gICAgdG9wX3ggPSBjbGllbnRYIC0gdy5jbGllbnRXaWR0aCAvIDI7XG4gICAgdG9wX3kgPSBjbGllbnRZIC0gdy5jbGllbnRIZWlnaHQgLyAyO1xuICAgIGlmICgodG9wX3ggKyB3LmNsaWVudFdpZHRoKSA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XG4gICAgICB0b3BfeCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gdy5jbGllbnRXaWR0aCAtIDUwO1xuICAgIH1cbiAgICBpZiAoKHRvcF95ICsgdy5jbGllbnRIZWlnaHQpID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICB0b3BfeSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHcuY2xpZW50SGVpZ2h0ICsgNTA7XG4gICAgfVxuICAgIGlmICh0b3BfeCA8IDUwKSB7XG4gICAgICB0b3BfeCA9IDUwO1xuICAgIH1cbiAgICBpZiAodG9wX3kgPCA1MCkge1xuICAgICAgdG9wX3kgPSA1MDtcbiAgICB9XG4gICAgdy5zdHlsZS5sZWZ0ID0gdG9wX3g7XG4gICAgcmV0dXJuIHcuc3R5bGUudG9wID0gdG9wX3k7XG4gIH07XG4gIF9kcmFnX2V2dF9mdW5jID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdG9wX3ggKz0gZXZ0LmNsaWVudFggLSBvbGRfeDtcbiAgICB0b3BfeSArPSBldnQuY2xpZW50WSAtIG9sZF95O1xuICAgIHcuc3R5bGUubGVmdCA9IHRvcF94O1xuICAgIHcuc3R5bGUudG9wID0gdG9wX3k7XG4gICAgb2xkX3ggPSBldnQuY2xpZW50WDtcbiAgICBvbGRfeSA9IGV2dC5jbGllbnRZO1xuICAgIHJldHVybiB0eXBlb2YgZXZ0LnByZXZlbnREZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBldnQucHJldmVudERlZmF1bHQoKSA6IHZvaWQgMDtcbiAgfTtcbiAgX2RyYWdfZW5kX2Z1bmMgPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmRldGFjaEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25tb3VzZW1vdmVcIiwgX2RyYWdfZXZ0X2Z1bmMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmRldGFjaEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvY3VtZW50LmRldGFjaEV2ZW50KFwib25tb3VzZXVwXCIsIF9kcmFnX2VuZF9mdW5jKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX2RyYWdfZXZ0X2Z1bmMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiA/IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9kcmFnX2VuZF9mdW5jLCB0cnVlKSA6IHZvaWQgMDtcbiAgfTtcbiAgZXh0ZW50aW9uID0gXCJweFwiO1xuICBpZiAoIXBhcmFtcy50b3BfeCkge1xuICAgIHNldFRpbWVvdXQocmVwb3MsIDEpO1xuICAgIGV4dGVudGlvbiA9IFwiJVwiO1xuICB9XG4gIHcgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgIHBhcmVudE5vZGU6IGRvY3VtZW50LmJvZHksXG4gICAgY2xhc3NOYW1lOiBcIlBvcHVwXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiB0b3BfeCxcbiAgICAgIHRvcDogdG9wX3ksXG4gICAgICB3aWR0aDogd2lkdGggKyBleHRlbnRpb24sXG4gICAgICBoZWlnaHQ6IGhlaWdodCArIGV4dGVudGlvbixcbiAgICAgIHpJbmRleDogX2luZGV4X2N1cnJlbnRfcG9wdXAgKyAxLFxuICAgICAgYm9yZGVyOiAndGhpbiBzb2xpZCBibGFjaycsXG4gICAgICBiYWNrZ3JvdW5kOiAnI2U1ZTVlNScsXG4gICAgICByZXNpemU6ICdib3RoJyxcbiAgICAgIG92ZXJmbG93OiAnYXV0bycsXG4gICAgICBwYWRkaW5nQm90dG9tOiAnOHB4J1xuICAgIH1cbiAgfSk7XG4gIF9pbmRleF9jdXJyZW50X3BvcHVwICs9IDI7XG4gIGNsb3NlX2VsZW1lbnQgPSBuZXdfZG9tX2VsZW1lbnQoe1xuICAgIHBhcmVudE5vZGU6IHcsXG4gICAgY2xhc3NOYW1lOiBcIlBvcHVwQ2xvc2VcIixcbiAgICB0eHQ6IFwiQ2xvc2VcIixcbiAgICBzdHlsZToge1xuICAgICAgZmxvYXQ6ICdyaWdodCcsXG4gICAgICBtYXJnaW5SaWdodDogJzRweCcsXG4gICAgICBtYXJnaW5Ub3A6ICc0cHgnLFxuICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICB9LFxuICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLm9uY2xvc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwYXJhbXMub25jbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodyk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHRpdGxlKSB7XG4gICAgdCA9IG5ld19kb21fZWxlbWVudCh7XG4gICAgICBwYXJlbnROb2RlOiB3LFxuICAgICAgY2xhc3NOYW1lOiBcIlBvcHVwVGl0bGVcIixcbiAgICAgIGlubmVySFRNTDogdGl0bGUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kOiAnIzI2MjYyNicsXG4gICAgICAgIHBhZGRpbmc6ICc1IDEwIDMgMTAnLFxuICAgICAgICBoZWlnaHQ6ICcyMnB4JyxcbiAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgYm9yZGVyQm90dG9tOiAndGhpbiBzb2xpZCBibGFjaycsXG4gICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICBjb2xvcjogJ3doaXRlJ1xuICAgICAgfSxcbiAgICAgIG9ubW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgb2xkX3ggPSBldnQuY2xpZW50WDtcbiAgICAgICAgb2xkX3kgPSBldnQuY2xpZW50WTtcbiAgICAgICAgdG9wX3ggPSBwYXJzZUludCh3LnN0eWxlLmxlZnQpO1xuICAgICAgICB0b3BfeSA9IHBhcnNlSW50KHcuc3R5bGUudG9wKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfZHJhZ19ldnRfZnVuYywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF9kcmFnX2VuZF9mdW5jLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBldnQucHJldmVudERlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiA/IGV2dC5wcmV2ZW50RGVmYXVsdCgpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJlcyA9IG5ld19kb21fZWxlbWVudCh7XG4gICAgcGFyZW50Tm9kZTogdyxcbiAgICBjbGFzc05hbWU6IFwiUG9wdXBXaW5kb3dcIixcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogXCI2cHhcIixcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgY29sb3I6ICcjMjYyNjI2J1xuICAgIH1cbiAgfSk7XG4gIGlmIChwYXJhbXMuY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlcy5hcHBlbmRDaGlsZChwYXJhbXMuY2hpbGQpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJ2YXIgVnVlIC8vIGxhdGUgYmluZFxudmFyIHZlcnNpb25cbnZhciBtYXAgPSAod2luZG93Ll9fVlVFX0hPVF9NQVBfXyA9IE9iamVjdC5jcmVhdGUobnVsbCkpXG52YXIgaW5zdGFsbGVkID0gZmFsc2VcbnZhciBpc0Jyb3dzZXJpZnkgPSBmYWxzZVxudmFyIGluaXRIb29rTmFtZSA9ICdiZWZvcmVDcmVhdGUnXG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uICh2dWUsIGJyb3dzZXJpZnkpIHtcbiAgaWYgKGluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsZWQgPSB0cnVlXG5cbiAgVnVlID0gdnVlLl9fZXNNb2R1bGUgPyB2dWUuZGVmYXVsdCA6IHZ1ZVxuICB2ZXJzaW9uID0gVnVlLnZlcnNpb24uc3BsaXQoJy4nKS5tYXAoTnVtYmVyKVxuICBpc0Jyb3dzZXJpZnkgPSBicm93c2VyaWZ5XG5cbiAgLy8gY29tcGF0IHdpdGggPCAyLjAuMC1hbHBoYS43XG4gIGlmIChWdWUuY29uZmlnLl9saWZlY3ljbGVIb29rcy5pbmRleE9mKCdpbml0JykgPiAtMSkge1xuICAgIGluaXRIb29rTmFtZSA9ICdpbml0J1xuICB9XG5cbiAgZXhwb3J0cy5jb21wYXRpYmxlID0gdmVyc2lvblswXSA+PSAyXG4gIGlmICghZXhwb3J0cy5jb21wYXRpYmxlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1tITVJdIFlvdSBhcmUgdXNpbmcgYSB2ZXJzaW9uIG9mIHZ1ZS1ob3QtcmVsb2FkLWFwaSB0aGF0IGlzICcgK1xuICAgICAgICAnb25seSBjb21wYXRpYmxlIHdpdGggVnVlLmpzIGNvcmUgXjIuMC4wLidcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWNvcmQgZm9yIGEgaG90IG1vZHVsZSwgd2hpY2gga2VlcHMgdHJhY2sgb2YgaXRzIGNvbnN0cnVjdG9yXG4gKiBhbmQgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5cbmV4cG9ydHMuY3JlYXRlUmVjb3JkID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gIGlmKG1hcFtpZF0pIHsgcmV0dXJuIH1cbiAgXG4gIHZhciBDdG9yID0gbnVsbFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBDdG9yID0gb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnNcbiAgfVxuICBtYWtlT3B0aW9uc0hvdChpZCwgb3B0aW9ucylcbiAgbWFwW2lkXSA9IHtcbiAgICBDdG9yOiBDdG9yLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgaW5zdGFuY2VzOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbW9kdWxlIGlzIHJlY29yZGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cblxuZXhwb3J0cy5pc1JlY29yZGVkID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwW2lkXSAhPT0gJ3VuZGVmaW5lZCdcbn1cblxuLyoqXG4gKiBNYWtlIGEgQ29tcG9uZW50IG9wdGlvbnMgb2JqZWN0IGhvdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblxuZnVuY3Rpb24gbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHZhciByZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gKGgsIGN0eCkge1xuICAgICAgdmFyIGluc3RhbmNlcyA9IG1hcFtpZF0uaW5zdGFuY2VzXG4gICAgICBpZiAoY3R4ICYmIGluc3RhbmNlcy5pbmRleE9mKGN0eC5wYXJlbnQpIDwgMCkge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChjdHgucGFyZW50KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbmRlcihoLCBjdHgpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluamVjdEhvb2sob3B0aW9ucywgaW5pdEhvb2tOYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWNvcmQgPSBtYXBbaWRdXG4gICAgICBpZiAoIXJlY29yZC5DdG9yKSB7XG4gICAgICAgIHJlY29yZC5DdG9yID0gdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgfVxuICAgICAgcmVjb3JkLmluc3RhbmNlcy5wdXNoKHRoaXMpXG4gICAgfSlcbiAgICBpbmplY3RIb29rKG9wdGlvbnMsICdiZWZvcmVEZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5zdGFuY2VzID0gbWFwW2lkXS5pbnN0YW5jZXNcbiAgICAgIGluc3RhbmNlcy5zcGxpY2UoaW5zdGFuY2VzLmluZGV4T2YodGhpcyksIDEpXG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIEluamVjdCBhIGhvb2sgdG8gYSBob3QgcmVsb2FkYWJsZSBjb21wb25lbnQgc28gdGhhdFxuICogd2UgY2FuIGtlZXAgdHJhY2sgb2YgaXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0SG9vayhvcHRpb25zLCBuYW1lLCBob29rKSB7XG4gIHZhciBleGlzdGluZyA9IG9wdGlvbnNbbmFtZV1cbiAgb3B0aW9uc1tuYW1lXSA9IGV4aXN0aW5nXG4gICAgPyBBcnJheS5pc0FycmF5KGV4aXN0aW5nKSA/IGV4aXN0aW5nLmNvbmNhdChob29rKSA6IFtleGlzdGluZywgaG9va11cbiAgICA6IFtob29rXVxufVxuXG5mdW5jdGlvbiB0cnlXcmFwKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaWQsIGFyZykge1xuICAgIHRyeSB7XG4gICAgICBmbihpZCwgYXJnKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGR1cmluZyBWdWUgY29tcG9uZW50IGhvdC1yZWxvYWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLidcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyAob2xkT3B0aW9ucywgbmV3T3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb2xkT3B0aW9ucykge1xuICAgIGlmICghKGtleSBpbiBuZXdPcHRpb25zKSkge1xuICAgICAgZGVsZXRlIG9sZE9wdGlvbnNba2V5XVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBrZXkkMSBpbiBuZXdPcHRpb25zKSB7XG4gICAgb2xkT3B0aW9uc1trZXkkMV0gPSBuZXdPcHRpb25zW2tleSQxXVxuICB9XG59XG5cbmV4cG9ydHMucmVyZW5kZXIgPSB0cnlXcmFwKGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuICB2YXIgcmVjb3JkID0gbWFwW2lkXVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLiRmb3JjZVVwZGF0ZSgpXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucy5vcHRpb25zXG4gIH1cbiAgaWYgKHJlY29yZC5DdG9yKSB7XG4gICAgcmVjb3JkLkN0b3Iub3B0aW9ucy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgIHJlY29yZC5DdG9yLm9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcbiAgICByZWNvcmQuaW5zdGFuY2VzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLiRvcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBpbnN0YW5jZS4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZuc1xuICAgICAgLy8gcmVzZXQgc3RhdGljIHRyZWVzXG4gICAgICAvLyBwcmUgMi41LCBhbGwgc3RhdGljIHRyZWVzIGFyZSBjYWhjZWQgdG9nZXRoZXIgb24gdGhlIGluc3RhbmNlXG4gICAgICBpZiAoaW5zdGFuY2UuX3N0YXRpY1RyZWVzKSB7XG4gICAgICAgIGluc3RhbmNlLl9zdGF0aWNUcmVlcyA9IFtdXG4gICAgICB9XG4gICAgICAvLyAyLjUuMFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVjb3JkLkN0b3Iub3B0aW9ucy5jYWNoZWQpKSB7XG4gICAgICAgIHJlY29yZC5DdG9yLm9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIC8vIDIuNS4zXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnN0YW5jZS4kb3B0aW9ucy5jYWNoZWQpKSB7XG4gICAgICAgIGluc3RhbmNlLiRvcHRpb25zLmNhY2hlZCA9IFtdXG4gICAgICB9XG4gICAgICAvLyBwb3N0IDIuNS40OiB2LW9uY2UgdHJlZXMgYXJlIGNhY2hlZCBvbiBpbnN0YW5jZS5fc3RhdGljVHJlZXMuXG4gICAgICAvLyBQdXJlIHN0YXRpYyB0cmVlcyBhcmUgY2FjaGVkIG9uIHRoZSBzdGF0aWNSZW5kZXJGbnMgYXJyYXlcbiAgICAgIC8vIChib3RoIGFscmVhZHkgcmVzZXQgYWJvdmUpXG4gICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gZnVuY3Rpb25hbCBvciBubyBpbnN0YW5jZSBjcmVhdGVkIHlldFxuICAgIHJlY29yZC5vcHRpb25zLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgcmVjb3JkLm9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNcblxuICAgIC8vIGhhbmRsZSBmdW5jdGlvbmFsIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgICBpZiAocmVjb3JkLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gcmVyZW5kZXIgd2l0aCBmdWxsIG9wdGlvbnNcbiAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAyKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMocmVjb3JkLm9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZW1wbGF0ZS1vbmx5IHJlcmVuZGVyLlxuICAgICAgICAvLyBuZWVkIHRvIGluamVjdCB0aGUgc3R5bGUgaW5qZWN0aW9uIGNvZGUgZm9yIENTUyBtb2R1bGVzXG4gICAgICAgIC8vIHRvIHdvcmsgcHJvcGVybHkuXG4gICAgICAgIHZhciBpbmplY3RTdHlsZXMgPSByZWNvcmQub3B0aW9ucy5faW5qZWN0U3R5bGVzXG4gICAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgICB2YXIgcmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgICAgICByZWNvcmQub3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiAoaCwgY3R4KSB7XG4gICAgICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChjdHgpXG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyKGgsIGN0eClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlY29yZC5vcHRpb25zLl9DdG9yID0gbnVsbFxuICAgICAgLy8gMi41LjNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlY29yZC5vcHRpb25zLmNhY2hlZCkpIHtcbiAgICAgICAgcmVjb3JkLm9wdGlvbnMuY2FjaGVkID0gW11cbiAgICAgIH1cbiAgICAgIHJlY29yZC5pbnN0YW5jZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS4kZm9yY2VVcGRhdGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydHMucmVsb2FkID0gdHJ5V3JhcChmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcbiAgdmFyIHJlY29yZCA9IG1hcFtpZF1cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnNcbiAgICB9XG4gICAgbWFrZU9wdGlvbnNIb3QoaWQsIG9wdGlvbnMpXG4gICAgaWYgKHJlY29yZC5DdG9yKSB7XG4gICAgICBpZiAodmVyc2lvblsxXSA8IDIpIHtcbiAgICAgICAgLy8gcHJlc2VydmUgcHJlIDIuMiBiZWhhdmlvciBmb3IgZ2xvYmFsIG1peGluIGhhbmRsaW5nXG4gICAgICAgIHJlY29yZC5DdG9yLmV4dGVuZE9wdGlvbnMgPSBvcHRpb25zXG4gICAgICB9XG4gICAgICB2YXIgbmV3Q3RvciA9IHJlY29yZC5DdG9yLnN1cGVyLmV4dGVuZChvcHRpb25zKVxuICAgICAgcmVjb3JkLkN0b3Iub3B0aW9ucyA9IG5ld0N0b3Iub3B0aW9uc1xuICAgICAgcmVjb3JkLkN0b3IuY2lkID0gbmV3Q3Rvci5jaWRcbiAgICAgIHJlY29yZC5DdG9yLnByb3RvdHlwZSA9IG5ld0N0b3IucHJvdG90eXBlXG4gICAgICBpZiAobmV3Q3Rvci5yZWxlYXNlKSB7XG4gICAgICAgIC8vIHRlbXBvcmFyeSBnbG9iYWwgbWl4aW4gc3RyYXRlZ3kgdXNlZCBpbiA8IDIuMC4wLWFscGhhLjZcbiAgICAgICAgbmV3Q3Rvci5yZWxlYXNlKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlT3B0aW9ucyhyZWNvcmQub3B0aW9ucywgb3B0aW9ucylcbiAgICB9XG4gIH1cbiAgcmVjb3JkLmluc3RhbmNlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlLiR2bm9kZSAmJiBpbnN0YW5jZS4kdm5vZGUuY29udGV4dCkge1xuICAgICAgaW5zdGFuY2UuJHZub2RlLmNvbnRleHQuJGZvcmNlVXBkYXRlKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnUm9vdCBvciBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlIG1vZGlmaWVkLiBGdWxsIHJlbG9hZCByZXF1aXJlZC4nXG4gICAgICApXG4gICAgfVxuICB9KVxufSlcbiIsIi8qIVxuICogdnVlLW1hdGVyaWFsIHYxLjAuMC1iZXRhLThcbiAqIE1hZGUgd2l0aCA8MyBieSBtYXJjb3Ntb3VyYSAyMDE4XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInZ1ZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJ2dWVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVnVlTWF0ZXJpYWxcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJ2dWVcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlZ1ZU1hdGVyaWFsXCJdID0gZmFjdG9yeShyb290W1wiVnVlXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1NCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciAvKiBzZXJ2ZXIgb25seSAqL1xuKSB7XG4gIHZhciBlc01vZHVsZVxuICB2YXIgc2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzIHx8IHt9XG5cbiAgLy8gRVM2IG1vZHVsZXMgaW50ZXJvcFxuICB2YXIgdHlwZSA9IHR5cGVvZiByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgaWYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBlc01vZHVsZSA9IHJhd1NjcmlwdEV4cG9ydHNcbiAgICBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cy5kZWZhdWx0XG4gIH1cblxuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKGNvbXBpbGVkVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZFRlbXBsYXRlLnN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgdmFyIGZ1bmN0aW9uYWwgPSBvcHRpb25zLmZ1bmN0aW9uYWxcbiAgICB2YXIgZXhpc3RpbmcgPSBmdW5jdGlvbmFsXG4gICAgICA/IG9wdGlvbnMucmVuZGVyXG4gICAgICA6IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG5cbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gZXhpc3RpbmcoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxudmFyIF9NZFJlYWN0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfTWRSZWFjdGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJlYWN0aXZlKTtcblxudmFyIF9NZFRoZW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBfTWRUaGVtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRoZW1lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICB2YXIgbWF0ZXJpYWwgPSBuZXcgX01kUmVhY3RpdmUyLmRlZmF1bHQoe1xuICAgIHJpcHBsZTogdHJ1ZSxcbiAgICB0aGVtaW5nOiB7fSxcbiAgICBsb2NhbGU6IHtcbiAgICAgIHN0YXJ0WWVhcjogMTkwMCxcbiAgICAgIGVuZFllYXI6IDIwOTksXG4gICAgICBkYXRlRm9ybWF0OiAnWVlZWS1NTS1ERCcsXG4gICAgICBkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gICAgICBzaG9ydERheXM6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgICBzaG9ydGVyRGF5czogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gICAgICBtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgc2hvcnRNb250aHM6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVnJywgJ1NlcHQnLCAnT2N0JywgJ05vdicsICdEZWMnXSxcbiAgICAgIHNob3J0ZXJNb250aHM6IFsnSicsICdGJywgJ00nLCAnQScsICdNJywgJ0p1JywgJ0p1JywgJ0EnLCAnU2UnLCAnTycsICdOJywgJ0QnXSxcbiAgICAgIGZpcnN0RGF5T2ZBV2VlazogMFxuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobWF0ZXJpYWwudGhlbWluZywge1xuICAgIG1ldGFDb2xvcnM6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX01kVGhlbWUyLmRlZmF1bHQubWV0YUNvbG9ycztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChtZXRhQ29sb3JzKSB7XG4gICAgICAgIF9NZFRoZW1lMi5kZWZhdWx0Lm1ldGFDb2xvcnMgPSBtZXRhQ29sb3JzO1xuICAgICAgfVxuICAgIH0sXG4gICAgdGhlbWU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX01kVGhlbWUyLmRlZmF1bHQudGhlbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGhlbWUpIHtcbiAgICAgICAgX01kVGhlbWUyLmRlZmF1bHQudGhlbWUgPSB0aGVtZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gX01kVGhlbWUyLmRlZmF1bHQuZW5hYmxlZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChlbmFibGVkKSB7XG4gICAgICAgIF9NZFRoZW1lMi5kZWZhdWx0LmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICBpZiAoIVZ1ZS5tYXRlcmlhbCkge1xuICAgIFZ1ZS5tYXRlcmlhbCA9IGluaXQoKTtcbiAgICBWdWUucHJvdG90eXBlLiRtYXRlcmlhbCA9IFZ1ZS5tYXRlcmlhbDtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChuZXdDb21wb25lbnQpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBtZFRoZW1lOiBudWxsXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgJG1kQWN0aXZlVGhlbWU6IGZ1bmN0aW9uICRtZEFjdGl2ZVRoZW1lKCkge1xuICAgICAgICB2YXIgZW5hYmxlZCA9IF9NZFRoZW1lMi5kZWZhdWx0LmVuYWJsZWQsXG4gICAgICAgICAgICBnZXRUaGVtZU5hbWUgPSBfTWRUaGVtZTIuZGVmYXVsdC5nZXRUaGVtZU5hbWUsXG4gICAgICAgICAgICBnZXRBbmNlc3RvclRoZW1lID0gX01kVGhlbWUyLmRlZmF1bHQuZ2V0QW5jZXN0b3JUaGVtZTtcblxuXG4gICAgICAgIGlmIChlbmFibGVkICYmIHRoaXMubWRUaGVtZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0VGhlbWVOYW1lKHRoaXMubWRUaGVtZSB8fCBnZXRBbmNlc3RvclRoZW1lKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKDAsIF9kZWVwbWVyZ2UyLmRlZmF1bHQpKGRlZmF1bHRzLCBuZXdDb21wb25lbnQpO1xufTtcblxudmFyIF9NZFRoZW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBfTWRUaGVtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRoZW1lKTtcblxudmFyIF9kZWVwbWVyZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxudmFyIF9kZWVwbWVyZ2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcG1lcmdlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxuXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwXG52YXIgREVGQVVMVF9BRERJVElPTkFMX0RJR0lUUyA9IDJcblxudmFyIHBhcnNlVG9rZW5EYXRlVGltZURlbGltZXRlciA9IC9bVCBdL1xudmFyIHBhcnNlVG9rZW5QbGFpblRpbWUgPSAvOi9cblxuLy8geWVhciB0b2tlbnNcbnZhciBwYXJzZVRva2VuWVkgPSAvXihcXGR7Mn0pJC9cbnZhciBwYXJzZVRva2Vuc1lZWSA9IFtcbiAgL14oWystXVxcZHsyfSkkLywgLy8gMCBhZGRpdGlvbmFsIGRpZ2l0c1xuICAvXihbKy1dXFxkezN9KSQvLCAvLyAxIGFkZGl0aW9uYWwgZGlnaXRcbiAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG5dXG5cbnZhciBwYXJzZVRva2VuWVlZWSA9IC9eKFxcZHs0fSkvXG52YXIgcGFyc2VUb2tlbnNZWVlZWSA9IFtcbiAgL14oWystXVxcZHs0fSkvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gIC9eKFsrLV1cXGR7NX0pLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gIC9eKFsrLV1cXGR7Nn0pLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG5dXG5cbi8vIGRhdGUgdG9rZW5zXG52YXIgcGFyc2VUb2tlbk1NID0gL14tKFxcZHsyfSkkL1xudmFyIHBhcnNlVG9rZW5EREQgPSAvXi0/KFxcZHszfSkkL1xudmFyIHBhcnNlVG9rZW5NTUREID0gL14tPyhcXGR7Mn0pLT8oXFxkezJ9KSQvXG52YXIgcGFyc2VUb2tlbld3dyA9IC9eLT9XKFxcZHsyfSkkL1xudmFyIHBhcnNlVG9rZW5Xd3dEID0gL14tP1coXFxkezJ9KS0/KFxcZHsxfSkkL1xuXG4vLyB0aW1lIHRva2Vuc1xudmFyIHBhcnNlVG9rZW5ISCA9IC9eKFxcZHsyfShbLixdXFxkKik/KSQvXG52YXIgcGFyc2VUb2tlbkhITU0gPSAvXihcXGR7Mn0pOj8oXFxkezJ9KFsuLF1cXGQqKT8pJC9cbnZhciBwYXJzZVRva2VuSEhNTVNTID0gL14oXFxkezJ9KTo/KFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkL1xuXG4vLyB0aW1lem9uZSB0b2tlbnNcbnZhciBwYXJzZVRva2VuVGltZXpvbmUgPSAvKFtaKy1dLiopJC9cbnZhciBwYXJzZVRva2VuVGltZXpvbmVaID0gL14oWikkL1xudmFyIHBhcnNlVG9rZW5UaW1lem9uZUhIID0gL14oWystXSkoXFxkezJ9KSQvXG52YXIgcGFyc2VUb2tlblRpbWV6b25lSEhNTSA9IC9eKFsrLV0pKFxcZHsyfSk6PyhcXGR7Mn0pJC9cblxuLyoqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxuICpcbiAqIElmIGFuIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0aGUgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgaXQuXG4gKiBGdW5jdGlvbiBhY2NlcHRzIGNvbXBsZXRlIElTTyA4NjAxIGZvcm1hdHMgYXMgd2VsbCBhcyBwYXJ0aWFsIGltcGxlbWVudGF0aW9ucy5cbiAqIElTTyA4NjAxOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxXG4gKlxuICogSWYgYWxsIGFib3ZlIGZhaWxzLCB0aGUgZnVuY3Rpb24gcGFzc2VzIHRoZSBnaXZlbiBhcmd1bWVudCB0byBEYXRlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqIEBwYXJhbSB7MCB8IDEgfCAyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcbiAqIHZhciByZXN1bHQgPSBwYXJzZSgnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBQYXJzZSBzdHJpbmcgJyswMjAxNDEwMScsXG4gKiAvLyBpZiB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdCBpcyAxOlxuICogdmFyIHJlc3VsdCA9IHBhcnNlKCcrMDIwMTQxMDEnLCB7YWRkaXRpb25hbERpZ2l0czogMX0pXG4gKiAvLz0+IEZyaSBBcHIgMTEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBwYXJzZSAoYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xuICBpZiAoaXNEYXRlKGFyZ3VtZW50KSkge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudClcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9XG4gIHZhciBhZGRpdGlvbmFsRGlnaXRzID0gb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzXG4gIGlmIChhZGRpdGlvbmFsRGlnaXRzID09IG51bGwpIHtcbiAgICBhZGRpdGlvbmFsRGlnaXRzID0gREVGQVVMVF9BRERJVElPTkFMX0RJR0lUU1xuICB9IGVsc2Uge1xuICAgIGFkZGl0aW9uYWxEaWdpdHMgPSBOdW1iZXIoYWRkaXRpb25hbERpZ2l0cylcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5ncyA9IHNwbGl0RGF0ZVN0cmluZyhhcmd1bWVudClcblxuICB2YXIgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpXG4gIHZhciB5ZWFyID0gcGFyc2VZZWFyUmVzdWx0LnllYXJcbiAgdmFyIHJlc3REYXRlU3RyaW5nID0gcGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nXG5cbiAgdmFyIGRhdGUgPSBwYXJzZURhdGUocmVzdERhdGVTdHJpbmcsIHllYXIpXG5cbiAgaWYgKGRhdGUpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKClcbiAgICB2YXIgdGltZSA9IDBcbiAgICB2YXIgb2Zmc2V0XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKVxuICAgIH1cblxuICAgIGlmIChkYXRlU3RyaW5ncy50aW1lem9uZSkge1xuICAgICAgb2Zmc2V0ID0gcGFyc2VUaW1lem9uZShkYXRlU3RyaW5ncy50aW1lem9uZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IG9mZnNldCBhY2N1cmF0ZSB0byBob3VyIGluIHRpbWV6b25lcyB0aGF0IGNoYW5nZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUpLmdldFRpbWV6b25lT2Zmc2V0KClcbiAgICAgIG9mZnNldCA9IG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFKS5nZXRUaW1lem9uZU9mZnNldCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcgKGRhdGVTdHJpbmcpIHtcbiAgdmFyIGRhdGVTdHJpbmdzID0ge31cbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXJzZVRva2VuRGF0ZVRpbWVEZWxpbWV0ZXIpXG4gIHZhciB0aW1lU3RyaW5nXG5cbiAgaWYgKHBhcnNlVG9rZW5QbGFpblRpbWUudGVzdChhcnJheVswXSkpIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gbnVsbFxuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXVxuICB9IGVsc2Uge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXVxuICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXVxuICB9XG5cbiAgaWYgKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXJzZVRva2VuVGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKVxuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpXG4gICAgICBkYXRlU3RyaW5ncy50aW1lem9uZSA9IHRva2VuWzFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzXG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhciAoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xuICB2YXIgcGFyc2VUb2tlbllZWSA9IHBhcnNlVG9rZW5zWVlZW2FkZGl0aW9uYWxEaWdpdHNdXG4gIHZhciBwYXJzZVRva2VuWVlZWVkgPSBwYXJzZVRva2Vuc1lZWVlZW2FkZGl0aW9uYWxEaWdpdHNdXG5cbiAgdmFyIHRva2VuXG5cbiAgLy8gWVlZWSBvciDCsVlZWVlZXG4gIHRva2VuID0gcGFyc2VUb2tlbllZWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXJzZVRva2VuWVlZWVkuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB2YXIgeWVhclN0cmluZyA9IHRva2VuWzFdXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKHllYXJTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFlZIG9yIMKxWVlZXG4gIHRva2VuID0gcGFyc2VUb2tlbllZLmV4ZWMoZGF0ZVN0cmluZykgfHwgcGFyc2VUb2tlbllZWS5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIHZhciBjZW50dXJ5U3RyaW5nID0gdG9rZW5bMV1cbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogcGFyc2VJbnQoY2VudHVyeVN0cmluZywgMTApICogMTAwLFxuICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoY2VudHVyeVN0cmluZy5sZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlIChkYXRlU3RyaW5nLCB5ZWFyKSB7XG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIGlmICh5ZWFyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciB0b2tlblxuICB2YXIgZGF0ZVxuICB2YXIgbW9udGhcbiAgdmFyIHdlZWtcblxuICAvLyBZWVlZXG4gIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhcilcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1NTVxuICB0b2tlbiA9IHBhcnNlVG9rZW5NTS5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoKVxuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLURERCBvciBZWVlZREREXG4gIHRva2VuID0gcGFyc2VUb2tlbkRERC5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIHZhciBkYXlPZlllYXIgPSBwYXJzZUludCh0b2tlblsxXSwgMTApXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBkYXlPZlllYXIpXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktTU0tREQgb3IgWVlZWU1NRERcbiAgdG9rZW4gPSBwYXJzZVRva2VuTU1ERC5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcbiAgICB2YXIgZGF5ID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKVxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRheSlcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1Xd3cgb3IgWVlZWVd3d1xuICB0b2tlbiA9IHBhcnNlVG9rZW5Xd3cuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcbiAgICByZXR1cm4gZGF5T2ZJU09ZZWFyKHllYXIsIHdlZWspXG4gIH1cblxuICAvLyBZWVlZLVd3dy1EIG9yIFlZWVlXd3dEXG4gIHRva2VuID0gcGFyc2VUb2tlbld3d0QuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcbiAgICB2YXIgZGF5T2ZXZWVrID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKSAtIDFcbiAgICByZXR1cm4gZGF5T2ZJU09ZZWFyKHllYXIsIHdlZWssIGRheU9mV2VlaylcbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBkYXRlXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSAodGltZVN0cmluZykge1xuICB2YXIgdG9rZW5cbiAgdmFyIGhvdXJzXG4gIHZhciBtaW51dGVzXG5cbiAgLy8gaGhcbiAgdG9rZW4gPSBwYXJzZVRva2VuSEguZXhlYyh0aW1lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlRmxvYXQodG9rZW5bMV0ucmVwbGFjZSgnLCcsICcuJykpXG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSXG4gIH1cblxuICAvLyBoaDptbSBvciBoaG1tXG4gIHRva2VuID0gcGFyc2VUb2tlbkhITU0uZXhlYyh0aW1lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcbiAgICBtaW51dGVzID0gcGFyc2VGbG9hdCh0b2tlblsyXS5yZXBsYWNlKCcsJywgJy4nKSlcbiAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgK1xuICAgICAgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEVcbiAgfVxuXG4gIC8vIGhoOm1tOnNzIG9yIGhobW1zc1xuICB0b2tlbiA9IHBhcnNlVG9rZW5ISE1NU1MuZXhlYyh0aW1lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKVxuICAgIHZhciBzZWNvbmRzID0gcGFyc2VGbG9hdCh0b2tlblszXS5yZXBsYWNlKCcsJywgJy4nKSlcbiAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgK1xuICAgICAgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUgK1xuICAgICAgc2Vjb25kcyAqIDEwMDBcbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB0aW1lXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmUgKHRpbWV6b25lU3RyaW5nKSB7XG4gIHZhciB0b2tlblxuICB2YXIgYWJzb2x1dGVPZmZzZXRcblxuICAvLyBaXG4gIHRva2VuID0gcGFyc2VUb2tlblRpbWV6b25lWi5leGVjKHRpbWV6b25lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gwrFoaFxuICB0b2tlbiA9IHBhcnNlVG9rZW5UaW1lem9uZUhILmV4ZWModGltZXpvbmVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGFic29sdXRlT2Zmc2V0ID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKSAqIDYwXG4gICAgcmV0dXJuICh0b2tlblsxXSA9PT0gJysnKSA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICAvLyDCsWhoOm1tIG9yIMKxaGhtbVxuICB0b2tlbiA9IHBhcnNlVG9rZW5UaW1lem9uZUhITU0uZXhlYyh0aW1lem9uZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgYWJzb2x1dGVPZmZzZXQgPSBwYXJzZUludCh0b2tlblsyXSwgMTApICogNjAgKyBwYXJzZUludCh0b2tlblszXSwgMTApXG4gICAgcmV0dXJuICh0b2tlblsxXSA9PT0gJysnKSA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkYXlPZklTT1llYXIgKGlzb1llYXIsIHdlZWssIGRheSkge1xuICB3ZWVrID0gd2VlayB8fCAwXG4gIGRheSA9IGRheSB8fCAwXG4gIHZhciBkYXRlID0gbmV3IERhdGUoMClcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29ZZWFyLCAwLCA0KVxuICB2YXIgZm91cnRoT2ZKYW51YXJ5RGF5ID0gZGF0ZS5nZXRVVENEYXkoKSB8fCA3XG4gIHZhciBkaWZmID0gd2VlayAqIDcgKyBkYXkgKyAxIC0gZm91cnRoT2ZKYW51YXJ5RGF5XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpXG4gIHJldHVybiBkYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92dWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3Z1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIF92dWUyLmRlZmF1bHQudXRpbC53YXJuKCdUaGUgJyArIG5hbWUgKyAnIHByb3AgaXMgaW52YWxpZC4gR2l2ZW4gdmFsdWU6ICcgKyB2YWx1ZSArICcuIEF2YWlsYWJsZSBvcHRpb25zOiAnICsgb3B0aW9ucy5qb2luKCcsICcpICsgJy4nLCB1bmRlZmluZWQpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEljb24vTWRJY29uLnZ1ZVxudmFyIE1kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTUxKTtcbnZhciBNZEljb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRJY29uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi01OWMxNGI4ZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEljb24vTWRJY29uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0ubWRTcmNcbiAgICA/IF9jKFwibWQtc3ZnLWxvYWRlclwiLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWljb24gbWQtaWNvbi1pbWFnZVwiLFxuICAgICAgICBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZV0sXG4gICAgICAgIGF0dHJzOiB7IFwibWQtc3JjXCI6IF92bS5tZFNyYyB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIFwibWQtbG9hZGVkXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLiRlbWl0KFwibWQtbG9hZGVkXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIDogX2MoXG4gICAgICAgIFwiaVwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24gbWQtaWNvbi1mb250XCIsIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lXSB9LFxuICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgIDJcbiAgICAgIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRJY29uX01kSWNvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNTljMTRiOGZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kSWNvbi9NZEljb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNTApXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEljb25fZGVmYXVsdC5hLFxuICBNZEljb25fTWRJY29uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRJY29uL01kSWNvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01OWMxNGI4ZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTU5YzE0YjhmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kSWNvbl9NZEljb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgTWRVdWlkID0gZnVuY3Rpb24gTWRVdWlkKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoNCk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNZFV1aWQ7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kUmlwcGxlL01kUmlwcGxlLnZ1ZVxudmFyIE1kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Myk7XG52YXIgTWRSaXBwbGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRSaXBwbGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTc2OTJiMWFmXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kUmlwcGxlL01kUmlwcGxlLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzOiBbXCJtZC1yaXBwbGVcIiwgX3ZtLnJpcHBsZUNsYXNzZXNdLFxuICAgICAgb246IHtcbiAgICAgICAgXCImdG91Y2hzdGFydFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICBfdm0udG91Y2hTdGFydENoZWNrKCRldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgXCImdG91Y2htb3ZlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgIF92bS50b3VjaE1vdmVDaGVjaygkZXZlbnQpXG4gICAgICAgIH0sXG4gICAgICAgIFwiJnRvdWNoZW5kXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgIF92bS5jbGVhcldhdmUoJGV2ZW50KVxuICAgICAgICB9LFxuICAgICAgICBcIiZtb3VzZWRvd25cIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgX3ZtLnN0YXJ0UmlwcGxlKCRldmVudClcbiAgICAgICAgfSxcbiAgICAgICAgXCImbW91c2V1cFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICBfdm0uY2xlYXJXYXZlKCRldmVudClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLl90KFwiZGVmYXVsdFwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAhX3ZtLmlzRGlzYWJsZWRcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwidHJhbnNpdGlvbi1ncm91cFwiLFxuICAgICAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcIm1kLXJpcHBsZVwiIH0gfSxcbiAgICAgICAgICAgIF92bS5fbChfdm0ucmlwcGxlcywgZnVuY3Rpb24ocmlwcGxlLCBpbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm4gX2MoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IFwicmlwcGxlXCIgKyBpbmRleCxcbiAgICAgICAgICAgICAgICBjbGFzczogW1wibWQtcmlwcGxlLXdhdmVcIiwgX3ZtLndhdmVDbGFzc2VzXSxcbiAgICAgICAgICAgICAgICBzdHlsZTogcmlwcGxlLndhdmVTdHlsZXNcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRSaXBwbGVfTWRSaXBwbGUgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTc2OTJiMWFmXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFJpcHBsZS9NZFJpcHBsZS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRSaXBwbGVfZGVmYXVsdC5hLFxuICBNZFJpcHBsZV9NZFJpcHBsZSxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kUmlwcGxlL01kUmlwcGxlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTc2OTJiMWFmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzY5MmIxYWZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRSaXBwbGVfTWRSaXBwbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgbm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSlcbiAgLCByb290ID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3dcbiAgLCB2ZW5kb3JzID0gWydtb3onLCAnd2Via2l0J11cbiAgLCBzdWZmaXggPSAnQW5pbWF0aW9uRnJhbWUnXG4gICwgcmFmID0gcm9vdFsncmVxdWVzdCcgKyBzdWZmaXhdXG4gICwgY2FmID0gcm9vdFsnY2FuY2VsJyArIHN1ZmZpeF0gfHwgcm9vdFsnY2FuY2VsUmVxdWVzdCcgKyBzdWZmaXhdXG5cbmZvcih2YXIgaSA9IDA7ICFyYWYgJiYgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcbiAgcmFmID0gcm9vdFt2ZW5kb3JzW2ldICsgJ1JlcXVlc3QnICsgc3VmZml4XVxuICBjYWYgPSByb290W3ZlbmRvcnNbaV0gKyAnQ2FuY2VsJyArIHN1ZmZpeF1cbiAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0JyArIHN1ZmZpeF1cbn1cblxuLy8gU29tZSB2ZXJzaW9ucyBvZiBGRiBoYXZlIHJBRiBidXQgbm90IGNBRlxuaWYoIXJhZiB8fCAhY2FmKSB7XG4gIHZhciBsYXN0ID0gMFxuICAgICwgaWQgPSAwXG4gICAgLCBxdWV1ZSA9IFtdXG4gICAgLCBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIDYwXG5cbiAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZihxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBfbm93ID0gbm93KClcbiAgICAgICAgLCBuZXh0ID0gTWF0aC5tYXgoMCwgZnJhbWVEdXJhdGlvbiAtIChfbm93IC0gbGFzdCkpXG4gICAgICBsYXN0ID0gbmV4dCArIF9ub3dcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjcCA9IHF1ZXVlLnNsaWNlKDApXG4gICAgICAgIC8vIENsZWFyIHF1ZXVlIGhlcmUgdG8gcHJldmVudFxuICAgICAgICAvLyBjYWxsYmFja3MgZnJvbSBhcHBlbmRpbmcgbGlzdGVuZXJzXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IGZyYW1lJ3MgcXVldWVcbiAgICAgICAgcXVldWUubGVuZ3RoID0gMFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3AubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZighY3BbaV0uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgIGNwW2ldLmNhbGxiYWNrKGxhc3QpXG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhyb3cgZSB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5yb3VuZChuZXh0KSlcbiAgICB9XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBoYW5kbGU6ICsraWQsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYW5jZWxsZWQ6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhZiA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYocXVldWVbaV0uaGFuZGxlID09PSBoYW5kbGUpIHtcbiAgICAgICAgcXVldWVbaV0uY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIC8vIFdyYXAgaW4gYSBuZXcgZnVuY3Rpb24gdG8gcHJldmVudFxuICAvLyBgY2FuY2VsYCBwb3RlbnRpYWxseSBiZWluZyBhc3NpZ25lZFxuICAvLyB0byB0aGUgbmF0aXZlIHJBRiBmdW5jdGlvblxuICByZXR1cm4gcmFmLmNhbGwocm9vdCwgZm4pXG59XG5tb2R1bGUuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgY2FmLmFwcGx5KHJvb3QsIGFyZ3VtZW50cylcbn1cbm1vZHVsZS5leHBvcnRzLnBvbHlmaWxsID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgb2JqZWN0ID0gcm9vdDtcbiAgfVxuICBvYmplY3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmFmXG4gIG9iamVjdC5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhZlxufVxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZy52dWVcbnZhciBNZERpYWxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2KTtcbnZhciBNZERpYWxvZ19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZERpYWxvZyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZjA4MGE2YTJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2cudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibWQtcG9ydGFsXCIsXG4gICAgW1xuICAgICAgX2MoXCJ0cmFuc2l0aW9uXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJtZC1kaWFsb2dcIiB9IH0sIFtcbiAgICAgICAgX3ZtLm1kQWN0aXZlXG4gICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgX3ZtLl9nKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWRpYWxvZ1wiLFxuICAgICAgICAgICAgICAgICAgY2xhc3M6IFtfdm0uZGlhbG9nQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXSxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGtleWRvd246IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICEoXCJidXR0b25cIiBpbiAkZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwiZXNjXCIsIDI3LCAkZXZlbnQua2V5KVxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLm9uRXNjKCRldmVudClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX3ZtLiRsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF9jKFwibWQtZm9jdXMtdHJhcFwiLCBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1kaWFsb2ctY29udGFpbmVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdChcImRlZmF1bHRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ubWRCYWNrZHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJtZC1vdmVybGF5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF92bS5tZEJhY2tkcm9wQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1maXhlZFwiOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtYWN0aXZlXCI6IF92bS5tZEFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLm9uQ2xpY2sgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICBdKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGlhbG9nX01kRGlhbG9nID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1mMDgwYTZhMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2cudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyMDUpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZERpYWxvZ19kZWZhdWx0LmEsXG4gIE1kRGlhbG9nX01kRGlhbG9nLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2cudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZjA4MGE2YTJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mMDgwYTZhMlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZERpYWxvZ19NZERpYWxvZyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRSaXBwbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxudmFyIF9NZFJpcHBsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJpcHBsZSk7XG5cbnZhciBfTWRMaXN0SXRlbUNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4Myk7XG5cbnZhciBfTWRMaXN0SXRlbUNvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbUNvbnRlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG1peGluczogW19NZFJpcHBsZTIuZGVmYXVsdF0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZExpc3RJdGVtQ29udGVudDogX01kTGlzdEl0ZW1Db250ZW50Mi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgcmV0dXJuICF0aGlzLm1kUmlwcGxlIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0LCBwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHByb3BzLCBjb250ZXh0LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ10ub3B0aW9ucy5wcm9wcyk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEJ1dHRvbl92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEJ1dHRvbl92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEJ1dHRvbl92dWVfXyk7XG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg5OClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEJ1dHRvbl92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEJ1dHRvbi9NZEJ1dHRvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03ZDJjZDgyMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTdkMmNkODIyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kSW5wdXQvTWRJbnB1dC52dWVcbnZhciBNZElucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkpO1xudmFyIE1kSW5wdXRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRJbnB1dCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjlkZTQyYWFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZElucHV0L01kSW5wdXQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiaW5wdXRcIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHtcbiAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0ubW9kZWwsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibW9kZWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtaW5wdXRcIixcbiAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLm1vZGVsIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGZvY3VzOiBfdm0ub25Gb2N1cyxcbiAgICAgICAgICAgIGJsdXI6IF92bS5vbkJsdXIsXG4gICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF92bS5tb2RlbCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgX3ZtLmF0dHJpYnV0ZXMsXG4gICAgICAgIGZhbHNlXG4gICAgICApLFxuICAgICAgX3ZtLmxpc3RlbmVyc1xuICAgIClcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZElucHV0X01kSW5wdXQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTY5ZGU0MmFhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kSW5wdXQvTWRJbnB1dC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kSW5wdXRfZGVmYXVsdC5hLFxuICBNZElucHV0X01kSW5wdXQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEZpZWxkL01kSW5wdXQvTWRJbnB1dC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02OWRlNDJhYVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTY5ZGU0MmFhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEZpZWxkX01kSW5wdXRfTWRJbnB1dCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZToge30sXG4gICAgcGxhY2Vob2xkZXI6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmcsXG4gICAgbWF4bGVuZ3RoOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIHJlYWRvbmx5OiBCb29sZWFuLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIG1kQ291bnRlcjogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbFZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgdGV4dGFyZWFIZWlnaHQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIG1vZGVsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbnB1dGV2ZW50Jykge1xuICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvY2FsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRGaWVsZC5jbGVhcjtcbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6IGZ1bmN0aW9uIGF0dHJpYnV0ZXMoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgIHJlcXVpcmVkOiB0aGlzLnJlcXVpcmVkLFxuICAgICAgICBwbGFjZWhvbGRlcjogdGhpcy5wbGFjZWhvbGRlcixcbiAgICAgICAgcmVhZG9ubHk6IHRoaXMucmVhZG9ubHksXG4gICAgICAgIG1heGxlbmd0aDogdGhpcy5tYXhsZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtb2RlbDogZnVuY3Rpb24gbW9kZWwoKSB7XG4gICAgICB0aGlzLnNldEZpZWxkVmFsdWUoKTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcihfY2xlYXIpIHtcbiAgICAgIGlmIChfY2xlYXIpIHtcbiAgICAgICAgdGhpcy5jbGVhckZpZWxkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwbGFjZWhvbGRlcjogZnVuY3Rpb24gcGxhY2Vob2xkZXIoKSB7XG4gICAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCk7XG4gICAgfSxcbiAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gICAgICB0aGlzLnNldERpc2FibGVkKCk7XG4gICAgfSxcbiAgICByZXF1aXJlZDogZnVuY3Rpb24gcmVxdWlyZWQoKSB7XG4gICAgICB0aGlzLnNldFJlcXVpcmVkKCk7XG4gICAgfSxcbiAgICBtYXhsZW5ndGg6IGZ1bmN0aW9uIG1heGxlbmd0aCgpIHtcbiAgICAgIHRoaXMuc2V0TWF4bGVuZ3RoKCk7XG4gICAgfSxcbiAgICBtZENvdW50ZXI6IGZ1bmN0aW9uIG1kQ291bnRlcigpIHtcbiAgICAgIHRoaXMuc2V0TWF4bGVuZ3RoKCk7XG4gICAgfSxcbiAgICBsb2NhbFZhbHVlOiBmdW5jdGlvbiBsb2NhbFZhbHVlKHZhbCkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWwpO1xuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHZhbCkge1xuICAgICAgdGhpcy5sb2NhbFZhbHVlID0gdmFsO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNsZWFyRmllbGQ6IGZ1bmN0aW9uIGNsZWFyRmllbGQoKSB7XG4gICAgICB0aGlzLiRlbC52YWx1ZSA9ICcnO1xuICAgICAgdGhpcy5tb2RlbCA9ICcnO1xuICAgICAgdGhpcy5zZXRGaWVsZFZhbHVlKCk7XG4gICAgfSxcbiAgICBzZXRMYWJlbEZvcjogZnVuY3Rpb24gc2V0TGFiZWxGb3IoKSB7XG4gICAgICBpZiAodGhpcy4kZWwucGFyZW50Tm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLiRlbC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsJyk7XG5cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgdmFyIGZvckF0dHJpYnV0ZSA9IGxhYmVsLmdldEF0dHJpYnV0ZSgnZm9yJyk7XG5cbiAgICAgICAgICBpZiAoIWZvckF0dHJpYnV0ZSB8fCBmb3JBdHRyaWJ1dGUuaW5kZXhPZignbWQtJykgPj0gMCkge1xuICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCB0aGlzLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEZpZWxkVmFsdWU6IGZ1bmN0aW9uIHNldEZpZWxkVmFsdWUoKSB7XG4gICAgICB0aGlzLk1kRmllbGQudmFsdWUgPSB0aGlzLm1vZGVsO1xuICAgIH0sXG4gICAgc2V0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uIHNldFBsYWNlaG9sZGVyKCkge1xuICAgICAgdGhpcy5NZEZpZWxkLnBsYWNlaG9sZGVyID0gQm9vbGVhbih0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICB9LFxuICAgIHNldERpc2FibGVkOiBmdW5jdGlvbiBzZXREaXNhYmxlZCgpIHtcbiAgICAgIHRoaXMuTWRGaWVsZC5kaXNhYmxlZCA9IEJvb2xlYW4odGhpcy5kaXNhYmxlZCk7XG4gICAgfSxcbiAgICBzZXRSZXF1aXJlZDogZnVuY3Rpb24gc2V0UmVxdWlyZWQoKSB7XG4gICAgICB0aGlzLk1kRmllbGQucmVxdWlyZWQgPSBCb29sZWFuKHRoaXMucmVxdWlyZWQpO1xuICAgIH0sXG4gICAgc2V0TWF4bGVuZ3RoOiBmdW5jdGlvbiBzZXRNYXhsZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy5tZENvdW50ZXIpIHtcbiAgICAgICAgdGhpcy5NZEZpZWxkLmNvdW50ZXIgPSBwYXJzZUludCh0aGlzLm1kQ291bnRlciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5NZEZpZWxkLm1heGxlbmd0aCA9IHBhcnNlSW50KHRoaXMubWF4bGVuZ3RoLCAxMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgICAgdGhpcy5NZEZpZWxkLmZvY3VzZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB0aGlzLk1kRmllbGQuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLnNldEZpZWxkVmFsdWUoKTtcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKCk7XG4gICAgdGhpcy5zZXREaXNhYmxlZCgpO1xuICAgIHRoaXMuc2V0UmVxdWlyZWQoKTtcbiAgICB0aGlzLnNldE1heGxlbmd0aCgpO1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuc2V0TGFiZWxGb3IoKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Z1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kUG9ydGFsJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbWRBdHRhY2hUb1BhcmVudDogQm9vbGVhbixcbiAgICBtZFRhcmdldDoge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgIGlmIChIVE1MRWxlbWVudCAmJiB2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBfdnVlMi5kZWZhdWx0LnV0aWwud2FybignVGhlIG1kLXRhcmdldC1lbCBwcm9wIGlzIGludmFsaWQuIFlvdSBzaG91bGQgcGFzcyBhIHZhbGlkIEhUTUxFbGVtZW50LicsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYXZlVGltZW91dDogbnVsbCxcbiAgICAgIG9yaWdpbmFsUGFyZW50RWw6IG51bGxcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHRyYW5zaXRpb25OYW1lOiBmdW5jdGlvbiB0cmFuc2l0aW9uTmFtZSgpIHtcbiAgICAgIHZhciBjaGlsZHJlbkNvbXBvbmVudCA9IHRoaXMuX3Zub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW5bMF07XG5cbiAgICAgIGlmIChjaGlsZHJlbkNvbXBvbmVudCkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IGNoaWxkcmVuQ29tcG9uZW50LmRhdGEudHJhbnNpdGlvbjtcblxuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uLm5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF90cmFuc2l0aW9uID0gY2hpbGRyZW5Db21wb25lbnQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEubmFtZTtcblxuICAgICAgICAgIGlmIChfdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3YnO1xuICAgIH0sXG4gICAgbGVhdmVDbGFzczogZnVuY3Rpb24gbGVhdmVDbGFzcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25OYW1lICsgJy1sZWF2ZSc7XG4gICAgfSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBmdW5jdGlvbiBsZWF2ZUFjdGl2ZUNsYXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbk5hbWUgKyAnLWxlYXZlLWFjdGl2ZSc7XG4gICAgfSxcbiAgICBsZWF2ZVRvQ2xhc3M6IGZ1bmN0aW9uIGxlYXZlVG9DbGFzcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zaXRpb25OYW1lICsgJy1sZWF2ZS10byc7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG1kVGFyZ2V0OiBmdW5jdGlvbiBtZFRhcmdldChuZXdUYXJnZXQsIG9sZFRhcmdldCkge1xuICAgICAgdGhpcy5jaGFuZ2VQYXJlbnRFbChuZXdUYXJnZXQpO1xuXG4gICAgICBpZiAob2xkVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uOiBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uRHVyYXRpb24oZWwpIHtcbiAgICAgIHZhciBkdXJhdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KGR1cmF0aW9uLCAxMCk7XG4gICAgICB2YXIgdW5pdCA9IGR1cmF0aW9uLm1hdGNoKC9tP3MvKTtcbiAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBudWxsO1xuXG4gICAgICBpZiAodW5pdCkge1xuICAgICAgICB1bml0ID0gdW5pdFswXTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG51bSAqIDEwMDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG51bTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaWxsaXNlY29uZHM7XG4gICAgfSxcbiAgICBraWxsR2hvc3RFbGVtZW50OiBmdW5jdGlvbiBraWxsR2hvc3RFbGVtZW50KGVsKSB7XG4gICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmNoYW5nZVBhcmVudEVsKHRoaXMub3JpZ2luYWxQYXJlbnRFbCk7XG4gICAgICAgIHRoaXMuJG9wdGlvbnMuX3BhcmVudEVsbSA9IHRoaXMub3JpZ2luYWxQYXJlbnRFbDtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0RGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobWFudWFsQ2FsbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbDtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGVsID0gdGhpcy4kZWw7XG5cblxuICAgICAgICAgICAgICAgIGlmIChtYW51YWxDYWxsICYmIHRoaXMuJGVsLm5vZGVUeXBlID09PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzLiR2bm9kZS5lbG07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmxlYXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQodGhpcy5sZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCh0aGlzLmxlYXZlVG9DbGFzcyk7XG5cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5sZWF2ZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVhdmVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5kZXN0cm95RWxlbWVudChlbCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5nZXRUcmFuc2l0aW9uRHVyYXRpb24oZWwpKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpbml0RGVzdHJveShfeCkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5pdERlc3Ryb3k7XG4gICAgfSgpLFxuICAgIGRlc3Ryb3lFbGVtZW50OiBmdW5jdGlvbiBkZXN0cm95RWxlbWVudChlbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMyLmxlYXZlQ2xhc3MpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKF90aGlzMi5sZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShfdGhpczIubGVhdmVUb0NsYXNzKTtcbiAgICAgICAgX3RoaXMyLiRlbWl0KCdtZC1kZXN0cm95Jyk7XG4gICAgICAgIF90aGlzMi5raWxsR2hvc3RFbGVtZW50KGVsKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY2hhbmdlUGFyZW50RWw6IGZ1bmN0aW9uIGNoYW5nZVBhcmVudEVsKG5ld1RhcmdldCkge1xuICAgICAgbmV3VGFyZ2V0ICYmIG5ld1RhcmdldC5hcHBlbmRDaGlsZCh0aGlzLiRlbCk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIGlmICghdGhpcy5vcmlnaW5hbFBhcmVudEVsKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsUGFyZW50RWwgPSB0aGlzLiRlbC5wYXJlbnROb2RlO1xuICAgICAgdGhpcy4kZW1pdCgnbWQtaW5pdGlhbC1wYXJlbnQnLCB0aGlzLiRlbC5wYXJlbnROb2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tZEF0dGFjaFRvUGFyZW50ICYmIHRoaXMuJGVsLnBhcmVudE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5jaGFuZ2VQYXJlbnRFbCh0aGlzLiRlbC5wYXJlbnROb2RlLnBhcmVudE5vZGUpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuY2hhbmdlUGFyZW50RWwodGhpcy5tZFRhcmdldCB8fCBkb2N1bWVudC5ib2R5KTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuJGVsLmNsYXNzTGlzdCkge1xuICAgICAgdGhpcy5pbml0RGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtpbGxHaG9zdEVsZW1lbnQodGhpcy4kZWwpO1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgIHZhciBkZWZhdWx0U2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG5cbiAgICBpZiAoZGVmYXVsdFNsb3QgJiYgZGVmYXVsdFNsb3RbMF0pIHtcbiAgICAgIHJldHVybiBkZWZhdWx0U2xvdFswXTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbWV0aG9kczoge1xuICAgIGlzQXNzZXRJY29uOiBmdW5jdGlvbiBpc0Fzc2V0SWNvbihpY29uKSB7XG4gICAgICByZXR1cm4gKC9cXHcrWy9cXFxcLl1cXHcrLy50ZXN0KGljb24pXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9NZFJpcHBsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJpcHBsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgY29tcG9uZW50czoge1xuICAgIE1kUmlwcGxlOiBfTWRSaXBwbGUyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZFJpcHBsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRGaWVsZC52dWVcbnZhciBNZEZpZWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDgpO1xudmFyIE1kRmllbGRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRGaWVsZCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMmVjZDdiOTdcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZEZpZWxkLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWZpZWxkXCIsXG4gICAgICBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZSwgX3ZtLmZpZWxkQ2xhc3Nlc10sXG4gICAgICBvbjogeyBibHVyOiBfdm0ub25CbHVyIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS5fdChcImRlZmF1bHRcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLmhhc0NvdW50ZXJcbiAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1jb3VudFwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgX3ZtLl9zKF92bS52YWx1ZUxlbmd0aCkgK1xuICAgICAgICAgICAgICAgIFwiIC8gXCIgK1xuICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uTWRGaWVsZC5tYXhsZW5ndGggfHwgX3ZtLk1kRmllbGQuY291bnRlcilcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcInRyYW5zaXRpb25cIixcbiAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcIm1kLWlucHV0LWFjdGlvblwiLCBhcHBlYXI6IFwiXCIgfSB9LFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLmhhc1ZhbHVlICYmIF92bS5tZENsZWFyYWJsZVxuICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICBcIm1kLWljb24tYnV0dG9uIG1kLWRlbnNlIG1kLWlucHV0LWFjdGlvbiBtZC1jbGVhclwiLFxuICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdGFiaW5kZXg6IFwiLTFcIiwgZGlzYWJsZWQ6IF92bS5NZEZpZWxkLmRpc2FibGVkIH0sXG4gICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmNsZWFySW5wdXQgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW19jKFwibWQtY2xlYXItaWNvblwiKV0sXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwidHJhbnNpdGlvblwiLFxuICAgICAgICB7IGF0dHJzOiB7IG5hbWU6IFwibWQtaW5wdXQtYWN0aW9uXCIsIGFwcGVhcjogXCJcIiB9IH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0uaGFzUGFzc3dvcmRUb2dnbGVcbiAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgXCJtZC1idXR0b25cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgXCJtZC1pY29uLWJ1dHRvbiBtZC1kZW5zZSBtZC1pbnB1dC1hY3Rpb24gbWQtdG9nZ2xlLXBhc3N3b3JkXCIsXG4gICAgICAgICAgICAgICAgICBhdHRyczogeyB0YWJpbmRleDogXCItMVwiIH0sXG4gICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnRvZ2dsZVBhc3N3b3JkIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF92bS5NZEZpZWxkLnRvZ2dsZVBhc3N3b3JkXG4gICAgICAgICAgICAgICAgICAgID8gX2MoXCJtZC1wYXNzd29yZC1vZmYtaWNvblwiKVxuICAgICAgICAgICAgICAgICAgICA6IF9jKFwibWQtcGFzc3dvcmQtb24taWNvblwiKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEZpZWxkX01kRmllbGQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTJlY2Q3Yjk3XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kRmllbGQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNDcpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEZpZWxkX2RlZmF1bHQuYSxcbiAgTWRGaWVsZF9NZEZpZWxkLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZEZpZWxkLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTJlY2Q3Yjk3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMmVjZDdiOTdcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRGaWVsZF9NZEZpZWxkID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgZGF5IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBzdGFydCBvZiBhIGRheVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBkYXkgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiB2YXIgcmVzdWx0ID0gc3RhcnRPZkRheShuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBUdWUgU2VwIDAyIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZkRheSAoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHJldHVybiBkYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhcnRPZkRheVxuXG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0YXJ0T2ZXZWVrID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzUpXG5cbi8qKlxuICogQGNhdGVnb3J5IElTTyBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYW4gSVNPIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBJU08gd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIHZhciByZXN1bHQgPSBzdGFydE9mSVNPV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBNb24gU2VwIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3RhcnRPZklTT1dlZWsgKGRpcnR5RGF0ZSkge1xuICByZXR1cm4gc3RhcnRPZldlZWsoZGlydHlEYXRlLCB7d2Vla1N0YXJ0c09uOiAxfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFydE9mSVNPV2Vla1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kT3ZlcmxheS9NZE92ZXJsYXkudnVlXG52YXIgTWRPdmVybGF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODIpO1xudmFyIE1kT3ZlcmxheV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZE92ZXJsYXkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTBlMDVjOTdhXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kT3ZlcmxheS9NZE92ZXJsYXkudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibWQtcG9ydGFsXCIsXG4gICAgeyBhdHRyczogeyBcIm1kLWF0dGFjaC10by1wYXJlbnRcIjogX3ZtLm1kQXR0YWNoVG9QYXJlbnQgfSB9LFxuICAgIFtcbiAgICAgIF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwibWQtb3ZlcmxheVwiIH0gfSwgW1xuICAgICAgICBfdm0ubWRBY3RpdmVcbiAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICBfdm0uX2coXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1vdmVybGF5XCIsIGNsYXNzOiBfdm0ub3ZlcmxheUNsYXNzZXMgfSxcbiAgICAgICAgICAgICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgXSlcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZE92ZXJsYXlfTWRPdmVybGF5ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wZTA1Yzk3YVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRPdmVybGF5L01kT3ZlcmxheS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kT3ZlcmxheV9kZWZhdWx0LmEsXG4gIE1kT3ZlcmxheV9NZE92ZXJsYXksXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZE92ZXJsYXkvTWRPdmVybGF5LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTBlMDVjOTdhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMGUwNWM5N2FcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRPdmVybGF5X01kT3ZlcmxheSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGdpdmVuIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGRheXMgYXJlIGluIEZlYnJ1YXJ5IDIwMDA/XG4gKiB2YXIgcmVzdWx0ID0gZ2V0RGF5c0luTW9udGgobmV3IERhdGUoMjAwMCwgMSkpXG4gKiAvLz0+IDI5XG4gKi9cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoIChkaXJ0eURhdGUpIHtcbiAgdmFyIGRhdGUgPSBwYXJzZShkaXJ0eURhdGUpXG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpXG4gIHZhciBtb250aEluZGV4ID0gZGF0ZS5nZXRNb250aCgpXG4gIHZhciBsYXN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKDApXG4gIGxhc3REYXlPZk1vbnRoLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoSW5kZXggKyAxLCAwKVxuICBsYXN0RGF5T2ZNb250aC5zZXRIb3VycygwLCAwLCAwLCAwKVxuICByZXR1cm4gbGFzdERheU9mTW9udGguZ2V0RGF0ZSgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF5c0luTW9udGhcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFBvcG92ZXJfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5OSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kUG9wb3Zlcl92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFBvcG92ZXJfdnVlX18pO1xudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTk4KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSBudWxsXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kUG9wb3Zlcl92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFBvcG92ZXIvTWRQb3BvdmVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWQzNjIzNmE2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZDM2MjM2YTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsLCBjb25maWcsIGNiKSB7XG4gIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKGNiKTtcblxuICAgIG9ic2VydmVyLm9ic2VydmUoZWwsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUhlYWQudnVlXG52YXIgTWRUYWJsZUhlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2MSk7XG52YXIgTWRUYWJsZUhlYWRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJsZUhlYWQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTk4ZGRjMDgyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUhlYWQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwidGhcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1oZWFkXCIsXG4gICAgICBjbGFzczogX3ZtLmhlYWRDbGFzc2VzLFxuICAgICAgc3R5bGU6IF92bS5oZWFkU3R5bGVzLFxuICAgICAgb246IHsgY2xpY2s6IF92bS5jaGFuZ2VTb3J0IH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS4kc2xvdHMuZGVmYXVsdFxuICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtaGVhZC1jb250YWluZXJcIiB9LCBbXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1oZWFkLWxhYmVsXCIgfSxcbiAgICAgICAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfYyhcbiAgICAgICAgICAgIFwibWQtcmlwcGxlXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXRhYmxlLWhlYWQtY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgIGF0dHJzOiB7IFwibWQtZGlzYWJsZWRcIjogIV92bS5oYXNTb3J0IH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1oZWFkLWxhYmVsXCIgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uaGFzU29ydFxuICAgICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC11cHdhcmQtaWNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1zb3J0YWJsZS1pY29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJhcnJvd191cHdhcmRcIildXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuXFxuICAgICAgXCIgKyBfdm0uX3MoX3ZtLmxhYmVsKSArIFwiXFxuXFxuICAgICAgXCIpLFxuICAgICAgICAgICAgICAgICAgX3ZtLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgPyBfYyhcIm1kLXRvb2x0aXBcIiwgW192bS5fdihfdm0uX3MoX3ZtLnRvb2x0aXApKV0pXG4gICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFRhYmxlX01kVGFibGVIZWFkID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi05OGRkYzA4MlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlSGVhZC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2MClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kVGFibGVIZWFkX2RlZmF1bHQuYSxcbiAgTWRUYWJsZV9NZFRhYmxlSGVhZCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUhlYWQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtOThkZGMwODJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi05OGRkYzA4MlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZFRhYmxlX01kVGFibGVIZWFkID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIEluc3RhbmNlID0ge307XG5cbiAgX3Z1ZTIuZGVmYXVsdC51dGlsLmRlZmluZVJlYWN0aXZlKEluc3RhbmNlLCAncmVhY3RpdmUnLCBkYXRhKTtcblxuICByZXR1cm4gSW5zdGFuY2UucmVhY3RpdmU7XG59O1xuXG52YXIgX3Z1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92dWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3Z1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbXNDb2xvciA9IG51bGw7XG52YXIgdGhlbWVDb2xvciA9IG51bGw7XG52YXIgbWFza0ljb24gPSBudWxsO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX3Z1ZTIuZGVmYXVsdCh7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByZWZpeDogJ21kLXRoZW1lLScsXG4gICAgICB0aGVtZTogJ2RlZmF1bHQnLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIG1ldGFDb2xvcnM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB0aGVtZVRhcmdldDogZnVuY3Rpb24gdGhlbWVUYXJnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuJGlzU2VydmVyKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGZ1bGxUaGVtZU5hbWU6IGZ1bmN0aW9uIGZ1bGxUaGVtZU5hbWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaGVtZU5hbWUoKTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdmFyIGZ1bGxUaGVtZU5hbWUgPSB0aGlzLmZ1bGxUaGVtZU5hbWUsXG4gICAgICAgICAgICB0aGVtZVRhcmdldCA9IHRoaXMudGhlbWVUYXJnZXQsXG4gICAgICAgICAgICBlbmFibGVkID0gdGhpcy5lbmFibGVkO1xuXG5cbiAgICAgICAgaWYgKHRoZW1lVGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoZW1lVGFyZ2V0LmNsYXNzTGlzdC5hZGQoZnVsbFRoZW1lTmFtZSk7XG4gICAgICAgICAgICB0aGlzLm1ldGFDb2xvcnMgJiYgdGhpcy5zZXRIdG1sTWV0YUNvbG9ycyhmdWxsVGhlbWVOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhlbWVUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZShmdWxsVGhlbWVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMubWV0YUNvbG9ycyAmJiB0aGlzLnNldEh0bWxNZXRhQ29sb3JzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0aGVtZTogZnVuY3Rpb24gdGhlbWUobmV3VGhlbWUsIG9sZFRoZW1lKSB7XG4gICAgICB2YXIgZ2V0VGhlbWVOYW1lID0gdGhpcy5nZXRUaGVtZU5hbWUsXG4gICAgICAgICAgdGhlbWVUYXJnZXQgPSB0aGlzLnRoZW1lVGFyZ2V0O1xuXG5cbiAgICAgIG5ld1RoZW1lID0gZ2V0VGhlbWVOYW1lKG5ld1RoZW1lKTtcblxuICAgICAgdGhlbWVUYXJnZXQuY2xhc3NMaXN0LnJlbW92ZShnZXRUaGVtZU5hbWUob2xkVGhlbWUpKTtcbiAgICAgIHRoZW1lVGFyZ2V0LmNsYXNzTGlzdC5hZGQobmV3VGhlbWUpO1xuXG4gICAgICBpZiAodGhpcy5tZXRhQ29sb3JzKSB7XG4gICAgICAgIHRoaXMuc2V0SHRtbE1ldGFDb2xvcnMobmV3VGhlbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0YUNvbG9yczogZnVuY3Rpb24gbWV0YUNvbG9ycyhtZXRhKSB7XG4gICAgICBpZiAobWV0YSkge1xuICAgICAgICB0aGlzLnNldEh0bWxNZXRhQ29sb3JzKHRoaXMuZnVsbFRoZW1lTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEh0bWxNZXRhQ29sb3JzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0QW5jZXN0b3JUaGVtZTogZnVuY3Rpb24gZ2V0QW5jZXN0b3JUaGVtZShjb21wb25lbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaGVtZSA9IGNvbXBvbmVudC5tZFRoZW1lO1xuICAgICAgICB2YXIgZ2V0UGFyZW50VGhlbWVOYW1lID0gZnVuY3Rpb24gZ2V0UGFyZW50VGhlbWVOYW1lKHBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtZFRoZW1lID0gcGFyZW50Lm1kVGhlbWUsXG4gICAgICAgICAgICAgICAgJHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuXG5cbiAgICAgICAgICAgIGlmIChtZFRoZW1lICYmIG1kVGhlbWUgIT09IGN1cnJlbnRUaGVtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWRUaGVtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdldFBhcmVudFRoZW1lTmFtZSgkcGFyZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3RoaXMudGhlbWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGdldFBhcmVudFRoZW1lTmFtZShjb21wb25lbnQuJHBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0VGhlbWVOYW1lOiBmdW5jdGlvbiBnZXRUaGVtZU5hbWUodGhlbWUpIHtcbiAgICAgIHZhciB0aGVtZU5hbWUgPSB0aGVtZSB8fCB0aGlzLnRoZW1lO1xuXG4gICAgICByZXR1cm4gdGhpcy5wcmVmaXggKyB0aGVtZU5hbWU7XG4gICAgfSxcbiAgICBzZXRNaWNyb3NvZnRDb2xvcnM6IGZ1bmN0aW9uIHNldE1pY3Jvc29mdENvbG9ycyhwcmltYXJ5Q29sb3IpIHtcbiAgICAgIGlmIChtc0NvbG9yKSB7XG4gICAgICAgIG1zQ29sb3Iuc2V0QXR0cmlidXRlKCdjb250ZW50JywgcHJpbWFyeUNvbG9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFRoZW1lQ29sb3JzOiBmdW5jdGlvbiBzZXRUaGVtZUNvbG9ycyhwcmltYXJ5Q29sb3IpIHtcbiAgICAgIGlmICh0aGVtZUNvbG9yKSB7XG4gICAgICAgIHRoZW1lQ29sb3Iuc2V0QXR0cmlidXRlKCdjb250ZW50JywgcHJpbWFyeUNvbG9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldE1hc2tDb2xvcnM6IGZ1bmN0aW9uIHNldE1hc2tDb2xvcnMocHJpbWFyeUNvbG9yKSB7XG4gICAgICBpZiAobWFza0ljb24pIHtcbiAgICAgICAgbWFza0ljb24uc2V0QXR0cmlidXRlKCdjb2xvcicsIHByaW1hcnlDb2xvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRIdG1sTWV0YUNvbG9yczogZnVuY3Rpb24gc2V0SHRtbE1ldGFDb2xvcnModGhlbWVOYW1lKSB7XG4gICAgICB2YXIgcHJpbWFyeUNvbG9yID0gJyNmZmYnO1xuXG4gICAgICBpZiAodGhlbWVOYW1lKSB7XG4gICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICBwcmltYXJ5Q29sb3IgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJy0tJyArIHRoZW1lTmFtZSArICctcHJpbWFyeScpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpbWFyeUNvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0TWljcm9zb2Z0Q29sb3JzKHByaW1hcnlDb2xvcik7XG4gICAgICAgIHRoaXMuc2V0VGhlbWVDb2xvcnMocHJpbWFyeUNvbG9yKTtcbiAgICAgICAgdGhpcy5zZXRNYXNrQ29sb3JzKHByaW1hcnlDb2xvcik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgbXNDb2xvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tuYW1lPVwibXNhcHBsaWNhdGlvbi1UaWxlQ29sb3JcIl0nKTtcbiAgICB0aGVtZUNvbG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW25hbWU9XCJ0aGVtZS1jb2xvclwiXScpO1xuICAgIG1hc2tJY29uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW3JlbD1cIm1hc2staWNvblwiXScpO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCAmJiB0aGlzLm1ldGFDb2xvcnMpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2V0SHRtbE1ldGFDb2xvcnMoX3RoaXMyLmZ1bGxUaGVtZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG5cdHZhciBjbG9uZSA9ICFvcHRpb25zQXJndW1lbnQgfHwgb3B0aW9uc0FyZ3VtZW50LmNsb25lICE9PSBmYWxzZTtcblxuXHRyZXR1cm4gKGNsb25lICYmIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zQXJndW1lbnQpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9uc0FyZ3VtZW50KVxuXHR9KVxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9uc0FyZ3VtZW50KSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAoaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9uc0FyZ3VtZW50KTtcblx0XHR9KTtcblx0fVxuXHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKCFpc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkgfHwgIXRhcmdldFtrZXldKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnNBcmd1bWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBkZWVwbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zQXJndW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudCkge1xuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBvcHRpb25zID0gb3B0aW9uc0FyZ3VtZW50IHx8IHsgYXJyYXlNZXJnZTogZGVmYXVsdEFycmF5TWVyZ2UgfTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnNBcmd1bWVudClcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0dmFyIGFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdFx0cmV0dXJuIGFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudClcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnNBcmd1bWVudClcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zQXJndW1lbnQpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9uc0FyZ3VtZW50KVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChkZWVwbWVyZ2VfMSk7XG5cblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JhZiA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfcmFmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZik7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIG1kQXBwTW9kZXMgPSBbJ2ZpeGVkJywgJ2ZpeGVkLWxhc3QnLCAncmV2ZWFsJywgJ292ZXJsYXAnLCAnZmxleGlibGUnXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBwcm9wczoge1xuICAgIG1kTW9kZTogX2V4dGVuZHMoe1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1tb2RlJywgbWRBcHBNb2RlcykpLFxuICAgIG1kV2F0ZXJmYWxsOiBCb29sZWFuLFxuICAgIG1kU2Nyb2xsYmFyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmV2ZWFsVGltZXI6IG51bGwsXG4gICAgICByZXZlYWxMYXN0UG9zOiAwLFxuICAgICAgbWFudWFsVGljazogZmFsc2UsXG4gICAgICBNZEFwcDoge1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgbW9kZTogbnVsbCxcbiAgICAgICAgICB3YXRlcmZhbGw6IGZhbHNlLFxuICAgICAgICAgIGZsZXhpYmxlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0b29sYmFyOiB7XG4gICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICB0aXRsZUVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgaGVpZ2h0OiAnMHB4JyxcbiAgICAgICAgICBpbml0aWFsSGVpZ2h0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICB0aXRsZVNpemU6IDIwLFxuICAgICAgICAgIGhhc0VsZXZhdGlvbjogdHJ1ZSxcbiAgICAgICAgICByZXZlYWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICAgIGZpeGVkTGFzdEFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgZml4ZWRMYXN0SGVpZ2h0OiBmYWxzZSxcbiAgICAgICAgICBvdmVybGFwT2ZmOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkcmF3ZXI6IHtcbiAgICAgICAgICBpbml0aWFsV2lkdGg6IDAsXG4gICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICBtb2RlOiAndGVtcG9yYXJ5JyxcbiAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTWRBcHA6IHRoaXMuTWRBcHBcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgY29udGVudFN0eWxlczogZnVuY3Rpb24gY29udGVudFN0eWxlcygpIHtcbiAgICAgIHZhciBkcmF3ZXIgPSB0aGlzLk1kQXBwLmRyYXdlcjtcblxuICAgICAgaWYgKGRyYXdlci5hY3RpdmUgJiYgZHJhd2VyLm1vZGUgPT09ICdwZXJzaXN0ZW50JyAmJiBkcmF3ZXIuc3VibW9kZSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IGRyYXdlci53aWR0aFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGFpbmVyU3R5bGVzOiBmdW5jdGlvbiBjb250YWluZXJTdHlsZXMoKSB7XG4gICAgICB2YXIgZHJhd2VyID0gdGhpcy5NZEFwcC5kcmF3ZXI7XG4gICAgICB2YXIgc3R5bGVzID0ge307XG5cbiAgICAgIGlmICh0aGlzLm1kTW9kZSAmJiB0aGlzLm1kTW9kZSAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBzdHlsZXNbJ21hcmdpbi10b3AnXSA9IHRoaXMuTWRBcHAudG9vbGJhci5pbml0aWFsSGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXdlci5tb2RlID09PSAncGVyc2lzdGVudCcgJiYgZHJhd2VyLnN1Ym1vZGUgPT09ICdtaW5pJykge1xuICAgICAgICBzdHlsZXNbJ3BhZGRpbmctbGVmdCddID0gIWRyYXdlci5hY3RpdmUgPyBkcmF3ZXIuaW5pdGlhbFdpZHRoICsgJ3B4JyA6IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcbiAgICBzY3JvbGxlckNsYXNzZXM6IGZ1bmN0aW9uIHNjcm9sbGVyQ2xhc3NlcygpIHtcbiAgICAgIGlmICh0aGlzLm1kU2Nyb2xsYmFyKSB7XG4gICAgICAgIHJldHVybiAnbWQtc2Nyb2xsYmFyJztcbiAgICAgIH1cbiAgICB9LFxuICAgIGFwcENsYXNzZXM6IGZ1bmN0aW9uIGFwcENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtd2F0ZXJmYWxsJzogdGhpcy5tZFdhdGVyZmFsbCxcbiAgICAgICAgJ21kLWZsZXhpYmxlJzogdGhpcy5tZE1vZGUgPT09ICdmbGV4aWJsZScsXG4gICAgICAgICdtZC1maXhlZCc6IHRoaXMubWRNb2RlID09PSAnZml4ZWQnLFxuICAgICAgICAnbWQtZml4ZWQtbGFzdCc6IHRoaXMubWRNb2RlID09PSAnZml4ZWQtbGFzdCcsXG4gICAgICAgICdtZC1yZXZlYWwnOiB0aGlzLm1kTW9kZSA9PT0gJ3JldmVhbCcsXG4gICAgICAgICdtZC1vdmVybGFwJzogdGhpcy5tZE1vZGUgPT09ICdvdmVybGFwJyxcbiAgICAgICAgJ21kLWRyYXdlci1hY3RpdmUnOiB0aGlzLk1kQXBwLmRyYXdlci5hY3RpdmVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG1kTW9kZTogZnVuY3Rpb24gbWRNb2RlKG1vZGUpIHtcbiAgICAgIHRoaXMuTWRBcHAub3B0aW9ucy5tb2RlID0gbW9kZTtcbiAgICB9LFxuICAgIG1kV2F0ZXJmYWxsOiBmdW5jdGlvbiBtZFdhdGVyZmFsbCh3YXRlcmZhbGwpIHtcbiAgICAgIHRoaXMuTWRBcHAub3B0aW9ucy53YXRlcmZhbGwgPSB3YXRlcmZhbGw7XG4gICAgICB0aGlzLnNldFRvb2xiYXJFbGV2YXRpb24oKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRUb29sYmFyRWxldmF0aW9uOiBmdW5jdGlvbiBzZXRUb29sYmFyRWxldmF0aW9uKCkge1xuICAgICAgdGhpcy5NZEFwcC50b29sYmFyLmhhc0VsZXZhdGlvbiA9ICF0aGlzLm1kV2F0ZXJmYWxsO1xuICAgIH0sXG4gICAgc2V0VG9vbGJhclRpbWVyOiBmdW5jdGlvbiBzZXRUb29sYmFyVGltZXIoc2Nyb2xsVG9wKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmV2ZWFsVGltZXIpO1xuXG4gICAgICB0aGlzLnJldmVhbFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5yZXZlYWxMYXN0UG9zID0gc2Nyb2xsVG9wO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuICAgIHNldFRvb2xiYXJNYXJnaW5BbmRIZWlnaHQ6IGZ1bmN0aW9uIHNldFRvb2xiYXJNYXJnaW5BbmRIZWlnaHQobWFyZ2luLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuTWRBcHAudG9vbGJhci50b3AgPSBtYXJnaW47XG4gICAgICB0aGlzLk1kQXBwLnRvb2xiYXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0sXG4gICAgZ2V0VG9vbGJhckNvbnN0cmFudHM6IGZ1bmN0aW9uIGdldFRvb2xiYXJDb25zdHJhbnRzKCRldmVudCkge1xuICAgICAgdmFyIHRvb2xiYXJIZWlnaHQgPSB0aGlzLk1kQXBwLnRvb2xiYXIuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgc2FmZUFtb3VudCA9IDEwO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IHRvb2xiYXJIZWlnaHQgKyBzYWZlQW1vdW50O1xuICAgICAgdmFyIHNjcm9sbFRvcCA9ICRldmVudC50YXJnZXQuc2Nyb2xsVG9wO1xuXG4gICAgICBpZiAoIXRoaXMuTWRBcHAudG9vbGJhci5pbml0aWFsSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5pbml0aWFsSGVpZ2h0ID0gdG9vbGJhckhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9vbGJhckhlaWdodDogdG9vbGJhckhlaWdodCxcbiAgICAgICAgc2FmZUFtb3VudDogc2FmZUFtb3VudCxcbiAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGQsXG4gICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wLFxuICAgICAgICBpbml0aWFsSGVpZ2h0OiB0aGlzLk1kQXBwLnRvb2xiYXIuaW5pdGlhbEhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIGhhbmRsZVdhdGVyZmFsbFNjcm9sbDogZnVuY3Rpb24gaGFuZGxlV2F0ZXJmYWxsU2Nyb2xsKCRldmVudCkge1xuICAgICAgdmFyIF9nZXRUb29sYmFyQ29uc3RyYW50cyA9IHRoaXMuZ2V0VG9vbGJhckNvbnN0cmFudHMoJGV2ZW50KSxcbiAgICAgICAgICB0aHJlc2hvbGQgPSBfZ2V0VG9vbGJhckNvbnN0cmFudHMudGhyZXNob2xkLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9nZXRUb29sYmFyQ29uc3RyYW50cy5zY3JvbGxUb3A7XG5cbiAgICAgIHZhciBlbGV2YXRpb25NYXJrID0gNDtcblxuICAgICAgaWYgKHRoaXMubWRNb2RlID09PSAncmV2ZWFsJykge1xuICAgICAgICBlbGV2YXRpb25NYXJrID0gdGhyZXNob2xkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLk1kQXBwLnRvb2xiYXIuaGFzRWxldmF0aW9uID0gc2Nyb2xsVG9wID49IGVsZXZhdGlvbk1hcms7XG4gICAgfSxcbiAgICBoYW5kbGVGbGV4aWJsZU1vZGU6IGZ1bmN0aW9uIGhhbmRsZUZsZXhpYmxlTW9kZSgkZXZlbnQpIHtcbiAgICAgIHZhciBfZ2V0VG9vbGJhckNvbnN0cmFudHMyID0gdGhpcy5nZXRUb29sYmFyQ29uc3RyYW50cygkZXZlbnQpLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czIuc2Nyb2xsVG9wLFxuICAgICAgICAgIGluaXRpYWxIZWlnaHQgPSBfZ2V0VG9vbGJhckNvbnN0cmFudHMyLmluaXRpYWxIZWlnaHQ7XG5cbiAgICAgIHZhciB0b29sYmFyID0gdGhpcy5NZEFwcC50b29sYmFyLmVsZW1lbnQ7XG4gICAgICB2YXIgZmlyc3RSb3cgPSB0b29sYmFyLnF1ZXJ5U2VsZWN0b3IoJy5tZC10b29sYmFyLXJvdzpmaXJzdC1jaGlsZCcpO1xuICAgICAgdmFyIGZpcnN0Um93SGVpZ2h0ID0gZmlyc3RSb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgdmFyIHNjcm9sbEFtb3VudCA9IGluaXRpYWxIZWlnaHQgLSBzY3JvbGxUb3A7XG4gICAgICB2YXIgc2hvdWxkS2VlcEZsZXhpYmxlID0gc2Nyb2xsVG9wIDwgaW5pdGlhbEhlaWdodCAtIGZpcnN0Um93SGVpZ2h0O1xuXG4gICAgICBpZiAoZmlyc3RSb3dIZWlnaHQpIHtcbiAgICAgICAgaWYgKHNob3VsZEtlZXBGbGV4aWJsZSkge1xuICAgICAgICAgIHRvb2xiYXIuc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsQW1vdW50ICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b29sYmFyLnN0eWxlLmhlaWdodCA9IGZpcnN0Um93SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGl0bGVFbGVtZW50ID0gdGhpcy5NZEFwcC50b29sYmFyLnRpdGxlRWxlbWVudDtcbiAgICAgIGlmICh0aXRsZUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRhcmdldFNpemUgPSAyMDtcbiAgICAgICAgdmFyIGluaXRpYWxTaXplID0gdGhpcy5NZEFwcC50b29sYmFyLnRpdGxlU2l6ZTtcblxuICAgICAgICBpZiAoc2hvdWxkS2VlcEZsZXhpYmxlKSB7XG4gICAgICAgICAgdmFyIG5ld1NpemUgPSBNYXRoLm1heCgwLCAxIC0gKHNjcm9sbFRvcCAtIGluaXRpYWxTaXplKSAvIChzY3JvbGxBbW91bnQgKyBpbml0aWFsU2l6ZSArIDAuMDAwMDAxKSkgKiAoaW5pdGlhbFNpemUgLSB0YXJnZXRTaXplKSArIHRhcmdldFNpemU7XG5cbiAgICAgICAgICB0aXRsZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSBuZXdTaXplICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aXRsZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMjBweCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9nZXRUb29sYmFyQ29uc3RyYW50czMgPSB0aGlzLmdldFRvb2xiYXJDb25zdHJhbnRzKCRldmVudCksXG4gICAgICAgICAgdGhyZXNob2xkID0gX2dldFRvb2xiYXJDb25zdHJhbnRzMy50aHJlc2hvbGQsXG4gICAgICAgICAgdG9vbGJhckhlaWdodCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czMudG9vbGJhckhlaWdodDtcblxuICAgICAgdGhpcy5zZXRUb29sYmFyTWFyZ2luQW5kSGVpZ2h0KHNjcm9sbFRvcCAtIHRocmVzaG9sZCwgdG9vbGJhckhlaWdodCk7XG4gICAgfSxcbiAgICBoYW5kbGVSZXZlYWxNb2RlOiBmdW5jdGlvbiBoYW5kbGVSZXZlYWxNb2RlKCRldmVudCkge1xuICAgICAgdmFyIF9nZXRUb29sYmFyQ29uc3RyYW50czQgPSB0aGlzLmdldFRvb2xiYXJDb25zdHJhbnRzKCRldmVudCksXG4gICAgICAgICAgdG9vbGJhckhlaWdodCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czQudG9vbGJhckhlaWdodCxcbiAgICAgICAgICBzYWZlQW1vdW50ID0gX2dldFRvb2xiYXJDb25zdHJhbnRzNC5zYWZlQW1vdW50LFxuICAgICAgICAgIHRocmVzaG9sZCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czQudGhyZXNob2xkLFxuICAgICAgICAgIHNjcm9sbFRvcCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czQuc2Nyb2xsVG9wO1xuXG4gICAgICB0aGlzLnNldFRvb2xiYXJUaW1lcihzY3JvbGxUb3ApO1xuICAgICAgdGhpcy5zZXRUb29sYmFyTWFyZ2luQW5kSGVpZ2h0KHNjcm9sbFRvcCAtIHRocmVzaG9sZCwgdG9vbGJhckhlaWdodCk7XG5cbiAgICAgIGlmIChzY3JvbGxUb3AgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5yZXZlYWxBY3RpdmUgPSB0aGlzLnJldmVhbExhc3RQb3MgPiBzY3JvbGxUb3AgKyBzYWZlQW1vdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5NZEFwcC50b29sYmFyLnJldmVhbEFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVGaXhlZExhc3RNb2RlOiBmdW5jdGlvbiBoYW5kbGVGaXhlZExhc3RNb2RlKCRldmVudCkge1xuICAgICAgdmFyIF9nZXRUb29sYmFyQ29uc3RyYW50czUgPSB0aGlzLmdldFRvb2xiYXJDb25zdHJhbnRzKCRldmVudCksXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX2dldFRvb2xiYXJDb25zdHJhbnRzNS5zY3JvbGxUb3AsXG4gICAgICAgICAgdG9vbGJhckhlaWdodCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czUudG9vbGJhckhlaWdodCxcbiAgICAgICAgICBzYWZlQW1vdW50ID0gX2dldFRvb2xiYXJDb25zdHJhbnRzNS5zYWZlQW1vdW50O1xuXG4gICAgICB2YXIgdG9vbGJhciA9IHRoaXMuTWRBcHAudG9vbGJhci5lbGVtZW50O1xuICAgICAgdmFyIGZpcnN0Um93ID0gdG9vbGJhci5xdWVyeVNlbGVjdG9yKCcubWQtdG9vbGJhci1yb3c6Zmlyc3QtY2hpbGQnKTtcbiAgICAgIHZhciBmaXJzdFJvd0hlaWdodCA9IGZpcnN0Um93Lm9mZnNldEhlaWdodDtcblxuICAgICAgdGhpcy5zZXRUb29sYmFyVGltZXIoc2Nyb2xsVG9wKTtcbiAgICAgIHRoaXMuc2V0VG9vbGJhck1hcmdpbkFuZEhlaWdodChzY3JvbGxUb3AgLSBmaXJzdFJvd0hlaWdodCwgdG9vbGJhckhlaWdodCk7XG4gICAgICB0aGlzLk1kQXBwLnRvb2xiYXIuZml4ZWRMYXN0SGVpZ2h0ID0gZmlyc3RSb3dIZWlnaHQ7XG5cbiAgICAgIGlmIChzY3JvbGxUb3AgPj0gZmlyc3RSb3dIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5NZEFwcC50b29sYmFyLmZpeGVkTGFzdEFjdGl2ZSA9IHRoaXMucmV2ZWFsTGFzdFBvcyA+IHNjcm9sbFRvcCArIHNhZmVBbW91bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLk1kQXBwLnRvb2xiYXIuZml4ZWRMYXN0QWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZU92ZXJsYXBNb2RlOiBmdW5jdGlvbiBoYW5kbGVPdmVybGFwTW9kZSgkZXZlbnQpIHtcbiAgICAgIHZhciBfZ2V0VG9vbGJhckNvbnN0cmFudHM2ID0gdGhpcy5nZXRUb29sYmFyQ29uc3RyYW50cygkZXZlbnQpLFxuICAgICAgICAgIHRvb2xiYXJIZWlnaHQgPSBfZ2V0VG9vbGJhckNvbnN0cmFudHM2LnRvb2xiYXJIZWlnaHQsXG4gICAgICAgICAgc2Nyb2xsVG9wID0gX2dldFRvb2xiYXJDb25zdHJhbnRzNi5zY3JvbGxUb3AsXG4gICAgICAgICAgaW5pdGlhbEhlaWdodCA9IF9nZXRUb29sYmFyQ29uc3RyYW50czYuaW5pdGlhbEhlaWdodDtcblxuICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLk1kQXBwLnRvb2xiYXIuZWxlbWVudDtcbiAgICAgIHZhciBmaXJzdFJvdyA9IHRvb2xiYXIucXVlcnlTZWxlY3RvcignLm1kLXRvb2xiYXItcm93OmZpcnN0LWNoaWxkJyk7XG4gICAgICB2YXIgZmlyc3RSb3dIZWlnaHQgPSBmaXJzdFJvdy5vZmZzZXRIZWlnaHQ7XG4gICAgICB2YXIgbmV3SGVpZ2h0ID0gaW5pdGlhbEhlaWdodCAtIHNjcm9sbFRvcCAtIHNjcm9sbFRvcCAqIDEwMCAvIChpbml0aWFsSGVpZ2h0IC0gZmlyc3RSb3dIZWlnaHQgLSBmaXJzdFJvd0hlaWdodCAvIDEuNSk7XG5cbiAgICAgIGlmIChmaXJzdFJvd0hlaWdodCkge1xuICAgICAgICBpZiAoc2Nyb2xsVG9wIDwgaW5pdGlhbEhlaWdodCAtIGZpcnN0Um93SGVpZ2h0ICYmIG5ld0hlaWdodCA+PSBmaXJzdFJvd0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5vdmVybGFwT2ZmID0gZmFsc2U7XG4gICAgICAgICAgdG9vbGJhci5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5vdmVybGFwT2ZmID0gdHJ1ZTtcbiAgICAgICAgICB0b29sYmFyLnN0eWxlLmhlaWdodCA9IGZpcnN0Um93SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFRvb2xiYXJNYXJnaW5BbmRIZWlnaHQoc2Nyb2xsVG9wLCB0b29sYmFySGVpZ2h0KTtcbiAgICB9LFxuICAgIGhhbmRsZU1vZGVTY3JvbGw6IGZ1bmN0aW9uIGhhbmRsZU1vZGVTY3JvbGwoJGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5tZE1vZGUgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmV2ZWFsTW9kZSgkZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1kTW9kZSA9PT0gJ2ZpeGVkLWxhc3QnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRml4ZWRMYXN0TW9kZSgkZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1kTW9kZSA9PT0gJ292ZXJsYXAnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlT3ZlcmxhcE1vZGUoJGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tZE1vZGUgPT09ICdmbGV4aWJsZScpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbGV4aWJsZU1vZGUoJGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVNjcm9sbDogZnVuY3Rpb24gaGFuZGxlU2Nyb2xsKCRldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLk1kQXBwLnRvb2xiYXIuZWxlbWVudCkge1xuICAgICAgICAoMCwgX3JhZjIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczIubWRXYXRlcmZhbGwpIHtcbiAgICAgICAgICAgIF90aGlzMi5oYW5kbGVXYXRlcmZhbGxTY3JvbGwoJGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3RoaXMyLm1kTW9kZSkge1xuICAgICAgICAgICAgX3RoaXMyLmhhbmRsZU1vZGVTY3JvbGwoJGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLk1kQXBwLm9wdGlvbnMubW9kZSA9IHRoaXMubWRNb2RlO1xuICAgIHRoaXMuTWRBcHAub3B0aW9ucy53YXRlcmZhbGwgPSB0aGlzLm1kV2F0ZXJmYWxsO1xuICAgIHRoaXMuc2V0VG9vbGJhckVsZXZhdGlvbigpO1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBmYWtlRXZlbnQgPSB7XG4gICAgICB0YXJnZXQ6IHtcbiAgICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0aGlzLm1kTW9kZSA9PT0gJ3JldmVhbCcpIHtcbiAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5yZXZlYWxBY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5oYW5kbGVSZXZlYWxNb2RlKGZha2VFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWRNb2RlID09PSAnZmxleGlibGUnKSB7XG4gICAgICB0aGlzLk1kQXBwLnRvb2xiYXIucmV2ZWFsQWN0aXZlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGFuZGxlRmxleGlibGVNb2RlKGZha2VFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWRNb2RlID09PSAnZml4ZWQtbGFzdCcpIHtcbiAgICAgIHRoaXMuTWRBcHAudG9vbGJhci5maXhlZExhc3RBY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5oYW5kbGVGaXhlZExhc3RNb2RlKGZha2VFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWRNb2RlID09PSAnb3ZlcmxhcCcpIHtcbiAgICAgIHRoaXMuaGFuZGxlT3ZlcmxhcE1vZGUoZmFrZUV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFJlYWN0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfTWRSZWFjdGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJlYWN0aXZlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGhhc0V2ZW50cyA9IGZhbHNlO1xudmFyIGV2ZW50VGFyZ2V0ID0gbnVsbDtcbnZhciBzdXBwb3J0c1Bhc3NpdmVFdmVudCA9IGZhbHNlO1xudmFyIE1kRm9jdXNlZCA9IG5ldyBfTWRSZWFjdGl2ZTIuZGVmYXVsdCh7XG4gIGN1cnJlbnRFbGVtZW50OiBudWxsXG59KTtcblxuZnVuY3Rpb24gY2hlY2tQYXNzaXZlRXZlbnRTdXBwb3J0KCkge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmVFdmVudCA9IHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdnaG9zdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiBzZXRLZXlib2FyZEludGVyYWN0aW9uKF9yZWYpIHtcbiAgdmFyIGtleUNvZGUgPSBfcmVmLmtleUNvZGUsXG4gICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldDtcblxuICBNZEZvY3VzZWQuY3VycmVudEVsZW1lbnQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHNldE1vdXNlQW5kVG91Y2hJbnRlcmFjdGlvbihldmVudCkge1xuICBNZEZvY3VzZWQuY3VycmVudEVsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlib2FyZEV2ZW50cygpIHtcbiAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBzZXRLZXlib2FyZEludGVyYWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRlckV2ZW50cygpIHtcbiAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgc2V0TW91c2VBbmRUb3VjaEludGVyYWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTVNQb2ludGVyRXZlbnRzKCkge1xuICBldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJVcCcsIHNldE1vdXNlQW5kVG91Y2hJbnRlcmFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vdXNlQW5kVG91Y2hFdmVudHMoKSB7XG4gIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzZXRNb3VzZUFuZFRvdWNoSW50ZXJhY3Rpb24pO1xuXG4gIGlmICgnb250b3VjaGVuZCcgaW4gd2luZG93KSB7XG4gICAgZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBzZXRNb3VzZUFuZFRvdWNoSW50ZXJhY3Rpb24sIHN1cHBvcnRzUGFzc2l2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIGNyZWF0ZVBvaW50ZXJFdmVudHMoKTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcbiAgICBjcmVhdGVNU1BvaW50ZXJFdmVudHMoKTtcbiAgfSBlbHNlIHtcbiAgICBjcmVhdGVNb3VzZUFuZFRvdWNoRXZlbnRzKCk7XG4gIH1cblxuICBjcmVhdGVLZXlib2FyZEV2ZW50cygpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gIGlmICghaGFzRXZlbnRzKSB7XG4gICAgZXZlbnRUYXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNoZWNrUGFzc2l2ZUV2ZW50U3VwcG9ydCgpO1xuICAgIGJpbmRFdmVudHMoKTtcbiAgICBoYXNFdmVudHMgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWRIYXNGb2N1czogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGZvY3VzZWRFbGVtZW50OiBmdW5jdGlvbiBmb2N1c2VkRWxlbWVudCgpIHtcbiAgICAgIHJldHVybiBNZEZvY3VzZWQuY3VycmVudEVsZW1lbnQ7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGZvY3VzZWRFbGVtZW50OiBmdW5jdGlvbiBmb2N1c2VkRWxlbWVudChlbCkge1xuICAgICAgdGhpcy5tZEhhc0ZvY3VzID0gZWwgPT09IHRoaXMuJGVsO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICBjcmVhdGVFdmVudHMoKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9NZFJpcHBsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJpcHBsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgY29tcG9uZW50czoge1xuICAgIE1kUmlwcGxlOiBfTWRSaXBwbGUyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtb2RlbDogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuLCBBcnJheV0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlciwgQm9vbGVhbl0sXG4gICAgICBkZWZhdWx0OiAnb24nXG4gICAgfSxcbiAgICBuYW1lOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ21vZGVsJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmlwcGxlQWN0aXZlOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIGlmICh0aGlzLmlzTW9kZWxBcnJheSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5pbmNsdWRlcyh0aGlzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNNb2RlbEJvb2xlYW4gJiYgdGhpcy52YWx1ZSA9PT0gJ29uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubW9kZWwgPT09IHRoaXMudmFsdWU7XG4gICAgfSxcbiAgICBpc01vZGVsQXJyYXk6IGZ1bmN0aW9uIGlzTW9kZWxBcnJheSgpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMubW9kZWwpO1xuICAgIH0sXG4gICAgaXNNb2RlbEJvb2xlYW46IGZ1bmN0aW9uIGlzTW9kZWxCb29sZWFuKCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm1vZGVsID09PSAnYm9vbGVhbic7XG4gICAgfSxcbiAgICBjaGVja0NsYXNzZXM6IGZ1bmN0aW9uIGNoZWNrQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC1jaGVja2VkJzogdGhpcy5pc1NlbGVjdGVkLFxuICAgICAgICAnbWQtZGlzYWJsZWQnOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICAnbWQtcmVxdWlyZWQnOiB0aGlzLnJlcXVpcmVkXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHJlbW92ZUl0ZW1Gcm9tTW9kZWw6IGZ1bmN0aW9uIHJlbW92ZUl0ZW1Gcm9tTW9kZWwobmV3TW9kZWwpIHtcbiAgICAgIHZhciBpbmRleCA9IG5ld01vZGVsLmluZGV4T2YodGhpcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbmV3TW9kZWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUFycmF5Q2hlY2tib3g6IGZ1bmN0aW9uIGhhbmRsZUFycmF5Q2hlY2tib3goKSB7XG4gICAgICB2YXIgbmV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgICBuZXdNb2RlbC5wdXNoKHRoaXMudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtRnJvbU1vZGVsKG5ld01vZGVsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgbmV3TW9kZWwpO1xuICAgIH0sXG4gICAgaGFuZGxlU3RyaW5nQ2hlY2tib3g6IGZ1bmN0aW9uIGhhbmRsZVN0cmluZ0NoZWNrYm94KCkge1xuICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBudWxsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUJvb2xlYW5DaGVja2JveDogZnVuY3Rpb24gaGFuZGxlQm9vbGVhbkNoZWNrYm94KCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgIXRoaXMubW9kZWwpO1xuICAgIH0sXG4gICAgdG9nZ2xlQ2hlY2s6IGZ1bmN0aW9uIHRvZ2dsZUNoZWNrKCkge1xuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMucmlwcGxlQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5pc01vZGVsQXJyYXkpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUFycmF5Q2hlY2tib3goKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTW9kZWxCb29sZWFuKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVCb29sZWFuQ2hlY2tib3goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVN0cmluZ0NoZWNrYm94KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kQ2xlYXJJY29uLnZ1ZVxudmFyIE1kQ2xlYXJJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDkpO1xudmFyIE1kQ2xlYXJJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2xlYXJJY29uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mNTMxMjZiYVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29yZS9pY29ucy9NZENsZWFySWNvbi52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDEsIGZhbHNlLCB0cnVlKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcInN2Z1wiLFxuICAgICAge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGhlaWdodDogXCIyNFwiLFxuICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGQ6XG4gICAgICAgICAgICAgIFwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAgMGgyNHYyNEgwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pXG4gICAgICBdXG4gICAgKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1pY29uLWltYWdlXCIgfSwgW1xuICAgICAgX3ZtLl9tKDAsIGZhbHNlLCB0cnVlKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGljb25zX01kQ2xlYXJJY29uID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1mNTMxMjZiYVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaWNvbnMvTWRDbGVhckljb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENsZWFySWNvbl9kZWZhdWx0LmEsXG4gIGljb25zX01kQ2xlYXJJY29uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvcmUvaWNvbnMvTWRDbGVhckljb24udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZjUzMTI2YmFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mNTMxMjZiYVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9pY29uc19NZENsZWFySWNvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZENvbnRlbnRfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kQ29udGVudF92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZENvbnRlbnRfdnVlX18pO1xudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kQ29udGVudF92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENvbnRlbnQvTWRDb250ZW50LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTUwMGNjMzU1XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNTAwY2MzNTVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBhcmd1bWVudCBhbiBpbnN0YW5jZSBvZiBEYXRlP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGFyZ3VtZW50IGFuIGluc3RhbmNlIG9mIERhdGU/XG4gKlxuICogQHBhcmFtIHsqfSBhcmd1bWVudCAtIHRoZSBhcmd1bWVudCB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElzICdtYXlvbm5haXNlJyBhIERhdGU/XG4gKiB2YXIgcmVzdWx0ID0gaXNEYXRlKCdtYXlvbm5haXNlJylcbiAqIC8vPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNEYXRlXG5cblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG52YXIgc3RhcnRPZklTT1dlZWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBJU08gV2Vlay1OdW1iZXJpbmcgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZSxcbiAqIHdoaWNoIGFsd2F5cyBzdGFydHMgMyBkYXlzIGJlZm9yZSB0aGUgeWVhcidzIGZpcnN0IFRodXJzZGF5LlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBnaXZlbiBkYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgSVNPIHdlZWstbnVtYmVyaW5nIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggSVNPLXdlZWsgbnVtYmVyaW5nIHllYXIgaXMgMiBKYW51YXJ5IDIwMDU/XG4gKiB2YXIgcmVzdWx0ID0gZ2V0SVNPWWVhcihuZXcgRGF0ZSgyMDA1LCAwLCAyKSlcbiAqIC8vPT4gMjAwNFxuICovXG5mdW5jdGlvbiBnZXRJU09ZZWFyIChkaXJ0eURhdGUpIHtcbiAgdmFyIGRhdGUgPSBwYXJzZShkaXJ0eURhdGUpXG4gIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpXG5cbiAgdmFyIGZvdXJ0aE9mSmFudWFyeU9mTmV4dFllYXIgPSBuZXcgRGF0ZSgwKVxuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldEZ1bGxZZWFyKHllYXIgKyAxLCAwLCA0KVxuICBmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHZhciBzdGFydE9mTmV4dFllYXIgPSBzdGFydE9mSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZk5leHRZZWFyKVxuXG4gIHZhciBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyID0gbmV3IERhdGUoMClcbiAgZm91cnRoT2ZKYW51YXJ5T2ZUaGlzWWVhci5zZXRGdWxsWWVhcih5ZWFyLCAwLCA0KVxuICBmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHZhciBzdGFydE9mVGhpc1llYXIgPSBzdGFydE9mSVNPV2Vlayhmb3VydGhPZkphbnVhcnlPZlRoaXNZZWFyKVxuXG4gIGlmIChkYXRlLmdldFRpbWUoKSA+PSBzdGFydE9mTmV4dFllYXIuZ2V0VGltZSgpKSB7XG4gICAgcmV0dXJuIHllYXIgKyAxXG4gIH0gZWxzZSBpZiAoZGF0ZS5nZXRUaW1lKCkgPj0gc3RhcnRPZlRoaXNZZWFyLmdldFRpbWUoKSkge1xuICAgIHJldHVybiB5ZWFyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHllYXIgLSAxXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJU09ZZWFyXG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNEYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNilcblxuLyoqXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIHZhbGlkP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBmYWxzZSBpZiBhcmd1bWVudCBpcyBJbnZhbGlkIERhdGUgYW5kIHRydWUgb3RoZXJ3aXNlLlxuICogSW52YWxpZCBEYXRlIGlzIGEgRGF0ZSwgd2hvc2UgdGltZSB2YWx1ZSBpcyBOYU4uXG4gKlxuICogVGltZSB2YWx1ZSBvZiBEYXRlOiBodHRwOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjkuMS4xXG4gKlxuICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gdGhlIGRhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZSBpcyB2YWxpZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIERhdGVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRm9yIHRoZSB2YWxpZCBkYXRlOlxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoMjAxNCwgMSwgMzEpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZvciB0aGUgaW52YWxpZCBkYXRlOlxuICogdmFyIHJlc3VsdCA9IGlzVmFsaWQobmV3IERhdGUoJycpKVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkIChkaXJ0eURhdGUpIHtcbiAgaWYgKGlzRGF0ZShkaXJ0eURhdGUpKSB7XG4gICAgcmV0dXJuICFpc05hTihkaXJ0eURhdGUpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZy5jYWxsKGRpcnR5RGF0ZSkgKyAnIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBEYXRlJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVmFsaWRcblxuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcbnZhciBnZXREYXlzSW5Nb250aCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpXG5cbi8qKlxuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbW9udGhzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbW9udGhzIHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIG1vbnRocyBhZGRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBZGQgNSBtb250aHMgdG8gMSBTZXB0ZW1iZXIgMjAxNDpcbiAqIHZhciByZXN1bHQgPSBhZGRNb250aHMobmV3IERhdGUoMjAxNCwgOCwgMSksIDUpXG4gKiAvLz0+IFN1biBGZWIgMDEgMjAxNSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBhZGRNb250aHMgKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgdmFyIGRhdGUgPSBwYXJzZShkaXJ0eURhdGUpXG4gIHZhciBhbW91bnQgPSBOdW1iZXIoZGlydHlBbW91bnQpXG4gIHZhciBkZXNpcmVkTW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyBhbW91bnRcbiAgdmFyIGRhdGVXaXRoRGVzaXJlZE1vbnRoID0gbmV3IERhdGUoMClcbiAgZGF0ZVdpdGhEZXNpcmVkTW9udGguc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkZXNpcmVkTW9udGgsIDEpXG4gIGRhdGVXaXRoRGVzaXJlZE1vbnRoLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHZhciBkYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoKGRhdGVXaXRoRGVzaXJlZE1vbnRoKVxuICAvLyBTZXQgdGhlIGxhc3QgZGF5IG9mIHRoZSBuZXcgbW9udGhcbiAgLy8gaWYgdGhlIG9yaWdpbmFsIGRhdGUgd2FzIHRoZSBsYXN0IGRheSBvZiB0aGUgbG9uZ2VyIG1vbnRoXG4gIGRhdGUuc2V0TW9udGgoZGVzaXJlZE1vbnRoLCBNYXRoLm1pbihkYXlzSW5Nb250aCwgZGF0ZS5nZXREYXRlKCkpKVxuICByZXR1cm4gZGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZE1vbnRoc1xuXG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF92dWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3Z1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEZvY3VzVHJhcCcsXG4gIGFic3RyYWN0OiB0cnVlLFxuICBtZXRob2RzOiB7XG4gICAgc2V0Rm9jdXM6IGZ1bmN0aW9uIHNldEZvY3VzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuJGVsLnRhZ05hbWUpIHtcbiAgICAgICAgICBfdGhpcy4kZWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgIF90aGlzLiRlbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkZWZhdWx0U2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG5cbiAgICAgIGlmICghZGVmYXVsdFNsb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2xvdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmYXVsdFNsb3RbMF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgX3Z1ZTIuZGVmYXVsdC51dGlsLndhcm4oJ01kRm9jdXNUcmFwIGNhbiBvbmx5IHJlbmRlciBvbmUsIGFuZCBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRW1wdHlTdGF0ZS9NZEVtcHR5U3RhdGUudnVlXG52YXIgTWRFbXB0eVN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDApO1xudmFyIE1kRW1wdHlTdGF0ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZEVtcHR5U3RhdGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWQ4YTg5M2EyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRW1wdHlTdGF0ZS9NZEVtcHR5U3RhdGUudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwibWQtZW1wdHktc3RhdGVcIiwgYXBwZWFyOiBcIlwiIH0gfSwgW1xuICAgIF9jKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtZW1wdHktc3RhdGVcIixcbiAgICAgICAgY2xhc3M6IFtfdm0uZW1wdHlTdGF0ZUNsYXNzZXMsIF92bS4kbWRBY3RpdmVUaGVtZV0sXG4gICAgICAgIHN0eWxlOiBfdm0uZW1wdHlTdGF0ZVN0eWxlc1xuICAgICAgfSxcbiAgICAgIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWVtcHR5LXN0YXRlLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX3ZtLm1kSWNvblxuICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgIF92bS5pc0Fzc2V0SWNvbihfdm0ubWRJY29uKVxuICAgICAgICAgICAgICAgICAgICA/IF9jKFwibWQtaWNvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1lbXB0eS1zdGF0ZS1pY29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBcIm1kLXNyY1wiOiBfdm0ubWRJY29uIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWVtcHR5LXN0YXRlLWljb25cIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5tZEljb24pKVxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF92bS5tZExhYmVsXG4gICAgICAgICAgICAgID8gX2MoXCJzdHJvbmdcIiwgeyBzdGF0aWNDbGFzczogXCJtZC1lbXB0eS1zdGF0ZS1sYWJlbFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm1kTGFiZWwpKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLm1kRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgPyBfYyhcInBcIiwgeyBzdGF0aWNDbGFzczogXCJtZC1lbXB0eS1zdGF0ZS1kZXNjcmlwdGlvblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm1kRGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLl90KFwiZGVmYXVsdFwiKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMlxuICAgICAgICApXG4gICAgICBdXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEVtcHR5U3RhdGVfTWRFbXB0eVN0YXRlID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1kOGE4OTNhMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRFbXB0eVN0YXRlL01kRW1wdHlTdGF0ZS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kRW1wdHlTdGF0ZV9kZWZhdWx0LmEsXG4gIE1kRW1wdHlTdGF0ZV9NZEVtcHR5U3RhdGUsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEVtcHR5U3RhdGUvTWRFbXB0eVN0YXRlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWQ4YTg5M2EyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZDhhODkzYTJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRFbXB0eVN0YXRlX01kRW1wdHlTdGF0ZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG1kUm91bmRlZDogQm9vbGVhbixcbiAgbWRTaXplOiB7XG4gICAgdHlwZTogTnVtYmVyLFxuICAgIGRlZmF1bHQ6IDQyMFxuICB9LFxuICBtZEljb246IFN0cmluZyxcbiAgbWRMYWJlbDogU3RyaW5nLFxuICBtZERlc2NyaXB0aW9uOiBTdHJpbmdcbn07XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfTWRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRJY29uMi5kZWZhdWx0Lm5hbWUsIF9NZEljb24yLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudS52dWVcbnZhciBNZE1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0OSk7XG52YXIgTWRNZW51X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kTWVudSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNTc3YzA2NjJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudS52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICBfdm0uX2coeyBzdGF0aWNDbGFzczogXCJtZC1tZW51XCIgfSwgX3ZtLiRsaXN0ZW5lcnMpLFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRNZW51X01kTWVudSA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNTc3YzA2NjJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kTWVudS9NZE1lbnUudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNDgpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZE1lbnVfZGVmYXVsdC5hLFxuICBNZE1lbnVfTWRNZW51LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01NzdjMDY2MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTU3N2MwNjYyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kTWVudV9NZE1lbnUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudUNvbnRlbnQudnVlXG52YXIgTWRNZW51Q29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUxKTtcbnZhciBNZE1lbnVDb250ZW50X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kTWVudUNvbnRlbnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTJjMTY3NzRjXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kTWVudS9NZE1lbnVDb250ZW50LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLXBvcG92ZXJcIixcbiAgICB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcIm1kLXNldHRpbmdzXCI6IF92bS5wb3BwZXJTZXR0aW5ncyxcbiAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnNob3VsZFJlbmRlclxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLnNob3VsZFJlbmRlclxuICAgICAgICA/IF9jKFxuICAgICAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgICAgICBfdm0uX2coXG4gICAgICAgICAgICAgIHsgYXR0cnM6IHsgbmFtZTogXCJtZC1tZW51LWNvbnRlbnRcIiwgY3NzOiBfdm0uZGlkTW91bnQgfSB9LFxuICAgICAgICAgICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZWY6IFwibWVudVwiLFxuICAgICAgICAgICAgICAgICAgY2xhc3M6IFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLm1lbnVDbGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICBfdm0ubWRDb250ZW50Q2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIF92bS4kbWRBY3RpdmVUaGVtZVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0eWxlOiBfdm0ubWVudVN0eWxlcyxcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGtleWRvd246IFtcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJyb3ctZG93blwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zZXRIaWdobGlnaHQoXCJkb3duXCIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJyb3ctdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGV2ZW50LmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2V0SGlnaGxpZ2h0KFwidXBcIilcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhKFwiYnV0dG9uXCIgaW4gJGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwic3BhY2VcIiwgMzIsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2V0U2VsZWN0aW9uKCRldmVudClcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAhKFwiYnV0dG9uXCIgaW4gJGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwiZW50ZXJcIiwgMTMsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2V0U2VsZWN0aW9uKCRldmVudClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmOiBcImNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLW1lbnUtY29udGVudC1jb250YWluZXIgbWQtc2Nyb2xsYmFyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF92bS4kbWRBY3RpdmVUaGVtZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBfdm0ubGlzdENsYXNzZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleWRvd246IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwiZXNjXCIsIDI3LCAkZXZlbnQua2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5vbkVzYygkZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWxpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmZpbHRlcmVkQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgOiBfdm0uX2UoKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTWVudV9NZE1lbnVDb250ZW50ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yYzE2Nzc0Y1wiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudUNvbnRlbnQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNTApXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZE1lbnVDb250ZW50X2RlZmF1bHQuYSxcbiAgTWRNZW51X01kTWVudUNvbnRlbnQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZE1lbnUvTWRNZW51Q29udGVudC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yYzE2Nzc0Y1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJjMTY3NzRjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kTWVudV9NZE1lbnVDb250ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGVsLCBldmVudE5hbWUsIG9ic2VydmVyRm4sIG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24ga2lsbE9ic2VydmVyKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvYnNlcnZlckZuKTtcbiAgfVxuXG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvYnNlcnZlckZuLCBvcHRpb25zIHx8IGZhbHNlKTtcblxuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGtpbGxPYnNlcnZlclxuICB9O1xufTtcblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdC52dWVcbnZhciBNZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1NCk7XG52YXIgTWRMaXN0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kTGlzdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMTZlZDE3ZWZcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ1bFwiLFxuICAgIF92bS5fZyhcbiAgICAgIF92bS5fYihcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1saXN0XCIsIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lXSB9LFxuICAgICAgICBcInVsXCIsXG4gICAgICAgIF92bS4kYXR0cnMsXG4gICAgICAgIGZhbHNlXG4gICAgICApLFxuICAgICAgX3ZtLiRsaXN0ZW5lcnNcbiAgICApLFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0X01kTGlzdCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMTZlZDE3ZWZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3QudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNTMpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZExpc3RfZGVmYXVsdC5hLFxuICBNZExpc3RfTWRMaXN0LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xNmVkMTdlZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTE2ZWQxN2VmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kTGlzdF9NZExpc3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRMaXN0SXRlbV92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRMaXN0SXRlbV92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZExpc3RJdGVtX3Z1ZV9fKTtcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3OSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZExpc3RJdGVtX3Z1ZV9fX2RlZmF1bHQuYSxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW0udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtY2ZmNDYzMzZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1jZmY0NjMzNlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCddO1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFN0ZXBwZXJzL01kU3RlcEhlYWRlci52dWVcbnZhciBNZFN0ZXBIZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMyk7XG52YXIgTWRTdGVwSGVhZGVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kU3RlcEhlYWRlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDNlOTU4NjZcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTdGVwcGVycy9NZFN0ZXBIZWFkZXIudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibWQtYnV0dG9uXCIsXG4gICAgX3ZtLl9nKFxuICAgICAgX3ZtLl9iKFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtc3RlcHBlci1oZWFkZXJcIixcbiAgICAgICAgICBjbGFzczogX3ZtLmNsYXNzZXMsXG4gICAgICAgICAgYXR0cnM6IHsgZGlzYWJsZWQ6IF92bS5zaG91bGREaXNhYmxlIH0sXG4gICAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLk1kU3RlcHBlcnMuc2V0QWN0aXZlU3RlcChfdm0uaW5kZXgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICBfdm0uZGF0YS5wcm9wcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0uZGF0YS5ldmVudHNcbiAgICApLFxuICAgIFtcbiAgICAgIF92bS5kYXRhLmVycm9yXG4gICAgICAgID8gX2MoXCJtZC13YXJuaW5nLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1zdGVwcGVyLWljb25cIiB9KVxuICAgICAgICA6IF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtc3RlcHBlci1udW1iZXJcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uZGF0YS5kb25lICYmIF92bS5kYXRhLmVkaXRhYmxlXG4gICAgICAgICAgICAgICAgPyBfYyhcIm1kLWVkaXQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLXN0ZXBwZXItZWRpdGFibGVcIiB9KVxuICAgICAgICAgICAgICAgIDogX3ZtLmRhdGEuZG9uZVxuICAgICAgICAgICAgICAgICAgPyBfYyhcIm1kLWNoZWNrLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1zdGVwcGVyLWRvbmVcIiB9KVxuICAgICAgICAgICAgICAgICAgOiBbX3ZtLl92KF92bS5fcyhfdm0uTWRTdGVwcGVycy5nZXRTdGVwcGVyTnVtYmVyKF92bS5pbmRleCkpKV1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLXN0ZXBwZXItdGV4dFwiIH0sIFtcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtc3RlcHBlci1sYWJlbFwiIH0sIFtcbiAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5kYXRhLmxhYmVsKSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5kYXRhLmVycm9yXG4gICAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1zdGVwcGVyLWVycm9yXCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5kYXRhLmVycm9yKSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgOiBfdm0uZGF0YS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1zdGVwcGVyLWRlc2NyaXB0aW9uXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLmRhdGEuZGVzY3JpcHRpb24pKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgXSlcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFN0ZXBwZXJzX01kU3RlcEhlYWRlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDNlOTU4NjZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kU3RlcHBlcnMvTWRTdGVwSGVhZGVyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTdGVwSGVhZGVyX2RlZmF1bHQuYSxcbiAgTWRTdGVwcGVyc19NZFN0ZXBIZWFkZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFN0ZXBwZXJzL01kU3RlcEhlYWRlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi00M2U5NTg2NlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTQzZTk1ODY2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kU3RlcHBlcnNfTWRTdGVwSGVhZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZVJvdy52dWVcbnZhciBNZFRhYmxlUm93ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzApO1xudmFyIE1kVGFibGVSb3dfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJsZVJvdyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDBhNDQ5NmFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlUm93LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInRyXCIsXG4gICAgX3ZtLl9nKFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1yb3dcIixcbiAgICAgICAgY2xhc3M6IF92bS5yb3dDbGFzc2VzLFxuICAgICAgICBvbjogeyBjbGljazogX3ZtLm9uQ2xpY2sgfVxuICAgICAgfSxcbiAgICAgIF92bS4kbGlzdGVuZXJzXG4gICAgKSxcbiAgICBbXG4gICAgICBfdm0uc2VsZWN0YWJsZUNvdW50XG4gICAgICAgID8gX2MoXCJtZC10YWJsZS1jZWxsLXNlbGVjdGlvblwiLCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBcIm1kLWRpc2FibGVkXCI6IF92bS5tZERpc2FibGVkLFxuICAgICAgICAgICAgICBcIm1kLXNlbGVjdGFibGVcIjogX3ZtLm1kU2VsZWN0YWJsZSA9PT0gXCJtdWx0aXBsZVwiLFxuICAgICAgICAgICAgICBcIm1kLXJvdy1pZFwiOiBfdm0ubWRJbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0uaXNTZWxlY3RlZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCQkdikge1xuICAgICAgICAgICAgICAgIF92bS5pc1NlbGVjdGVkID0gJCR2XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX3QoXCJkZWZhdWx0XCIpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUYWJsZV9NZFRhYmxlUm93ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wMGE0NDk2YVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlUm93LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzY5KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZVJvd19kZWZhdWx0LmEsXG4gIE1kVGFibGVfTWRUYWJsZVJvdyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZVJvdy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0wMGE0NDk2YVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTAwYTQ0OTZhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZVJvdyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsU2VsZWN0aW9uLnZ1ZVxudmFyIE1kVGFibGVDZWxsU2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzIpO1xudmFyIE1kVGFibGVDZWxsU2VsZWN0aW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kVGFibGVDZWxsU2VsZWN0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi01MGE0YjcwYVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsU2VsZWN0aW9uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0ubWRTZWxlY3RhYmxlXG4gICAgPyBfYyhcInRkXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtY2VsbCBtZC10YWJsZS1jZWxsLXNlbGVjdGlvblwiIH0sIFtcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXRhYmxlLWNlbGwtY29udGFpbmVyXCIgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcIm1kLWNoZWNrYm94XCIsIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHsgZGlzYWJsZWQ6ICFfdm0ubWRTZWxlY3RhYmxlIHx8IF92bS5tZERpc2FibGVkIH0sXG4gICAgICAgICAgICAgIG9uOiB7IGNoYW5nZTogX3ZtLm9uQ2hhbmdlIH0sXG4gICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IF92bS5pc1NlbGVjdGVkLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigkJHYpIHtcbiAgICAgICAgICAgICAgICAgIF92bS5pc1NlbGVjdGVkID0gJCR2XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImlzU2VsZWN0ZWRcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMVxuICAgICAgICApXG4gICAgICBdKVxuICAgIDogX3ZtLl9lKClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUYWJsZV9NZFRhYmxlQ2VsbFNlbGVjdGlvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNTBhNGI3MGFcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUNlbGxTZWxlY3Rpb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzNzEpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFRhYmxlQ2VsbFNlbGVjdGlvbl9kZWZhdWx0LmEsXG4gIE1kVGFibGVfTWRUYWJsZUNlbGxTZWxlY3Rpb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsU2VsZWN0aW9uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTUwYTRiNzBhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNTBhNGI3MGFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRUYWJsZV9NZFRhYmxlQ2VsbFNlbGVjdGlvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRvb2xiYXIvTWRUb29sYmFyLnZ1ZVxudmFyIE1kVG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzc5KTtcbnZhciBNZFRvb2xiYXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUb29sYmFyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zOGEwYjRkOVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRvb2xiYXIvTWRUb29sYmFyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXRvb2xiYXJcIixcbiAgICAgIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lLCBcIm1kLWVsZXZhdGlvbi1cIiArIF92bS5tZEVsZXZhdGlvbl1cbiAgICB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUb29sYmFyX01kVG9vbGJhciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzhhMGI0ZDlcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVG9vbGJhci9NZFRvb2xiYXIudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzNzgpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFRvb2xiYXJfZGVmYXVsdC5hLFxuICBNZFRvb2xiYXJfTWRUb29sYmFyLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUb29sYmFyL01kVG9vbGJhci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zOGEwYjRkOVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM4YTBiNGQ5XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVG9vbGJhcl9NZFRvb2xiYXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX2NvbXBvbmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcblxudmFyIE1kQ29tcG9uZW50cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb21wb25lbnRzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFZ1ZU1hdGVyaWFsID0gZnVuY3Rpb24gVnVlTWF0ZXJpYWwoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG5cbiAgT2JqZWN0LnZhbHVlcyhNZENvbXBvbmVudHMpLmZvckVhY2goZnVuY3Rpb24gKE1kQ29tcG9uZW50KSB7XG4gICAgVnVlLnVzZShNZENvbXBvbmVudCk7XG4gIH0pO1xufTtcblxuVnVlTWF0ZXJpYWwudmVyc2lvbiA9ICdfX1ZFUlNJT05fXyc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFZ1ZU1hdGVyaWFsO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGdsb2JhbC5wcm9jZXNzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbC5wcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gZ2xvYmFsLnByb2Nlc3MuZG9tYWluLmJpbmQoaW52b2tlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk1kVG9vbHRpcCA9IGV4cG9ydHMuTWRUb29sYmFyID0gZXhwb3J0cy5NZFRhYnMgPSBleHBvcnRzLk1kVGFibGUgPSBleHBvcnRzLk1kU3dpdGNoID0gZXhwb3J0cy5NZFN1YmhlYWRlciA9IGV4cG9ydHMuTWRTdGVwcGVycyA9IGV4cG9ydHMuTWRTcGVlZERpYWwgPSBleHBvcnRzLk1kU25hY2tiYXIgPSBleHBvcnRzLk1kUmlwcGxlID0gZXhwb3J0cy5NZFJhZGlvID0gZXhwb3J0cy5NZFByb2dyZXNzID0gZXhwb3J0cy5NZE1lbnUgPSBleHBvcnRzLk1kTGlzdCA9IGV4cG9ydHMuTWRMYXlvdXQgPSBleHBvcnRzLk1kSW1hZ2UgPSBleHBvcnRzLk1kSWNvbiA9IGV4cG9ydHMuTWRIaWdobGlnaHRUZXh0ID0gZXhwb3J0cy5NZEZpZWxkID0gZXhwb3J0cy5NZEVtcHR5U3RhdGUgPSBleHBvcnRzLk1kRWxldmF0aW9uID0gZXhwb3J0cy5NZERyYXdlciA9IGV4cG9ydHMuTWREaXZpZGVyID0gZXhwb3J0cy5NZERpYWxvZ1Byb21wdCA9IGV4cG9ydHMuTWREaWFsb2dDb25maXJtID0gZXhwb3J0cy5NZERpYWxvZ0FsZXJ0ID0gZXhwb3J0cy5NZERpYWxvZyA9IGV4cG9ydHMuTWREYXRlcGlja2VyID0gZXhwb3J0cy5NZENvbnRlbnQgPSBleHBvcnRzLk1kQ2hpcHMgPSBleHBvcnRzLk1kQ2hlY2tib3ggPSBleHBvcnRzLk1kQ2FyZCA9IGV4cG9ydHMuTWRCdXR0b24gPSBleHBvcnRzLk1kQm90dG9tQmFyID0gZXhwb3J0cy5NZEF2YXRhciA9IGV4cG9ydHMuTWRBdXRvY29tcGxldGUgPSBleHBvcnRzLk1kQXBwID0gdW5kZWZpbmVkO1xuXG52YXIgX01kQXBwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbnZhciBfTWRBcHAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBcHApO1xuXG52YXIgX01kQXV0b2NvbXBsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OCk7XG5cbnZhciBfTWRBdXRvY29tcGxldGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBdXRvY29tcGxldGUpO1xuXG52YXIgX01kQXZhdGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cbnZhciBfTWRBdmF0YXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBdmF0YXIpO1xuXG52YXIgX01kQm90dG9tQmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cbnZhciBfTWRCb3R0b21CYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRCb3R0b21CYXIpO1xuXG52YXIgX01kQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nyk7XG5cbnZhciBfTWRCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRCdXR0b24pO1xuXG52YXIgX01kQ2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcblxudmFyIF9NZENhcmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDYXJkKTtcblxudmFyIF9NZENoZWNrYm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzkpO1xuXG52YXIgX01kQ2hlY2tib3gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDaGVja2JveCk7XG5cbnZhciBfTWRDaGlwcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQzKTtcblxudmFyIF9NZENoaXBzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2hpcHMpO1xuXG52YXIgX01kQ29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYzKTtcblxudmFyIF9NZENvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb250ZW50KTtcblxudmFyIF9NZERhdGVwaWNrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2NSk7XG5cbnZhciBfTWREYXRlcGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRGF0ZXBpY2tlcik7XG5cbnZhciBfTWREaWFsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwOSk7XG5cbnZhciBfTWREaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2cpO1xuXG52YXIgX01kRGlhbG9nQWxlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOSk7XG5cbnZhciBfTWREaWFsb2dBbGVydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERpYWxvZ0FsZXJ0KTtcblxudmFyIF9NZERpYWxvZ0NvbmZpcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMik7XG5cbnZhciBfTWREaWFsb2dDb25maXJtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRGlhbG9nQ29uZmlybSk7XG5cbnZhciBfTWREaWFsb2dQcm9tcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XG5cbnZhciBfTWREaWFsb2dQcm9tcHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2dQcm9tcHQpO1xuXG52YXIgX01kRGl2aWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjI4KTtcblxudmFyIF9NZERpdmlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaXZpZGVyKTtcblxudmFyIF9NZERyYXdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMyKTtcblxudmFyIF9NZERyYXdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERyYXdlcik7XG5cbnZhciBfTWRFbGV2YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNik7XG5cbnZhciBfTWRFbGV2YXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRFbGV2YXRpb24pO1xuXG52YXIgX01kRW1wdHlTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM4KTtcblxudmFyIF9NZEVtcHR5U3RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRFbXB0eVN0YXRlKTtcblxudmFyIF9NZEZpZWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDEpO1xuXG52YXIgX01kRmllbGQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRGaWVsZCk7XG5cbnZhciBfTWRIaWdobGlnaHRUZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjgpO1xuXG52YXIgX01kSGlnaGxpZ2h0VGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEhpZ2hsaWdodFRleHQpO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG52YXIgX01kSW1hZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3Mik7XG5cbnZhciBfTWRJbWFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEltYWdlKTtcblxudmFyIF9NZExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMjc2KTtcblxudmFyIF9NZExheW91dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExheW91dCk7XG5cbnZhciBfTWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzgpO1xuXG52YXIgX01kTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExpc3QpO1xuXG52YXIgX01kTWVudSA9IF9fd2VicGFja19yZXF1aXJlX18oMjk2KTtcblxudmFyIF9NZE1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRNZW51KTtcblxudmFyIF9NZFByb2dyZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTkpO1xuXG52YXIgX01kUHJvZ3Jlc3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9ncmVzcyk7XG5cbnZhciBfTWRSYWRpbyA9IF9fd2VicGFja19yZXF1aXJlX18oMzA3KTtcblxudmFyIF9NZFJhZGlvMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUmFkaW8pO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTEpO1xuXG52YXIgX01kUmlwcGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUmlwcGxlKTtcblxudmFyIF9NZFNuYWNrYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTIpO1xuXG52YXIgX01kU25hY2tiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTbmFja2Jhcik7XG5cbnZhciBfTWRTcGVlZERpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxOSk7XG5cbnZhciBfTWRTcGVlZERpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTcGVlZERpYWwpO1xuXG52YXIgX01kU3RlcHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyOSk7XG5cbnZhciBfTWRTdGVwcGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN0ZXBwZXJzKTtcblxudmFyIF9NZFN1YmhlYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQzKTtcblxudmFyIF9NZFN1YmhlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN1YmhlYWRlcik7XG5cbnZhciBfTWRTd2l0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0Nyk7XG5cbnZhciBfTWRTd2l0Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTd2l0Y2gpO1xuXG52YXIgX01kVGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1MSk7XG5cbnZhciBfTWRUYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlKTtcblxudmFyIF9NZFRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4OSk7XG5cbnZhciBfTWRUYWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGFicyk7XG5cbnZhciBfTWRUb29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTUpO1xuXG52YXIgX01kVG9vbGJhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRvb2xiYXIpO1xuXG52YXIgX01kVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMzk2KTtcblxudmFyIF9NZFRvb2x0aXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUb29sdGlwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5NZEFwcCA9IF9NZEFwcDIuZGVmYXVsdDtcbmV4cG9ydHMuTWRBdXRvY29tcGxldGUgPSBfTWRBdXRvY29tcGxldGUyLmRlZmF1bHQ7XG5leHBvcnRzLk1kQXZhdGFyID0gX01kQXZhdGFyMi5kZWZhdWx0O1xuZXhwb3J0cy5NZEJvdHRvbUJhciA9IF9NZEJvdHRvbUJhcjIuZGVmYXVsdDtcbmV4cG9ydHMuTWRCdXR0b24gPSBfTWRCdXR0b24yLmRlZmF1bHQ7XG5leHBvcnRzLk1kQ2FyZCA9IF9NZENhcmQyLmRlZmF1bHQ7XG5leHBvcnRzLk1kQ2hlY2tib3ggPSBfTWRDaGVja2JveDIuZGVmYXVsdDtcbmV4cG9ydHMuTWRDaGlwcyA9IF9NZENoaXBzMi5kZWZhdWx0O1xuZXhwb3J0cy5NZENvbnRlbnQgPSBfTWRDb250ZW50Mi5kZWZhdWx0O1xuZXhwb3J0cy5NZERhdGVwaWNrZXIgPSBfTWREYXRlcGlja2VyMi5kZWZhdWx0O1xuZXhwb3J0cy5NZERpYWxvZyA9IF9NZERpYWxvZzIuZGVmYXVsdDtcbmV4cG9ydHMuTWREaWFsb2dBbGVydCA9IF9NZERpYWxvZ0FsZXJ0Mi5kZWZhdWx0O1xuZXhwb3J0cy5NZERpYWxvZ0NvbmZpcm0gPSBfTWREaWFsb2dDb25maXJtMi5kZWZhdWx0O1xuZXhwb3J0cy5NZERpYWxvZ1Byb21wdCA9IF9NZERpYWxvZ1Byb21wdDIuZGVmYXVsdDtcbmV4cG9ydHMuTWREaXZpZGVyID0gX01kRGl2aWRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuTWREcmF3ZXIgPSBfTWREcmF3ZXIyLmRlZmF1bHQ7XG5leHBvcnRzLk1kRWxldmF0aW9uID0gX01kRWxldmF0aW9uMi5kZWZhdWx0O1xuZXhwb3J0cy5NZEVtcHR5U3RhdGUgPSBfTWRFbXB0eVN0YXRlMi5kZWZhdWx0O1xuZXhwb3J0cy5NZEZpZWxkID0gX01kRmllbGQyLmRlZmF1bHQ7XG5leHBvcnRzLk1kSGlnaGxpZ2h0VGV4dCA9IF9NZEhpZ2hsaWdodFRleHQyLmRlZmF1bHQ7XG5leHBvcnRzLk1kSWNvbiA9IF9NZEljb24yLmRlZmF1bHQ7XG5leHBvcnRzLk1kSW1hZ2UgPSBfTWRJbWFnZTIuZGVmYXVsdDtcbmV4cG9ydHMuTWRMYXlvdXQgPSBfTWRMYXlvdXQyLmRlZmF1bHQ7XG5leHBvcnRzLk1kTGlzdCA9IF9NZExpc3QyLmRlZmF1bHQ7XG5leHBvcnRzLk1kTWVudSA9IF9NZE1lbnUyLmRlZmF1bHQ7XG5leHBvcnRzLk1kUHJvZ3Jlc3MgPSBfTWRQcm9ncmVzczIuZGVmYXVsdDtcbmV4cG9ydHMuTWRSYWRpbyA9IF9NZFJhZGlvMi5kZWZhdWx0O1xuZXhwb3J0cy5NZFJpcHBsZSA9IF9NZFJpcHBsZTIuZGVmYXVsdDtcbmV4cG9ydHMuTWRTbmFja2JhciA9IF9NZFNuYWNrYmFyMi5kZWZhdWx0O1xuZXhwb3J0cy5NZFNwZWVkRGlhbCA9IF9NZFNwZWVkRGlhbDIuZGVmYXVsdDtcbmV4cG9ydHMuTWRTdGVwcGVycyA9IF9NZFN0ZXBwZXJzMi5kZWZhdWx0O1xuZXhwb3J0cy5NZFN1YmhlYWRlciA9IF9NZFN1YmhlYWRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuTWRTd2l0Y2ggPSBfTWRTd2l0Y2gyLmRlZmF1bHQ7XG5leHBvcnRzLk1kVGFibGUgPSBfTWRUYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMuTWRUYWJzID0gX01kVGFiczIuZGVmYXVsdDtcbmV4cG9ydHMuTWRUb29sYmFyID0gX01kVG9vbGJhcjIuZGVmYXVsdDtcbmV4cG9ydHMuTWRUb29sdGlwID0gX01kVG9vbHRpcDIuZGVmYXVsdDtcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRBcHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcblxudmFyIF9NZEFwcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFwcCk7XG5cbnZhciBfTWRBcHBUb29sYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cbnZhciBfTWRBcHBUb29sYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQXBwVG9vbGJhcik7XG5cbnZhciBfTWRBcHBDb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbnZhciBfTWRBcHBDb250ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQXBwQ29udGVudCk7XG5cbnZhciBfTWRBcHBEcmF3ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2KTtcblxudmFyIF9NZEFwcERyYXdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFwcERyYXdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRBcHAyLmRlZmF1bHQubmFtZSwgX01kQXBwMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRBcHBUb29sYmFyMi5kZWZhdWx0Lm5hbWUsIF9NZEFwcFRvb2xiYXIyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZEFwcENvbnRlbnQyLmRlZmF1bHQubmFtZSwgX01kQXBwQ29udGVudDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQXBwRHJhd2VyMi5kZWZhdWx0Lm5hbWUsIF9NZEFwcERyYXdlcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEFwcF92dWVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEFwcF92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEFwcF92dWVfXyk7XG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2MClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEFwcF92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi04YjczODliNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LThiNzM4OWI2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9NZEFwcFNpZGVEcmF3ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcblxudmFyIF9NZEFwcFNpZGVEcmF3ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBcHBTaWRlRHJhd2VyKTtcblxudmFyIF9NZEFwcEludGVybmFsRHJhd2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XG5cbnZhciBfTWRBcHBJbnRlcm5hbERyYXdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFwcEludGVybmFsRHJhd2VyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNvbXBvbmVudFR5cGVzID0gWydtZC1hcHAtdG9vbGJhcicsICdtZC1hcHAtZHJhd2VyJywgJ21kLWFwcC1jb250ZW50J107XG5cbmZ1bmN0aW9uIGJ1aWxkU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQsIGZ1bmN0aW9uYWxDb250ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBzbG90cyA9IFtdO1xuXG4gIGlmIChjaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IGNoaWxkLmNvbXBvbmVudE9wdGlvbnM7XG5cbiAgICAgIGlmIChkYXRhICYmIGNvbXBvbmVudFR5cGVzLmluY2x1ZGVzKGRhdGEuc2xvdCkgfHwgY29tcG9uZW50T3B0aW9ucyAmJiBjb21wb25lbnRUeXBlcy5pbmNsdWRlcyhjb21wb25lbnRPcHRpb25zLnRhZykpIHtcbiAgICAgICAgY2hpbGQuZGF0YS5zbG90ID0gZGF0YS5zbG90IHx8IGNvbXBvbmVudE9wdGlvbnMudGFnO1xuICAgICAgICBjaGlsZC5kYXRhLnByb3ZpZGUgPSBvcHRpb25zLkN0b3Iub3B0aW9ucy5wcm92aWRlO1xuICAgICAgICBjaGlsZC5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPSBmdW5jdGlvbmFsQ29udGV4dDtcblxuICAgICAgICBzbG90cy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzbG90cztcbn1cblxuZnVuY3Rpb24gZ2V0RHJhd2VycyhjaGlsZHJlbikge1xuICB2YXIgZHJhd2VyVm5vZGVzID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC5jb21wb25lbnRPcHRpb25zLnRhZyA9PT0gJ21kLWFwcC1kcmF3ZXInO1xuICB9KTtcblxuICByZXR1cm4gZHJhd2VyVm5vZGVzLmxlbmd0aCA/IGRyYXdlclZub2RlcyA6IFtdO1xufVxuXG5mdW5jdGlvbiBoYXNJbnRlcm5hbERyYXdlcihhdHRycykge1xuICB2YXIgbWRQZXJtYW5lbnQgPSBhdHRycyAmJiBhdHRyc1snbWQtcGVybWFuZW50J107XG5cbiAgcmV0dXJuIG1kUGVybWFuZW50ICYmIChtZFBlcm1hbmVudCA9PT0gJ2NsaXBwZWQnIHx8IG1kUGVybWFuZW50ID09PSAnY2FyZCcpO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEFwcCcsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQsIF9yZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuLFxuICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGE7XG5cbiAgICB2YXIgYXBwQ29tcG9uZW50ID0gX01kQXBwU2lkZURyYXdlcjIuZGVmYXVsdDtcblxuICAgIHZhciBfY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoYXBwQ29tcG9uZW50KSxcbiAgICAgICAgY29udGV4dCA9IF9jcmVhdGVFbGVtZW50LmNvbnRleHQsXG4gICAgICAgIGZ1bmN0aW9uYWxDb250ZXh0ID0gX2NyZWF0ZUVsZW1lbnQuZnVuY3Rpb25hbENvbnRleHQsXG4gICAgICAgIGNvbXBvbmVudE9wdGlvbnMgPSBfY3JlYXRlRWxlbWVudC5jb21wb25lbnRPcHRpb25zO1xuXG4gICAgdmFyIHNsb3RzID0gYnVpbGRTbG90cyhjaGlsZHJlbiwgY29udGV4dCwgZnVuY3Rpb25hbENvbnRleHQsIGNvbXBvbmVudE9wdGlvbnMpO1xuICAgIHZhciBkcmF3ZXJzID0gZ2V0RHJhd2VycyhzbG90cyk7XG5cbiAgICBkcmF3ZXJzLmZvckVhY2goZnVuY3Rpb24gKGRyYXdlcikge1xuICAgICAgaWYgKGRyYXdlciAmJiBoYXNJbnRlcm5hbERyYXdlcihkcmF3ZXIuZGF0YS5hdHRycykpIHtcbiAgICAgICAgYXBwQ29tcG9uZW50ID0gX01kQXBwSW50ZXJuYWxEcmF3ZXIyLmRlZmF1bHQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgc3RhdGljQ2xhc3MgPSB7fTtcbiAgICBpZiAoZGF0YS5zdGF0aWNDbGFzcykge1xuICAgICAgZGF0YS5zdGF0aWNDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHN0YXRpY0NsYXNzW25hbWVdID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGFwcENvbXBvbmVudCwge1xuICAgICAgYXR0cnM6IHByb3BzLFxuICAgICAgY2xhc3M6IF9leHRlbmRzKHt9LCBzdGF0aWNDbGFzcywgZGF0YS5jbGFzcyksXG4gICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGRhdGEuc3RhdGljU3R5bGUsIGRhdGEuc3R5bGUpXG4gICAgfSwgc2xvdHMpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcFNpZGVEcmF3ZXIudnVlXG52YXIgTWRBcHBTaWRlRHJhd2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG52YXIgTWRBcHBTaWRlRHJhd2VyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQXBwU2lkZURyYXdlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMmFhYTY3YTZcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBTaWRlRHJhd2VyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWFwcCBtZC1hcHAtc2lkZS1kcmF3ZXIgbWQtbGF5b3V0LXJvd1wiLFxuICAgICAgY2xhc3M6IFtfdm0uYXBwQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLl90KFwibWQtYXBwLWRyYXdlclwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJtYWluXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1hcHAtY29udGFpbmVyIG1kLWZsZXggbWQtbGF5b3V0LWNvbHVtblwiLFxuICAgICAgICAgIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lLCBfdm0uc2Nyb2xsZXJDbGFzc2VzXSxcbiAgICAgICAgICBzdHlsZTogX3ZtLmNvbnRlbnRTdHlsZXMsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIFwiJnNjcm9sbFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLmhhbmRsZVNjcm9sbCgkZXZlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLl90KFwibWQtYXBwLXRvb2xiYXJcIiksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWFwcC1zY3JvbGxlciBtZC1sYXlvdXQtY29sdW1uIG1kLWZsZXhcIixcbiAgICAgICAgICAgICAgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWUsIF92bS5zY3JvbGxlckNsYXNzZXNdLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLmNvbnRhaW5lclN0eWxlcyxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBcIiZzY3JvbGxcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICBfdm0uaGFuZGxlU2Nyb2xsKCRldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwibWQtYXBwLWNvbnRlbnRcIildLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQXBwX01kQXBwU2lkZURyYXdlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMmFhYTY3YTZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwU2lkZURyYXdlci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRBcHBTaWRlRHJhd2VyX2RlZmF1bHQuYSxcbiAgTWRBcHBfTWRBcHBTaWRlRHJhd2VyLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBTaWRlRHJhd2VyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTJhYWE2N2E2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMmFhYTY3YTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRBcHBfTWRBcHBTaWRlRHJhd2VyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRBcHBNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgX01kQXBwTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBcHBNaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRBcHBJbnRlcm5hbFNpZGVEcmF3ZXInLFxuICBtaXhpbnM6IFtfTWRBcHBNaXhpbjIuZGVmYXVsdF1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7Ly8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjEyLjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIGdldE5hbm9TZWNvbmRzLCBocnRpbWUsIGxvYWRUaW1lLCBtb2R1bGVMb2FkVGltZSwgbm9kZUxvYWRUaW1lLCB1cFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbm9kZUxvYWRUaW1lKSAvIDFlNjtcbiAgICB9O1xuICAgIGhydGltZSA9IHByb2Nlc3MuaHJ0aW1lO1xuICAgIGdldE5hbm9TZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGhydGltZSgpO1xuICAgICAgcmV0dXJuIGhyWzBdICogMWU5ICsgaHJbMV07XG4gICAgfTtcbiAgICBtb2R1bGVMb2FkVGltZSA9IGdldE5hbm9TZWNvbmRzKCk7XG4gICAgdXBUaW1lID0gcHJvY2Vzcy51cHRpbWUoKSAqIDFlOTtcbiAgICBub2RlTG9hZFRpbWUgPSBtb2R1bGVMb2FkVGltZSAtIHVwVGltZTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyZm9ybWFuY2Utbm93LmpzLm1hcFxuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyg2NikpKVxuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBJbnRlcm5hbERyYXdlci52dWVcbnZhciBNZEFwcEludGVybmFsRHJhd2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG52YXIgTWRBcHBJbnRlcm5hbERyYXdlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZEFwcEludGVybmFsRHJhd2VyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mMzNlYTBkYVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcEludGVybmFsRHJhd2VyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWFwcCBtZC1hcHAtaW50ZXJuYWwtZHJhd2VyIG1kLWxheW91dC1jb2x1bW5cIixcbiAgICAgIGNsYXNzOiBbX3ZtLmFwcENsYXNzZXMsIF92bS4kbWRBY3RpdmVUaGVtZV1cbiAgICB9LFxuICAgIFtcbiAgICAgIF92bS5fdChcIm1kLWFwcC10b29sYmFyXCIpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcIm1haW5cIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWFwcC1jb250YWluZXIgbWQtZmxleCBtZC1sYXlvdXQtcm93XCIsXG4gICAgICAgICAgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWUsIF92bS5zY3JvbGxlckNsYXNzZXNdLFxuICAgICAgICAgIHN0eWxlOiBbX3ZtLmNvbnRhaW5lclN0eWxlcywgX3ZtLmNvbnRlbnRTdHlsZXNdXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0uX3QoXCJtZC1hcHAtZHJhd2VyXCIpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1hcHAtc2Nyb2xsZXIgbWQtbGF5b3V0LWNvbHVtbiBtZC1mbGV4XCIsXG4gICAgICAgICAgICAgIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lLCBfdm0uc2Nyb2xsZXJDbGFzc2VzXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfdm0uX3QoXCJtZC1hcHAtY29udGVudFwiKV0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICBdLFxuICAgICAgICAyXG4gICAgICApXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRBcHBfTWRBcHBJbnRlcm5hbERyYXdlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtZjMzZWEwZGFcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwSW50ZXJuYWxEcmF3ZXIudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg2OClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQXBwSW50ZXJuYWxEcmF3ZXJfZGVmYXVsdC5hLFxuICBNZEFwcF9NZEFwcEludGVybmFsRHJhd2VyLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBJbnRlcm5hbERyYXdlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1mMzNlYTBkYVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWYzM2VhMGRhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQXBwX01kQXBwSW50ZXJuYWxEcmF3ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZEFwcE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMSk7XG5cbnZhciBfTWRBcHBNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFwcE1peGluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZEFwcEludGVybmFsRHJhd2VyJyxcbiAgbWl4aW5zOiBbX01kQXBwTWl4aW4yLmRlZmF1bHRdXG59KTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBUb29sYmFyLnZ1ZVxudmFyIE1kQXBwVG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xudmFyIE1kQXBwVG9vbGJhcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZEFwcFRvb2xiYXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTJkM2U0MTc0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwVG9vbGJhci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC10b29sYmFyXCIsXG4gICAgX3ZtLl9nKFxuICAgICAgX3ZtLl9iKFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtYXBwLXRvb2xiYXJcIixcbiAgICAgICAgICBjbGFzczogX3ZtLnRvb2xiYXJDbGFzc2VzLFxuICAgICAgICAgIHN0eWxlOiBfdm0udG9vbGJhclN0eWxlc1xuICAgICAgICB9LFxuICAgICAgICBcIm1kLXRvb2xiYXJcIixcbiAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICksXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEFwcF9NZEFwcFRvb2xiYXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTJkM2U0MTc0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcFRvb2xiYXIudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3MSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQXBwVG9vbGJhcl9kZWZhdWx0LmEsXG4gIE1kQXBwX01kQXBwVG9vbGJhcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQXBwL01kQXBwVG9vbGJhci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yZDNlNDE3NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJkM2U0MTc0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQXBwX01kQXBwVG9vbGJhciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRBcHBUb29sYmFyJyxcbiAgaW5qZWN0OiBbJ01kQXBwJ10sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9vbGJhckNsYXNzZXM6IGZ1bmN0aW9uIHRvb2xiYXJDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLW5vLWVsZXZhdGlvbic6ICF0aGlzLk1kQXBwLnRvb2xiYXIuaGFzRWxldmF0aW9uLFxuICAgICAgICAnbWQtcmV2ZWFsLWFjdGl2ZSc6IHRoaXMuTWRBcHAudG9vbGJhci5yZXZlYWxBY3RpdmUsXG4gICAgICAgICdtZC1maXhlZC1sYXN0LWFjdGl2ZSc6IHRoaXMuTWRBcHAudG9vbGJhci5maXhlZExhc3RBY3RpdmUsXG4gICAgICAgICdtZC1vdmVybGFwLW9mZic6IHRoaXMuTWRBcHAudG9vbGJhci5vdmVybGFwT2ZmXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9vbGJhclN0eWxlczogZnVuY3Rpb24gdG9vbGJhclN0eWxlcygpIHtcbiAgICAgIHZhciBzdHlsZXMgPSB7XG4gICAgICAgICd0b3AnOiB0aGlzLk1kQXBwLnRvb2xiYXIudG9wICsgJ3B4J1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuTWRBcHAudG9vbGJhci5maXhlZExhc3RBY3RpdmUpIHtcbiAgICAgICAgc3R5bGVzWyd0cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzRCgwLCAnICsgdGhpcy5NZEFwcC50b29sYmFyLmZpeGVkTGFzdEhlaWdodCArICdweCwgMCknO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB2YXIgdGl0bGUgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcubWQtdGl0bGUsIC5tZC1kaXNwbGF5LTEsIC5tZC1kaXNwbGF5LTInKTtcblxuICAgIHRoaXMuTWRBcHAudG9vbGJhci5lbGVtZW50ID0gdGhpcy4kZWw7XG4gICAgdGhpcy5NZEFwcC50b29sYmFyLnRpdGxlRWxlbWVudCA9IHRpdGxlO1xuXG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICB0aGlzLk1kQXBwLnRvb2xiYXIudGl0bGVTaXplID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGl0bGUpLmZvbnRTaXplLCAxMCk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcENvbnRlbnQudnVlXG52YXIgTWRBcHBDb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSk7XG52YXIgTWRBcHBDb250ZW50X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQXBwQ29udGVudCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjVmM2Q5NDRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRBcHAvTWRBcHBDb250ZW50LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uc2hvd0NhcmRcbiAgICA/IF9jKFxuICAgICAgICBcIm1kLWNhcmRcIixcbiAgICAgICAgX3ZtLl9nKFxuICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtYXBwLWNvbnRlbnQgbWQtZmxleFwiIH0sXG4gICAgICAgICAgICBcIm1kLWNhcmRcIixcbiAgICAgICAgICAgIF92bS4kYXR0cnMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLiRsaXN0ZW5lcnNcbiAgICAgICAgKSxcbiAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAyXG4gICAgICApXG4gICAgOiBfYyhcbiAgICAgICAgXCJtZC1jb250ZW50XCIsXG4gICAgICAgIF92bS5fZyhcbiAgICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWFwcC1jb250ZW50IG1kLWZsZXhcIiB9LFxuICAgICAgICAgICAgXCJtZC1jb250ZW50XCIsXG4gICAgICAgICAgICBfdm0uJGF0dHJzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApLFxuICAgICAgICAgIF92bS4kbGlzdGVuZXJzXG4gICAgICAgICksXG4gICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEFwcF9NZEFwcENvbnRlbnQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTY1ZjNkOTQ0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEFwcC9NZEFwcENvbnRlbnQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg3NClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQXBwQ29udGVudF9kZWZhdWx0LmEsXG4gIE1kQXBwX01kQXBwQ29udGVudCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQXBwL01kQXBwQ29udGVudC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02NWYzZDk0NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTY1ZjNkOTQ0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQXBwX01kQXBwQ29udGVudCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogNzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQXBwQ29udGVudCcsXG4gIGluamVjdDogWydNZEFwcCddLFxuICBjb21wdXRlZDoge1xuICAgIHNob3dDYXJkOiBmdW5jdGlvbiBzaG93Q2FyZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kQXBwLm9wdGlvbnMgJiYgdGhpcy5NZEFwcC5vcHRpb25zLm1vZGUgPT09ICdvdmVybGFwJztcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwRHJhd2VyLnZ1ZVxudmFyIE1kQXBwRHJhd2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG52YXIgTWRBcHBEcmF3ZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRBcHBEcmF3ZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTFkNDFkMWY2XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwRHJhd2VyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWRyYXdlclwiLFxuICAgIF92bS5fZyhcbiAgICAgIF92bS5fYih7IHN0YXRpY0NsYXNzOiBcIm1kLWFwcC1kcmF3ZXJcIiB9LCBcIm1kLWRyYXdlclwiLCBfdm0uJGF0dHJzLCBmYWxzZSksXG4gICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICksXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEFwcF9NZEFwcERyYXdlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMWQ0MWQxZjZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQXBwL01kQXBwRHJhd2VyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRBcHBEcmF3ZXJfZGVmYXVsdC5hLFxuICBNZEFwcF9NZEFwcERyYXdlcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQXBwL01kQXBwRHJhd2VyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTFkNDFkMWY2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMWQ0MWQxZjZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRBcHBfTWRBcHBEcmF3ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiA3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQXBwRHJhd2VyJyxcbiAgaW5qZWN0OiBbJ01kQXBwJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYXdlckVsZW1lbnQ6IHtcbiAgICAgICAgbWRBY3RpdmU6IG51bGwsXG4gICAgICAgIG1vZGU6IG51bGwsXG4gICAgICAgIHN1Ym1vZGU6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3ZXJFbGVtZW50Lm1kQWN0aXZlO1xuICAgIH0sXG4gICAgbW9kZTogZnVuY3Rpb24gbW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRyYXdlckVsZW1lbnQubW9kZTtcbiAgICB9LFxuICAgIHN1Ym1vZGU6IGZ1bmN0aW9uIHN1Ym1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kcmF3ZXJFbGVtZW50LnN1Ym1vZGU7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUoX3Zpc2libGUpIHtcbiAgICAgIHRoaXMuTWRBcHAuZHJhd2VyLndpZHRoID0gdGhpcy5nZXREcmF3ZXJXaWR0aCgpO1xuICAgICAgdGhpcy5NZEFwcC5kcmF3ZXIuYWN0aXZlID0gX3Zpc2libGU7XG4gICAgfSxcbiAgICBtb2RlOiBmdW5jdGlvbiBtb2RlKF9tb2RlKSB7XG4gICAgICB0aGlzLk1kQXBwLmRyYXdlci5tb2RlID0gX21vZGU7XG4gICAgfSxcbiAgICBzdWJtb2RlOiBmdW5jdGlvbiBzdWJtb2RlKF9zdWJtb2RlKSB7XG4gICAgICB0aGlzLk1kQXBwLmRyYXdlci5zdWJtb2RlID0gX3N1Ym1vZGU7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0RHJhd2VyV2lkdGg6IGZ1bmN0aW9uIGdldERyYXdlcldpZHRoKCkge1xuICAgICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdGhpcy5kcmF3ZXJFbGVtZW50ID0gdGhpcy4kY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgIHRoaXMuTWRBcHAuZHJhd2VyLndpZHRoID0gdGhpcy5nZXREcmF3ZXJXaWR0aCgpO1xuICAgICAgICAgICAgICB0aGlzLk1kQXBwLmRyYXdlci5hY3RpdmUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgICAgICAgIHRoaXMuTWRBcHAuZHJhd2VyLm1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICAgIHRoaXMuTWRBcHAuZHJhd2VyLnN1Ym1vZGUgPSB0aGlzLnN1Ym1vZGU7XG4gICAgICAgICAgICAgIHRoaXMuTWRBcHAuZHJhd2VyLmluaXRpYWxXaWR0aCA9IHRoaXMuJGVsLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH0oKVxufTtcblxuLyoqKi8gfSksXG4vKiA3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRBdXRvY29tcGxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxudmFyIF9NZEF1dG9jb21wbGV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEF1dG9jb21wbGV0ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRBdXRvY29tcGxldGUyLmRlZmF1bHQubmFtZSwgX01kQXV0b2NvbXBsZXRlMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQXV0b2NvbXBsZXRlL01kQXV0b2NvbXBsZXRlLnZ1ZVxudmFyIE1kQXV0b2NvbXBsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG52YXIgTWRBdXRvY29tcGxldGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRBdXRvY29tcGxldGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTEzMGU1ZWEyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQXV0b2NvbXBsZXRlL01kQXV0b2NvbXBsZXRlLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWZpZWxkXCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWQtYXV0b2NvbXBsZXRlXCIsXG4gICAgICBjbGFzczogX3ZtLmZpZWxkQ2xhc3NlcyxcbiAgICAgIGF0dHJzOiB7IFwibWQtY2xlYXJhYmxlXCI6IFwiXCIsIFwibWQtaW5saW5lXCI6IF92bS5pc0JveExheW91dCB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJtZC1tZW51XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgXCJtZC1kaXJlY3Rpb25cIjogXCJib3R0b20tc3RhcnRcIixcbiAgICAgICAgICAgIFwibWQtZGVuc2VcIjogX3ZtLm1kRGVuc2UsXG4gICAgICAgICAgICBcIm1kLWFsaWduLXRyaWdnZXJcIjogXCJcIixcbiAgICAgICAgICAgIFwibWQtZnVsbC13aWR0aFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnNob3dNZW51XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgXCJ1cGRhdGU6bWRBY3RpdmVcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIF92bS5zaG93TWVudSA9ICRldmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJtZC1pbnB1dFwiLFxuICAgICAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBfdm0ubWRJbnB1dElkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogX3ZtLm1kSW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgbWF4bGVuZ3RoOiBfdm0ubWRJbnB1dE1heGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0ubWRJbnB1dFBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgX3ZtLm9wZW5PbkZvY3VzKCRldmVudClcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBibHVyOiBfdm0uaGlkZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogX3ZtLm9uSW5wdXQsXG4gICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICBfdm0ub3Blbk9uRm9jdXMoJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uc2VhcmNoVGVybSxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigkJHYpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLnNlYXJjaFRlcm0gPSAkJHZcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInNlYXJjaFRlcm1cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJtZC1pbnB1dFwiLFxuICAgICAgICAgICAgICBfdm0uJGF0dHJzLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwibWQtbWVudS1jb250ZW50XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmhhc1Njb3BlZEVtcHR5U2xvdCB8fCBfdm0uaGFzRmlsdGVyZWRJdGVtcyxcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiaGFzU2NvcGVkRW1wdHlTbG90IHx8IGhhc0ZpbHRlcmVkSXRlbXNcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgY2xhc3M6IF92bS5jb250ZW50Q2xhc3Nlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX3ZtLmlzUHJvbWlzZVBlbmRpbmdcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWF1dG9jb21wbGV0ZS1sb2FkaW5nXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwibWQtcHJvZ3Jlc3Mtc3Bpbm5lclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRpYW1ldGVyXCI6IDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLXN0cm9rZVwiOiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLW1vZGVcIjogXCJpbmRldGVybWluYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX3ZtLmhhc0ZpbHRlcmVkSXRlbXNcbiAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWF1dG9jb21wbGV0ZS1pdGVtc1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0uZ2V0T3B0aW9ucygpLCBmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtbWVudS1pdGVtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNlbGVjdEl0ZW0oaXRlbSwgJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLiRzY29wZWRTbG90c1tcIm1kLWF1dG9jb21wbGV0ZS1pdGVtXCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfdm0uX3QoXCJtZC1hdXRvY29tcGxldGUtaXRlbVwiLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm06IF92bS5zZWFyY2hUZXJtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW192bS5fdihfdm0uX3MoaXRlbSkpXVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uaGFzU2NvcGVkRW1wdHlTbG90XG4gICAgICAgICAgICAgICAgICA/IF9jKFwibWQtbWVudS1pdGVtXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWF1dG9jb21wbGV0ZS1lbXB0eVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdChcIm1kLWF1dG9jb21wbGV0ZS1lbXB0eVwiLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybTogX3ZtLnNlYXJjaFRlcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl90KFwiZGVmYXVsdFwiKVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQXV0b2NvbXBsZXRlX01kQXV0b2NvbXBsZXRlID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0xMzBlNWVhMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRBdXRvY29tcGxldGUvTWRBdXRvY29tcGxldGUudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg4MClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQXV0b2NvbXBsZXRlX2RlZmF1bHQuYSxcbiAgTWRBdXRvY29tcGxldGVfTWRBdXRvY29tcGxldGUsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEF1dG9jb21wbGV0ZS9NZEF1dG9jb21wbGV0ZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xMzBlNWVhMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTEzMGU1ZWEyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQXV0b2NvbXBsZXRlX01kQXV0b2NvbXBsZXRlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9mdXp6eXNlYXJjaCA9IF9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG52YXIgX2Z1enp5c2VhcmNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Z1enp5c2VhcmNoKTtcblxudmFyIF9pc1Byb21pc2UyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Myk7XG5cbnZhciBfaXNQcm9taXNlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzUHJvbWlzZTIpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQXV0b2NvbXBsZXRlJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBtZERlbnNlOiBCb29sZWFuLFxuICAgIG1kTGF5b3V0OiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZmxvYXRpbmcnXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1sYXlvdXQnLCBbJ2Zsb2F0aW5nJywgJ2JveCddKSksXG4gICAgbWRPcGVuT25Gb2N1czoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIG1kRnV6enlTZWFyY2g6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZE9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IFtBcnJheSwgUHJvbWlzZV0sXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgbWRJbnB1dE5hbWU6IFN0cmluZyxcbiAgICBtZElucHV0SWQ6IFN0cmluZyxcbiAgICBtZElucHV0TWF4bGVuZ3RoOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1kSW5wdXRQbGFjZWhvbGRlcjogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hUZXJtOiB0aGlzLnZhbHVlLFxuICAgICAgc2hvd01lbnU6IGZhbHNlLFxuICAgICAgdHJpZ2dlclBvcG92ZXI6IGZhbHNlLFxuICAgICAgaXNQcm9taXNlUGVuZGluZzogZmFsc2UsXG4gICAgICBmaWx0ZXJlZEFzeW5jT3B0aW9uczogW11cbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNCb3hMYXlvdXQ6IGZ1bmN0aW9uIGlzQm94TGF5b3V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRMYXlvdXQgPT09ICdib3gnO1xuICAgIH0sXG4gICAgZmllbGRDbGFzc2VzOiBmdW5jdGlvbiBmaWVsZENsYXNzZXMoKSB7XG4gICAgICBpZiAodGhpcy5pc0JveExheW91dCkge1xuICAgICAgICByZXR1cm4gJ21kLWF1dG9jb21wbGV0ZS1ib3gnO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGVudENsYXNzZXM6IGZ1bmN0aW9uIGNvbnRlbnRDbGFzc2VzKCkge1xuICAgICAgaWYgKHRoaXMuaXNCb3hMYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuICdtZC1hdXRvY29tcGxldGUtYm94LWNvbnRlbnQnO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmlsdGVyZWRTdGF0aWNPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJlZFN0YXRpY09wdGlvbnMoKSB7XG4gICAgICBpZiAodGhpcy5pc1Byb21pc2UodGhpcy5tZE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0SXRlbSA9IHRoaXMubWRPcHRpb25zWzBdO1xuXG4gICAgICBpZiAodGhpcy5tZE9wdGlvbnNbMF0gJiYgdGhpcy5zZWFyY2hUZXJtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RJdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5U3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBmaXJzdEl0ZW0gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGZpcnN0SXRlbSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJ5T2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWRPcHRpb25zO1xuICAgIH0sXG4gICAgaGFzRmlsdGVyZWRJdGVtczogZnVuY3Rpb24gaGFzRmlsdGVyZWRJdGVtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkU3RhdGljT3B0aW9ucy5sZW5ndGggPiAwIHx8IHRoaXMuZmlsdGVyZWRBc3luY09wdGlvbnMubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGhhc1Njb3BlZEVtcHR5U2xvdDogZnVuY3Rpb24gaGFzU2NvcGVkRW1wdHlTbG90KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHNjb3BlZFNsb3RzWydtZC1hdXRvY29tcGxldGUtZW1wdHknXTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRPcHRpb25zOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNQcm9taXNlKHRoaXMubWRPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9taXNlUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1kT3B0aW9ucztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRBc3luY09wdGlvbnMgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgICAgICB0aGlzLmlzUHJvbWlzZVBlbmRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICB9KClcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHZhbCkge1xuICAgICAgdGhpcy5zZWFyY2hUZXJtID0gdmFsO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XG4gICAgICBpZiAodGhpcy5pc1Byb21pc2UodGhpcy5tZE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkQXN5bmNPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZFN0YXRpY09wdGlvbnM7XG4gICAgfSxcbiAgICBpc1Byb21pc2U6IGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAgIHJldHVybiAoMCwgX2lzUHJvbWlzZTMuZGVmYXVsdCkob2JqKTtcbiAgICB9LFxuICAgIG1hdGNoVGV4dDogZnVuY3Rpb24gbWF0Y2hUZXh0KGl0ZW0pIHtcbiAgICAgIHZhciB0YXJnZXQgPSBpdGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICh0aGlzLm1kRnV6enlTZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZnV6enlzZWFyY2gyLmRlZmF1bHQpKHNlYXJjaCwgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldC5pbmNsdWRlcyhzZWFyY2gpO1xuICAgIH0sXG4gICAgZmlsdGVyQnlTdHJpbmc6IGZ1bmN0aW9uIGZpbHRlckJ5U3RyaW5nKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMubWRPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gX3RoaXMubWF0Y2hUZXh0KGl0ZW0pO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBmaWx0ZXJCeU9iamVjdDogZnVuY3Rpb24gZmlsdGVyQnlPYmplY3QoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMubWRPcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyhpdGVtKTtcbiAgICAgICAgdmFyIHZhbHVlc0NvdW50ID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSB2YWx1ZXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNbaV0gPT09ICdzdHJpbmcnICYmIF90aGlzMi5tYXRjaFRleHQodmFsdWVzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9wZW5PbkZvY3VzOiBmdW5jdGlvbiBvcGVuT25Gb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLm1kT3Blbk9uRm9jdXMpIHtcbiAgICAgICAgdGhpcy5zaG93T3B0aW9ucygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dCh2YWx1ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG5cbiAgICAgIGlmICghdGhpcy5tZE9wZW5PbkZvY3VzKSB7XG4gICAgICAgIHRoaXMuc2hvd09wdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2VhcmNoVGVybS5jb25zdHJ1Y3Rvci5uYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbnB1dGV2ZW50Jykge1xuICAgICAgICB0aGlzLiRlbWl0KCdtZC1jaGFuZ2VkJywgdGhpcy5zZWFyY2hUZXJtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaG93TWVudSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNob3dNZW51ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlclBvcG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ21kLW9wZW5lZCcpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2hvd09wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvd09wdGlvbnM7XG4gICAgfSgpLFxuICAgIGhpZGVPcHRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TWVudSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyUG9wb3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ21kLWNsb3NlZCcpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaGlkZU9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGlkZU9wdGlvbnM7XG4gICAgfSgpLFxuICAgIHNlbGVjdEl0ZW06IGZ1bmN0aW9uIHNlbGVjdEl0ZW0oaXRlbSwgJGV2ZW50KSB7XG4gICAgICB2YXIgY29udGVudCA9ICRldmVudC50YXJnZXQudGV4dENvbnRlbnQudHJpbSgpO1xuXG4gICAgICB0aGlzLnNlYXJjaFRlcm0gPSBjb250ZW50O1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBpdGVtKTtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLXNlbGVjdGVkJywgaXRlbSk7XG4gICAgICB0aGlzLmhpZGVPcHRpb25zKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIGZ1enp5c2VhcmNoIChuZWVkbGUsIGhheXN0YWNrKSB7XG4gIHZhciB0bGVuID0gaGF5c3RhY2subGVuZ3RoO1xuICB2YXIgcWxlbiA9IG5lZWRsZS5sZW5ndGg7XG4gIGlmIChxbGVuID4gdGxlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocWxlbiA9PT0gdGxlbikge1xuICAgIHJldHVybiBuZWVkbGUgPT09IGhheXN0YWNrO1xuICB9XG4gIG91dGVyOiBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBxbGVuOyBpKyspIHtcbiAgICB2YXIgbmNoID0gbmVlZGxlLmNoYXJDb2RlQXQoaSk7XG4gICAgd2hpbGUgKGogPCB0bGVuKSB7XG4gICAgICBpZiAoaGF5c3RhY2suY2hhckNvZGVBdChqKyspID09PSBuY2gpIHtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdXp6eXNlYXJjaDtcblxuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kQXZhdGFyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSk7XG5cbnZhciBfTWRBdmF0YXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBdmF0YXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQXZhdGFyMi5kZWZhdWx0Lm5hbWUsIF9NZEF2YXRhcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEF2YXRhci9NZEF2YXRhci52dWVcbnZhciBNZEF2YXRhciA9IF9fd2VicGFja19yZXF1aXJlX18oODcpO1xudmFyIE1kQXZhdGFyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQXZhdGFyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yYmM2MWZjZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEF2YXRhci9NZEF2YXRhci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWF2YXRhclwiLCBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZV0gfSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQXZhdGFyX01kQXZhdGFyID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yYmM2MWZjZlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRBdmF0YXIvTWRBdmF0YXIudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg4Nilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQXZhdGFyX2RlZmF1bHQuYSxcbiAgTWRBdmF0YXJfTWRBdmF0YXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEF2YXRhci9NZEF2YXRhci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yYmM2MWZjZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJiYzYxZmNmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQXZhdGFyX01kQXZhdGFyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRBdmF0YXInXG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZEJvdHRvbUJhciA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xuXG52YXIgX01kQm90dG9tQmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQm90dG9tQmFyKTtcblxudmFyIF9NZEJvdHRvbUJhckl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxudmFyIF9NZEJvdHRvbUJhckl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRCb3R0b21CYXJJdGVtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZEJvdHRvbUJhcjIuZGVmYXVsdC5uYW1lLCBfTWRCb3R0b21CYXIyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZEJvdHRvbUJhckl0ZW0yLmRlZmF1bHQubmFtZSwgX01kQm90dG9tQmFySXRlbTIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEJvdHRvbUJhci9NZEJvdHRvbUJhci52dWVcbnZhciBNZEJvdHRvbUJhciA9IF9fd2VicGFja19yZXF1aXJlX18oOTEpO1xudmFyIE1kQm90dG9tQmFyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQm90dG9tQmFyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wZmFjNjc3M1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEJvdHRvbUJhci9NZEJvdHRvbUJhci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJtZC1ib3R0b20tYmFyXCIsXG4gICAgICBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZSwgX3ZtLmJhckNsYXNzZXNdXG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJtZC1yaXBwbGVcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBcIm1kLWRpc2FibGVkXCI6IF92bS5tZFR5cGUgPT09IFwiZml4ZWRcIixcbiAgICAgICAgICAgIFwibWQtYWN0aXZlXCI6IF92bS5NZEJvdHRvbUJhci5tb3VzZUV2ZW50XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgIDJcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEJvdHRvbUJhcl9NZEJvdHRvbUJhciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMGZhYzY3NzNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQm90dG9tQmFyL01kQm90dG9tQmFyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oOTApXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEJvdHRvbUJhcl9kZWZhdWx0LmEsXG4gIE1kQm90dG9tQmFyX01kQm90dG9tQmFyLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRCb3R0b21CYXIvTWRCb3R0b21CYXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMGZhYzY3NzNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wZmFjNjc3M1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZEJvdHRvbUJhcl9NZEJvdHRvbUJhciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb3BWYWxpZGF0b3IpO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9NZFJpcHBsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJpcHBsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRCb3R0b21CYXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRSaXBwbGU6IF9NZFJpcHBsZTIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kU3luY1JvdXRlOiBCb29sZWFuLFxuICAgIG1kQWN0aXZlSXRlbTogW1N0cmluZywgTnVtYmVyXSxcbiAgICBtZFR5cGU6IF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdmaXhlZCdcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLXR5cGUnLCBbJ2ZpeGVkJywgJ3NoaWZ0J10pKVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBNZEJvdHRvbUJhcjoge1xuICAgICAgICBtb3VzZUV2ZW50OiBudWxsLFxuICAgICAgICBhY3RpdmVJdGVtOiBudWxsLFxuICAgICAgICBpdGVtczoge31cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBNZEJvdHRvbUJhcjogdGhpcy5NZEJvdHRvbUJhclxuICAgIH07XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBhY3RpdmVJdGVtOiBmdW5jdGlvbiBhY3RpdmVJdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRCb3R0b21CYXIuYWN0aXZlSXRlbTtcbiAgICB9LFxuICAgIGJhckNsYXNzZXM6IGZ1bmN0aW9uIGJhckNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCAnbWQtdHlwZS0nICsgdGhpcy5tZFR5cGUsIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBhY3RpdmVJdGVtOiBmdW5jdGlvbiBhY3RpdmVJdGVtKCkge1xuICAgICAgdGhpcy4kZW1pdCgnbWQtY2hhbmdlZCcsIHRoaXMuYWN0aXZlSXRlbSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0dXBXYXRjaGVyczogZnVuY3Rpb24gc2V0dXBXYXRjaGVycygpIHtcbiAgICAgIGlmICh0aGlzLm1kU3luY1JvdXRlKSB7XG4gICAgICAgIHRoaXMuJHdhdGNoKCckcm91dGUnLCB7XG4gICAgICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWRTeW5jUm91dGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtQnlSb3V0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNBY3RpdmVJdGVtOiBmdW5jdGlvbiBoYXNBY3RpdmVJdGVtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRCb3R0b21CYXIuYWN0aXZlSXRlbSB8fCB0aGlzLm1kQWN0aXZlSXRlbTtcbiAgICB9LFxuICAgIGdldEl0ZW1zQW5kS2V5czogZnVuY3Rpb24gZ2V0SXRlbXNBbmRLZXlzKCkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5NZEJvdHRvbUJhci5pdGVtcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyhpdGVtcylcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXRBY3RpdmVJdGVtQnlJbmRleDogZnVuY3Rpb24gc2V0QWN0aXZlSXRlbUJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgIHZhciBfZ2V0SXRlbXNBbmRLZXlzID0gdGhpcy5nZXRJdGVtc0FuZEtleXMoKSxcbiAgICAgICAgICBrZXlzID0gX2dldEl0ZW1zQW5kS2V5cy5rZXlzO1xuXG4gICAgICBpZiAoIXRoaXMubWRBY3RpdmVJdGVtKSB7XG4gICAgICAgIHRoaXMuTWRCb3R0b21CYXIuYWN0aXZlSXRlbSA9IGtleXNbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5NZEJvdHRvbUJhci5hY3RpdmVJdGVtID0gdGhpcy5tZEFjdGl2ZUl0ZW07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBY3RpdmVJdGVtQnlSb3V0ZTogZnVuY3Rpb24gc2V0QWN0aXZlSXRlbUJ5Um91dGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX2dldEl0ZW1zQW5kS2V5czIgPSB0aGlzLmdldEl0ZW1zQW5kS2V5cygpLFxuICAgICAgICAgIGl0ZW1zID0gX2dldEl0ZW1zQW5kS2V5czIuaXRlbXMsXG4gICAgICAgICAga2V5cyA9IF9nZXRJdGVtc0FuZEtleXMyLmtleXM7XG5cbiAgICAgIHZhciB0YWJJbmRleCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLiRyb3V0ZXIpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1trZXldO1xuICAgICAgICAgIHZhciB0b1Byb3AgPSBpdGVtLnByb3BzLnRvO1xuXG4gICAgICAgICAgaWYgKHRvUHJvcCAmJiB0b1Byb3AgPT09IF90aGlzLiRyb3V0ZS5wYXRoKSB7XG4gICAgICAgICAgICB0YWJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oYXNBY3RpdmVJdGVtKCkpIHtcbiAgICAgICAgaWYgKGtleXNbdGFiSW5kZXhdKSB7XG4gICAgICAgICAgdGhpcy5NZEJvdHRvbUJhci5hY3RpdmVJdGVtID0ga2V5c1t0YWJJbmRleF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5NZEJvdHRvbUJhci5hY3RpdmVJdGVtID0ga2V5c1swXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXlzW3RhYkluZGV4XSkge1xuICAgICAgICB0aGlzLk1kQm90dG9tQmFyLmFjdGl2ZUl0ZW0gPSBrZXlzW3RhYkluZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5NZEJvdHRvbUJhci50eXBlID0gdGhpcy5tZFR5cGU7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcblxuICAgICAgICAgICAgICBpZiAodGhpcy5tZFN5bmNSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbUJ5Um91dGUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUl0ZW1CeUluZGV4KDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5zZXR1cFdhdGNoZXJzKCk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH0oKVxufSk7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JhZiA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfcmFmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZik7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZERlYm91bmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NCk7XG5cbnZhciBfTWREZWJvdW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERlYm91bmNlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH0gLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFJpcHBsZScsXG4gIHByb3BzOiB7XG4gICAgbWRBY3RpdmU6IG51bGwsXG4gICAgbWREaXNhYmxlZDogQm9vbGVhbixcbiAgICBtZENlbnRlcmVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJpcHBsZXM6IFtdLFxuICAgICAgdG91Y2hUaW1lb3V0OiBudWxsLFxuICAgICAgZXZlbnRUeXBlOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgICAgcmV0dXJuICF0aGlzLiRtYXRlcmlhbC5yaXBwbGUgfHwgdGhpcy5tZERpc2FibGVkO1xuICAgIH0sXG4gICAgcmlwcGxlQ2xhc3NlczogZnVuY3Rpb24gcmlwcGxlQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC1kaXNhYmxlZCc6IHRoaXMuaXNEaXNhYmxlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIHdhdmVDbGFzc2VzOiBmdW5jdGlvbiB3YXZlQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC1jZW50ZXJlZCc6IHRoaXMubWRDZW50ZXJlZFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRBY3RpdmU6IGZ1bmN0aW9uIG1kQWN0aXZlKGFjdGl2ZSkge1xuICAgICAgdmFyIGlzQm9vbGVhbiA9IHR5cGVvZiBhY3RpdmUgPT09ICdib29sZWFuJztcbiAgICAgIHZhciBpc0V2ZW50ID0gYWN0aXZlLmNvbnN0cnVjdG9yLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ21vdXNlZXZlbnQnO1xuXG4gICAgICBpZiAoaXNCb29sZWFuICYmIHRoaXMubWRDZW50ZXJlZCAmJiBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5zdGFydFJpcHBsZSh7XG4gICAgICAgICAgdHlwZTogJ21vdXNlZG93bidcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptZEFjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFdmVudCkge1xuICAgICAgICB0aGlzLnN0YXJ0UmlwcGxlKGFjdGl2ZSk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptZEFjdGl2ZScsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xlYXJXYXZlKCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG91Y2hNb3ZlQ2hlY2s6IGZ1bmN0aW9uIHRvdWNoTW92ZUNoZWNrKCkge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XG4gICAgfSxcbiAgICB0b3VjaFN0YXJ0Q2hlY2s6IGZ1bmN0aW9uIHRvdWNoU3RhcnRDaGVjaygkZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdGFydFJpcHBsZSgkZXZlbnQpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9LFxuICAgIHN0YXJ0UmlwcGxlOiBmdW5jdGlvbiBzdGFydFJpcHBsZSgkZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAoMCwgX3JhZjIuZGVmYXVsdCkoX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgZXZlbnRUeXBlLCBpc0Rpc2FibGVkLCBtZENlbnRlcmVkLCBzaXplLCBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IF90aGlzMi5ldmVudFR5cGUsIGlzRGlzYWJsZWQgPSBfdGhpczIuaXNEaXNhYmxlZCwgbWRDZW50ZXJlZCA9IF90aGlzMi5tZENlbnRlcmVkO1xuXG5cbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlzYWJsZWQgJiYgKCFldmVudFR5cGUgfHwgZXZlbnRUeXBlID09PSAkZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgIHNpemUgPSBfdGhpczIuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBudWxsO1xuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChtZENlbnRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gX3RoaXMyLmdldENlbnRlcmVkUG9zaXRpb24oc2l6ZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzMi5nZXRIaXRQb3NpdGlvbigkZXZlbnQsIHNpemUpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczIuZXZlbnRUeXBlID0gJGV2ZW50LnR5cGU7XG4gICAgICAgICAgICAgICAgICBfdGhpczIucmlwcGxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3YXZlU3R5bGVzOiBfdGhpczIuYXBwbHlTdHlsZXMocG9zaXRpb24sIHNpemUpXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCBfdGhpczIpO1xuICAgICAgfSkpKTtcbiAgICB9LFxuICAgIGFwcGx5U3R5bGVzOiBmdW5jdGlvbiBhcHBseVN0eWxlcyhwb3NpdGlvbiwgc2l6ZSkge1xuICAgICAgc2l6ZSArPSAncHgnO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBvc2l0aW9uLCB7XG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICBoZWlnaHQ6IHNpemVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjbGVhcldhdmU6ICgwLCBfTWREZWJvdW5jZTIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5yaXBwbGVzID0gW107XG4gICAgfSwgMjAwMCksXG4gICAgZ2V0U2l6ZTogZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgIHZhciBfJGVsID0gdGhpcy4kZWwsXG4gICAgICAgICAgb2Zmc2V0V2lkdGggPSBfJGVsLm9mZnNldFdpZHRoLFxuICAgICAgICAgIG9mZnNldEhlaWdodCA9IF8kZWwub2Zmc2V0SGVpZ2h0O1xuXG5cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWF4KG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQpKTtcbiAgICB9LFxuICAgIGdldENlbnRlcmVkUG9zaXRpb246IGZ1bmN0aW9uIGdldENlbnRlcmVkUG9zaXRpb24oc2l6ZSkge1xuICAgICAgdmFyIGhhbGZTaXplID0gLXNpemUgLyAyICsgJ3B4JztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21hcmdpbi10b3AnOiBoYWxmU2l6ZSxcbiAgICAgICAgJ21hcmdpbi1sZWZ0JzogaGFsZlNpemVcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRIaXRQb3NpdGlvbjogZnVuY3Rpb24gZ2V0SGl0UG9zaXRpb24oJGV2ZW50LCBlbGVtZW50U2l6ZSkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0b3AgPSAkZXZlbnQucGFnZVk7XG4gICAgICB2YXIgbGVmdCA9ICRldmVudC5wYWdlWDtcblxuICAgICAgaWYgKCRldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgdG9wID0gJGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICBsZWZ0ID0gJGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCAtIHJlY3QudG9wIC0gZWxlbWVudFNpemUgLyAyIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGxlZnQgLSByZWN0LmxlZnQgLSBlbGVtZW50U2l6ZSAvIDIgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCArICdweCdcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcbiAgdmFyIHRpbWVvdXQgPSB2b2lkIDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmdW5jdGlvbkNhbGwgPSBmdW5jdGlvbiBmdW5jdGlvbkNhbGwoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoX3RoaXMsIF9hcmd1bWVudHMpO1xuICAgIH07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uQ2FsbCwgdGltZSk7XG4gIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEJvdHRvbUJhci9NZEJvdHRvbUJhckl0ZW0udnVlXG52YXIgTWRCb3R0b21CYXJJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Nik7XG52YXIgTWRCb3R0b21CYXJJdGVtX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQm90dG9tQmFySXRlbSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtN2JhMjlmYTZcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRCb3R0b21CYXIvTWRCb3R0b21CYXJJdGVtLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWJ1dHRvblwiLFxuICAgIF92bS5fZyhcbiAgICAgIF92bS5fYihcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWJvdHRvbS1iYXItaXRlbVwiLFxuICAgICAgICAgIGNsYXNzOiBfdm0uaXRlbUNsYXNzZXMsXG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGlkOiBfdm0uaWQsXG4gICAgICAgICAgICBkaXNhYmxlZDogX3ZtLm1kRGlzYWJsZWQsXG4gICAgICAgICAgICBcIm1kLXJpcHBsZVwiOiBfdm0uTWRCb3R0b21CYXIudHlwZSA9PT0gXCJmaXhlZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnNldEFjdGl2ZUl0ZW0gfVxuICAgICAgICB9LFxuICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICBfdm0uJGF0dHJzLFxuICAgICAgICBmYWxzZVxuICAgICAgKSxcbiAgICAgIF92bS4kbGlzdGVuZXJzXG4gICAgKSxcbiAgICBbXG4gICAgICBfdm0uJHNsb3RzLmRlZmF1bHRcbiAgICAgICAgPyBfdm0uX3QoXCJkZWZhdWx0XCIpXG4gICAgICAgIDogW1xuICAgICAgICAgICAgX3ZtLmlzQXNzZXRJY29uKF92bS5tZEljb24pXG4gICAgICAgICAgICAgID8gX2MoXCJtZC1pY29uXCIsIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWJvdHRvbS1iYXItaWNvblwiLFxuICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgXCJtZC1zcmNcIjogX3ZtLm1kSWNvbiB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1ib3R0b20tYmFyLWljb25cIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5tZEljb24pKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWJvdHRvbS1iYXItbGFiZWxcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLm1kTGFiZWwpKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRCb3R0b21CYXJfTWRCb3R0b21CYXJJdGVtID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03YmEyOWZhNlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRCb3R0b21CYXIvTWRCb3R0b21CYXJJdGVtLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRCb3R0b21CYXJJdGVtX2RlZmF1bHQuYSxcbiAgTWRCb3R0b21CYXJfTWRCb3R0b21CYXJJdGVtLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRCb3R0b21CYXIvTWRCb3R0b21CYXJJdGVtLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTdiYTI5ZmE2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtN2JhMjlmYTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRCb3R0b21CYXJfTWRCb3R0b21CYXJJdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogOTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEFzc2V0SWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgX01kQXNzZXRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQXNzZXRJY29uKTtcblxudmFyIF9NZFV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX01kVXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFV1aWQpO1xuXG52YXIgX01kUm91dGVyTGlua1Byb3BzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBfTWRSb3V0ZXJMaW5rUHJvcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSb3V0ZXJMaW5rUHJvcHMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgaWdub3JlZFByb3BzID0gWydpZCcsICdtZExhYmVsJywgJ21kSWNvbicsICdtZERpc2FibGVkJ107IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEJvdHRvbUJhckl0ZW0nLFxuICBtaXhpbnM6IFtfTWRBc3NldEljb24yLmRlZmF1bHRdLFxuICBwcm9wczoge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdtZC1ib3R0b20tYmFyLWl0ZW0tJyArICgwLCBfTWRVdWlkMi5kZWZhdWx0KSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG86IG51bGwsXG4gICAgbWRMYWJlbDogU3RyaW5nLFxuICAgIG1kSWNvbjogU3RyaW5nLFxuICAgIG1kRGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgaW5qZWN0OiBbJ01kQm90dG9tQmFyJ10sXG4gIHdhdGNoOiB7XG4gICAgJHByb3BzOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtRGF0YSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJGF0dHJzOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5zZXRJdGVtRGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpdGVtQ2xhc3NlczogZnVuY3Rpb24gaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtYWN0aXZlJzogdGhpcy5pZCA9PT0gdGhpcy5NZEJvdHRvbUJhci5hY3RpdmVJdGVtXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldFByb3BWYWx1ZXM6IGZ1bmN0aW9uIGdldFByb3BWYWx1ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy4kb3B0aW9ucy5wcm9wcyk7XG4gICAgICB2YXIgdmFsdWVzID0ge307XG5cbiAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghaWdub3JlZFByb3BzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgaWYgKF90aGlzW3Byb3BdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbcHJvcF0gPSBfdGhpc1twcm9wXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLiRhdHRycyAmJiBfdGhpcy4kYXR0cnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgIHZhbHVlc1twcm9wXSA9IF90aGlzLiRhdHRyc1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlc1twcm9wXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuICAgIHNldEl0ZW1EYXRhOiBmdW5jdGlvbiBzZXRJdGVtRGF0YSgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLk1kQm90dG9tQmFyLml0ZW1zLCB0aGlzLmlkLCB7XG4gICAgICAgIGRpc2FibGVkOiB0aGlzLm1kRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMubWRUZW1wbGF0ZU9wdGlvbnMsXG4gICAgICAgIHByb3BzOiB0aGlzLmdldFByb3BWYWx1ZXMoKVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRBY3RpdmVJdGVtOiBmdW5jdGlvbiBzZXRBY3RpdmVJdGVtKCRldmVudCkge1xuICAgICAgdGhpcy5NZEJvdHRvbUJhci5hY3RpdmVJdGVtID0gdGhpcy5pZDtcblxuICAgICAgaWYgKHRoaXMuTWRCb3R0b21CYXIudHlwZSA9PT0gJ3NoaWZ0Jykge1xuICAgICAgICB0aGlzLk1kQm90dG9tQmFyLm1vdXNlRXZlbnQgPSAkZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmICh0aGlzLiRyb3V0ZXIgJiYgdGhpcy4kb3B0aW9ucy5wcm9wc0RhdGEudG8pIHtcbiAgICAgIHZhciBjb21wb25lbnRQcm9wcyA9ICgwLCBfTWRSb3V0ZXJMaW5rUHJvcHMyLmRlZmF1bHQpKHRoaXMsIHRoaXMuJG9wdGlvbnMucHJvcHMpO1xuICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuJG9wdGlvbnMucHJvcHNEYXRhKTtcblxuICAgICAgdGhpcy4kb3B0aW9ucy5wcm9wcyA9IGNvbXBvbmVudFByb3BzO1xuICAgICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKCFpZ25vcmVkUHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICBfdGhpczIuJGF0dHJzW3Byb3BdID0gX3RoaXMyLiRvcHRpb25zLnByb3BzRGF0YVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuc2V0SXRlbURhdGEoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLiRkZWxldGUodGhpcy5NZEJvdHRvbUJhci5pdGVtcywgdGhpcy5pZCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kQnV0dG9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBfTWRCdXR0b24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRCdXR0b24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQnV0dG9uMi5kZWZhdWx0Lm5hbWUsIF9NZEJ1dHRvbjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kRm9jdXNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuXG52YXIgX01kRm9jdXNlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEZvY3VzZWQpO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfTWRSaXBwbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSaXBwbGUpO1xuXG52YXIgX01kUm91dGVyTGlua1Byb3BzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBfTWRSb3V0ZXJMaW5rUHJvcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSb3V0ZXJMaW5rUHJvcHMpO1xuXG52YXIgX01kQnV0dG9uQ29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAwKTtcblxudmFyIF9NZEJ1dHRvbkNvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRCdXR0b25Db250ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZEJ1dHRvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEJ1dHRvbkNvbnRlbnQ6IF9NZEJ1dHRvbkNvbnRlbnQyLmRlZmF1bHRcbiAgfSxcbiAgbWl4aW5zOiBbX01kUmlwcGxlMi5kZWZhdWx0LCBfTWRGb2N1c2VkMi5kZWZhdWx0XSxcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2J1dHRvbidcbiAgICB9LFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHRvOiBudWxsXG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICB2YXIgYnV0dG9uQ29udGVudCA9IGNyZWF0ZUVsZW1lbnQoJ21kLWJ1dHRvbi1jb250ZW50Jywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgbWRSaXBwbGU6IHRoaXMubWRSaXBwbGUsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkXG4gICAgICB9XG4gICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGJ1dHRvbkF0dHJzID0ge1xuICAgICAgc3RhdGljQ2xhc3M6ICdtZC1idXR0b24nLFxuICAgICAgY2xhc3M6IFt0aGlzLiRtZEFjdGl2ZVRoZW1lLCB7XG4gICAgICAgICdtZC1yaXBwbGUtb2ZmJzogIXRoaXMubWRSaXBwbGUsXG4gICAgICAgICdtZC1mb2N1c2VkJzogdGhpcy5tZEhhc0ZvY3VzXG4gICAgICB9XSxcbiAgICAgIGF0dHJzOiBfZXh0ZW5kcyh7fSwgdGhpcy5hdHRycywge1xuICAgICAgICBocmVmOiB0aGlzLmhyZWYsXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICB0eXBlOiAhdGhpcy5ocmVmICYmICh0aGlzLnR5cGUgfHwgJ2J1dHRvbicpXG4gICAgICB9KSxcbiAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICB9O1xuICAgIHZhciB0YWcgPSAnYnV0dG9uJztcblxuICAgIGlmICh0aGlzLmhyZWYpIHtcbiAgICAgIHRhZyA9ICdhJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuJHJvdXRlciAmJiB0aGlzLnRvKSB7XG4gICAgICB0aGlzLiRvcHRpb25zLnByb3BzID0gKDAsIF9NZFJvdXRlckxpbmtQcm9wczIuZGVmYXVsdCkodGhpcywgdGhpcy4kb3B0aW9ucy5wcm9wcyk7XG5cbiAgICAgIHRhZyA9ICdyb3V0ZXItbGluayc7XG4gICAgICBidXR0b25BdHRycy5wcm9wcyA9IHRoaXMuJHByb3BzO1xuICAgICAgZGVsZXRlIGJ1dHRvbkF0dHJzLnByb3BzLnR5cGU7XG4gICAgICBkZWxldGUgYnV0dG9uQXR0cnMuYXR0cnMudHlwZTtcbiAgICAgIGRlbGV0ZSBidXR0b25BdHRycy5wcm9wcy5ocmVmO1xuICAgICAgZGVsZXRlIGJ1dHRvbkF0dHJzLmF0dHJzLmhyZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnLCBidXR0b25BdHRycywgW2J1dHRvbkNvbnRlbnRdKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEJ1dHRvbi9NZEJ1dHRvbkNvbnRlbnQudnVlXG52YXIgTWRCdXR0b25Db250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xudmFyIE1kQnV0dG9uQ29udGVudF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZEJ1dHRvbkNvbnRlbnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTAwOGFlOTNhXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQnV0dG9uL01kQnV0dG9uQ29udGVudC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC1yaXBwbGVcIixcbiAgICB7IGF0dHJzOiB7IFwibWQtZGlzYWJsZWRcIjogIV92bS5tZFJpcHBsZSB8fCBfdm0uZGlzYWJsZWQgfSB9LFxuICAgIFtfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWJ1dHRvbi1jb250ZW50XCIgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKV1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEJ1dHRvbl9NZEJ1dHRvbkNvbnRlbnQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTAwOGFlOTNhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEJ1dHRvbi9NZEJ1dHRvbkNvbnRlbnQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEJ1dHRvbkNvbnRlbnRfZGVmYXVsdC5hLFxuICBNZEJ1dHRvbl9NZEJ1dHRvbkNvbnRlbnQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEJ1dHRvbi9NZEJ1dHRvbkNvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMDA4YWU5M2FcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wMDhhZTkzYVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZEJ1dHRvbl9NZEJ1dHRvbkNvbnRlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFJpcHBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfTWRSaXBwbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSaXBwbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEJ1dHRvbkNvbnRlbnQnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRSaXBwbGU6IF9NZFJpcHBsZTIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kUmlwcGxlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRDYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQpO1xuXG52YXIgX01kQ2FyZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENhcmQpO1xuXG52YXIgX01kQ2FyZEFyZWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNyk7XG5cbnZhciBfTWRDYXJkQXJlYTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENhcmRBcmVhKTtcblxudmFyIF9NZENhcmRIZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMCk7XG5cbnZhciBfTWRDYXJkSGVhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZEhlYWRlcik7XG5cbnZhciBfTWRDYXJkSGVhZGVyVGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcblxudmFyIF9NZENhcmRIZWFkZXJUZXh0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZEhlYWRlclRleHQpO1xuXG52YXIgX01kQ2FyZE1lZGlhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpO1xuXG52YXIgX01kQ2FyZE1lZGlhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZE1lZGlhKTtcblxudmFyIF9NZENhcmRNZWRpYUFjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCk7XG5cbnZhciBfTWRDYXJkTWVkaWFBY3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZE1lZGlhQWN0aW9ucyk7XG5cbnZhciBfTWRDYXJkTWVkaWFDb3ZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIxKTtcblxudmFyIF9NZENhcmRNZWRpYUNvdmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZE1lZGlhQ292ZXIpO1xuXG52YXIgX01kQ2FyZENvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCk7XG5cbnZhciBfTWRDYXJkQ29udGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENhcmRDb250ZW50KTtcblxudmFyIF9NZENhcmRFeHBhbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyk7XG5cbnZhciBfTWRDYXJkRXhwYW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZEV4cGFuZCk7XG5cbnZhciBfTWRDYXJkRXhwYW5kVHJpZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMwKTtcblxudmFyIF9NZENhcmRFeHBhbmRUcmlnZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2FyZEV4cGFuZFRyaWdnZXIpO1xuXG52YXIgX01kQ2FyZEV4cGFuZENvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XG5cbnZhciBfTWRDYXJkRXhwYW5kQ29udGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENhcmRFeHBhbmRDb250ZW50KTtcblxudmFyIF9NZENhcmRBY3Rpb25zID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzYpO1xuXG52YXIgX01kQ2FyZEFjdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDYXJkQWN0aW9ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmQyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZENhcmRBcmVhMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRBcmVhMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkSGVhZGVyMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRIZWFkZXIyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZENhcmRIZWFkZXJUZXh0Mi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRIZWFkZXJUZXh0Mi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkTWVkaWEyLmRlZmF1bHQubmFtZSwgX01kQ2FyZE1lZGlhMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkTWVkaWFBY3Rpb25zMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRNZWRpYUFjdGlvbnMyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZENhcmRNZWRpYUNvdmVyMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRNZWRpYUNvdmVyMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkQ29udGVudDIuZGVmYXVsdC5uYW1lLCBfTWRDYXJkQ29udGVudDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQ2FyZEV4cGFuZDIuZGVmYXVsdC5uYW1lLCBfTWRDYXJkRXhwYW5kMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRDYXJkRXhwYW5kVHJpZ2dlcjIuZGVmYXVsdC5uYW1lLCBfTWRDYXJkRXhwYW5kVHJpZ2dlcjIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQ2FyZEV4cGFuZENvbnRlbnQyLmRlZmF1bHQubmFtZSwgX01kQ2FyZEV4cGFuZENvbnRlbnQyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZENhcmRBY3Rpb25zMi5kZWZhdWx0Lm5hbWUsIF9NZENhcmRBY3Rpb25zMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkLnZ1ZVxudmFyIE1kQ2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcbnZhciBNZENhcmRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRDYXJkKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yNGY3ZjNhZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtY2FyZFwiLCBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZSwgX3ZtLmNhcmRDbGFzc2VzXSB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMjRmN2YzYWZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENhcmRfZGVmYXVsdC5hLFxuICBNZENhcmRfTWRDYXJkLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yNGY3ZjNhZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTI0ZjdmM2FmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQ2FyZF9NZENhcmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kQ2FyZCcsXG4gIHByb3BzOiB7XG4gICAgbWRXaXRoSG92ZXI6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTWRDYXJkOiB7XG4gICAgICAgIGV4cGFuZDogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBNZENhcmQ6IHRoaXMuTWRDYXJkXG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGNhcmRDbGFzc2VzOiBmdW5jdGlvbiBjYXJkQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC13aXRoLWhvdmVyJzogdGhpcy5tZFdpdGhIb3ZlcixcbiAgICAgICAgJ21kLWV4cGFuZC1hY3RpdmUnOiB0aGlzLk1kQ2FyZC5leHBhbmRcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDEwNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZEFyZWEvTWRDYXJkQXJlYS52dWVcbnZhciBNZENhcmRBcmVhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDkpO1xudmFyIE1kQ2FyZEFyZWFfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRDYXJkQXJlYSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMTMyZjAyZDdcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZEFyZWEvTWRDYXJkQXJlYS52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWNhcmQtYXJlYVwiLCBjbGFzczogX3ZtLmFyZWFDbGFzc2VzIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRBcmVhX01kQ2FyZEFyZWEgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTEzMmYwMmQ3XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkQXJlYS9NZENhcmRBcmVhLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTA4KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkQXJlYV9kZWZhdWx0LmEsXG4gIE1kQ2FyZEFyZWFfTWRDYXJkQXJlYSxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRBcmVhL01kQ2FyZEFyZWEudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMTMyZjAyZDdcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xMzJmMDJkN1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZEFyZWFfTWRDYXJkQXJlYSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDEwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZENhcmRBcmVhJyxcbiAgcHJvcHM6IHtcbiAgICBtZEluc2V0OiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYXJlYUNsYXNzZXM6IGZ1bmN0aW9uIGFyZWFDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLWluc2V0JzogdGhpcy5tZEluc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRIZWFkZXIvTWRDYXJkSGVhZGVyLnZ1ZVxudmFyIE1kQ2FyZEhlYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyKTtcbnZhciBNZENhcmRIZWFkZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRDYXJkSGVhZGVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZDEwMzgxN1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkSGVhZGVyL01kQ2FyZEhlYWRlci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZC1jYXJkLWhlYWRlclwiIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkSGVhZGVyX01kQ2FyZEhlYWRlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNGQxMDM4MTdcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRIZWFkZXIvTWRDYXJkSGVhZGVyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTExKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkSGVhZGVyX2RlZmF1bHQuYSxcbiAgTWRDYXJkSGVhZGVyX01kQ2FyZEhlYWRlcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRIZWFkZXIvTWRDYXJkSGVhZGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTRkMTAzODE3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNGQxMDM4MTdcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQ2FyZF9NZENhcmRIZWFkZXJfTWRDYXJkSGVhZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZEhlYWRlcidcbn07XG5cbi8qKiovIH0pLFxuLyogMTEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkSGVhZGVyL01kQ2FyZEhlYWRlclRleHQudnVlXG52YXIgTWRDYXJkSGVhZGVyVGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE0KTtcbnZhciBNZENhcmRIZWFkZXJUZXh0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2FyZEhlYWRlclRleHQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQ5YTNhYjY0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRIZWFkZXIvTWRDYXJkSGVhZGVyVGV4dC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWNhcmQtaGVhZGVyLXRleHRcIiB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkSGVhZGVyX01kQ2FyZEhlYWRlclRleHQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTQ5YTNhYjY0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkSGVhZGVyL01kQ2FyZEhlYWRlclRleHQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENhcmRIZWFkZXJUZXh0X2RlZmF1bHQuYSxcbiAgTWRDYXJkSGVhZGVyX01kQ2FyZEhlYWRlclRleHQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkSGVhZGVyL01kQ2FyZEhlYWRlclRleHQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDlhM2FiNjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00OWEzYWI2NFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZEhlYWRlcl9NZENhcmRIZWFkZXJUZXh0ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZEhlYWRlclRleHQnLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRDbGFzc2VzOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLnBhcmVudENsYXNzZXMgPSB0aGlzLiRwYXJlbnQuJGVsLmNsYXNzTGlzdDtcblxuICAgIGlmICh0aGlzLnBhcmVudENsYXNzZXMuY29udGFpbnMoJ21kLWNhcmQtaGVhZGVyJykpIHtcbiAgICAgIHRoaXMucGFyZW50Q2xhc3Nlcy5hZGQoJ21kLWNhcmQtaGVhZGVyLWZsZXgnKTtcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5wYXJlbnRDbGFzc2VzLnJlbW92ZSgnbWQtY2FyZC1oZWFkZXItZmxleCcpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZE1lZGlhL01kQ2FyZE1lZGlhLnZ1ZVxudmFyIE1kQ2FyZE1lZGlhID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpO1xudmFyIE1kQ2FyZE1lZGlhX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2FyZE1lZGlhKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zM2UxZjI1M1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkTWVkaWEvTWRDYXJkTWVkaWEudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1jYXJkLW1lZGlhXCIsIGNsYXNzOiBfdm0ubWVkaWFDbGFzc2VzIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRNZWRpYV9NZENhcmRNZWRpYSA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzNlMWYyNTNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRNZWRpYS9NZENhcmRNZWRpYS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQ2FyZE1lZGlhX2RlZmF1bHQuYSxcbiAgTWRDYXJkTWVkaWFfTWRDYXJkTWVkaWEsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkTWVkaWEvTWRDYXJkTWVkaWEudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMzNlMWYyNTNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zM2UxZjI1M1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZE1lZGlhX01kQ2FyZE1lZGlhID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZE1lZGlhJyxcbiAgcHJvcHM6IHtcbiAgICBtZFJhdGlvOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLXJhdGlvJywgWycxNi05JywgJzE2LzknLCAnMTY6OScsICc0LTMnLCAnNC8zJywgJzQ6MycsICcxLTEnLCAnMS8xJywgJzE6MSddKSksXG4gICAgbWRNZWRpdW06IEJvb2xlYW4sXG4gICAgbWRCaWc6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBtZWRpYUNsYXNzZXM6IGZ1bmN0aW9uIG1lZGlhQ2xhc3NlcygpIHtcbiAgICAgIHZhciBjbGFzc2VzID0ge307XG5cbiAgICAgIGlmICh0aGlzLm1kUmF0aW8pIHtcbiAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5nZXRBc3BlY3RSYXRpbygpO1xuXG4gICAgICAgIGlmIChyYXRpbykge1xuICAgICAgICAgIHZhciBfcmF0aW8gPSBfc2xpY2VkVG9BcnJheShyYXRpbywgMiksXG4gICAgICAgICAgICAgIGhvcml6ID0gX3JhdGlvWzBdLFxuICAgICAgICAgICAgICB2ZXJ0ID0gX3JhdGlvWzFdO1xuXG4gICAgICAgICAgY2xhc3Nlc1snbWQtcmF0aW8tJyArIGhvcml6ICsgJy0nICsgdmVydF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1kTWVkaXVtIHx8IHRoaXMubWRCaWcpIHtcbiAgICAgICAgY2xhc3NlcyA9IHtcbiAgICAgICAgICAnbWQtbWVkaXVtJzogdGhpcy5tZE1lZGl1bSxcbiAgICAgICAgICAnbWQtYmlnJzogdGhpcy5tZEJpZ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRBc3BlY3RSYXRpbzogZnVuY3Rpb24gZ2V0QXNwZWN0UmF0aW8oKSB7XG4gICAgICB2YXIgcmF0aW8gPSBbXTtcblxuICAgICAgaWYgKHRoaXMubWRSYXRpby5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgIHJhdGlvID0gdGhpcy5tZFJhdGlvLnNwbGl0KCc6Jyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWRSYXRpby5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICAgIHJhdGlvID0gdGhpcy5tZFJhdGlvLnNwbGl0KCcvJyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWRSYXRpby5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICAgIHJhdGlvID0gdGhpcy5tZFJhdGlvLnNwbGl0KCctJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYXRpby5sZW5ndGggPT09IDIgPyByYXRpbyA6IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZE1lZGlhL01kQ2FyZE1lZGlhQWN0aW9ucy52dWVcbnZhciBNZENhcmRNZWRpYUFjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG52YXIgTWRDYXJkTWVkaWFBY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2FyZE1lZGlhQWN0aW9ucyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMTAyNTg0ZGFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZE1lZGlhL01kQ2FyZE1lZGlhQWN0aW9ucy52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWNhcmQtbWVkaWEtYWN0aW9uc1wiIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRNZWRpYV9NZENhcmRNZWRpYUFjdGlvbnMgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTEwMjU4NGRhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkTWVkaWEvTWRDYXJkTWVkaWFBY3Rpb25zLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTE5KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkTWVkaWFBY3Rpb25zX2RlZmF1bHQuYSxcbiAgTWRDYXJkTWVkaWFfTWRDYXJkTWVkaWFBY3Rpb25zLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZE1lZGlhL01kQ2FyZE1lZGlhQWN0aW9ucy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xMDI1ODRkYVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTEwMjU4NGRhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRfTWRDYXJkTWVkaWFfTWRDYXJkTWVkaWFBY3Rpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZE1lZGlhQWN0aW9ucydcbn07XG5cbi8qKiovIH0pLFxuLyogMTIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkTWVkaWEvTWRDYXJkTWVkaWFDb3Zlci52dWVcbnZhciBNZENhcmRNZWRpYUNvdmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjMpO1xudmFyIE1kQ2FyZE1lZGlhQ292ZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRDYXJkTWVkaWFDb3Zlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMjBkZmNmZDRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZE1lZGlhL01kQ2FyZE1lZGlhQ292ZXIudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1jYXJkLW1lZGlhLWNvdmVyXCIsIGNsYXNzOiBfdm0uY292ZXJDbGFzc2VzIH0sXG4gICAgW1xuICAgICAgX3ZtLl90KFwiZGVmYXVsdFwiKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0ubWRUZXh0U2NyaW1cbiAgICAgICAgPyBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgICByZWY6IFwiYmFja2Ryb3BcIixcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWNhcmQtYmFja2Ryb3BcIixcbiAgICAgICAgICAgIHN0eWxlOiBfdm0uY292ZXJTdHlsZXNcbiAgICAgICAgICB9KVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkTWVkaWFfTWRDYXJkTWVkaWFDb3ZlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMjBkZmNmZDRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRNZWRpYS9NZENhcmRNZWRpYUNvdmVyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTIyKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkTWVkaWFDb3Zlcl9kZWZhdWx0LmEsXG4gIE1kQ2FyZE1lZGlhX01kQ2FyZE1lZGlhQ292ZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkTWVkaWEvTWRDYXJkTWVkaWFDb3Zlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yMGRmY2ZkNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTIwZGZjZmQ0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRfTWRDYXJkTWVkaWFfTWRDYXJkTWVkaWFDb3ZlciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRDYXJkTWVkaWFDb3ZlcicsXG4gIHByb3BzOiB7XG4gICAgbWRUZXh0U2NyaW06IEJvb2xlYW4sXG4gICAgbWRTb2xpZDogQm9vbGVhblxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBiYWNrZHJvcEJhY2tncm91bmQ6IHt9XG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjb3ZlckNsYXNzZXM6IGZ1bmN0aW9uIGNvdmVyQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC10ZXh0LXNjcmltJzogdGhpcy5tZFRleHRTY3JpbSxcbiAgICAgICAgJ21kLXNvbGlkJzogdGhpcy5tZFNvbGlkXG4gICAgICB9O1xuICAgIH0sXG4gICAgY292ZXJTdHlsZXM6IGZ1bmN0aW9uIGNvdmVyU3R5bGVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5iYWNrZHJvcEJhY2tncm91bmRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYXBwbHlTY3JpbUNvbG9yOiBmdW5jdGlvbiBhcHBseVNjcmltQ29sb3IoZGFya25lc3MpIHtcbiAgICAgIGlmICh0aGlzLiRyZWZzLmJhY2tkcm9wKSB7XG4gICAgICAgIHRoaXMuYmFja2Ryb3BCYWNrZ3JvdW5kID0gJ2xpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHJnYmEoMCwgMCwgMCwgMCkgMjAlLCByZ2JhKDAsIDAsIDAsICcgKyBkYXJrbmVzcyAvIDIgKyAnKSA2NiUsIHJnYmEoMCwgMCwgMCwgJyArIGRhcmtuZXNzICsgJykgMTAwJSknO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXBwbHlTb2xpZENvbG9yOiBmdW5jdGlvbiBhcHBseVNvbGlkQ29sb3IoZGFya25lc3MpIHtcbiAgICAgIHZhciBhcmVhID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLm1kLWNhcmQtYXJlYScpO1xuXG4gICAgICBpZiAoYXJlYSkge1xuICAgICAgICBhcmVhLnN0eWxlLmJhY2tncm91bmQgPSAncmdiYSgwLCAwLCAwLCAnICsgZGFya25lc3MgKyAnKSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRJbWFnZUxpZ2h0bmVzczogZnVuY3Rpb24gZ2V0SW1hZ2VMaWdodG5lc3MoaW1hZ2UsIG9uTG9hZCwgb25FcnJvcikge1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuXG4gICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb2xvclN1bSA9IDA7XG4gICAgICAgIHZhciBjdHggPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbWFnZURhdGEgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbWFnZU1ldGFkYXRhID0gdm9pZCAwO1xuICAgICAgICB2YXIgciA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGcgPSB2b2lkIDA7XG4gICAgICAgIHZhciBiID0gdm9pZCAwO1xuICAgICAgICB2YXIgYXZlcmFnZSA9IHZvaWQgMDtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG5cbiAgICAgICAgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBpbWFnZU1ldGFkYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgeCA9IDAsIGxlbiA9IGltYWdlTWV0YWRhdGEubGVuZ3RoOyB4IDwgbGVuOyB4ICs9IDQpIHtcbiAgICAgICAgICByID0gaW1hZ2VNZXRhZGF0YVt4XTtcbiAgICAgICAgICBnID0gaW1hZ2VNZXRhZGF0YVt4ICsgMV07XG4gICAgICAgICAgYiA9IGltYWdlTWV0YWRhdGFbeCArIDJdO1xuXG4gICAgICAgICAgYXZlcmFnZSA9IE1hdGguZmxvb3IoKHIgKyBnICsgYikgLyAzKTtcbiAgICAgICAgICBjb2xvclN1bSArPSBhdmVyYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgb25Mb2FkKE1hdGguZmxvb3IoY29sb3JTdW0gLyAodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KSkpO1xuICAgICAgfTtcblxuICAgICAgaW1hZ2Uub25lcnJvciA9IG9uRXJyb3I7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgYXBwbHlCYWNrZ3JvdW5kID0gZnVuY3Rpb24gYXBwbHlCYWNrZ3JvdW5kKCkge1xuICAgICAgdmFyIGRhcmtuZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwLjY7XG5cbiAgICAgIGlmIChfdGhpcy5tZFRleHRTY3JpbSkge1xuICAgICAgICBfdGhpcy5hcHBseVNjcmltQ29sb3IoZGFya25lc3MpO1xuICAgICAgfSBlbHNlIGlmIChfdGhpcy5tZFNvbGlkKSB7XG4gICAgICAgIF90aGlzLmFwcGx5U29saWRDb2xvcihkYXJrbmVzcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW1hZ2UgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcblxuICAgIGlmIChpbWFnZSAmJiAodGhpcy5tZFRleHRTY3JpbSB8fCB0aGlzLm1kU29saWQpKSB7XG4gICAgICB0aGlzLmdldEltYWdlTGlnaHRuZXNzKGltYWdlLCBmdW5jdGlvbiAobGlnaHRuZXNzKSB7XG4gICAgICAgIHZhciBsaW1pdCA9IDI1NjtcbiAgICAgICAgdmFyIGRhcmtuZXNzID0gKE1hdGguYWJzKGxpbWl0IC0gbGlnaHRuZXNzKSAqIDEwMCAvIGxpbWl0ICsgMTUpIC8gMTAwO1xuXG4gICAgICAgIGlmIChkYXJrbmVzcyA+PSAwLjcpIHtcbiAgICAgICAgICBkYXJrbmVzcyA9IDAuNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGx5QmFja2dyb3VuZChkYXJrbmVzcyk7XG4gICAgICB9LCBhcHBseUJhY2tncm91bmQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRDb250ZW50L01kQ2FyZENvbnRlbnQudnVlXG52YXIgTWRDYXJkQ29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcbnZhciBNZENhcmRDb250ZW50X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2FyZENvbnRlbnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTM2YTk4NDg2XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRDb250ZW50L01kQ2FyZENvbnRlbnQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtY2FyZC1jb250ZW50XCIgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRDb250ZW50X01kQ2FyZENvbnRlbnQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTM2YTk4NDg2XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkQ29udGVudC9NZENhcmRDb250ZW50LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTI1KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkQ29udGVudF9kZWZhdWx0LmEsXG4gIE1kQ2FyZENvbnRlbnRfTWRDYXJkQ29udGVudCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRDb250ZW50L01kQ2FyZENvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMzZhOTg0ODZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zNmE5ODQ4NlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZENvbnRlbnRfTWRDYXJkQ29udGVudCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDEyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDEyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZENhcmRDb250ZW50J1xufTtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRFeHBhbmQvTWRDYXJkRXhwYW5kLnZ1ZVxudmFyIE1kQ2FyZEV4cGFuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI5KTtcbnZhciBNZENhcmRFeHBhbmRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRDYXJkRXhwYW5kKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1kNDZkMzU5MlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkRXhwYW5kL01kQ2FyZEV4cGFuZC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZC1jYXJkLWV4cGFuZFwiIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkRXhwYW5kX01kQ2FyZEV4cGFuZCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtZDQ2ZDM1OTJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRFeHBhbmQvTWRDYXJkRXhwYW5kLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTI4KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDYXJkRXhwYW5kX2RlZmF1bHQuYSxcbiAgTWRDYXJkRXhwYW5kX01kQ2FyZEV4cGFuZCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRFeHBhbmQvTWRDYXJkRXhwYW5kLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWQ0NmQzNTkyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtZDQ2ZDM1OTJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQ2FyZF9NZENhcmRFeHBhbmRfTWRDYXJkRXhwYW5kID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZEV4cGFuZCcsXG4gIGluamVjdDogWydNZENhcmQnXVxufTtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kQ2FyZEV4cGFuZFRyaWdnZXJfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kQ2FyZEV4cGFuZFRyaWdnZXJfdnVlX19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRDYXJkRXhwYW5kVHJpZ2dlcl92dWVfXyk7XG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMzEpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG52YXIgX192dWVfdGVtcGxhdGVfXyA9IG51bGxcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRDYXJkRXhwYW5kVHJpZ2dlcl92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkRXhwYW5kL01kQ2FyZEV4cGFuZFRyaWdnZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNGVkZTAwYjFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00ZWRlMDBiMVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZENhcmRFeHBhbmRUcmlnZ2VyJyxcbiAgaW5qZWN0OiBbJ01kQ2FyZCddLFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfJHNsb3RzJGRlZmF1bHQgPSBfc2xpY2VkVG9BcnJheSh0aGlzLiRzbG90cy5kZWZhdWx0LCAxKSxcbiAgICAgICAgdHJpZ2dlciA9IF8kc2xvdHMkZGVmYXVsdFswXTtcblxuICAgIHZhciBzdGF0aWNDbGFzcyA9ICcgbWQtY2FyZC1leHBhbmQtdHJpZ2dlcic7XG4gICAgdmFyIGxpc3RlbmVycyA9IHtcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiBjbGljaygpIHtcbiAgICAgICAgX3RoaXMuTWRDYXJkLmV4cGFuZCA9ICFfdGhpcy5NZENhcmQuZXhwYW5kO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgdHJpZ2dlci5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyA9IF9leHRlbmRzKHt9LCB0cmlnZ2VyLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLCBsaXN0ZW5lcnMpO1xuICAgICAgdHJpZ2dlci5kYXRhLnN0YXRpY0NsYXNzICs9IHN0YXRpY0NsYXNzO1xuXG4gICAgICByZXR1cm4gdHJpZ2dlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IHN0YXRpY0NsYXNzLFxuICAgICAgb246IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZEV4cGFuZC9NZENhcmRFeHBhbmRDb250ZW50LnZ1ZVxudmFyIE1kQ2FyZEV4cGFuZENvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNSk7XG52YXIgTWRDYXJkRXhwYW5kQ29udGVudF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZENhcmRFeHBhbmRDb250ZW50KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02MDQyOTZmMlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkRXhwYW5kL01kQ2FyZEV4cGFuZENvbnRlbnQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1jYXJkLWV4cGFuZC1jb250ZW50XCIsIHN0eWxlOiBfdm0uY29udGVudFN0eWxlcyB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkRXhwYW5kX01kQ2FyZEV4cGFuZENvbnRlbnQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTYwNDI5NmYyXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkRXhwYW5kL01kQ2FyZEV4cGFuZENvbnRlbnQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENhcmRFeHBhbmRDb250ZW50X2RlZmF1bHQuYSxcbiAgTWRDYXJkRXhwYW5kX01kQ2FyZEV4cGFuZENvbnRlbnQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkRXhwYW5kL01kQ2FyZEV4cGFuZENvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNjA0Mjk2ZjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi02MDQyOTZmMlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRDYXJkX01kQ2FyZEV4cGFuZF9NZENhcmRFeHBhbmRDb250ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZEV4cGFuZENvbnRlbnQnLFxuICBpbmplY3Q6IFsnTWRDYXJkJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcmdpblRvcDogMFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZXhwYW5kOiBmdW5jdGlvbiBleHBhbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZENhcmQuZXhwYW5kO1xuICAgIH0sXG4gICAgY29udGVudFN0eWxlczogZnVuY3Rpb24gY29udGVudFN0eWxlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtYXJnaW4tdG9wJzogJy0nICsgdGhpcy5tYXJnaW5Ub3AgKyAncHgnLFxuICAgICAgICAnb3BhY2l0eSc6IHRoaXMubWFyZ2luVG9wID09PSAwID8gMSA6IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKF9leHBhbmQpIHtcbiAgICAgIGlmICghX2V4cGFuZCkge1xuICAgICAgICB0aGlzLm1hcmdpblRvcCA9IHRoaXMuJGVsLmNoaWxkcmVuWzBdLm9mZnNldEhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFyZ2luVG9wID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5tYXJnaW5Ub3AgPSB0aGlzLiRlbC5jaGlsZHJlblswXS5vZmZzZXRIZWlnaHQ7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkQWN0aW9ucy9NZENhcmRBY3Rpb25zLnZ1ZVxudmFyIE1kQ2FyZEFjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzOCk7XG52YXIgTWRDYXJkQWN0aW9uc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZENhcmRBY3Rpb25zKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yODk0ZWJjNVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENhcmQvTWRDYXJkQWN0aW9ucy9NZENhcmRBY3Rpb25zLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWNhcmQtYWN0aW9uc1wiLFxuICAgICAgY2xhc3M6IFwibWQtYWxpZ25tZW50LVwiICsgX3ZtLm1kQWxpZ25tZW50XG4gICAgfSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQ2FyZEFjdGlvbnNfTWRDYXJkQWN0aW9ucyA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMjg5NGViYzVcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2FyZC9NZENhcmRBY3Rpb25zL01kQ2FyZEFjdGlvbnMudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxMzcpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENhcmRBY3Rpb25zX2RlZmF1bHQuYSxcbiAgTWRDYXJkQWN0aW9uc19NZENhcmRBY3Rpb25zLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRDYXJkL01kQ2FyZEFjdGlvbnMvTWRDYXJkQWN0aW9ucy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yODk0ZWJjNVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTI4OTRlYmM1XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENhcmRfTWRDYXJkQWN0aW9uc19NZENhcmRBY3Rpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9NZFByb3BWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb3BWYWxpZGF0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgYWxpZ25tZW50cyA9IFsnbGVmdCcsICdyaWdodCcsICdzcGFjZS1iZXR3ZWVuJ107XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2FyZEFjdGlvbnMnLFxuICBwcm9wczoge1xuICAgIG1kQWxpZ25tZW50OiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAncmlnaHQnXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1hbGlnbm1lbnQnLCBhbGlnbm1lbnRzKSlcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kQ2hlY2tib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCk7XG5cbnZhciBfTWRDaGVja2JveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENoZWNrYm94KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZENoZWNrYm94Mi5kZWZhdWx0Lm5hbWUsIF9NZENoZWNrYm94Mi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENoZWNrYm94L01kQ2hlY2tib3gudnVlXG52YXIgTWRDaGVja2JveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQyKTtcbnZhciBNZENoZWNrYm94X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2hlY2tib3gpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdjMjg5OWNmXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kQ2hlY2tib3gvTWRDaGVja2JveC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJtZC1jaGVja2JveFwiLFxuICAgICAgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWUsIF92bS5jaGVja0NsYXNzZXNdXG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWNoZWNrYm94LWNvbnRhaW5lclwiLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICBfdm0udG9nZ2xlQ2hlY2soJGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJtZC1yaXBwbGVcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBcIm1kLWNlbnRlcmVkXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnJpcHBsZUFjdGl2ZSxcbiAgICAgICAgICAgICAgICBcIm1kLWRpc2FibGVkXCI6IF92bS5kaXNhYmxlZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFwidXBkYXRlOm1kQWN0aXZlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLnJpcHBsZUFjdGl2ZSA9ICRldmVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAgICAgIHsgYXR0cnM6IHsgdHlwZTogXCJjaGVja2JveFwiIH0gfSxcbiAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IF92bS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX3ZtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBfdm0ucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0udmFsdWVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uJHNsb3RzLmRlZmF1bHRcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtY2hlY2tib3gtbGFiZWxcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgZm9yOiBfdm0uaWQgfSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgX3ZtLnRvZ2dsZUNoZWNrKCRldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kQ2hlY2tib3hfTWRDaGVja2JveCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtN2MyODk5Y2ZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2hlY2tib3gvTWRDaGVja2JveC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kQ2hlY2tib3hfZGVmYXVsdC5hLFxuICBNZENoZWNrYm94X01kQ2hlY2tib3gsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENoZWNrYm94L01kQ2hlY2tib3gudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtN2MyODk5Y2ZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03YzI4OTljZlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZENoZWNrYm94X01kQ2hlY2tib3ggPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kQ2hlY2tib3hNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG52YXIgX01kQ2hlY2tib3hNaXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENoZWNrYm94TWl4aW4pO1xuXG52YXIgX01kVXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfTWRVdWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVXVpZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRDaGVja2JveCcsXG4gIG1peGluczogW19NZENoZWNrYm94TWl4aW4yLmRlZmF1bHRdLFxuICBwcm9wczoge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdtZC1jaGVja2JveC0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMTQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZENoaXBzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQpO1xuXG52YXIgX01kQ2hpcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDaGlwcyk7XG5cbnZhciBfTWRDaGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjApO1xuXG52YXIgX01kQ2hpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENoaXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kQ2hpcHMyLmRlZmF1bHQubmFtZSwgX01kQ2hpcHMyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZENoaXAyLmRlZmF1bHQubmFtZSwgX01kQ2hpcDIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDaGlwcy9NZENoaXBzLnZ1ZVxudmFyIE1kQ2hpcHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0Nik7XG52YXIgTWRDaGlwc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZENoaXBzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wYjNkMmExZVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENoaXBzL01kQ2hpcHMudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibWQtZmllbGRcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWNoaXBzXCIsIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lLCBfdm0uY2hpcHNDbGFzc2VzXSB9LFxuICAgIFtcbiAgICAgIF92bS5fdChcImRlZmF1bHRcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl9sKF92bS52YWx1ZSwgZnVuY3Rpb24oY2hpcCwga2V5KSB7XG4gICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICBcIm1kLWNoaXBcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGNoaXAsXG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBcIm1kLWRlbGV0YWJsZVwiOiAhX3ZtLm1kU3RhdGljLFxuICAgICAgICAgICAgICBcIm1kLWNsaWNrYWJsZVwiOiAhX3ZtLm1kU3RhdGljLFxuICAgICAgICAgICAgICBcIm1kLWR1cGxpY2F0ZWRcIjogX3ZtLmR1cGxpY2F0ZWRDaGlwID09PSBjaGlwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgIF92bS5faygkZXZlbnQua2V5Q29kZSwgXCJlbnRlclwiLCAxMywgJGV2ZW50LmtleSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92bS4kZW1pdChcIm1kLWNsaWNrXCIsIGNoaXAsIGtleSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJtZC1kZWxldGVcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgICAgX3ZtLnJlbW92ZUNoaXAoY2hpcClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdm0uJGVtaXQoXCJtZC1jbGlja1wiLCBjaGlwLCBrZXkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF92bS4kc2NvcGVkU2xvdHNbXCJtZC1jaGlwXCJdXG4gICAgICAgICAgICAgID8gX3ZtLl90KFwibWQtY2hpcFwiLCBbX3ZtLl92KF92bS5fcyhjaGlwKSldLCB7IGNoaXA6IGNoaXAgfSlcbiAgICAgICAgICAgICAgOiBbX3ZtLl92KF92bS5fcyhjaGlwKSldXG4gICAgICAgICAgXSxcbiAgICAgICAgICAyXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICFfdm0ubWRTdGF0aWMgJiYgX3ZtLm1vZGVsUmVzcGVjdExpbWl0XG4gICAgICAgID8gX2MoXCJtZC1pbnB1dFwiLCB7XG4gICAgICAgICAgICByZWY6IFwiaW5wdXRcIixcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIHR5cGU6IF92bS5tZElucHV0VHlwZSxcbiAgICAgICAgICAgICAgaWQ6IF92bS5pZCxcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS5tZFBsYWNlaG9sZGVyXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgaW5wdXQ6IF92bS5oYW5kbGVJbnB1dCxcbiAgICAgICAgICAgICAga2V5ZG93bjogW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhKFwiYnV0dG9uXCIgaW4gJGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwiZW50ZXJcIiwgMTMsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF92bS5pbnNlcnRDaGlwKCRldmVudClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCEoXCJidXR0b25cIiBpbiAkZXZlbnQpICYmICRldmVudC5rZXlDb2RlICE9PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdm0uaGFuZGxlQmFja1JlbW92ZSgkZXZlbnQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5pbnB1dFZhbHVlLFxuICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICAgICAgX3ZtLmlucHV0VmFsdWUgPSB0eXBlb2YgJCR2ID09PSBcInN0cmluZ1wiID8gJCR2LnRyaW0oKSA6ICQkdlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImlucHV0VmFsdWVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENoaXBzX01kQ2hpcHMgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTBiM2QyYTFlXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZENoaXBzL01kQ2hpcHMudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygxNDUpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZENoaXBzX2RlZmF1bHQuYSxcbiAgTWRDaGlwc19NZENoaXBzLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRDaGlwcy9NZENoaXBzLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTBiM2QyYTFlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMGIzZDJhMWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRDaGlwc19NZENoaXBzID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZEZpZWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfTWRGaWVsZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEZpZWxkKTtcblxudmFyIF9NZElucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfTWRJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZElucHV0KTtcblxudmFyIF9NZFV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX01kVXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFV1aWQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRDaGlwcycsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEZpZWxkOiBfTWRGaWVsZDIuZGVmYXVsdCxcbiAgICBNZElucHV0OiBfTWRJbnB1dDIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBBcnJheSxcbiAgICBpZDoge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ21kLWNoaXBzLScgKyAoMCwgX01kVXVpZDIuZGVmYXVsdCkoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1kSW5wdXRUeXBlOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1pbnB1dC10eXBlJywgWydlbWFpbCcsICdudW1iZXInLCAncGFzc3dvcmQnLCAnc2VhcmNoJywgJ3RlbCcsICd0ZXh0JywgJ3VybCddKSksXG4gICAgbWRQbGFjZWhvbGRlcjogW1N0cmluZywgTnVtYmVyXSxcbiAgICBtZFN0YXRpYzogQm9vbGVhbixcbiAgICBtZExpbWl0OiBOdW1iZXIsXG4gICAgbWRDaGVja0R1cGxpY2F0ZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgbWRGb3JtYXQ6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dFZhbHVlOiAnJyxcbiAgICAgIGR1cGxpY2F0ZWRDaGlwOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjaGlwc0NsYXNzZXM6IGZ1bmN0aW9uIGNoaXBzQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC1oYXMtdmFsdWUnOiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0sXG4gICAgbW9kZWxSZXNwZWN0TGltaXQ6IGZ1bmN0aW9uIG1vZGVsUmVzcGVjdExpbWl0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLm1kTGltaXQgfHwgdGhpcy52YWx1ZS5sZW5ndGggPCB0aGlzLm1kTGltaXQ7XG4gICAgfSxcbiAgICBmb3JtYXR0ZWRJbnB1dFZhbHVlOiBmdW5jdGlvbiBmb3JtYXR0ZWRJbnB1dFZhbHVlKCkge1xuICAgICAgaWYgKCF0aGlzLm1kRm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tZEZvcm1hdCh0aGlzLmlucHV0VmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGluc2VydENoaXA6IGZ1bmN0aW9uIGluc2VydENoaXAoX3JlZikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHRhcmdldCA9IF9yZWYudGFyZ2V0O1xuXG4gICAgICB2YXIgaW5wdXRWYWx1ZSA9IHRoaXMuZm9ybWF0dGVkSW5wdXRWYWx1ZTtcblxuICAgICAgaWYgKCFpbnB1dFZhbHVlIHx8ICF0aGlzLm1vZGVsUmVzcGVjdExpbWl0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmFsdWUuaW5jbHVkZXMoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kdXBsaWNhdGVkQ2hpcCA9IG51bGw7XG4gICAgICAgIC8vIHRvIHRyaWdnZXIgYW5pbWF0ZVxuICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZHVwbGljYXRlZENoaXAgPSBpbnB1dFZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbHVlLnB1c2goaW5wdXRWYWx1ZSk7XG4gICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMudmFsdWUpO1xuICAgICAgdGhpcy4kZW1pdCgnbWQtaW5zZXJ0JywgaW5wdXRWYWx1ZSk7XG4gICAgICB0aGlzLmlucHV0VmFsdWUgPSAnJztcbiAgICB9LFxuICAgIHJlbW92ZUNoaXA6IGZ1bmN0aW9uIHJlbW92ZUNoaXAoY2hpcCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMudmFsdWUuaW5kZXhPZihjaGlwKTtcblxuICAgICAgdGhpcy52YWx1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLnZhbHVlKTtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLWRlbGV0ZScsIGNoaXAsIGluZGV4KTtcbiAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi4kcmVmcy5pbnB1dC4kZWwuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaGFuZGxlQmFja1JlbW92ZTogZnVuY3Rpb24gaGFuZGxlQmFja1JlbW92ZSgpIHtcbiAgICAgIGlmICghdGhpcy5pbnB1dFZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQ2hpcCh0aGlzLnZhbHVlW3RoaXMudmFsdWUubGVuZ3RoIC0gMV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uIGhhbmRsZUlucHV0KCkge1xuICAgICAgaWYgKHRoaXMubWRDaGVja0R1cGxpY2F0ZWQpIHtcbiAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHVwbGljYXRlZENoaXAgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2hlY2tEdXBsaWNhdGVkOiBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWQoKSB7XG4gICAgICBpZiAoIXRoaXMudmFsdWUuaW5jbHVkZXModGhpcy5mb3JtYXR0ZWRJbnB1dFZhbHVlKSkge1xuICAgICAgICB0aGlzLmR1cGxpY2F0ZWRDaGlwID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWRDaGVja0R1cGxpY2F0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmR1cGxpY2F0ZWRDaGlwID0gdGhpcy5mb3JtYXR0ZWRJbnB1dFZhbHVlO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlZCgpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZENsZWFySWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX01kQ2xlYXJJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2xlYXJJY29uKTtcblxudmFyIF9NZFBhc3N3b3JkT2ZmSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU1KTtcblxudmFyIF9NZFBhc3N3b3JkT2ZmSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFBhc3N3b3JkT2ZmSWNvbik7XG5cbnZhciBfTWRQYXNzd29yZE9uSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU3KTtcblxudmFyIF9NZFBhc3N3b3JkT25JY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUGFzc3dvcmRPbkljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfSAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRGaWVsZCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZENsZWFySWNvbjogX01kQ2xlYXJJY29uMi5kZWZhdWx0LFxuICAgIE1kUGFzc3dvcmRPZmZJY29uOiBfTWRQYXNzd29yZE9mZkljb24yLmRlZmF1bHQsXG4gICAgTWRQYXNzd29yZE9uSWNvbjogX01kUGFzc3dvcmRPbkljb24yLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZElubGluZTogQm9vbGVhbixcbiAgICBtZENsZWFyYWJsZTogQm9vbGVhbixcbiAgICBtZENvdW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZFRvZ2dsZVBhc3N3b3JkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd1Bhc3N3b3JkOiBmYWxzZSxcbiAgICAgIE1kRmllbGQ6IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgICBoaWdobGlnaHRlZDogZmFsc2UsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBwbGFjZWhvbGRlcjogZmFsc2UsXG4gICAgICAgIHRleHRhcmVhOiBmYWxzZSxcbiAgICAgICAgYXV0b2dyb3c6IGZhbHNlLFxuICAgICAgICBtYXhsZW5ndGg6IG51bGwsXG4gICAgICAgIGNvdW50ZXI6IG51bGwsXG4gICAgICAgIHBhc3N3b3JkOiBudWxsLFxuICAgICAgICB0b2dnbGVQYXNzd29yZDogZmFsc2UsXG4gICAgICAgIGNsZWFyOiBmYWxzZSxcbiAgICAgICAgZmlsZTogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBNZEZpZWxkOiB0aGlzLk1kRmllbGRcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgc3RyaW5nVmFsdWU6IGZ1bmN0aW9uIHN0cmluZ1ZhbHVlKCkge1xuICAgICAgcmV0dXJuICh0aGlzLk1kRmllbGQudmFsdWUgfHwgdGhpcy5NZEZpZWxkLnZhbHVlID09PSAwKSAmJiB0aGlzLk1kRmllbGQudmFsdWUudG9TdHJpbmcoKTtcbiAgICB9LFxuICAgIGhhc0NvdW50ZXI6IGZ1bmN0aW9uIGhhc0NvdW50ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZENvdW50ZXIgJiYgKHRoaXMuTWRGaWVsZC5tYXhsZW5ndGggfHwgdGhpcy5NZEZpZWxkLmNvdW50ZXIpO1xuICAgIH0sXG4gICAgaGFzUGFzc3dvcmRUb2dnbGU6IGZ1bmN0aW9uIGhhc1Bhc3N3b3JkVG9nZ2xlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRUb2dnbGVQYXNzd29yZCAmJiB0aGlzLk1kRmllbGQucGFzc3dvcmQ7XG4gICAgfSxcbiAgICBoYXNWYWx1ZTogZnVuY3Rpb24gaGFzVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZSAmJiB0aGlzLnN0cmluZ1ZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICB2YWx1ZUxlbmd0aDogZnVuY3Rpb24gdmFsdWVMZW5ndGgoKSB7XG4gICAgICBpZiAodGhpcy5zdHJpbmdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZmllbGRDbGFzc2VzOiBmdW5jdGlvbiBmaWVsZENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtaW5saW5lJzogdGhpcy5tZElubGluZSxcbiAgICAgICAgJ21kLWNsZWFyYWJsZSc6IHRoaXMubWRDbGVhcmFibGUsXG4gICAgICAgICdtZC1mb2N1c2VkJzogdGhpcy5NZEZpZWxkLmZvY3VzZWQsXG4gICAgICAgICdtZC1oaWdobGlnaHQnOiB0aGlzLk1kRmllbGQuaGlnaGxpZ2h0ZWQsXG4gICAgICAgICdtZC1kaXNhYmxlZCc6IHRoaXMuTWRGaWVsZC5kaXNhYmxlZCxcbiAgICAgICAgJ21kLXJlcXVpcmVkJzogdGhpcy5NZEZpZWxkLnJlcXVpcmVkLFxuICAgICAgICAnbWQtaGFzLXZhbHVlJzogdGhpcy5oYXNWYWx1ZSxcbiAgICAgICAgJ21kLWhhcy1wbGFjZWhvbGRlcic6IHRoaXMuTWRGaWVsZC5wbGFjZWhvbGRlcixcbiAgICAgICAgJ21kLWhhcy10ZXh0YXJlYSc6IHRoaXMuTWRGaWVsZC50ZXh0YXJlYSxcbiAgICAgICAgJ21kLWhhcy1wYXNzd29yZCc6IHRoaXMuTWRGaWVsZC5wYXNzd29yZCxcbiAgICAgICAgJ21kLWhhcy1maWxlJzogdGhpcy5NZEZpZWxkLmZpbGUsXG4gICAgICAgICdtZC1oYXMtc2VsZWN0JzogdGhpcy5NZEZpZWxkLnNlbGVjdCxcbiAgICAgICAgJ21kLWF1dG9ncm93JzogdGhpcy5NZEZpZWxkLmF1dG9ncm93XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNsZWFySW5wdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5NZEZpZWxkLmNsZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGhpcy5NZEZpZWxkLmNsZWFyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gY2xlYXJJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsZWFySW5wdXQ7XG4gICAgfSgpLFxuICAgIHRvZ2dsZVBhc3N3b3JkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuTWRGaWVsZC50b2dnbGVQYXNzd29yZCA9ICF0aGlzLk1kRmllbGQudG9nZ2xlUGFzc3dvcmQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB0b2dnbGVQYXNzd29yZCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2dnbGVQYXNzd29yZDtcbiAgICB9KCksXG4gICAgb25CbHVyOiBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICB0aGlzLk1kRmllbGQuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfTWRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQ2xlYXJJY29uJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kSWNvbjogX01kSWNvbjIuZGVmYXVsdFxuICB9XG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMTUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZFN2Z0xvYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTUyKTtcblxudmFyIF9NZFN2Z0xvYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN2Z0xvYWRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRJY29uJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kU3ZnTG9hZGVyOiBfTWRTdmdMb2FkZXIyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZFNyYzogU3RyaW5nXG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTdmdMb2FkZXIvTWRTdmdMb2FkZXIudnVlXG52YXIgTWRTdmdMb2FkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1NCk7XG52YXIgTWRTdmdMb2FkZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRTdmdMb2FkZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTBkYjM2NTVlXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kU3ZnTG9hZGVyL01kU3ZnTG9hZGVyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImlcIiwge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1kLXN2Zy1sb2FkZXJcIixcbiAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0uaHRtbCkgfVxuICB9KVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFN2Z0xvYWRlcl9NZFN2Z0xvYWRlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMGRiMzY1NWVcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kU3ZnTG9hZGVyL01kU3ZnTG9hZGVyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTUzKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTdmdMb2FkZXJfZGVmYXVsdC5hLFxuICBNZFN2Z0xvYWRlcl9NZFN2Z0xvYWRlcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kU3ZnTG9hZGVyL01kU3ZnTG9hZGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTBkYjM2NTVlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMGRiMzY1NWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTdmdMb2FkZXJfTWRTdmdMb2FkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAxNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuLy9cbi8vXG4vL1xuLy9cblxudmFyIG1kU1ZHU3RvcmUgPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTVkdMb2FkZXInLFxuICBwcm9wczoge1xuICAgIG1kU3JjOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHRtbDogbnVsbCxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZFNyYzogZnVuY3Rpb24gbWRTcmMoKSB7XG4gICAgICB0aGlzLmh0bWwgPSBudWxsO1xuICAgICAgdGhpcy5sb2FkU1ZHKCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaXNTVkc6IGZ1bmN0aW9uIGlzU1ZHKG1pbWV0eXBlKSB7XG4gICAgICByZXR1cm4gbWltZXR5cGUuaW5kZXhPZignc3ZnJykgPj0gMDtcbiAgICB9LFxuICAgIHNldEh0bWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWRTVkdTdG9yZVt0aGlzLm1kU3JjXTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5odG1sID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdtZC1sb2FkZWQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRIdG1sKF94KSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRIdG1sO1xuICAgIH0oKSxcbiAgICB1bmV4cGVjdGVkRXJyb3I6IGZ1bmN0aW9uIHVuZXhwZWN0ZWRFcnJvcihyZWplY3QpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSAnU29tZXRoaW5nIGJhZCBoYXBwZW5lZCB0cnlpbmcgdG8gZmV0Y2ggJyArIHRoaXMubWRTcmMgKyAnLic7XG4gICAgICByZWplY3QodGhpcy5lcnJvcik7XG4gICAgfSxcbiAgICBsb2FkU1ZHOiBmdW5jdGlvbiBsb2FkU1ZHKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCFtZFNWR1N0b3JlLmhhc093blByb3BlcnR5KHRoaXMubWRTcmMpKSB7XG4gICAgICAgIG1kU1ZHU3RvcmVbdGhpcy5tZFNyY10gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIF90aGlzLm1kU3JjLCB0cnVlKTtcblxuICAgICAgICAgIHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pbWV0eXBlID0gcmVxdWVzdC5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5pc1NWRyhtaW1ldHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEh0bWwoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvciA9ICdUaGUgZmlsZSAnICsgX3RoaXMubWRTcmMgKyAnIGlzIG5vdCBhIHZhbGlkIFNWRy4nO1xuICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPj0gNDAwICYmIHJlcXVlc3Quc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICAgIF90aGlzLmVycm9yID0gJ1RoZSBmaWxlICcgKyBfdGhpcy5tZFNyYyArICcgZG8gbm90IGV4aXN0cy4nO1xuICAgICAgICAgICAgICByZWplY3QoX3RoaXMuZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMudW5leHBlY3RlZEVycm9yKHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy51bmV4cGVjdGVkRXJyb3IocmVqZWN0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy51bmV4cGVjdGVkRXJyb3IocmVqZWN0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0SHRtbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmxvYWRTVkcoKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kUGFzc3dvcmRPZmZJY29uLnZ1ZVxudmFyIE1kUGFzc3dvcmRPZmZJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTYpO1xudmFyIE1kUGFzc3dvcmRPZmZJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kUGFzc3dvcmRPZmZJY29uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00MTEzMjA2YVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29yZS9pY29ucy9NZFBhc3N3b3JkT2ZmSWNvbi52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDAsIGZhbHNlLCB0cnVlKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJtZC1pY29uXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtaWNvbi1pbWFnZVwiIH0sIFtcbiAgICAgIF9jKFxuICAgICAgICBcInN2Z1wiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyNFwiLFxuICAgICAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6IFwiTTAgMGgyNHYyNEgwem0wIDBoMjR2MjRIMHptMCAwaDI0djI0SDB6bTAgMGgyNHYyNEgwelwiLFxuICAgICAgICAgICAgICBmaWxsOiBcIm5vbmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6XG4gICAgICAgICAgICAgICAgXCJNMTIgN2MyLjc2IDAgNSAyLjI0IDUgNSAwIC42NS0uMTMgMS4yNi0uMzYgMS44M2wyLjkyIDIuOTJjMS41MS0xLjI2IDIuNy0yLjg5IDMuNDMtNC43NS0xLjczLTQuMzktNi03LjUtMTEtNy41LTEuNCAwLTIuNzQuMjUtMy45OC43bDIuMTYgMi4xNkMxMC43NCA3LjEzIDExLjM1IDcgMTIgN3pNMiA0LjI3bDIuMjggMi4yOC40Ni40NkMzLjA4IDguMyAxLjc4IDEwLjAyIDEgMTJjMS43MyA0LjM5IDYgNy41IDExIDcuNSAxLjU1IDAgMy4wMy0uMyA0LjM4LS44NGwuNDIuNDJMMTkuNzMgMjIgMjEgMjAuNzMgMy4yNyAzIDIgNC4yN3pNNy41MyA5LjhsMS41NSAxLjU1Yy0uMDUuMjEtLjA4LjQzLS4wOC42NSAwIDEuNjYgMS4zNCAzIDMgMyAuMjIgMCAuNDQtLjAzLjY1LS4wOGwxLjU1IDEuNTVjLS42Ny4zMy0xLjQxLjUzLTIuMi41My0yLjc2IDAtNS0yLjI0LTUtNSAwLS43OS4yLTEuNTMuNTMtMi4yem00LjMxLS43OGwzLjE1IDMuMTUuMDItLjE2YzAtMS42Ni0xLjM0LTMtMy0zbC0uMTcuMDF6XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaWNvbnNfTWRQYXNzd29yZE9mZkljb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTQxMTMyMDZhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9pY29ucy9NZFBhc3N3b3JkT2ZmSWNvbi52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kUGFzc3dvcmRPZmZJY29uX2RlZmF1bHQuYSxcbiAgaWNvbnNfTWRQYXNzd29yZE9mZkljb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29yZS9pY29ucy9NZFBhc3N3b3JkT2ZmSWNvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi00MTEzMjA2YVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTQxMTMyMDZhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlX2ljb25zX01kUGFzc3dvcmRPZmZJY29uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9NZEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRQYXNzd29yZE9mZkljb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJY29uOiBfTWRJY29uMi5kZWZhdWx0XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAxNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kUGFzc3dvcmRPbkljb24udnVlXG52YXIgTWRQYXNzd29yZE9uSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU4KTtcbnZhciBNZFBhc3N3b3JkT25JY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kUGFzc3dvcmRPbkljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTcxZWM4ZGY0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kUGFzc3dvcmRPbkljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAgMGgyNHYyNEgwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6XG4gICAgICAgICAgICAgICAgXCJNMTIgNC41QzcgNC41IDIuNzMgNy42MSAxIDEyYzEuNzMgNC4zOSA2IDcuNSAxMSA3LjVzOS4yNy0zLjExIDExLTcuNWMtMS43My00LjM5LTYtNy41LTExLTcuNXpNMTIgMTdjLTIuNzYgMC01LTIuMjQtNS01czIuMjQtNSA1LTUgNSAyLjI0IDUgNS0yLjI0IDUtNSA1em0wLThjLTEuNjYgMC0zIDEuMzQtMyAzczEuMzQgMyAzIDMgMy0xLjM0IDMtMy0xLjM0LTMtMy0zelwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGljb25zX01kUGFzc3dvcmRPbkljb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTcxZWM4ZGY0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9pY29ucy9NZFBhc3N3b3JkT25JY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRQYXNzd29yZE9uSWNvbl9kZWZhdWx0LmEsXG4gIGljb25zX01kUGFzc3dvcmRPbkljb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29yZS9pY29ucy9NZFBhc3N3b3JkT25JY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTcxZWM4ZGY0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzFlYzhkZjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRQYXNzd29yZE9uSWNvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDE1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfTWRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kUGFzc3dvcmRPbkljb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJY29uOiBfTWRJY29uMi5kZWZhdWx0XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAxNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kVXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfTWRVdWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVXVpZCk7XG5cbnZhciBfTWRGaWVsZE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfTWRGaWVsZE1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRmllbGRNaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRJbnB1dCcsXG4gIG1peGluczogW19NZEZpZWxkTWl4aW4yLmRlZmF1bHRdLFxuICBpbmplY3Q6IFsnTWRGaWVsZCddLFxuICBwcm9wczoge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdtZC1pbnB1dC0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndGV4dCdcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlVHlwZTogZnVuY3Rpb24gdG9nZ2xlVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kRmllbGQudG9nZ2xlUGFzc3dvcmQ7XG4gICAgfSxcbiAgICBpc1Bhc3N3b3JkOiBmdW5jdGlvbiBpc1Bhc3N3b3JkKCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ3Bhc3N3b3JkJztcbiAgICB9LFxuICAgIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xuICAgICAgdmFyIGwgPSBfZXh0ZW5kcyh7fSwgdGhpcy4kbGlzdGVuZXJzKTtcbiAgICAgIGRlbGV0ZSBsLmlucHV0O1xuICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHR5cGU6IGZ1bmN0aW9uIHR5cGUoX3R5cGUpIHtcbiAgICAgIHRoaXMuc2V0UGFzc3dvcmQodGhpcy5pc1Bhc3N3b3JkKTtcbiAgICB9LFxuICAgIHRvZ2dsZVR5cGU6IGZ1bmN0aW9uIHRvZ2dsZVR5cGUodG9nZ2xlKSB7XG4gICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuc2V0VHlwZVRleHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0VHlwZVBhc3N3b3JkKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0UGFzc3dvcmQ6IGZ1bmN0aW9uIHNldFBhc3N3b3JkKHN0YXRlKSB7XG4gICAgICB0aGlzLk1kRmllbGQucGFzc3dvcmQgPSBzdGF0ZTtcbiAgICAgIHRoaXMuTWRGaWVsZC50b2dnbGVQYXNzd29yZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgc2V0VHlwZVBhc3N3b3JkOiBmdW5jdGlvbiBzZXRUeXBlUGFzc3dvcmQoKSB7XG4gICAgICB0aGlzLiRlbC50eXBlID0gJ3Bhc3N3b3JkJztcbiAgICB9LFxuICAgIHNldFR5cGVUZXh0OiBmdW5jdGlvbiBzZXRUeXBlVGV4dCgpIHtcbiAgICAgIHRoaXMuJGVsLnR5cGUgPSAndGV4dCc7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuc2V0UGFzc3dvcmQodGhpcy5pc1Bhc3N3b3JkKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnNldFBhc3N3b3JkKGZhbHNlKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZENoaXBzL01kQ2hpcC52dWVcbnZhciBNZENoaXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2Mik7XG52YXIgTWRDaGlwX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2hpcCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtODRiYTc3MWNcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRDaGlwcy9NZENoaXAudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwibWQtY2hpcFwiLCBhcHBlYXI6IFwiXCIgfSB9LCBbXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAgX3ZtLl9nKFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtY2hpcFwiLFxuICAgICAgICAgIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lLCBfdm0uY2hpcENsYXNzZXNdLFxuICAgICAgICAgIGF0dHJzOiB7IHRhYmluZGV4OiBcIjBcIiB9XG4gICAgICAgIH0sXG4gICAgICAgIF92bS4kbGlzdGVuZXJzXG4gICAgICApLFxuICAgICAgW1xuICAgICAgICBfdm0ubWRDbGlja2FibGUgfHwgIV92bS5tZFJpcHBsZVxuICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgIFwibWQtcmlwcGxlXCIsXG4gICAgICAgICAgICAgIHsgYXR0cnM6IHsgXCJtZC1kaXNhYmxlZFwiOiBfdm0ubWREaXNhYmxlZCB9IH0sXG4gICAgICAgICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogX3ZtLl90KFwiZGVmYXVsdFwiKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcIm1kLWlucHV0LWFjdGlvblwiLCBhcHBlYXI6IFwiXCIgfSB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF92bS5tZERlbGV0YWJsZVxuICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgXCJtZC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgXCJtZC1pY29uLWJ1dHRvbiBtZC1kZW5zZSBtZC1pbnB1dC1hY3Rpb24gbWQtY2xlYXJcIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgdGFiaW5kZXg6IFwiLTFcIiB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS4kZW1pdChcIm1kLWRlbGV0ZVwiLCAkZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW19jKFwibWQtY2xlYXItaWNvblwiKV0sXG4gICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgXSxcbiAgICAgICAgICAxXG4gICAgICAgIClcbiAgICAgIF0sXG4gICAgICAyXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZENoaXBzX01kQ2hpcCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtODRiYTc3MWNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kQ2hpcHMvTWRDaGlwLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTYxKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDaGlwX2RlZmF1bHQuYSxcbiAgTWRDaGlwc19NZENoaXAsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZENoaXBzL01kQ2hpcC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi04NGJhNzcxY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTg0YmE3NzFjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kQ2hpcHNfTWRDaGlwID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZEZvY3VzZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxudmFyIF9NZEZvY3VzZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRGb2N1c2VkKTtcblxudmFyIF9NZFJpcHBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgX01kUmlwcGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUmlwcGxlKTtcblxudmFyIF9NZENsZWFySWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgX01kQ2xlYXJJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ2xlYXJJY29uKTtcblxudmFyIF9NZEJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX01kQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQnV0dG9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZENoaXAnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRCdXR0b246IF9NZEJ1dHRvbjIuZGVmYXVsdCxcbiAgICBNZENsZWFySWNvbjogX01kQ2xlYXJJY29uMi5kZWZhdWx0XG4gIH0sXG4gIG1peGluczogW19NZEZvY3VzZWQyLmRlZmF1bHQsIF9NZFJpcHBsZTIuZGVmYXVsdF0sXG4gIHByb3BzOiB7XG4gICAgbWREaXNhYmxlZDogQm9vbGVhbixcbiAgICBtZERlbGV0YWJsZTogQm9vbGVhbixcbiAgICBtZENsaWNrYWJsZTogQm9vbGVhbixcbiAgICBtZER1cGxpY2F0ZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjaGlwQ2xhc3NlczogZnVuY3Rpb24gY2hpcENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtZGlzYWJsZWQnOiB0aGlzLm1kRGlzYWJsZWQsXG4gICAgICAgICdtZC1kZWxldGFibGUnOiB0aGlzLm1kRGVsZXRhYmxlLFxuICAgICAgICAnbWQtY2xpY2thYmxlJzogdGhpcy5tZENsaWNrYWJsZSxcbiAgICAgICAgJ21kLWZvY3VzZWQnOiB0aGlzLm1kSGFzRm9jdXMsXG4gICAgICAgICdtZC1kdXBsaWNhdGVkJzogdGhpcy5tZER1cGxpY2F0ZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDE2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRDb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBfTWRDb250ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29udGVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRDb250ZW50Mi5kZWZhdWx0Lm5hbWUsIF9NZENvbnRlbnQyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kQ29udGVudCcsXG4gIHByb3BzOiB7XG4gICAgbWRUYWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdkaXYnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGhpcy5tZFRhZywge1xuICAgICAgc3RhdGljQ2xhc3M6ICdtZC1jb250ZW50JyxcbiAgICAgIGNsYXNzOiBbdGhpcy4kbWRBY3RpdmVUaGVtZV0sXG4gICAgICBhdHRyczogdGhpcy4kYXR0cnMsXG4gICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgfSwgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWREYXRlcGlja2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjYpO1xuXG52YXIgX01kRGF0ZXBpY2tlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERhdGVwaWNrZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kRGF0ZXBpY2tlcjIuZGVmYXVsdC5uYW1lLCBfTWREYXRlcGlja2VyMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyLnZ1ZVxudmFyIE1kRGF0ZXBpY2tlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTY4KTtcbnZhciBNZERhdGVwaWNrZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWREYXRlcGlja2VyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zN2ZlNzkyZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWZpZWxkXCIsXG4gICAge1xuICAgICAgY2xhc3M6IFtcIm1kLWRhdGVwaWNrZXJcIiwgeyBcIm1kLW5hdGl2ZVwiOiAhdGhpcy5tZE92ZXJyaWRlTmF0aXZlIH1dLFxuICAgICAgYXR0cnM6IHsgXCJtZC1jbGVhcmFibGVcIjogXCJcIiB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcIm1kLWRhdGUtaWNvblwiLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWRhdGUtaWNvblwiLFxuICAgICAgICBuYXRpdmVPbjoge1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgIF92bS50b2dnbGVEaWFsb2coJGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJtZC1pbnB1dFwiLCB7XG4gICAgICAgIHJlZjogXCJpbnB1dFwiLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBfdm0udHlwZSwgcGF0dGVybjogXCJbMC05XXs0fS1bMC05XXsyfS1bMC05XXsyfVwiIH0sXG4gICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgZm9jdXM6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLm9uRm9jdXMoJGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICB2YWx1ZTogX3ZtLm1vZGVsRGF0ZSxcbiAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICBfdm0ubW9kZWxEYXRlID0gJCR2XG4gICAgICAgICAgfSxcbiAgICAgICAgICBleHByZXNzaW9uOiBcIm1vZGVsRGF0ZVwiXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5fdChcImRlZmF1bHRcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLnNob3dEaWFsb2dcbiAgICAgICAgICAgID8gX2MoXCJtZC1kYXRlcGlja2VyLWRpYWxvZ1wiLCB7XG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIFwibWQtZGF0ZVwiOiBfdm0uc2VsZWN0ZWREYXRlLFxuICAgICAgICAgICAgICAgICAgXCJtZC1kaXNhYmxlZC1kYXRlc1wiOiBfdm0ubWREaXNhYmxlZERhdGVzXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgXCJ1cGRhdGU6bWREYXRlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdm0uc2VsZWN0ZWREYXRlID0gJGV2ZW50XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJtZC1jbG9zZWRcIjogX3ZtLnRvZ2dsZURpYWxvZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcIm1kLW92ZXJsYXlcIiwge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1kYXRlcGlja2VyLW92ZXJsYXlcIixcbiAgICAgICAgYXR0cnM6IHsgXCJtZC1maXhlZFwiOiBcIlwiLCBcIm1kLWFjdGl2ZVwiOiBfdm0uc2hvd0RpYWxvZyB9LFxuICAgICAgICBvbjogeyBjbGljazogX3ZtLnRvZ2dsZURpYWxvZyB9XG4gICAgICB9KVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGF0ZXBpY2tlcl9NZERhdGVwaWNrZXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTM3ZmU3OTJmXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTY3KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREYXRlcGlja2VyX2RlZmF1bHQuYSxcbiAgTWREYXRlcGlja2VyX01kRGF0ZXBpY2tlcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRGF0ZXBpY2tlci9NZERhdGVwaWNrZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMzdmZTc5MmZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zN2ZlNzkyZlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZERhdGVwaWNrZXJfTWREYXRlcGlja2VyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdnVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxudmFyIF9pc0ZpcmVmb3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2OSk7XG5cbnZhciBfaXNGaXJlZm94MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzRmlyZWZveCk7XG5cbnZhciBfZm9ybWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzApO1xuXG52YXIgX2Zvcm1hdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb3JtYXQpO1xuXG52YXIgX3BhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9wYXJzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZSk7XG5cbnZhciBfaXNfdmFsaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxudmFyIF9pc192YWxpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc192YWxpZCk7XG5cbnZhciBfTWRPdmVybGF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfTWRPdmVybGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kT3ZlcmxheSk7XG5cbnZhciBfTWREYXRlcGlja2VyRGlhbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODMpO1xuXG52YXIgX01kRGF0ZXBpY2tlckRpYWxvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERhdGVwaWNrZXJEaWFsb2cpO1xuXG52YXIgX01kRGF0ZUljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNyk7XG5cbnZhciBfTWREYXRlSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERhdGVJY29uKTtcblxudmFyIF9NZEZpZWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfTWRGaWVsZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEZpZWxkKTtcblxudmFyIF9NZElucHV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfTWRJbnB1dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZElucHV0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZERhdGVwaWNrZXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRPdmVybGF5OiBfTWRPdmVybGF5Mi5kZWZhdWx0LFxuICAgIE1kRGF0ZUljb246IF9NZERhdGVJY29uMi5kZWZhdWx0LFxuICAgIE1kRmllbGQ6IF9NZEZpZWxkMi5kZWZhdWx0LFxuICAgIE1kSW5wdXQ6IF9NZElucHV0Mi5kZWZhdWx0LFxuICAgIE1kRGF0ZXBpY2tlckRpYWxvZzogX01kRGF0ZXBpY2tlckRpYWxvZzIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbU3RyaW5nLCBEYXRlXSxcbiAgICBtZERpc2FibGVkRGF0ZXM6IFtBcnJheSwgRnVuY3Rpb25dLFxuICAgIG1kT3Blbk9uRm9jdXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZE92ZXJyaWRlTmF0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd0RpYWxvZzogZmFsc2UsXG4gICAgICBtb2RlbERhdGU6IG51bGwsXG4gICAgICBzZWxlY3RlZERhdGU6IG51bGxcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHR5cGU6IGZ1bmN0aW9uIHR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZE92ZXJyaWRlTmF0aXZlID8gJ3RleHQnIDogJ2RhdGUnO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBzZWxlY3RlZERhdGU6IGZ1bmN0aW9uIHNlbGVjdGVkRGF0ZShfc2VsZWN0ZWREYXRlKSB7XG4gICAgICBpZiAoX3NlbGVjdGVkRGF0ZSkge1xuICAgICAgICB0aGlzLm1vZGVsRGF0ZSA9IHRoaXMuZGF0ZVRvSFRNTFN0cmluZyhfc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCBfc2VsZWN0ZWREYXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMubW9kZWxEYXRlID0gdGhpcy5kYXRlVG9IVE1MU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbW9kZWxEYXRlOiBmdW5jdGlvbiBtb2RlbERhdGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFyc2VkRGF0ZSA9ICgwLCBfcGFyc2UyLmRlZmF1bHQpKHZhbHVlKTtcblxuICAgICAgICBpZiAoKDAsIF9pc192YWxpZDIuZGVmYXVsdCkocGFyc2VkRGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHBhcnNlZERhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB0b2dnbGVEaWFsb2c6IGZ1bmN0aW9uIHRvZ2dsZURpYWxvZygpIHtcbiAgICAgIGlmICghX2lzRmlyZWZveDIuZGVmYXVsdCB8fCB0aGlzLm1kT3ZlcnJpZGVOYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zaG93RGlhbG9nID0gIXRoaXMuc2hvd0RpYWxvZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuJGVsLmNsaWNrKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMubWRPcGVuT25Gb2N1cykge1xuICAgICAgICB0aGlzLnRvZ2dsZURpYWxvZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGF0ZVRvSFRNTFN0cmluZzogZnVuY3Rpb24gZGF0ZVRvSFRNTFN0cmluZyhkYXRlKSB7XG4gICAgICBpZiAoZGF0ZSkge1xuICAgICAgICB2YXIgZm9ybWF0dGVkRGF0ZSA9IG51bGw7XG4gICAgICAgIHZhciBkYXRlRm9ybWF0ID0gdGhpcy4kbWF0ZXJpYWwubG9jYWxlLmRhdGVGb3JtYXQgfHwgJ1lZWVktTU0tREQnO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9ybWF0dGVkRGF0ZSA9ICgwLCBfZm9ybWF0Mi5kZWZhdWx0KShkYXRlLCBkYXRlRm9ybWF0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBfdnVlMi5kZWZhdWx0LnV0aWwud2FybignVGhlIGRhdGVwaWNrZXIgdmFsdWUgaXMgbm90IGEgdmFsaWQgZGF0ZS4gR2l2ZW4gdmFsdWU6ICcgKyBkYXRlICsgJy4nLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWREYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLm1vZGVsRGF0ZSA9IHRoaXMuZGF0ZVRvSFRNTFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuXG4vKioqLyB9KSxcbi8qIDE3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0RGF5T2ZZZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzEpXG52YXIgZ2V0SVNPV2VlayA9IF9fd2VicGFja19yZXF1aXJlX18oMTc0KVxudmFyIGdldElTT1llYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KVxudmFyIHBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxudmFyIGlzVmFsaWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KVxudmFyIGVuTG9jYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzcpXG5cbi8qKlxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBGb3JtYXQgdGhlIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBkYXRlIHN0cmluZyBpbiB0aGUgZ2l2ZW4gZm9ybWF0LlxuICpcbiAqIEFjY2VwdGVkIHRva2VuczpcbiAqIHwgVW5pdCAgICAgICAgICAgICAgICAgICAgfCBUb2tlbiB8IFJlc3VsdCBleGFtcGxlcyAgICAgICAgICAgICAgICAgIHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgTW9udGggICAgICAgICAgICAgICAgICAgfCBNICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNbyAgICB8IDFzdCwgMm5kLCAuLi4sIDEydGggICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTSAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU0gICB8IEphbiwgRmViLCAuLi4sIERlYyAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBNTU1NICB8IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyIHxcbiAqIHwgUXVhcnRlciAgICAgICAgICAgICAgICAgfCBRICAgICB8IDEsIDIsIDMsIDQgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBRbyAgICB8IDFzdCwgMm5kLCAzcmQsIDR0aCAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIG1vbnRoICAgICAgICAgICAgfCBEICAgICB8IDEsIDIsIC4uLiwgMzEgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEbyAgICB8IDFzdCwgMm5kLCAuLi4sIDMxc3QgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERCAgICB8IDAxLCAwMiwgLi4uLCAzMSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHllYXIgICAgICAgICAgICAgfCBEREQgICB8IDEsIDIsIC4uLiwgMzY2ICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBERERvICB8IDFzdCwgMm5kLCAuLi4sIDM2NnRoICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBEREREICB8IDAwMSwgMDAyLCAuLi4sIDM2NiAgICAgICAgICAgICAgIHxcbiAqIHwgRGF5IG9mIHdlZWsgICAgICAgICAgICAgfCBkICAgICB8IDAsIDEsIC4uLiwgNiAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkbyAgICB8IDB0aCwgMXN0LCAuLi4sIDZ0aCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZCAgICB8IFN1LCBNbywgLi4uLCBTYSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGQgICB8IFN1biwgTW9uLCAuLi4sIFNhdCAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBkZGRkICB8IFN1bmRheSwgTW9uZGF5LCAuLi4sIFNhdHVyZGF5ICAgIHxcbiAqIHwgRGF5IG9mIElTTyB3ZWVrICAgICAgICAgfCBFICAgICB8IDEsIDIsIC4uLiwgNyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWsgICAgICAgICAgICAgICAgfCBXICAgICB8IDEsIDIsIC4uLiwgNTMgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXbyAgICB8IDFzdCwgMm5kLCAuLi4sIDUzcmQgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBXVyAgICB8IDAxLCAwMiwgLi4uLCA1MyAgICAgICAgICAgICAgICAgIHxcbiAqIHwgWWVhciAgICAgICAgICAgICAgICAgICAgfCBZWSAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBZWVlZICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgSVNPIHdlZWstbnVtYmVyaW5nIHllYXIgfCBHRyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBHR0dHICB8IDE5MDAsIDE5MDEsIC4uLiwgMjA5OSAgICAgICAgICAgIHxcbiAqIHwgQU0vUE0gICAgICAgICAgICAgICAgICAgfCBBICAgICB8IEFNLCBQTSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhICAgICB8IGFtLCBwbSAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBhYSAgICB8IGEubS4sIHAubS4gICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgSG91ciAgICAgICAgICAgICAgICAgICAgfCBIICAgICB8IDAsIDEsIC4uLiAyMyAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBISCAgICB8IDAwLCAwMSwgLi4uIDIzICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoICAgICB8IDEsIDIsIC4uLiwgMTIgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBoaCAgICB8IDAxLCAwMiwgLi4uLCAxMiAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWludXRlICAgICAgICAgICAgICAgICAgfCBtICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBtbSAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgU2Vjb25kICAgICAgICAgICAgICAgICAgfCBzICAgICB8IDAsIDEsIC4uLiwgNTkgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBzcyAgICB8IDAwLCAwMSwgLi4uLCA1OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMCBvZiBzZWNvbmQgICAgICAgICAgfCBTICAgICB8IDAsIDEsIC4uLiwgOSAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMS8xMDAgb2Ygc2Vjb25kICAgICAgICAgfCBTUyAgICB8IDAwLCAwMSwgLi4uLCA5OSAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmQgICAgICAgICAgICAgfCBTU1MgICB8IDAwMCwgMDAxLCAuLi4sIDk5OSAgICAgICAgICAgICAgIHxcbiAqIHwgVGltZXpvbmUgICAgICAgICAgICAgICAgfCBaICAgICB8IC0wMTowMCwgKzAwOjAwLCAuLi4gKzEyOjAwICAgICAgIHxcbiAqIHwgICAgICAgICAgICAgICAgICAgICAgICAgfCBaWiAgICB8IC0wMTAwLCArMDAwMCwgLi4uLCArMTIwMCAgICAgICAgIHxcbiAqIHwgU2Vjb25kcyB0aW1lc3RhbXAgICAgICAgfCBYICAgICB8IDUxMjk2OTUyMCAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgTWlsbGlzZWNvbmRzIHRpbWVzdGFtcCAgfCB4ICAgICB8IDUxMjk2OTUyMDkwMCAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBUaGUgY2hhcmFjdGVycyB3cmFwcGVkIGluIHNxdWFyZSBicmFja2V0cyBhcmUgZXNjYXBlZC5cbiAqXG4gKiBUaGUgcmVzdWx0IG1heSB2YXJ5IGJ5IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Zvcm1hdD0nWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJ10gLSB0aGUgc3RyaW5nIG9mIHRva2Vuc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubG9jYWxlPWVuTG9jYWxlXSAtIHRoZSBsb2NhbGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAxMSBGZWJydWFyeSAyMDE0IGluIG1pZGRsZS1lbmRpYW4gZm9ybWF0OlxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcbiAqICAgbmV3IERhdGUoMjAxNCwgMSwgMTEpLFxuICogICAnTU0vREQvWVlZWSdcbiAqIClcbiAqIC8vPT4gJzAyLzExLzIwMTQnXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlcHJlc2VudCAyIEp1bHkgMjAxNCBpbiBFc3BlcmFudG86XG4gKiB2YXIgZW9Mb2NhbGUgPSByZXF1aXJlKCdkYXRlLWZucy9sb2NhbGUvZW8nKVxuICogdmFyIHJlc3VsdCA9IGZvcm1hdChcbiAqICAgbmV3IERhdGUoMjAxNCwgNiwgMiksXG4gKiAgICdEbyBbZGVdIE1NTU0gWVlZWScsXG4gKiAgIHtsb2NhbGU6IGVvTG9jYWxlfVxuICogKVxuICogLy89PiAnMi1hIGRlIGp1bGlvIDIwMTQnXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdCAoZGlydHlEYXRlLCBkaXJ0eUZvcm1hdFN0ciwgZGlydHlPcHRpb25zKSB7XG4gIHZhciBmb3JtYXRTdHIgPSBkaXJ0eUZvcm1hdFN0ciA/IFN0cmluZyhkaXJ0eUZvcm1hdFN0cikgOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1NaJ1xuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxuXG4gIHZhciBsb2NhbGUgPSBvcHRpb25zLmxvY2FsZVxuICB2YXIgbG9jYWxlRm9ybWF0dGVycyA9IGVuTG9jYWxlLmZvcm1hdC5mb3JtYXR0ZXJzXG4gIHZhciBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gZW5Mb2NhbGUuZm9ybWF0LmZvcm1hdHRpbmdUb2tlbnNSZWdFeHBcbiAgaWYgKGxvY2FsZSAmJiBsb2NhbGUuZm9ybWF0ICYmIGxvY2FsZS5mb3JtYXQuZm9ybWF0dGVycykge1xuICAgIGxvY2FsZUZvcm1hdHRlcnMgPSBsb2NhbGUuZm9ybWF0LmZvcm1hdHRlcnNcblxuICAgIGlmIChsb2NhbGUuZm9ybWF0LmZvcm1hdHRpbmdUb2tlbnNSZWdFeHApIHtcbiAgICAgIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSBsb2NhbGUuZm9ybWF0LmZvcm1hdHRpbmdUb2tlbnNSZWdFeHBcbiAgICB9XG4gIH1cblxuICB2YXIgZGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcblxuICBpZiAoIWlzVmFsaWQoZGF0ZSkpIHtcbiAgICByZXR1cm4gJ0ludmFsaWQgRGF0ZSdcbiAgfVxuXG4gIHZhciBmb3JtYXRGbiA9IGJ1aWxkRm9ybWF0Rm4oZm9ybWF0U3RyLCBsb2NhbGVGb3JtYXR0ZXJzLCBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKVxuXG4gIHJldHVybiBmb3JtYXRGbihkYXRlKVxufVxuXG52YXIgZm9ybWF0dGVycyA9IHtcbiAgLy8gTW9udGg6IDEsIDIsIC4uLiwgMTJcbiAgJ00nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCkgKyAxXG4gIH0sXG5cbiAgLy8gTW9udGg6IDAxLCAwMiwgLi4uLCAxMlxuICAnTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRNb250aCgpICsgMSwgMilcbiAgfSxcblxuICAvLyBRdWFydGVyOiAxLCAyLCAzLCA0XG4gICdRJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDMpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIG1vbnRoOiAxLCAyLCAuLi4sIDMxXG4gICdEJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKClcbiAgfSxcblxuICAvLyBEYXkgb2YgbW9udGg6IDAxLCAwMiwgLi4uLCAzMVxuICAnREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXREYXRlKCksIDIpXG4gIH0sXG5cbiAgLy8gRGF5IG9mIHllYXI6IDEsIDIsIC4uLiwgMzY2XG4gICdEREQnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBnZXREYXlPZlllYXIoZGF0ZSlcbiAgfSxcblxuICAvLyBEYXkgb2YgeWVhcjogMDAxLCAwMDIsIC4uLiwgMzY2XG4gICdEREREJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGdldERheU9mWWVhcihkYXRlKSwgMylcbiAgfSxcblxuICAvLyBEYXkgb2Ygd2VlazogMCwgMSwgLi4uLCA2XG4gICdkJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXkoKVxuICB9LFxuXG4gIC8vIERheSBvZiBJU08gd2VlazogMSwgMiwgLi4uLCA3XG4gICdFJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXkoKSB8fCA3XG4gIH0sXG5cbiAgLy8gSVNPIHdlZWs6IDEsIDIsIC4uLiwgNTNcbiAgJ1cnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBnZXRJU09XZWVrKGRhdGUpXG4gIH0sXG5cbiAgLy8gSVNPIHdlZWs6IDAxLCAwMiwgLi4uLCA1M1xuICAnV1cnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZ2V0SVNPV2VlayhkYXRlKSwgMilcbiAgfSxcblxuICAvLyBZZWFyOiAwMCwgMDEsIC4uLiwgOTlcbiAgJ1lZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0RnVsbFllYXIoKSwgNCkuc3Vic3RyKDIpXG4gIH0sXG5cbiAgLy8gWWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdZWVlZJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gYWRkTGVhZGluZ1plcm9zKGRhdGUuZ2V0RnVsbFllYXIoKSwgNClcbiAgfSxcblxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMDAsIDAxLCAuLi4sIDk5XG4gICdHRyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIFN0cmluZyhnZXRJU09ZZWFyKGRhdGUpKS5zdWJzdHIoMilcbiAgfSxcblxuICAvLyBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogMTkwMCwgMTkwMSwgLi4uLCAyMDk5XG4gICdHR0dHJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZ2V0SVNPWWVhcihkYXRlKVxuICB9LFxuXG4gIC8vIEhvdXI6IDAsIDEsIC4uLiAyM1xuICAnSCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKVxuICB9LFxuXG4gIC8vIEhvdXI6IDAwLCAwMSwgLi4uLCAyM1xuICAnSEgnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRIb3VycygpLCAyKVxuICB9LFxuXG4gIC8vIEhvdXI6IDEsIDIsIC4uLiwgMTJcbiAgJ2gnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHZhciBob3VycyA9IGRhdGUuZ2V0SG91cnMoKVxuICAgIGlmIChob3VycyA9PT0gMCkge1xuICAgICAgcmV0dXJuIDEyXG4gICAgfSBlbHNlIGlmIChob3VycyA+IDEyKSB7XG4gICAgICByZXR1cm4gaG91cnMgJSAxMlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaG91cnNcbiAgICB9XG4gIH0sXG5cbiAgLy8gSG91cjogMDEsIDAyLCAuLi4sIDEyXG4gICdoaCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhmb3JtYXR0ZXJzWydoJ10oZGF0ZSksIDIpXG4gIH0sXG5cbiAgLy8gTWludXRlOiAwLCAxLCAuLi4sIDU5XG4gICdtJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKClcbiAgfSxcblxuICAvLyBNaW51dGU6IDAwLCAwMSwgLi4uLCA1OVxuICAnbW0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRNaW51dGVzKCksIDIpXG4gIH0sXG5cbiAgLy8gU2Vjb25kOiAwLCAxLCAuLi4sIDU5XG4gICdzJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKClcbiAgfSxcblxuICAvLyBTZWNvbmQ6IDAwLCAwMSwgLi4uLCA1OVxuICAnc3MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRTZWNvbmRzKCksIDIpXG4gIH0sXG5cbiAgLy8gMS8xMCBvZiBzZWNvbmQ6IDAsIDEsIC4uLiwgOVxuICAnUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAvIDEwMClcbiAgfSxcblxuICAvLyAxLzEwMCBvZiBzZWNvbmQ6IDAwLCAwMSwgLi4uLCA5OVxuICAnU1MnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBhZGRMZWFkaW5nWmVyb3MoTWF0aC5mbG9vcihkYXRlLmdldE1pbGxpc2Vjb25kcygpIC8gMTApLCAyKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kOiAwMDAsIDAwMSwgLi4uLCA5OTlcbiAgJ1NTUyc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpLCAzKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDE6MDAsICswMDowMCwgLi4uICsxMjowMFxuICAnWic6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGZvcm1hdFRpbWV6b25lKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgJzonKVxuICB9LFxuXG4gIC8vIFRpbWV6b25lOiAtMDEwMCwgKzAwMDAsIC4uLiArMTIwMFxuICAnWlonOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgIHJldHVybiBmb3JtYXRUaW1lem9uZShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpXG4gIH0sXG5cbiAgLy8gU2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMFxuICAnWCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKVxuICB9LFxuXG4gIC8vIE1pbGxpc2Vjb25kcyB0aW1lc3RhbXA6IDUxMjk2OTUyMDkwMFxuICAneCc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtYXRGbiAoZm9ybWF0U3RyLCBsb2NhbGVGb3JtYXR0ZXJzLCBmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKSB7XG4gIHZhciBhcnJheSA9IGZvcm1hdFN0ci5tYXRjaChmb3JtYXR0aW5nVG9rZW5zUmVnRXhwKVxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoXG5cbiAgdmFyIGlcbiAgdmFyIGZvcm1hdHRlclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBmb3JtYXR0ZXIgPSBsb2NhbGVGb3JtYXR0ZXJzW2FycmF5W2ldXSB8fCBmb3JtYXR0ZXJzW2FycmF5W2ldXVxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIGFycmF5W2ldID0gZm9ybWF0dGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICB2YXIgb3V0cHV0ID0gJydcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0oZGF0ZSwgZm9ybWF0dGVycylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dCArPSBhcnJheVtpXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyAoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XSQvZywgJycpXG4gIH1cbiAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRpbWV6b25lIChvZmZzZXQsIGRlbGltZXRlcikge1xuICBkZWxpbWV0ZXIgPSBkZWxpbWV0ZXIgfHwgJydcbiAgdmFyIHNpZ24gPSBvZmZzZXQgPiAwID8gJy0nIDogJysnXG4gIHZhciBhYnNPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQpXG4gIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzT2Zmc2V0IC8gNjApXG4gIHZhciBtaW51dGVzID0gYWJzT2Zmc2V0ICUgNjBcbiAgcmV0dXJuIHNpZ24gKyBhZGRMZWFkaW5nWmVyb3MoaG91cnMsIDIpICsgZGVsaW1ldGVyICsgYWRkTGVhZGluZ1plcm9zKG1pbnV0ZXMsIDIpXG59XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdaZXJvcyAobnVtYmVyLCB0YXJnZXRMZW5ndGgpIHtcbiAgdmFyIG91dHB1dCA9IE1hdGguYWJzKG51bWJlcikudG9TdHJpbmcoKVxuICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgIG91dHB1dCA9ICcwJyArIG91dHB1dFxuICB9XG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JtYXRcblxuXG4vKioqLyB9KSxcbi8qIDE3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG52YXIgc3RhcnRPZlllYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MilcbnZhciBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3MylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgZGF5IG9mIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBkYXkgb2YgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZ2l2ZW4gZGF0ZVxuICogQHJldHVybnMge051bWJlcn0gdGhlIGRheSBvZiB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgeWVhciBpcyAyIEp1bHkgMjAxND9cbiAqIHZhciByZXN1bHQgPSBnZXREYXlPZlllYXIobmV3IERhdGUoMjAxNCwgNiwgMikpXG4gKiAvLz0+IDE4M1xuICovXG5mdW5jdGlvbiBnZXREYXlPZlllYXIgKGRpcnR5RGF0ZSkge1xuICB2YXIgZGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcbiAgdmFyIGRpZmYgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZSwgc3RhcnRPZlllYXIoZGF0ZSkpXG4gIHZhciBkYXlPZlllYXIgPSBkaWZmICsgMVxuICByZXR1cm4gZGF5T2ZZZWFyXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF5T2ZZZWFyXG5cblxuLyoqKi8gfSksXG4vKiAxNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSB5ZWFyIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSByZXN1bHQgd2lsbCBiZSBpbiB0aGUgbG9jYWwgdGltZXpvbmUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBzdGFydCBvZiBhIHllYXJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVGhlIHN0YXJ0IG9mIGEgeWVhciBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIHZhciByZXN1bHQgPSBzdGFydE9mWWVhcihuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDAwKSlcbiAqIC8vPT4gV2VkIEphbiAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZZZWFyIChkaXJ0eURhdGUpIHtcbiAgdmFyIGNsZWFuRGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICBkYXRlLnNldEZ1bGxZZWFyKGNsZWFuRGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKVxuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHJldHVybiBkYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhcnRPZlllYXJcblxuXG4vKioqLyB9KSxcbi8qIDE3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RhcnRPZkRheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpXG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDBcbnZhciBNSUxMSVNFQ09ORFNfSU5fREFZID0gODY0MDAwMDBcblxuLyoqXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgbnVtYmVyIG9mIGNhbGVuZGFyIGRheXMgYmV0d2VlbiB0aGUgZ2l2ZW4gZGF0ZXMuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciBkYXlzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlTGVmdCAtIHRoZSBsYXRlciBkYXRlXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZVJpZ2h0IC0gdGhlIGVhcmxpZXIgZGF0ZVxuICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBvZiBjYWxlbmRhciBkYXlzXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEhvdyBtYW55IGNhbGVuZGFyIGRheXMgYXJlIGJldHdlZW5cbiAqIC8vIDIgSnVseSAyMDExIDIzOjAwOjAwIGFuZCAyIEp1bHkgMjAxMiAwMDowMDowMD9cbiAqIHZhciByZXN1bHQgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoXG4gKiAgIG5ldyBEYXRlKDIwMTIsIDYsIDIsIDAsIDApLFxuICogICBuZXcgRGF0ZSgyMDExLCA2LCAyLCAyMywgMClcbiAqIClcbiAqIC8vPT4gMzY2XG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyAoZGlydHlEYXRlTGVmdCwgZGlydHlEYXRlUmlnaHQpIHtcbiAgdmFyIHN0YXJ0T2ZEYXlMZWZ0ID0gc3RhcnRPZkRheShkaXJ0eURhdGVMZWZ0KVxuICB2YXIgc3RhcnRPZkRheVJpZ2h0ID0gc3RhcnRPZkRheShkaXJ0eURhdGVSaWdodClcblxuICB2YXIgdGltZXN0YW1wTGVmdCA9IHN0YXJ0T2ZEYXlMZWZ0LmdldFRpbWUoKSAtXG4gICAgc3RhcnRPZkRheUxlZnQuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIE1JTExJU0VDT05EU19JTl9NSU5VVEVcbiAgdmFyIHRpbWVzdGFtcFJpZ2h0ID0gc3RhcnRPZkRheVJpZ2h0LmdldFRpbWUoKSAtXG4gICAgc3RhcnRPZkRheVJpZ2h0LmdldFRpbWV6b25lT2Zmc2V0KCkgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFXG5cbiAgLy8gUm91bmQgdGhlIG51bWJlciBvZiBkYXlzIHRvIHRoZSBuZWFyZXN0IGludGVnZXJcbiAgLy8gYmVjYXVzZSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpbiBhIGRheSBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIGRheSBvZiB0aGUgZGF5bGlnaHQgc2F2aW5nIHRpbWUgY2xvY2sgc2hpZnQpXG4gIHJldHVybiBNYXRoLnJvdW5kKCh0aW1lc3RhbXBMZWZ0IC0gdGltZXN0YW1wUmlnaHQpIC8gTUlMTElTRUNPTkRTX0lOX0RBWSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXNcblxuXG4vKioqLyB9KSxcbi8qIDE3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG52YXIgc3RhcnRPZklTT1dlZWsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKVxudmFyIHN0YXJ0T2ZJU09ZZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzYpXG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fV0VFSyA9IDYwNDgwMDAwMFxuXG4vKipcbiAqIEBjYXRlZ29yeSBJU08gV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIElTTyB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBJU08gd2VlayBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBJU08gd2Vlay1udW1iZXJpbmcgeWVhcjogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZ2l2ZW4gZGF0ZVxuICogQHJldHVybnMge051bWJlcn0gdGhlIElTTyB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIHdlZWsgb2YgdGhlIElTTy13ZWVrIG51bWJlcmluZyB5ZWFyIGlzIDIgSmFudWFyeSAyMDA1P1xuICogdmFyIHJlc3VsdCA9IGdldElTT1dlZWsobmV3IERhdGUoMjAwNSwgMCwgMikpXG4gKiAvLz0+IDUzXG4gKi9cbmZ1bmN0aW9uIGdldElTT1dlZWsgKGRpcnR5RGF0ZSkge1xuICB2YXIgZGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcbiAgdmFyIGRpZmYgPSBzdGFydE9mSVNPV2VlayhkYXRlKS5nZXRUaW1lKCkgLSBzdGFydE9mSVNPWWVhcihkYXRlKS5nZXRUaW1lKClcblxuICAvLyBSb3VuZCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gdGhlIG5lYXJlc3QgaW50ZWdlclxuICAvLyBiZWNhdXNlIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGluIGEgd2VlayBpcyBub3QgY29uc3RhbnRcbiAgLy8gKGUuZy4gaXQncyBkaWZmZXJlbnQgaW4gdGhlIHdlZWsgb2YgdGhlIGRheWxpZ2h0IHNhdmluZyB0aW1lIGNsb2NrIHNoaWZ0KVxuICByZXR1cm4gTWF0aC5yb3VuZChkaWZmIC8gTUlMTElTRUNPTkRTX0lOX1dFRUspICsgMVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldElTT1dlZWtcblxuXG4vKioqLyB9KSxcbi8qIDE3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG5cbi8qKlxuICogQGNhdGVnb3J5IFdlZWsgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIHJlc3VsdCB3aWxsIGJlIGluIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgc3RhcnQgb2YgYSB3ZWVrXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiB2YXIgcmVzdWx0ID0gc3RhcnRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gU3VuIEF1ZyAzMSAyMDE0IDAwOjAwOjAwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRoZSB3ZWVrIHN0YXJ0cyBvbiBNb25kYXksIHRoZSBzdGFydCBvZiB0aGUgd2VlayBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIHZhciByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApLCB7d2Vla1N0YXJ0c09uOiAxfSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZXZWVrIChkaXJ0eURhdGUsIGRpcnR5T3B0aW9ucykge1xuICB2YXIgd2Vla1N0YXJ0c09uID0gZGlydHlPcHRpb25zID8gKE51bWJlcihkaXJ0eU9wdGlvbnMud2Vla1N0YXJ0c09uKSB8fCAwKSA6IDBcblxuICB2YXIgZGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcbiAgdmFyIGRheSA9IGRhdGUuZ2V0RGF5KClcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uXG5cbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gZGlmZilcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKVxuICByZXR1cm4gZGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXJ0T2ZXZWVrXG5cblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldElTT1llYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KVxudmFyIHN0YXJ0T2ZJU09XZWVrID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMilcblxuLyoqXG4gKiBAY2F0ZWdvcnkgSVNPIFdlZWstTnVtYmVyaW5nIFllYXIgSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGFuIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyLFxuICogd2hpY2ggYWx3YXlzIHN0YXJ0cyAzIGRheXMgYmVmb3JlIHRoZSB5ZWFyJ3MgZmlyc3QgVGh1cnNkYXkuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIElTTyB3ZWVrLW51bWJlcmluZyB5ZWFyOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGVcbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBvcmlnaW5hbCBkYXRlXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHN0YXJ0IG9mIGFuIElTTyB5ZWFyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhbiBJU08gd2Vlay1udW1iZXJpbmcgeWVhciBmb3IgMiBKdWx5IDIwMDU6XG4gKiB2YXIgcmVzdWx0ID0gc3RhcnRPZklTT1llYXIobmV3IERhdGUoMjAwNSwgNiwgMikpXG4gKiAvLz0+IE1vbiBKYW4gMDMgMjAwNSAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzdGFydE9mSVNPWWVhciAoZGlydHlEYXRlKSB7XG4gIHZhciB5ZWFyID0gZ2V0SVNPWWVhcihkaXJ0eURhdGUpXG4gIHZhciBmb3VydGhPZkphbnVhcnkgPSBuZXcgRGF0ZSgwKVxuICBmb3VydGhPZkphbnVhcnkuc2V0RnVsbFllYXIoeWVhciwgMCwgNClcbiAgZm91cnRoT2ZKYW51YXJ5LnNldEhvdXJzKDAsIDAsIDAsIDApXG4gIHZhciBkYXRlID0gc3RhcnRPZklTT1dlZWsoZm91cnRoT2ZKYW51YXJ5KVxuICByZXR1cm4gZGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXJ0T2ZJU09ZZWFyXG5cblxuLyoqKi8gfSksXG4vKiAxNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJ1aWxkRGlzdGFuY2VJbldvcmRzTG9jYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzgpXG52YXIgYnVpbGRGb3JtYXRMb2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3OSlcblxuLyoqXG4gKiBAY2F0ZWdvcnkgTG9jYWxlc1xuICogQHN1bW1hcnkgRW5nbGlzaCBsb2NhbGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkaXN0YW5jZUluV29yZHM6IGJ1aWxkRGlzdGFuY2VJbldvcmRzTG9jYWxlKCksXG4gIGZvcm1hdDogYnVpbGRGb3JtYXRMb2NhbGUoKVxufVxuXG5cbi8qKiovIH0pLFxuLyogMTc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIGJ1aWxkRGlzdGFuY2VJbldvcmRzTG9jYWxlICgpIHtcbiAgdmFyIGRpc3RhbmNlSW5Xb3Jkc0xvY2FsZSA9IHtcbiAgICBsZXNzVGhhblhTZWNvbmRzOiB7XG4gICAgICBvbmU6ICdsZXNzIHRoYW4gYSBzZWNvbmQnLFxuICAgICAgb3RoZXI6ICdsZXNzIHRoYW4ge3tjb3VudH19IHNlY29uZHMnXG4gICAgfSxcblxuICAgIHhTZWNvbmRzOiB7XG4gICAgICBvbmU6ICcxIHNlY29uZCcsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBzZWNvbmRzJ1xuICAgIH0sXG5cbiAgICBoYWxmQU1pbnV0ZTogJ2hhbGYgYSBtaW51dGUnLFxuXG4gICAgbGVzc1RoYW5YTWludXRlczoge1xuICAgICAgb25lOiAnbGVzcyB0aGFuIGEgbWludXRlJyxcbiAgICAgIG90aGVyOiAnbGVzcyB0aGFuIHt7Y291bnR9fSBtaW51dGVzJ1xuICAgIH0sXG5cbiAgICB4TWludXRlczoge1xuICAgICAgb25lOiAnMSBtaW51dGUnLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gbWludXRlcydcbiAgICB9LFxuXG4gICAgYWJvdXRYSG91cnM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgaG91cicsXG4gICAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSBob3VycydcbiAgICB9LFxuXG4gICAgeEhvdXJzOiB7XG4gICAgICBvbmU6ICcxIGhvdXInLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0gaG91cnMnXG4gICAgfSxcblxuICAgIHhEYXlzOiB7XG4gICAgICBvbmU6ICcxIGRheScsXG4gICAgICBvdGhlcjogJ3t7Y291bnR9fSBkYXlzJ1xuICAgIH0sXG5cbiAgICBhYm91dFhNb250aHM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgbW9udGgnLFxuICAgICAgb3RoZXI6ICdhYm91dCB7e2NvdW50fX0gbW9udGhzJ1xuICAgIH0sXG5cbiAgICB4TW9udGhzOiB7XG4gICAgICBvbmU6ICcxIG1vbnRoJyxcbiAgICAgIG90aGVyOiAne3tjb3VudH19IG1vbnRocydcbiAgICB9LFxuXG4gICAgYWJvdXRYWWVhcnM6IHtcbiAgICAgIG9uZTogJ2Fib3V0IDEgeWVhcicsXG4gICAgICBvdGhlcjogJ2Fib3V0IHt7Y291bnR9fSB5ZWFycydcbiAgICB9LFxuXG4gICAgeFllYXJzOiB7XG4gICAgICBvbmU6ICcxIHllYXInLFxuICAgICAgb3RoZXI6ICd7e2NvdW50fX0geWVhcnMnXG4gICAgfSxcblxuICAgIG92ZXJYWWVhcnM6IHtcbiAgICAgIG9uZTogJ292ZXIgMSB5ZWFyJyxcbiAgICAgIG90aGVyOiAnb3ZlciB7e2NvdW50fX0geWVhcnMnXG4gICAgfSxcblxuICAgIGFsbW9zdFhZZWFyczoge1xuICAgICAgb25lOiAnYWxtb3N0IDEgeWVhcicsXG4gICAgICBvdGhlcjogJ2FsbW9zdCB7e2NvdW50fX0geWVhcnMnXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9jYWxpemUgKHRva2VuLCBjb3VudCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgICB2YXIgcmVzdWx0XG4gICAgaWYgKHR5cGVvZiBkaXN0YW5jZUluV29yZHNMb2NhbGVbdG9rZW5dID09PSAnc3RyaW5nJykge1xuICAgICAgcmVzdWx0ID0gZGlzdGFuY2VJbldvcmRzTG9jYWxlW3Rva2VuXVxuICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgIHJlc3VsdCA9IGRpc3RhbmNlSW5Xb3Jkc0xvY2FsZVt0b2tlbl0ub25lXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGRpc3RhbmNlSW5Xb3Jkc0xvY2FsZVt0b2tlbl0ub3RoZXIucmVwbGFjZSgne3tjb3VudH19JywgY291bnQpXG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYWRkU3VmZml4KSB7XG4gICAgICBpZiAob3B0aW9ucy5jb21wYXJpc29uID4gMCkge1xuICAgICAgICByZXR1cm4gJ2luICcgKyByZXN1bHRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyAnIGFnbydcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxvY2FsaXplOiBsb2NhbGl6ZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGREaXN0YW5jZUluV29yZHNMb2NhbGVcblxuXG4vKioqLyB9KSxcbi8qIDE3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYnVpbGRGb3JtYXR0aW5nVG9rZW5zUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODApXG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0TG9jYWxlICgpIHtcbiAgLy8gTm90ZTogaW4gRW5nbGlzaCwgdGhlIG5hbWVzIG9mIGRheXMgb2YgdGhlIHdlZWsgYW5kIG1vbnRocyBhcmUgY2FwaXRhbGl6ZWQuXG4gIC8vIElmIHlvdSBhcmUgbWFraW5nIGEgbmV3IGxvY2FsZSBiYXNlZCBvbiB0aGlzIG9uZSwgY2hlY2sgaWYgdGhlIHNhbWUgaXMgdHJ1ZSBmb3IgdGhlIGxhbmd1YWdlIHlvdSdyZSB3b3JraW5nIG9uLlxuICAvLyBHZW5lcmFsbHksIGZvcm1hdHRlZCBkYXRlcyBzaG91bGQgbG9vayBsaWtlIHRoZXkgYXJlIGluIHRoZSBtaWRkbGUgb2YgYSBzZW50ZW5jZSxcbiAgLy8gZS5nLiBpbiBTcGFuaXNoIGxhbmd1YWdlIHRoZSB3ZWVrZGF5cyBhbmQgbW9udGhzIHNob3VsZCBiZSBpbiB0aGUgbG93ZXJjYXNlLlxuICB2YXIgbW9udGhzM2NoYXIgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ11cbiAgdmFyIG1vbnRoc0Z1bGwgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxuICB2YXIgd2Vla2RheXMyY2hhciA9IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXVxuICB2YXIgd2Vla2RheXMzY2hhciA9IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J11cbiAgdmFyIHdlZWtkYXlzRnVsbCA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXVxuICB2YXIgbWVyaWRpZW1VcHBlcmNhc2UgPSBbJ0FNJywgJ1BNJ11cbiAgdmFyIG1lcmlkaWVtTG93ZXJjYXNlID0gWydhbScsICdwbSddXG4gIHZhciBtZXJpZGllbUZ1bGwgPSBbJ2EubS4nLCAncC5tLiddXG5cbiAgdmFyIGZvcm1hdHRlcnMgPSB7XG4gICAgLy8gTW9udGg6IEphbiwgRmViLCAuLi4sIERlY1xuICAgICdNTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG1vbnRoczNjaGFyW2RhdGUuZ2V0TW9udGgoKV1cbiAgICB9LFxuXG4gICAgLy8gTW9udGg6IEphbnVhcnksIEZlYnJ1YXJ5LCAuLi4sIERlY2VtYmVyXG4gICAgJ01NTU0nOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG1vbnRoc0Z1bGxbZGF0ZS5nZXRNb250aCgpXVxuICAgIH0sXG5cbiAgICAvLyBEYXkgb2Ygd2VlazogU3UsIE1vLCAuLi4sIFNhXG4gICAgJ2RkJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiB3ZWVrZGF5czJjaGFyW2RhdGUuZ2V0RGF5KCldXG4gICAgfSxcblxuICAgIC8vIERheSBvZiB3ZWVrOiBTdW4sIE1vbiwgLi4uLCBTYXRcbiAgICAnZGRkJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiB3ZWVrZGF5czNjaGFyW2RhdGUuZ2V0RGF5KCldXG4gICAgfSxcblxuICAgIC8vIERheSBvZiB3ZWVrOiBTdW5kYXksIE1vbmRheSwgLi4uLCBTYXR1cmRheVxuICAgICdkZGRkJzogZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgIHJldHVybiB3ZWVrZGF5c0Z1bGxbZGF0ZS5nZXREYXkoKV1cbiAgICB9LFxuXG4gICAgLy8gQU0sIFBNXG4gICAgJ0EnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgLyAxMikgPj0gMSA/IG1lcmlkaWVtVXBwZXJjYXNlWzFdIDogbWVyaWRpZW1VcHBlcmNhc2VbMF1cbiAgICB9LFxuXG4gICAgLy8gYW0sIHBtXG4gICAgJ2EnOiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgLyAxMikgPj0gMSA/IG1lcmlkaWVtTG93ZXJjYXNlWzFdIDogbWVyaWRpZW1Mb3dlcmNhc2VbMF1cbiAgICB9LFxuXG4gICAgLy8gYS5tLiwgcC5tLlxuICAgICdhYSc6IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICByZXR1cm4gKGRhdGUuZ2V0SG91cnMoKSAvIDEyKSA+PSAxID8gbWVyaWRpZW1GdWxsWzFdIDogbWVyaWRpZW1GdWxsWzBdXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgb3JkaW5hbCB2ZXJzaW9uIG9mIGZvcm1hdHRlcnM6IE0gLT4gTW8sIEQgLT4gRG8sIGV0Yy5cbiAgdmFyIG9yZGluYWxGb3JtYXR0ZXJzID0gWydNJywgJ0QnLCAnREREJywgJ2QnLCAnUScsICdXJ11cbiAgb3JkaW5hbEZvcm1hdHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0dGVyVG9rZW4pIHtcbiAgICBmb3JtYXR0ZXJzW2Zvcm1hdHRlclRva2VuICsgJ28nXSA9IGZ1bmN0aW9uIChkYXRlLCBmb3JtYXR0ZXJzKSB7XG4gICAgICByZXR1cm4gb3JkaW5hbChmb3JtYXR0ZXJzW2Zvcm1hdHRlclRva2VuXShkYXRlKSlcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzLFxuICAgIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHA6IGJ1aWxkRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cChmb3JtYXR0ZXJzKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICB2YXIgcmVtMTAwID0gbnVtYmVyICUgMTAwXG4gIGlmIChyZW0xMDAgPiAyMCB8fCByZW0xMDAgPCAxMCkge1xuICAgIHN3aXRjaCAocmVtMTAwICUgMTApIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdzdCdcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICduZCdcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG51bWJlciArICdyZCdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bWJlciArICd0aCdcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBidWlsZEZvcm1hdExvY2FsZVxuXG5cbi8qKiovIH0pLFxuLyogMTgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjb21tb25Gb3JtYXR0ZXJLZXlzID0gW1xuICAnTScsICdNTScsICdRJywgJ0QnLCAnREQnLCAnREREJywgJ0REREQnLCAnZCcsXG4gICdFJywgJ1cnLCAnV1cnLCAnWVknLCAnWVlZWScsICdHRycsICdHR0dHJyxcbiAgJ0gnLCAnSEgnLCAnaCcsICdoaCcsICdtJywgJ21tJyxcbiAgJ3MnLCAnc3MnLCAnUycsICdTUycsICdTU1MnLFxuICAnWicsICdaWicsICdYJywgJ3gnXG5dXG5cbmZ1bmN0aW9uIGJ1aWxkRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cCAoZm9ybWF0dGVycykge1xuICB2YXIgZm9ybWF0dGVyS2V5cyA9IFtdXG4gIGZvciAodmFyIGtleSBpbiBmb3JtYXR0ZXJzKSB7XG4gICAgaWYgKGZvcm1hdHRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZm9ybWF0dGVyS2V5cy5wdXNoKGtleSlcbiAgICB9XG4gIH1cblxuICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IGNvbW1vbkZvcm1hdHRlcktleXNcbiAgICAuY29uY2F0KGZvcm1hdHRlcktleXMpXG4gICAgLnNvcnQoKVxuICAgIC5yZXZlcnNlKClcbiAgdmFyIGZvcm1hdHRpbmdUb2tlbnNSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICAgICcoXFxcXFtbXlxcXFxbXSpcXFxcXSl8KFxcXFxcXFxcKT8nICsgJygnICsgZm9ybWF0dGluZ1Rva2Vucy5qb2luKCd8JykgKyAnfC4pJywgJ2cnXG4gIClcblxuICByZXR1cm4gZm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkRm9ybWF0dGluZ1Rva2Vuc1JlZ0V4cFxuXG5cbi8qKiovIH0pLFxuLyogMTgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRQb3J0YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9NZFBvcnRhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFBvcnRhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kT3ZlcmxheScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZFBvcnRhbDogX01kUG9ydGFsMi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWRBY3RpdmU6IEJvb2xlYW4sXG4gICAgbWRBdHRhY2hUb1BhcmVudDogQm9vbGVhbixcbiAgICBtZEZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgb3ZlcmxheUNsYXNzZXM6IGZ1bmN0aW9uIG92ZXJsYXlDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLWZpeGVkJzogdGhpcy5tZEZpeGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMTgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyRGlhbG9nLnZ1ZVxudmFyIE1kRGF0ZXBpY2tlckRpYWxvZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1KTtcbnZhciBNZERhdGVwaWNrZXJEaWFsb2dfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWREYXRlcGlja2VyRGlhbG9nKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZjBhM2Q1MlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyRGlhbG9nLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLXBvcG92ZXJcIixcbiAgICB7IGF0dHJzOiB7IFwibWQtc2V0dGluZ3NcIjogX3ZtLnBvcHBlclNldHRpbmdzLCBcIm1kLWFjdGl2ZVwiOiBcIlwiIH0gfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgIHsgYXR0cnM6IHsgbmFtZTogXCJtZC1kYXRlcGlja2VyLWRpYWxvZ1wiLCBhcHBlYXI6IFwiXCIgfSB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1kYXRlcGlja2VyLWRpYWxvZ1wiLFxuICAgICAgICAgICAgICBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1oZWFkZXJcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci15ZWFyLXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBcIm1kLXNlbGVjdGVkXCI6IF92bS5jdXJyZW50VmlldyA9PT0gXCJ5ZWFyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uY3VycmVudFZpZXcgPSBcInllYXJcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKF92bS5zZWxlY3RlZFllYXIpKV1cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1kYXRlcGlja2VyLWRhdGUtc2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7IFwibWQtc2VsZWN0ZWRcIjogX3ZtLmN1cnJlbnRWaWV3ICE9PSBcInllYXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50VmlldyA9IFwiZGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3Ryb25nXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1kYXluYW1lXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnNob3J0RGF5TmFtZSkgKyBcIiwgXCIpXG4gICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInN0cm9uZ1wiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWRhdGVwaWNrZXItbW9udGhuYW1lXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnNob3J0TW9udGhOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwic3Ryb25nXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1kYXlcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uY3VycmVudERheSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWRhdGVwaWNrZXItYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwidHJhbnNpdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICB7IGF0dHJzOiB7IG5hbWU6IFwibWQtZGF0ZXBpY2tlci1ib2R5LWhlYWRlclwiIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50VmlldyA9PT0gXCJkYXlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1ib2R5LWhlYWRlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1kZW5zZSBtZC1pY29uLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ucHJldmlvdXNNb250aCB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfYyhcIm1kLWFycm93LWxlZnQtaWNvblwiKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1kZW5zZSBtZC1pY29uLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0ubmV4dE1vbnRoIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19jKFwibWQtYXJyb3ctcmlnaHQtaWNvblwiKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1ib2R5LWNvbnRlbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogX3ZtLmNvbnRlbnRTdHlsZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGF0dHJzOiB7IG5hbWU6IFwibWQtZGF0ZXBpY2tlci12aWV3XCIgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uY3VycmVudFZpZXcgPT09IFwiZGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRyYW5zaXRpb24tZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1kYXRlcGlja2VyLXBhbmVsIG1kLWRhdGVwaWNrZXItY2FsZW5kYXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogX3ZtLmNhbGVuZGFyQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtZC1kYXRlcGlja2VyLW1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fbChbX3ZtLmN1cnJlbnREYXRlXSwgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBtb250aC5nZXRNb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRhdGVwaWNrZXItcGFuZWwgbWQtZGF0ZXBpY2tlci1tb250aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRlbnNlIG1kLWRhdGVwaWNrZXItbW9udGgtdHJpZ2dlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50VmlldyA9IFwibW9udGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uY3VycmVudE1vbnRoTmFtZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLmN1cnJlbnRZZWFyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWRhdGVwaWNrZXItd2Vla1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9sKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ubG9jYWxlLnNob3J0ZXJEYXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihkYXksIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID49XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uZmlyc3REYXlPZkFXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwic3BhblwiLCB7IGtleTogaW5kZXggfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoZGF5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2woXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5sb2NhbGUuc2hvcnRlckRheXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGRheSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPCBfdm0uZmlyc3REYXlPZkFXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFwic3BhblwiLCB7IGtleTogaW5kZXggfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoZGF5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1kYXlzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnByZWZpeEVtcHR5RGF5cywgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogXCJkYXktZW1wdHktXCIgKyBkYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtZGF0ZXBpY2tlci1lbXB0eVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmRheXNJbk1vbnRoLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBcImRheS1cIiArIGRheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWRhdGVwaWNrZXItZGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1kYXRlcGlja2VyLWRheS1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1kYXRlcGlja2VyLXNlbGVjdGVkXCI6IF92bS5pc1NlbGVjdGVkRGF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRhdGVwaWNrZXItdG9kYXlcIjogX3ZtLmlzVG9kYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtZGF0ZXBpY2tlci1kaXNhYmxlZFwiOiBfdm0uaXNEaXNhYmxlZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2VsZWN0RGF0ZShkYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhkYXkpKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLmN1cnJlbnRWaWV3ID09PSBcIm1vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1kYXRlcGlja2VyLXBhbmVsIG1kLWRhdGVwaWNrZXItbW9udGgtc2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtZGF0ZXBpY2tlci15ZWFyLXRyaWdnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uY3VycmVudFZpZXcgPSBcInllYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLmN1cnJlbnRZZWFyKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0ubG9jYWxlLm1vbnRocywgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG1vbnRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtZGF0ZXBpY2tlci1tb250aC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtZGF0ZXBpY2tlci1zZWxlY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50TW9udGhOYW1lID09PSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uc3dpdGNoTW9udGgoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKG1vbnRoKSldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLmN1cnJlbnRWaWV3ID09PSBcInllYXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRhdGVwaWNrZXItcGFuZWwgbWQtZGF0ZXBpY2tlci15ZWFyLXNlbGVjdG9yIG1kLXNjcm9sbGJhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLmF2YWlsYWJsZVllYXJzLCBmdW5jdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWRhdGVwaWNrZXIteWVhci1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1kYXRlcGlja2VyLXNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5jdXJyZW50WWVhciA9PT0geWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnN3aXRjaFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKHllYXIpKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwibWQtZGlhbG9nLWFjdGlvbnNcIixcbiAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1kYXRlcGlja2VyLWJvZHktZm9vdGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtcHJpbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLm9uQ2FuY2VsIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KFwiQ2FuY2VsXCIpXVxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5vbkNvbmZpcm0gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJPa1wiKV1cbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGF0ZXBpY2tlcl9NZERhdGVwaWNrZXJEaWFsb2cgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTRmMGEzZDUyXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZERhdGVwaWNrZXIvTWREYXRlcGlja2VyRGlhbG9nLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTg0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREYXRlcGlja2VyRGlhbG9nX2RlZmF1bHQuYSxcbiAgTWREYXRlcGlja2VyX01kRGF0ZXBpY2tlckRpYWxvZyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRGF0ZXBpY2tlci9NZERhdGVwaWNrZXJEaWFsb2cudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNGYwYTNkNTJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00ZjBhM2Q1MlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZERhdGVwaWNrZXJfTWREYXRlcGlja2VyRGlhbG9nID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMTg0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMTg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYWRkX21vbnRocyA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX2FkZF9tb250aHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYWRkX21vbnRocyk7XG5cbnZhciBfc3RhcnRfb2ZfbW9udGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4Nik7XG5cbnZhciBfc3RhcnRfb2ZfbW9udGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhcnRfb2ZfbW9udGgpO1xuXG52YXIgX3N1Yl9tb250aHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4Nyk7XG5cbnZhciBfc3ViX21vbnRoczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdWJfbW9udGhzKTtcblxudmFyIF9nZXRfZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg4KTtcblxudmFyIF9nZXRfZGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRfZGF0ZSk7XG5cbnZhciBfZ2V0X2RheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg5KTtcblxudmFyIF9nZXRfZGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldF9kYXkpO1xuXG52YXIgX2dldF9kYXlzX2luX21vbnRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBfZ2V0X2RheXNfaW5fbW9udGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0X2RheXNfaW5fbW9udGgpO1xuXG52YXIgX2dldF9tb250aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkwKTtcblxudmFyIF9nZXRfbW9udGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0X21vbnRoKTtcblxudmFyIF9nZXRfeWVhciA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxKTtcblxudmFyIF9nZXRfeWVhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRfeWVhcik7XG5cbnZhciBfaXNfZXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5Mik7XG5cbnZhciBfaXNfZXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNfZXF1YWwpO1xuXG52YXIgX2lzX3NhbWVfZGF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTMpO1xuXG52YXIgX2lzX3NhbWVfZGF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzX3NhbWVfZGF5KTtcblxudmFyIF9pc190b2RheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTk0KTtcblxudmFyIF9pc190b2RheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc190b2RheSk7XG5cbnZhciBfc2V0X2RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5NSk7XG5cbnZhciBfc2V0X2RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0X2RhdGUpO1xuXG52YXIgX3NldF9tb250aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTk2KTtcblxudmFyIF9zZXRfbW9udGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0X21vbnRoKTtcblxudmFyIF9zZXRfeWVhciA9IF9fd2VicGFja19yZXF1aXJlX18oMTk3KTtcblxudmFyIF9zZXRfeWVhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRfeWVhcik7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZFBvcG92ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9NZFBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQb3BvdmVyKTtcblxudmFyIF9NZEFycm93UmlnaHRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDEpO1xuXG52YXIgX01kQXJyb3dSaWdodEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBcnJvd1JpZ2h0SWNvbik7XG5cbnZhciBfTWRBcnJvd0xlZnRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDMpO1xuXG52YXIgX01kQXJyb3dMZWZ0SWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFycm93TGVmdEljb24pO1xuXG52YXIgX01kRGlhbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfTWREaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2cpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfSAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBkYXlzSW5BV2VlayA9IDc7XG5cbnZhciBnZXRFbGVtZW50cyA9IGZ1bmN0aW9uIGdldEVsZW1lbnRzKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoZWwgJiYgZWwucXVlcnlTZWxlY3Rvcikge1xuICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWREYXRlcGlja2VyRGlhbG9nJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kUG9wb3ZlcjogX01kUG9wb3ZlcjIuZGVmYXVsdCxcbiAgICBNZEFycm93UmlnaHRJY29uOiBfTWRBcnJvd1JpZ2h0SWNvbjIuZGVmYXVsdCxcbiAgICBNZEFycm93TGVmdEljb246IF9NZEFycm93TGVmdEljb24yLmRlZmF1bHQsXG4gICAgTWREaWFsb2c6IF9NZERpYWxvZzIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kRGF0ZTogRGF0ZSxcbiAgICBtZERpc2FibGVkRGF0ZXM6IFtBcnJheSwgRnVuY3Rpb25dXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnREYXRlOiBudWxsLFxuICAgICAgc2VsZWN0ZWREYXRlOiBudWxsLFxuICAgICAgc2hvd0RpYWxvZzogZmFsc2UsXG4gICAgICBtb250aEFjdGlvbjogbnVsbCxcbiAgICAgIGN1cnJlbnRWaWV3OiAnZGF5JyxcbiAgICAgIGNvbnRlbnRTdHlsZXM6IHt9LFxuICAgICAgYXZhaWxhYmxlWWVhcnM6IG51bGxcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGZpcnN0RGF5T2ZBV2VlazogZnVuY3Rpb24gZmlyc3REYXlPZkFXZWVrKCkge1xuICAgICAgLy8gbm9ybWFsaXplXG4gICAgICB2YXIgZmlyc3REYXlPZkFXZWVrID0gTnVtYmVyKHRoaXMuJG1hdGVyaWFsLmxvY2FsZS5maXJzdERheU9mQVdlZWspO1xuICAgICAgaWYgKE51bWJlci5pc05hTihmaXJzdERheU9mQVdlZWspIHx8ICFOdW1iZXIuaXNGaW5pdGUoZmlyc3REYXlPZkFXZWVrKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGZpcnN0RGF5T2ZBV2VlayA9IE1hdGguZmxvb3IoZmlyc3REYXlPZkFXZWVrKSAlIGRheXNJbkFXZWVrO1xuICAgICAgZmlyc3REYXlPZkFXZWVrICs9IGZpcnN0RGF5T2ZBV2VlayA8IDAgPyBkYXlzSW5BV2VlayA6IDA7XG4gICAgICByZXR1cm4gZmlyc3REYXlPZkFXZWVrO1xuICAgIH0sXG4gICAgbG9jYWxlOiBmdW5jdGlvbiBsb2NhbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kbWF0ZXJpYWwubG9jYWxlO1xuICAgIH0sXG4gICAgcG9wcGVyU2V0dGluZ3M6IGZ1bmN0aW9uIHBvcHBlclNldHRpbmdzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLXN0YXJ0JyxcbiAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAga2VlcFRvZ2V0aGVyOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNhbGVuZGFyQ2xhc3NlczogZnVuY3Rpb24gY2FsZW5kYXJDbGFzc2VzKCkge1xuICAgICAgaWYgKHRoaXMubW9udGhBY3Rpb24gPT09ICduZXh0Jykge1xuICAgICAgICByZXR1cm4gJ21kLW5leHQnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ21kLXByZXZpb3VzJztcbiAgICB9LFxuICAgIGZpcnN0RGF5T2ZNb250aDogZnVuY3Rpb24gZmlyc3REYXlPZk1vbnRoKCkge1xuICAgICAgcmV0dXJuICgwLCBfc3RhcnRfb2ZfbW9udGgyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpLmdldERheSgpO1xuICAgIH0sXG4gICAgcHJlZml4RW1wdHlEYXlzOiBmdW5jdGlvbiBwcmVmaXhFbXB0eURheXMoKSB7XG4gICAgICB2YXIgcHJlZml4RW1wdHlEYXlzID0gdGhpcy5maXJzdERheU9mTW9udGggLSB0aGlzLmZpcnN0RGF5T2ZBV2VlaztcbiAgICAgIHByZWZpeEVtcHR5RGF5cyArPSBwcmVmaXhFbXB0eURheXMgPCAwID8gZGF5c0luQVdlZWsgOiAwO1xuICAgICAgcmV0dXJuIHByZWZpeEVtcHR5RGF5cztcbiAgICB9LFxuICAgIGRheXNJbk1vbnRoOiBmdW5jdGlvbiBkYXlzSW5Nb250aCgpIHtcbiAgICAgIHJldHVybiAoMCwgX2dldF9kYXlzX2luX21vbnRoMi5kZWZhdWx0KSh0aGlzLmN1cnJlbnREYXRlKTtcbiAgICB9LFxuICAgIGN1cnJlbnREYXk6IGZ1bmN0aW9uIGN1cnJlbnREYXkoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZ2V0X2RhdGUyLmRlZmF1bHQpKHRoaXMuc2VsZWN0ZWREYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfZ2V0X2RhdGUyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpO1xuICAgIH0sXG4gICAgY3VycmVudE1vbnRoOiBmdW5jdGlvbiBjdXJyZW50TW9udGgoKSB7XG4gICAgICByZXR1cm4gKDAsIF9nZXRfbW9udGgyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpO1xuICAgIH0sXG4gICAgY3VycmVudE1vbnRoTmFtZTogZnVuY3Rpb24gY3VycmVudE1vbnRoTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvY2FsZS5tb250aHNbdGhpcy5jdXJyZW50TW9udGhdO1xuICAgIH0sXG4gICAgY3VycmVudFllYXI6IGZ1bmN0aW9uIGN1cnJlbnRZZWFyKCkge1xuICAgICAgcmV0dXJuICgwLCBfZ2V0X3llYXIyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpO1xuICAgIH0sXG4gICAgc2VsZWN0ZWRZZWFyOiBmdW5jdGlvbiBzZWxlY3RlZFllYXIoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfZ2V0X3llYXIyLmRlZmF1bHQpKHRoaXMuc2VsZWN0ZWREYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfZ2V0X3llYXIyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpO1xuICAgIH0sXG4gICAgc2hvcnREYXlOYW1lOiBmdW5jdGlvbiBzaG9ydERheU5hbWUoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlLnNob3J0RGF5c1soMCwgX2dldF9kYXkyLmRlZmF1bHQpKHRoaXMuc2VsZWN0ZWREYXRlKV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmxvY2FsZS5zaG9ydERheXNbKDAsIF9nZXRfZGF5Mi5kZWZhdWx0KSh0aGlzLmN1cnJlbnREYXRlKV07XG4gICAgfSxcbiAgICBzaG9ydE1vbnRoTmFtZTogZnVuY3Rpb24gc2hvcnRNb250aE5hbWUoKSB7XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlLnNob3J0TW9udGhzWygwLCBfZ2V0X21vbnRoMi5kZWZhdWx0KSh0aGlzLnNlbGVjdGVkRGF0ZSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5sb2NhbGUuc2hvcnRNb250aHNbKDAsIF9nZXRfbW9udGgyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUpXTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWREYXRlOiBmdW5jdGlvbiBtZERhdGUoKSB7XG4gICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tZERhdGUgfHwgbmV3IERhdGUoKTtcbiAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gdGhpcy5tZERhdGU7XG4gICAgfSxcbiAgICBjdXJyZW50RGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUobmV4dCwgcHJldmlvdXMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDb250ZW50U3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnREYXRlO1xuICAgIH0oKSxcbiAgICBjdXJyZW50VmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIGFjdGl2ZVllYXI7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZVllYXIgPSBnZXRFbGVtZW50cyh0aGlzLiRlbCwgJy5tZC1kYXRlcGlja2VyLXllYXItYnV0dG9uLm1kLWRhdGVwaWNrZXItc2VsZWN0ZWQnKTtcblxuXG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlWWVhci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlWWVhclswXS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3I6ICdpbnN0YW50JyxcbiAgICAgICAgICAgICAgICAgICAgICBibG9jazogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgaW5saW5lOiAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjdXJyZW50VmlldygpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50VmlldztcbiAgICB9KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNldENvbnRlbnRTdHlsZXM6IGZ1bmN0aW9uIHNldENvbnRlbnRTdHlsZXMoKSB7XG4gICAgICB2YXIgbW9udGhzID0gZ2V0RWxlbWVudHModGhpcy4kZWwsICcubWQtZGF0ZXBpY2tlci1tb250aCcpO1xuXG4gICAgICBpZiAobW9udGhzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1vbnRoID0gbW9udGhzW21vbnRocy5sZW5ndGggLSAxXTtcblxuICAgICAgICB0aGlzLmNvbnRlbnRTdHlsZXMgPSB7XG4gICAgICAgICAgaGVpZ2h0OiBuZXh0TW9udGgub2Zmc2V0SGVpZ2h0ICsgMTAgKyAncHgnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBdmFpbGFibGVZZWFyczogZnVuY3Rpb24gc2V0QXZhaWxhYmxlWWVhcnMoKSB7XG4gICAgICB2YXIgX2xvY2FsZSA9IHRoaXMubG9jYWxlLFxuICAgICAgICAgIHN0YXJ0WWVhciA9IF9sb2NhbGUuc3RhcnRZZWFyLFxuICAgICAgICAgIGVuZFllYXIgPSBfbG9jYWxlLmVuZFllYXI7XG5cbiAgICAgIHZhciBjb3VudGVyID0gc3RhcnRZZWFyO1xuICAgICAgdmFyIHllYXJzID0gW107XG5cbiAgICAgIHdoaWxlIChjb3VudGVyIDw9IGVuZFllYXIpIHtcbiAgICAgICAgeWVhcnMucHVzaChjb3VudGVyKyspO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmF2YWlsYWJsZVllYXJzID0geWVhcnM7XG4gICAgfSxcbiAgICBoYW5kbGVEaXNhYmxlZERhdGVCeUFycmF5OiBmdW5jdGlvbiBoYW5kbGVEaXNhYmxlZERhdGVCeUFycmF5KGRhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kRGlzYWJsZWREYXRlcy5zb21lKGZ1bmN0aW9uIChkaXNhYmxlZERhdGUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfaXNfc2FtZV9kYXkyLmRlZmF1bHQpKGRpc2FibGVkRGF0ZSwgZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uIGlzRGlzYWJsZWQoZGF5KSB7XG4gICAgICBpZiAodGhpcy5tZERpc2FibGVkRGF0ZXMpIHtcbiAgICAgICAgdmFyIHRhcmdldERhdGUgPSAoMCwgX3NldF9kYXRlMi5kZWZhdWx0KSh0aGlzLmN1cnJlbnREYXRlLCBkYXkpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWREaXNhYmxlZERhdGVzKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURpc2FibGVkRGF0ZUJ5QXJyYXkodGFyZ2V0RGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMubWREaXNhYmxlZERhdGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubWREaXNhYmxlZERhdGVzKHRhcmdldERhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkRGF5OiBmdW5jdGlvbiBpc1NlbGVjdGVkRGF5KGRheSkge1xuICAgICAgcmV0dXJuICgwLCBfaXNfZXF1YWwyLmRlZmF1bHQpKHRoaXMuc2VsZWN0ZWREYXRlLCAoMCwgX3NldF9kYXRlMi5kZWZhdWx0KSh0aGlzLmN1cnJlbnREYXRlLCBkYXkpKTtcbiAgICB9LFxuICAgIGlzVG9kYXk6IGZ1bmN0aW9uIGlzVG9kYXkoZGF5KSB7XG4gICAgICByZXR1cm4gKDAsIF9pc190b2RheTIuZGVmYXVsdCkoKDAsIF9zZXRfZGF0ZTIuZGVmYXVsdCkodGhpcy5jdXJyZW50RGF0ZSwgZGF5KSk7XG4gICAgfSxcbiAgICBwcmV2aW91c01vbnRoOiBmdW5jdGlvbiBwcmV2aW91c01vbnRoKCkge1xuICAgICAgdGhpcy5tb250aEFjdGlvbiA9ICdwcmV2aW91cyc7XG4gICAgICB0aGlzLmN1cnJlbnREYXRlID0gKDAsIF9zdWJfbW9udGhzMi5kZWZhdWx0KSh0aGlzLmN1cnJlbnREYXRlLCAxKTtcbiAgICB9LFxuICAgIG5leHRNb250aDogZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgdGhpcy5tb250aEFjdGlvbiA9ICduZXh0JztcbiAgICAgIHRoaXMuY3VycmVudERhdGUgPSAoMCwgX2FkZF9tb250aHMyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUsIDEpO1xuICAgIH0sXG4gICAgc3dpdGNoTW9udGg6IGZ1bmN0aW9uIHN3aXRjaE1vbnRoKGluZGV4KSB7XG4gICAgICB0aGlzLmN1cnJlbnREYXRlID0gKDAsIF9zZXRfbW9udGgyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUsIGluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcgPSAnZGF5JztcbiAgICB9LFxuICAgIHN3aXRjaFllYXI6IGZ1bmN0aW9uIHN3aXRjaFllYXIoeWVhcikge1xuICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9ICgwLCBfc2V0X3llYXIyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUsIHllYXIpO1xuICAgICAgdGhpcy5jdXJyZW50VmlldyA9ICdtb250aCc7XG4gICAgfSxcbiAgICBzZWxlY3REYXRlOiBmdW5jdGlvbiBzZWxlY3REYXRlKGRheSkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9ICgwLCBfc2V0X2RhdGUyLmRlZmF1bHQpKHRoaXMuY3VycmVudERhdGUsIGRheSk7XG4gICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHRoaXMuY3VycmVudERhdGU7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWREYXRlJywgdGhpcy5zZWxlY3RlZERhdGUpO1xuICAgIH0sXG4gICAgY2xvc2VEaWFsb2c6IGZ1bmN0aW9uIGNsb3NlRGlhbG9nKCkge1xuICAgICAgdGhpcy4kZW1pdCgnbWQtY2xvc2VkJyk7XG4gICAgfSxcbiAgICBvbkNsb3NlOiBmdW5jdGlvbiBvbkNsb3NlKCkge1xuICAgICAgdGhpcy5jbG9zZURpYWxvZygpO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgdGhpcy5jbG9zZURpYWxvZygpO1xuICAgIH0sXG4gICAgb25Db25maXJtOiBmdW5jdGlvbiBvbkNvbmZpcm0oKSB7XG4gICAgICB0aGlzLmNsb3NlRGlhbG9nKCk7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWREYXRlJywgdGhpcy5zZWxlY3RlZERhdGUpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5zZXRBdmFpbGFibGVZZWFycygpO1xuICAgIHRoaXMuY3VycmVudERhdGUgPSB0aGlzLm1kRGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gdGhpcy5tZERhdGU7XG4gICAgdGhpcy5jdXJyZW50VmlldyA9ICdkYXknO1xuXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0Q29udGVudFN0eWxlcygpO1xuICAgIH0sIDUwKTtcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgTW9udGggSGVscGVyc1xuICogQHN1bW1hcnkgUmV0dXJuIHRoZSBzdGFydCBvZiBhIG1vbnRoIGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybiB0aGUgc3RhcnQgb2YgYSBtb250aCBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIG9yaWdpbmFsIGRhdGVcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgc3RhcnQgb2YgYSBtb250aFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGUgc3RhcnQgb2YgYSBtb250aCBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIHZhciByZXN1bHQgPSBzdGFydE9mTW9udGgobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0T2ZNb250aCAoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICBkYXRlLnNldERhdGUoMSlcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKVxuICByZXR1cm4gZGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXJ0T2ZNb250aFxuXG5cbi8qKiovIH0pLFxuLyogMTg3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhZGRNb250aHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KVxuXG4vKipcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1vbnRocyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbW9udGhzIHRvIGJlIHN1YnRyYWN0ZWRcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbW9udGhzIHN1YnRyYWN0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgNSBtb250aHMgZnJvbSAxIEZlYnJ1YXJ5IDIwMTU6XG4gKiB2YXIgcmVzdWx0ID0gc3ViTW9udGhzKG5ldyBEYXRlKDIwMTUsIDEsIDEpLCA1KVxuICogLy89PiBNb24gU2VwIDAxIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc3ViTW9udGhzIChkaXJ0eURhdGUsIGRpcnR5QW1vdW50KSB7XG4gIHZhciBhbW91bnQgPSBOdW1iZXIoZGlydHlBbW91bnQpXG4gIHJldHVybiBhZGRNb250aHMoZGlydHlEYXRlLCAtYW1vdW50KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1Yk1vbnRoc1xuXG5cbi8qKiovIH0pLFxuLyogMTg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBnaXZlbiBkYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgZGF5IG9mIG1vbnRoXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFdoaWNoIGRheSBvZiB0aGUgbW9udGggaXMgMjkgRmVicnVhcnkgMjAxMj9cbiAqIHZhciByZXN1bHQgPSBnZXREYXRlKG5ldyBEYXRlKDIwMTIsIDEsIDI5KSlcbiAqIC8vPT4gMjlcbiAqL1xuZnVuY3Rpb24gZ2V0RGF0ZSAoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICB2YXIgZGF5T2ZNb250aCA9IGRhdGUuZ2V0RGF0ZSgpXG4gIHJldHVybiBkYXlPZk1vbnRoXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF0ZVxuXG5cbi8qKiovIH0pLFxuLyogMTg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgV2Vla2RheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGdpdmVuIGRhdGVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBkYXkgb2Ygd2Vla1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCBkYXkgb2YgdGhlIHdlZWsgaXMgMjkgRmVicnVhcnkgMjAxMj9cbiAqIHZhciByZXN1bHQgPSBnZXREYXkobmV3IERhdGUoMjAxMiwgMSwgMjkpKVxuICogLy89PiAzXG4gKi9cbmZ1bmN0aW9uIGdldERheSAoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKVxuICByZXR1cm4gZGF5XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RGF5XG5cblxuLyoqKi8gfSksXG4vKiAxOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBNb250aCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBHZXQgdGhlIG1vbnRoIG9mIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogR2V0IHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBnaXZlbiBkYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbW9udGhcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gV2hpY2ggbW9udGggaXMgMjkgRmVicnVhcnkgMjAxMj9cbiAqIHZhciByZXN1bHQgPSBnZXRNb250aChuZXcgRGF0ZSgyMDEyLCAxLCAyOSkpXG4gKiAvLz0+IDFcbiAqL1xuZnVuY3Rpb24gZ2V0TW9udGggKGRpcnR5RGF0ZSkge1xuICB2YXIgZGF0ZSA9IHBhcnNlKGRpcnR5RGF0ZSlcbiAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpXG4gIHJldHVybiBtb250aFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1vbnRoXG5cblxuLyoqKi8gfSksXG4vKiAxOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhcnNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBZZWFyIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEdldCB0aGUgeWVhciBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBnaXZlbiBkYXRlXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgeWVhclxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaGljaCB5ZWFyIGlzIDIgSnVseSAyMDE0P1xuICogdmFyIHJlc3VsdCA9IGdldFllYXIobmV3IERhdGUoMjAxNCwgNiwgMikpXG4gKiAvLz0+IDIwMTRcbiAqL1xuZnVuY3Rpb24gZ2V0WWVhciAoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKVxuICByZXR1cm4geWVhclxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFllYXJcblxuXG4vKioqLyB9KSxcbi8qIDE5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG5cbi8qKlxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGVxdWFsP1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQXJlIHRoZSBnaXZlbiBkYXRlcyBlcXVhbD9cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZUxlZnQgLSB0aGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZVJpZ2h0IC0gdGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZXMgYXJlIGVxdWFsXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSAyIEp1bHkgMjAxNCAwNjozMDo0NS4wMDAgYW5kIDIgSnVseSAyMDE0IDA2OjMwOjQ1LjUwMCBlcXVhbD9cbiAqIHZhciByZXN1bHQgPSBpc0VxdWFsKFxuICogICBuZXcgRGF0ZSgyMDE0LCA2LCAyLCA2LCAzMCwgNDUsIDApXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDYsIDIsIDYsIDMwLCA0NSwgNTAwKVxuICogKVxuICogLy89PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsIChkaXJ0eUxlZnREYXRlLCBkaXJ0eVJpZ2h0RGF0ZSkge1xuICB2YXIgZGF0ZUxlZnQgPSBwYXJzZShkaXJ0eUxlZnREYXRlKVxuICB2YXIgZGF0ZVJpZ2h0ID0gcGFyc2UoZGlydHlSaWdodERhdGUpXG4gIHJldHVybiBkYXRlTGVmdC5nZXRUaW1lKCkgPT09IGRhdGVSaWdodC5nZXRUaW1lKClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsXG5cblxuLyoqKi8gfSksXG4vKiAxOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHN0YXJ0T2ZEYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKVxuXG4vKipcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBkYXk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIGRheT9cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZUxlZnQgLSB0aGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGVSaWdodCAtIHRoZSBzZWNvbmQgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciAwNjowMDowMCBhbmQgNCBTZXB0ZW1iZXIgMTg6MDA6MDAgaW4gdGhlIHNhbWUgZGF5P1xuICogdmFyIHJlc3VsdCA9IGlzU2FtZURheShcbiAqICAgbmV3IERhdGUoMjAxNCwgOCwgNCwgNiwgMCksXG4gKiAgIG5ldyBEYXRlKDIwMTQsIDgsIDQsIDE4LCAwKVxuICogKVxuICogLy89PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZURheSAoZGlydHlEYXRlTGVmdCwgZGlydHlEYXRlUmlnaHQpIHtcbiAgdmFyIGRhdGVMZWZ0U3RhcnRPZkRheSA9IHN0YXJ0T2ZEYXkoZGlydHlEYXRlTGVmdClcbiAgdmFyIGRhdGVSaWdodFN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZVJpZ2h0KVxuXG4gIHJldHVybiBkYXRlTGVmdFN0YXJ0T2ZEYXkuZ2V0VGltZSgpID09PSBkYXRlUmlnaHRTdGFydE9mRGF5LmdldFRpbWUoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2FtZURheVxuXG5cbi8qKiovIH0pLFxuLyogMTk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzdGFydE9mRGF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSlcblxuLyoqXG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIHRvZGF5P1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSXMgdGhlIGdpdmVuIGRhdGUgdG9kYXk/XG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IHRoZSBkYXRlIGlzIHRvZGF5XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDYgT2N0b2JlciAyMDE0LCBpcyA2IE9jdG9iZXIgMTQ6MDA6MDAgdG9kYXk/XG4gKiB2YXIgcmVzdWx0ID0gaXNUb2RheShuZXcgRGF0ZSgyMDE0LCA5LCA2LCAxNCwgMCkpXG4gKiAvLz0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNUb2RheSAoZGlydHlEYXRlKSB7XG4gIHJldHVybiBzdGFydE9mRGF5KGRpcnR5RGF0ZSkuZ2V0VGltZSgpID09PSBzdGFydE9mRGF5KG5ldyBEYXRlKCkpLmdldFRpbWUoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVG9kYXlcblxuXG4vKioqLyB9KSxcbi8qIDE5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG5cbi8qKlxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIGRheSBvZiB0aGUgbW9udGggdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIGRheSBvZiB0aGUgbW9udGggdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gZGF5T2ZNb250aCAtIHRoZSBkYXkgb2YgdGhlIG1vbnRoIG9mIHRoZSBuZXcgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBkYXkgb2YgdGhlIG1vbnRoIHNldHRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXQgdGhlIDMwdGggZGF5IG9mIHRoZSBtb250aCB0byAxIFNlcHRlbWJlciAyMDE0OlxuICogdmFyIHJlc3VsdCA9IHNldERhdGUobmV3IERhdGUoMjAxNCwgOCwgMSksIDMwKVxuICogLy89PiBUdWUgU2VwIDMwIDIwMTQgMDA6MDA6MDBcbiAqL1xuZnVuY3Rpb24gc2V0RGF0ZSAoZGlydHlEYXRlLCBkaXJ0eURheU9mTW9udGgpIHtcbiAgdmFyIGRhdGUgPSBwYXJzZShkaXJ0eURhdGUpXG4gIHZhciBkYXlPZk1vbnRoID0gTnVtYmVyKGRpcnR5RGF5T2ZNb250aClcbiAgZGF0ZS5zZXREYXRlKGRheU9mTW9udGgpXG4gIHJldHVybiBkYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0RGF0ZVxuXG5cbi8qKiovIH0pLFxuLyogMTk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcbnZhciBnZXREYXlzSW5Nb250aCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpXG5cbi8qKlxuICogQGNhdGVnb3J5IE1vbnRoIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFNldCB0aGUgbW9udGggdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIG1vbnRoIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoIC0gdGhlIG1vbnRoIG9mIHRoZSBuZXcgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtb250aCBzZXR0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2V0IEZlYnJ1YXJ5IHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiB2YXIgcmVzdWx0ID0gc2V0TW9udGgobmV3IERhdGUoMjAxNCwgOCwgMSksIDEpXG4gKiAvLz0+IFNhdCBGZWIgMDEgMjAxNCAwMDowMDowMFxuICovXG5mdW5jdGlvbiBzZXRNb250aCAoZGlydHlEYXRlLCBkaXJ0eU1vbnRoKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICB2YXIgbW9udGggPSBOdW1iZXIoZGlydHlNb250aClcbiAgdmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKClcbiAgdmFyIGRheSA9IGRhdGUuZ2V0RGF0ZSgpXG5cbiAgdmFyIGRhdGVXaXRoRGVzaXJlZE1vbnRoID0gbmV3IERhdGUoMClcbiAgZGF0ZVdpdGhEZXNpcmVkTW9udGguc2V0RnVsbFllYXIoeWVhciwgbW9udGgsIDE1KVxuICBkYXRlV2l0aERlc2lyZWRNb250aC5zZXRIb3VycygwLCAwLCAwLCAwKVxuICB2YXIgZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aChkYXRlV2l0aERlc2lyZWRNb250aClcbiAgLy8gU2V0IHRoZSBsYXN0IGRheSBvZiB0aGUgbmV3IG1vbnRoXG4gIC8vIGlmIHRoZSBvcmlnaW5hbCBkYXRlIHdhcyB0aGUgbGFzdCBkYXkgb2YgdGhlIGxvbmdlciBtb250aFxuICBkYXRlLnNldE1vbnRoKG1vbnRoLCBNYXRoLm1pbihkYXksIGRheXNJbk1vbnRoKSlcbiAgcmV0dXJuIGRhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRNb250aFxuXG5cbi8qKiovIH0pLFxuLyogMTk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMylcblxuLyoqXG4gKiBAY2F0ZWdvcnkgWWVhciBIZWxwZXJzXG4gKiBAc3VtbWFyeSBTZXQgdGhlIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXQgdGhlIHllYXIgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0geWVhciAtIHRoZSB5ZWFyIG9mIHRoZSBuZXcgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSB5ZWFyIHNldHRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTZXQgeWVhciAyMDEzIHRvIDEgU2VwdGVtYmVyIDIwMTQ6XG4gKiB2YXIgcmVzdWx0ID0gc2V0WWVhcihuZXcgRGF0ZSgyMDE0LCA4LCAxKSwgMjAxMylcbiAqIC8vPT4gU3VuIFNlcCAwMSAyMDEzIDAwOjAwOjAwXG4gKi9cbmZ1bmN0aW9uIHNldFllYXIgKGRpcnR5RGF0ZSwgZGlydHlZZWFyKSB7XG4gIHZhciBkYXRlID0gcGFyc2UoZGlydHlEYXRlKVxuICB2YXIgeWVhciA9IE51bWJlcihkaXJ0eVllYXIpXG4gIGRhdGUuc2V0RnVsbFllYXIoeWVhcilcbiAgcmV0dXJuIGRhdGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRZZWFyXG5cblxuLyoqKi8gfSksXG4vKiAxOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAxOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9wb3BwZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwMCk7XG5cbnZhciBfcG9wcGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvcHBlcik7XG5cbnZhciBfZGVlcG1lcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMCk7XG5cbnZhciBfZGVlcG1lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZXBtZXJnZSk7XG5cbnZhciBfTWRQb3J0YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9NZFBvcnRhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFBvcnRhbCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kUG9wb3ZlcicsXG4gIGFic3RyYWN0OiB0cnVlLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRQb3J0YWw6IF9NZFBvcnRhbDIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kQWN0aXZlOiBCb29sZWFuLFxuICAgIG1kU2V0dGluZ3M6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3BwZXJJbnN0YW5jZTogbnVsbCxcbiAgICAgIG9yaWdpbmFsUGFyZW50RWw6IG51bGwsXG4gICAgICBzaG91bGRSZW5kZXI6IGZhbHNlLFxuICAgICAgc2hvdWxkQWN0aXZhdGU6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBwb3BvdmVyQ2xhc3NlczogZnVuY3Rpb24gcG9wb3ZlckNsYXNzZXMoKSB7XG4gICAgICBpZiAodGhpcy5zaG91bGRBY3RpdmF0ZSkge1xuICAgICAgICByZXR1cm4gJ21kLWFjdGl2ZSc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgIHJldHVybiAnbWQtcmVuZGVyaW5nJztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRBY3RpdmU6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkUmVuZGVyID0gc2hvdWxkUmVuZGVyO1xuXG4gICAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmJpbmRQb3BwZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3VsZEFjdGl2YXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1kU2V0dGluZ3M6IGZ1bmN0aW9uIG1kU2V0dGluZ3MoKSB7XG4gICAgICBpZiAodGhpcy5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmNyZWF0ZVBvcHBlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldFBvcHBlck9wdGlvbnM6IGZ1bmN0aW9uIGdldFBvcHBlck9wdGlvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgICAgICAgICAgcGFkZGluZzogMTZcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXB1dGVTdHlsZToge1xuICAgICAgICAgICAgZ3B1QWNjZWxlcmF0aW9uOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge1xuICAgICAgICAgIF90aGlzLnNob3VsZEFjdGl2YXRlID0gdHJ1ZTtcbiAgICAgICAgICBfdGhpcy4kZW1pdCgnbWQtYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBzZXRPcmlnaW5hbFBhcmVudDogZnVuY3Rpb24gc2V0T3JpZ2luYWxQYXJlbnQoZWwpIHtcbiAgICAgIGlmICghdGhpcy5vcmlnaW5hbFBhcmVudEVsKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxQYXJlbnRFbCA9IGVsO1xuICAgICAgfVxuICAgIH0sXG4gICAga2lsbFBvcHBlcjogZnVuY3Rpb24ga2lsbFBvcHBlcigpIHtcbiAgICAgIGlmICh0aGlzLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnBvcHBlckluc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmRQb3BwZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luYWxQYXJlbnRFbCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQb3BwZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYmluZFBvcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJpbmRQb3BwZXI7XG4gICAgfSgpLFxuICAgIGNyZWF0ZVBvcHBlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWRTZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9ICgwLCBfZGVlcG1lcmdlMi5kZWZhdWx0KSh0aGlzLmdldFBvcHBlck9wdGlvbnMoKSwgdGhpcy5tZFNldHRpbmdzKTtcblxuXG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy4kZWwubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UgPSBuZXcgX3BvcHBlcjIuZGVmYXVsdCh0aGlzLm9yaWdpbmFsUGFyZW50RWwsIHRoaXMuJGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjcmVhdGVQb3BwZXIoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlUG9wcGVyO1xuICAgIH0oKSxcbiAgICByZXNldFBvcHBlcjogZnVuY3Rpb24gcmVzZXRQb3BwZXIoKSB7XG4gICAgICBpZiAodGhpcy5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmtpbGxQb3BwZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVQb3BwZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5raWxsUG9wcGVyKCk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5yZXNldFBvcHBlcigpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoX01kUG9ydGFsMi5kZWZhdWx0LCB7XG4gICAgICBwcm9wczogX2V4dGVuZHMoe30sIHRoaXMuJGF0dHJzKSxcbiAgICAgIG9uOiBfZXh0ZW5kcyh7fSwgdGhpcy4kbGlzdGVuZXJzLCB7XG4gICAgICAgICdtZC1pbml0aWFsLXBhcmVudCc6IHRoaXMuc2V0T3JpZ2luYWxQYXJlbnQsXG4gICAgICAgICdtZC1kZXN0cm95JzogdGhpcy5raWxsUG9wcGVyXG4gICAgICB9KVxuICAgIH0sIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDIwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjEyLjlcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG52YXIgdGltZW91dER1cmF0aW9uID0gMDtcbmZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgIHRpbWVvdXREdXJhdGlvbiA9IDE7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsKS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudCAmJiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuLyoqXG4gKiBUZWxscyBpZiB5b3UgYXJlIHJ1bm5pbmcgSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFMTBcbiAqL1xudmFyIGlzSUUxMCA9IHVuZGVmaW5lZDtcblxudmFyIGlzSUUxMCQxID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaXNJRTEwID09PSB1bmRlZmluZWQpIHtcbiAgICBpc0lFMTAgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgIT09IC0xO1xuICB9XG4gIHJldHVybiBpc0lFMTA7XG59O1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFMTAkMSgpID8gaHRtbFsnb2Zmc2V0JyArIGF4aXNdICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0gOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoKSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRTEwJDEoKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIGlmIChpc0lFMTAkMSgpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9IGVsc2Uge1xuICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGlzSUUxMCA9IGlzSUUxMCQxKCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgsIDEwKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCwgMTApO1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wLCAxMCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0LCAxMCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChodG1sKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKTtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQpO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICAvLyBmbG9vciBzaWRlcyB0byBhdm9pZCBibHVycnkgdGV4dFxuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBsZWZ0OiBNYXRoLmZsb29yKHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IE1hdGguZmxvb3IocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLmZsb29yKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBNYXRoLmZsb29yKHBvcHBlci5yaWdodClcbiAgfTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVjdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLXJpZ2h0YCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0bGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgaGVpZ2h0LlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gTW9yZSBvbiB0aGlzIFtyZWFkaW5nIHRoaXMgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEFuIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIgdGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgaGFzIGFsd2F5cyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLCBjYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNob3RoZXJzXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXhwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gYXNzdXJlIGl0IHRvIHBvaW50IHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcywgeW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpLlxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLFxuICAgICAqIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBrZWVwVG9nZXRoZXIgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdSBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9ucyB1c2VkIGJ5IFBvcHBlci5qc1xuICogdGhpcyBvYmplY3QgZ2V0IHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXIuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciwgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LCBpdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYXMgM3JkIGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhpcyBvYmplY3QsIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50XG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoUG9wcGVyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAyMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kQXJyb3dSaWdodEljb24udnVlXG52YXIgTWRBcnJvd1JpZ2h0SWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjAyKTtcbnZhciBNZEFycm93UmlnaHRJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQXJyb3dSaWdodEljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTFlMjNlMWJmXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kQXJyb3dSaWdodEljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICBhdHRyczogeyBkOiBcIk04LjU5IDE2LjM0bDQuNTgtNC41OS00LjU4LTQuNTlMMTAgNS43NWw2IDYtNiA2elwiIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAtLjI1aDI0djI0SDB6XCIsIGZpbGw6IFwibm9uZVwiIH0gfSlcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGljb25zX01kQXJyb3dSaWdodEljb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTFlMjNlMWJmXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9pY29ucy9NZEFycm93UmlnaHRJY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRBcnJvd1JpZ2h0SWNvbl9kZWZhdWx0LmEsXG4gIGljb25zX01kQXJyb3dSaWdodEljb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29yZS9pY29ucy9NZEFycm93UmlnaHRJY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTFlMjNlMWJmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMWUyM2UxYmZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRBcnJvd1JpZ2h0SWNvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfTWRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kQXJyb3dSaWdodEljb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJY29uOiBfTWRJY29uMi5kZWZhdWx0XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAyMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kQXJyb3dMZWZ0SWNvbi52dWVcbnZhciBNZEFycm93TGVmdEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNCk7XG52YXIgTWRBcnJvd0xlZnRJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQXJyb3dMZWZ0SWNvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNWNjN2I2ZjRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWRBcnJvd0xlZnRJY29uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMCwgZmFsc2UsIHRydWUpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1pY29uLWltYWdlXCIgfSwgW1xuICAgICAgX2MoXG4gICAgICAgIFwic3ZnXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgZDogXCJNMTUuNDEgMTYuMDlsLTQuNTgtNC41OSA0LjU4LTQuNTlMMTQgNS41bC02IDYgNiA2elwiIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAtLjVoMjR2MjRIMHpcIiwgZmlsbDogXCJub25lXCIgfSB9KVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaWNvbnNfTWRBcnJvd0xlZnRJY29uID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi01Y2M3YjZmNFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaWNvbnMvTWRBcnJvd0xlZnRJY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRBcnJvd0xlZnRJY29uX2RlZmF1bHQuYSxcbiAgaWNvbnNfTWRBcnJvd0xlZnRJY29uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvcmUvaWNvbnMvTWRBcnJvd0xlZnRJY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTVjYzdiNmY0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNWNjN2I2ZjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRBcnJvd0xlZnRJY29uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9NZEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRBcnJvd0xlZnRJY29uJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kSWNvbjogX01kSWNvbjIuZGVmYXVsdFxuICB9XG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZFBvcnRhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG52YXIgX01kUG9ydGFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUG9ydGFsKTtcblxudmFyIF9NZE92ZXJsYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9NZE92ZXJsYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRPdmVybGF5KTtcblxudmFyIF9NZEZvY3VzVHJhcCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuXG52YXIgX01kRm9jdXNUcmFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRm9jdXNUcmFwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH0gLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kRGlhbG9nJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kUG9ydGFsOiBfTWRQb3J0YWwyLmRlZmF1bHQsXG4gICAgTWRPdmVybGF5OiBfTWRPdmVybGF5Mi5kZWZhdWx0LFxuICAgIE1kRm9jdXNUcmFwOiBfTWRGb2N1c1RyYXAyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZEFjdGl2ZTogQm9vbGVhbixcbiAgICBtZEJhY2tkcm9wOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgbWRCYWNrZHJvcENsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbWQtZGlhbG9nLW92ZXJsYXknXG4gICAgfSxcbiAgICBtZENsb3NlT25Fc2M6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZENsaWNrT3V0c2lkZVRvQ2xvc2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZEZ1bGxzY3JlZW46IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtZEFuaW1hdGVGcm9tU291cmNlOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZGlhbG9nQ2xhc3NlczogZnVuY3Rpb24gZGlhbG9nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZC1kaWFsb2ctZnVsbHNjcmVlbic6IHRoaXMubWRGdWxsc2NyZWVuXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZEFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcblxuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnbWQtb3BlbmVkJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ21kLWNsb3NlZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBtZEFjdGl2ZShfeCkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWRBY3RpdmU7XG4gICAgfSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBjbG9zZURpYWxvZzogZnVuY3Rpb24gY2xvc2VEaWFsb2coKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWRBY3RpdmUnLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge1xuICAgICAgaWYgKHRoaXMubWRDbGlja091dHNpZGVUb0Nsb3NlKSB7XG4gICAgICAgIHRoaXMuY2xvc2VEaWFsb2coKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRXNjOiBmdW5jdGlvbiBvbkVzYygpIHtcbiAgICAgIGlmICh0aGlzLm1kQ2xvc2VPbkVzYykge1xuICAgICAgICB0aGlzLmNsb3NlRGlhbG9nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAyMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kRGF0ZUljb24udnVlXG52YXIgTWREYXRlSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjA4KTtcbnZhciBNZERhdGVJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGF0ZUljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTY0NGI3OWNjXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kRGF0ZUljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBkOlxuICAgICAgICAgICAgICAgIFwiTTE3IDEyaC01djVoNXYtNXpNMTYgMXYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yaC0xVjFoLTJ6bTMgMThINVY4aDE0djExelwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInBhdGhcIiwgeyBhdHRyczogeyBkOiBcIk0wIDBoMjR2MjRIMHpcIiwgZmlsbDogXCJub25lXCIgfSB9KVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaWNvbnNfTWREYXRlSWNvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNjQ0Yjc5Y2NcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2ljb25zL01kRGF0ZUljb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZERhdGVJY29uX2RlZmF1bHQuYSxcbiAgaWNvbnNfTWREYXRlSWNvbixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb3JlL2ljb25zL01kRGF0ZUljb24udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNjQ0Yjc5Y2NcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi02NDRiNzljY1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9pY29uc19NZERhdGVJY29uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9NZEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWREYXRlSWNvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEljb246IF9NZEljb24yLmRlZmF1bHRcbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDIwOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWREaWFsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9NZERpYWxvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERpYWxvZyk7XG5cbnZhciBfTWREaWFsb2dUaXRsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEwKTtcblxudmFyIF9NZERpYWxvZ1RpdGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRGlhbG9nVGl0bGUpO1xuXG52YXIgX01kRGlhbG9nQ29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEzKTtcblxudmFyIF9NZERpYWxvZ0NvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2dDb250ZW50KTtcblxudmFyIF9NZERpYWxvZ0FjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNik7XG5cbnZhciBfTWREaWFsb2dBY3Rpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRGlhbG9nQWN0aW9ucyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWREaWFsb2cyLmRlZmF1bHQubmFtZSwgX01kRGlhbG9nMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWREaWFsb2dUaXRsZTIuZGVmYXVsdC5uYW1lLCBfTWREaWFsb2dUaXRsZTIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kRGlhbG9nQ29udGVudDIuZGVmYXVsdC5uYW1lLCBfTWREaWFsb2dDb250ZW50Mi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWREaWFsb2dBY3Rpb25zMi5kZWZhdWx0Lm5hbWUsIF9NZERpYWxvZ0FjdGlvbnMyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nVGl0bGUudnVlXG52YXIgTWREaWFsb2dUaXRsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcbnZhciBNZERpYWxvZ1RpdGxlX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGlhbG9nVGl0bGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTg3OTI3NWNlXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nVGl0bGUudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwic3BhblwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtZGlhbG9nLXRpdGxlIG1kLXRpdGxlXCIgfSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGlhbG9nX01kRGlhbG9nVGl0bGUgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTg3OTI3NWNlXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ1RpdGxlLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMjExKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREaWFsb2dUaXRsZV9kZWZhdWx0LmEsXG4gIE1kRGlhbG9nX01kRGlhbG9nVGl0bGUsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ1RpdGxlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTg3OTI3NWNlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtODc5Mjc1Y2VcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWREaWFsb2dfTWREaWFsb2dUaXRsZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDIxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZERpYWxvZ1RpdGxlJ1xufTtcblxuLyoqKi8gfSksXG4vKiAyMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nQ29udGVudC52dWVcbnZhciBNZERpYWxvZ0NvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNSk7XG52YXIgTWREaWFsb2dDb250ZW50X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGlhbG9nQ29udGVudCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZGFlOTBmMGNcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dDb250ZW50LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWRpYWxvZy1jb250ZW50XCIgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpYWxvZ19NZERpYWxvZ0NvbnRlbnQgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWRhZTkwZjBjXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0NvbnRlbnQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyMTQpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZERpYWxvZ0NvbnRlbnRfZGVmYXVsdC5hLFxuICBNZERpYWxvZ19NZERpYWxvZ0NvbnRlbnQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0NvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZGFlOTBmMGNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1kYWU5MGYwY1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZERpYWxvZ19NZERpYWxvZ0NvbnRlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWREaWFsb2dDb250ZW50J1xufTtcblxuLyoqKi8gfSksXG4vKiAyMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nQWN0aW9ucy52dWVcbnZhciBNZERpYWxvZ0FjdGlvbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XG52YXIgTWREaWFsb2dBY3Rpb25zX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGlhbG9nQWN0aW9ucyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDkyZWFhZmVcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dBY3Rpb25zLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWRpYWxvZy1hY3Rpb25zXCIgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpYWxvZ19NZERpYWxvZ0FjdGlvbnMgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTA5MmVhYWZlXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0FjdGlvbnMudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyMTcpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZERpYWxvZ0FjdGlvbnNfZGVmYXVsdC5hLFxuICBNZERpYWxvZ19NZERpYWxvZ0FjdGlvbnMsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0FjdGlvbnMudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMDkyZWFhZmVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wOTJlYWFmZVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZERpYWxvZ19NZERpYWxvZ0FjdGlvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWREaWFsb2dBY3Rpb25zJ1xufTtcblxuLyoqKi8gfSksXG4vKiAyMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kRGlhbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfTWREaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2cpO1xuXG52YXIgX01kRGlhbG9nQWxlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMCk7XG5cbnZhciBfTWREaWFsb2dBbGVydDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERpYWxvZ0FsZXJ0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZERpYWxvZzIuZGVmYXVsdC5uYW1lLCBfTWREaWFsb2cyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZERpYWxvZ0FsZXJ0Mi5kZWZhdWx0Lm5hbWUsIF9NZERpYWxvZ0FsZXJ0Mi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0FsZXJ0L01kRGlhbG9nQWxlcnQudnVlXG52YXIgTWREaWFsb2dBbGVydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIxKTtcbnZhciBNZERpYWxvZ0FsZXJ0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGlhbG9nQWxlcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTE5N2FiOTRiXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nQWxlcnQvTWREaWFsb2dBbGVydC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC1kaWFsb2dcIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHsgYXR0cnM6IHsgXCJtZC1mdWxsc2NyZWVuXCI6IGZhbHNlIH0gfSxcbiAgICAgICAgXCJtZC1kaWFsb2dcIixcbiAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICksXG4gICAgW1xuICAgICAgX3ZtLm1kVGl0bGVcbiAgICAgICAgPyBfYyhcIm1kLWRpYWxvZy10aXRsZVwiLCBbX3ZtLl92KF92bS5fcyhfdm0ubWRUaXRsZSkpXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0ubWRDb250ZW50XG4gICAgICAgID8gX2MoXCJtZC1kaWFsb2ctY29udGVudFwiLCB7XG4gICAgICAgICAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0ubWRDb250ZW50KSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJtZC1kaWFsb2ctYWN0aW9uc1wiLFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1wcmltYXJ5XCIsXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLiRlbWl0KFwidXBkYXRlOm1kQWN0aXZlXCIsIGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfdm0uX3YoX3ZtLl9zKF92bS5tZENvbmZpcm1UZXh0KSldXG4gICAgICAgICAgKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWREaWFsb2dBbGVydF9NZERpYWxvZ0FsZXJ0ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0xOTdhYjk0YlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dBbGVydC9NZERpYWxvZ0FsZXJ0LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREaWFsb2dBbGVydF9kZWZhdWx0LmEsXG4gIE1kRGlhbG9nQWxlcnRfTWREaWFsb2dBbGVydCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nQWxlcnQvTWREaWFsb2dBbGVydC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xOTdhYjk0YlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTE5N2FiOTRiXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpYWxvZ19NZERpYWxvZ0FsZXJ0X01kRGlhbG9nQWxlcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZERpYWxvZ0FsZXJ0JyxcbiAgcHJvcHM6IHtcbiAgICBtZFRpdGxlOiBTdHJpbmcsXG4gICAgbWRDb250ZW50OiBTdHJpbmcsXG4gICAgbWRDb25maXJtVGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ09rJ1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kRGlhbG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBfTWREaWFsb2cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2cpO1xuXG52YXIgX01kRGlhbG9nQ29uZmlybSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIzKTtcblxudmFyIF9NZERpYWxvZ0NvbmZpcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2dDb25maXJtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZERpYWxvZzIuZGVmYXVsdC5uYW1lLCBfTWREaWFsb2cyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZERpYWxvZ0NvbmZpcm0yLmRlZmF1bHQubmFtZSwgX01kRGlhbG9nQ29uZmlybTIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dDb25maXJtL01kRGlhbG9nQ29uZmlybS52dWVcbnZhciBNZERpYWxvZ0NvbmZpcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNCk7XG52YXIgTWREaWFsb2dDb25maXJtX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRGlhbG9nQ29uZmlybSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWNjN2FmZGFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dDb25maXJtL01kRGlhbG9nQ29uZmlybS52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC1kaWFsb2dcIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHsgYXR0cnM6IHsgXCJtZC1mdWxsc2NyZWVuXCI6IGZhbHNlIH0gfSxcbiAgICAgICAgXCJtZC1kaWFsb2dcIixcbiAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICksXG4gICAgW1xuICAgICAgX3ZtLm1kVGl0bGVcbiAgICAgICAgPyBfYyhcIm1kLWRpYWxvZy10aXRsZVwiLCBbX3ZtLl92KF92bS5fcyhfdm0ubWRUaXRsZSkpXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0ubWRDb250ZW50XG4gICAgICAgID8gX2MoXCJtZC1kaWFsb2ctY29udGVudFwiLCB7XG4gICAgICAgICAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0ubWRDb250ZW50KSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJtZC1kaWFsb2ctYWN0aW9uc1wiLFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1wcmltYXJ5XCIsIG9uOiB7IGNsaWNrOiBfdm0ub25DYW5jZWwgfSB9LFxuICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLm1kQ2FuY2VsVGV4dCkpXVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXByaW1hcnlcIiwgb246IHsgY2xpY2s6IF92bS5vbkNvbmZpcm0gfSB9LFxuICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLm1kQ29uZmlybVRleHQpKV1cbiAgICAgICAgICApXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpYWxvZ0NvbmZpcm1fTWREaWFsb2dDb25maXJtID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1hY2M3YWZkYVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dDb25maXJtL01kRGlhbG9nQ29uZmlybS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kRGlhbG9nQ29uZmlybV9kZWZhdWx0LmEsXG4gIE1kRGlhbG9nQ29uZmlybV9NZERpYWxvZ0NvbmZpcm0sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZERpYWxvZy9NZERpYWxvZ0NvbmZpcm0vTWREaWFsb2dDb25maXJtLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LWFjYzdhZmRhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtYWNjN2FmZGFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGlhbG9nX01kRGlhbG9nQ29uZmlybV9NZERpYWxvZ0NvbmZpcm0gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWREaWFsb2dDb25maXJtJyxcbiAgcHJvcHM6IHtcbiAgICBtZFRpdGxlOiBTdHJpbmcsXG4gICAgbWRDb250ZW50OiBTdHJpbmcsXG4gICAgbWRDb25maXJtVGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ09rJ1xuICAgIH0sXG4gICAgbWRDYW5jZWxUZXh0OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnQ2FuY2VsJ1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2FuY2VsOiBmdW5jdGlvbiBvbkNhbmNlbCgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLWNhbmNlbCcpO1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1kQWN0aXZlJywgZmFsc2UpO1xuICAgIH0sXG4gICAgb25Db25maXJtOiBmdW5jdGlvbiBvbkNvbmZpcm0oKSB7XG4gICAgICB0aGlzLiRlbWl0KCdtZC1jb25maXJtJyk7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWRBY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDIyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWREaWFsb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIF9NZERpYWxvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERpYWxvZyk7XG5cbnZhciBfTWREaWFsb2dQcm9tcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNik7XG5cbnZhciBfTWREaWFsb2dQcm9tcHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWREaWFsb2dQcm9tcHQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kRGlhbG9nMi5kZWZhdWx0Lm5hbWUsIF9NZERpYWxvZzIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kRGlhbG9nUHJvbXB0Mi5kZWZhdWx0Lm5hbWUsIF9NZERpYWxvZ1Byb21wdDIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREaWFsb2cvTWREaWFsb2dQcm9tcHQvTWREaWFsb2dQcm9tcHQudnVlXG52YXIgTWREaWFsb2dQcm9tcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XG52YXIgTWREaWFsb2dQcm9tcHRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWREaWFsb2dQcm9tcHQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdiM2M4YzIyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nUHJvbXB0L01kRGlhbG9nUHJvbXB0LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWRpYWxvZ1wiLFxuICAgIF92bS5fYihcbiAgICAgIHtcbiAgICAgICAgYXR0cnM6IHsgXCJtZC1mdWxsc2NyZWVuXCI6IGZhbHNlIH0sXG4gICAgICAgIG9uOiB7IFwibWQtb3BlbmVkXCI6IF92bS5zZXRJbnB1dEZvY3VzIH1cbiAgICAgIH0sXG4gICAgICBcIm1kLWRpYWxvZ1wiLFxuICAgICAgX3ZtLiRhdHRycyxcbiAgICAgIGZhbHNlXG4gICAgKSxcbiAgICBbXG4gICAgICBfdm0ubWRUaXRsZVxuICAgICAgICA/IF9jKFwibWQtZGlhbG9nLXRpdGxlXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5tZFRpdGxlKSldKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5tZENvbnRlbnRcbiAgICAgICAgPyBfYyhcIm1kLWRpYWxvZy1jb250ZW50XCIsIHtcbiAgICAgICAgICAgIGRvbVByb3BzOiB7IGlubmVySFRNTDogX3ZtLl9zKF92bS5tZENvbnRlbnQpIH1cbiAgICAgICAgICB9KVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWRpYWxvZy1jb250ZW50XCIsXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwibWQtZmllbGRcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJtZC1pbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBfdm0ubWRJbnB1dElkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogX3ZtLm1kSW5wdXROYW1lLFxuICAgICAgICAgICAgICAgICAgbWF4bGVuZ3RoOiBfdm0ubWRJbnB1dE1heGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBfdm0ubWRJbnB1dFBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuYXRpdmVPbjoge1xuICAgICAgICAgICAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAhKFwiYnV0dG9uXCIgaW4gJGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgIF92bS5faygkZXZlbnQua2V5Q29kZSwgXCJlbnRlclwiLCAxMywgJGV2ZW50LmtleSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdm0ub25Db25maXJtKCRldmVudClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmlucHV0VmFsdWUsXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5pbnB1dFZhbHVlID0gJCR2XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJpbnB1dFZhbHVlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJtZC1kaWFsb2ctYWN0aW9uc1wiLFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1wcmltYXJ5XCIsIG9uOiB7IGNsaWNrOiBfdm0ub25DYW5jZWwgfSB9LFxuICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLm1kQ2FuY2VsVGV4dCkpXVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXByaW1hcnlcIiwgb246IHsgY2xpY2s6IF92bS5vbkNvbmZpcm0gfSB9LFxuICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLm1kQ29uZmlybVRleHQpKV1cbiAgICAgICAgICApXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpYWxvZ1Byb21wdF9NZERpYWxvZ1Byb21wdCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtN2IzYzhjMjJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nUHJvbXB0L01kRGlhbG9nUHJvbXB0LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREaWFsb2dQcm9tcHRfZGVmYXVsdC5hLFxuICBNZERpYWxvZ1Byb21wdF9NZERpYWxvZ1Byb21wdCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRGlhbG9nL01kRGlhbG9nUHJvbXB0L01kRGlhbG9nUHJvbXB0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTdiM2M4YzIyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtN2IzYzhjMjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRGlhbG9nX01kRGlhbG9nUHJvbXB0X01kRGlhbG9nUHJvbXB0ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZERpYWxvZ1Byb21wdCcsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IHt9LFxuICAgIG1kVGl0bGU6IFN0cmluZyxcbiAgICBtZElucHV0TmFtZTogU3RyaW5nLFxuICAgIG1kSW5wdXRJZDogU3RyaW5nLFxuICAgIG1kSW5wdXRNYXhsZW5ndGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgbWRJbnB1dFBsYWNlaG9sZGVyOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1kQ29udGVudDogU3RyaW5nLFxuICAgIG1kQ29uZmlybVRleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdPaydcbiAgICB9LFxuICAgIG1kQ2FuY2VsVGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ0NhbmNlbCdcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0VmFsdWU6IG51bGxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgdGhpcy4kZW1pdCgnbWQtY2FuY2VsJyk7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWRBY3RpdmUnLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvbkNvbmZpcm06IGZ1bmN0aW9uIG9uQ29uZmlybSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5pbnB1dFZhbHVlKTtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLWNvbmZpcm0nLCB0aGlzLmlucHV0VmFsdWUpO1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1kQWN0aXZlJywgZmFsc2UpO1xuICAgIH0sXG4gICAgc2V0SW5wdXRGb2N1czogZnVuY3Rpb24gc2V0SW5wdXRGb2N1cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuJHJlZnMuaW5wdXQuJGVsLmZvY3VzKCk7XG4gICAgICB9LCA1MCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZERpdmlkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyOSk7XG5cbnZhciBfTWREaXZpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRGl2aWRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWREaXZpZGVyMi5kZWZhdWx0Lm5hbWUsIF9NZERpdmlkZXIyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGl2aWRlci9NZERpdmlkZXIudnVlXG52YXIgTWREaXZpZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzEpO1xudmFyIE1kRGl2aWRlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZERpdmlkZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LThjYTdjZWQ2XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRGl2aWRlci9NZERpdmlkZXIudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5pbnNpZGVMaXN0XG4gICAgPyBfYyhcImxpXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtZGl2aWRlclwiLCBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZV0gfSlcbiAgICA6IF9jKFwiaHJcIiwgeyBzdGF0aWNDbGFzczogXCJtZC1kaXZpZGVyXCIsIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lXSB9KVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERpdmlkZXJfTWREaXZpZGVyID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi04Y2E3Y2VkNlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWREaXZpZGVyL01kRGl2aWRlci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kRGl2aWRlcl9kZWZhdWx0LmEsXG4gIE1kRGl2aWRlcl9NZERpdmlkZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZERpdmlkZXIvTWREaXZpZGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LThjYTdjZWQ2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtOGNhN2NlZDZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWREaXZpZGVyX01kRGl2aWRlciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDIzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDIzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWREaXZpZGVyJyxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnNpZGVMaXN0OiBmdW5jdGlvbiBpbnNpZGVMaXN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudC4kb3B0aW9ucy5fY29tcG9uZW50VGFnID09PSAnbWQtbGlzdCc7XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZERyYXdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMzKTtcblxudmFyIF9NZERyYXdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERyYXdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWREcmF3ZXIyLmRlZmF1bHQubmFtZSwgX01kRHJhd2VyMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZERyYXdlci9NZERyYXdlci52dWVcbnZhciBNZERyYXdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjM1KTtcbnZhciBNZERyYXdlcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZERyYXdlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtODAxY2FhNjJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWREcmF3ZXIvTWREcmF3ZXIudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWQtZHJhd2VyXCIsXG4gICAgICBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZSwgX3ZtLmRyYXdlckNsYXNzZXNdXG4gICAgfSxcbiAgICBbXG4gICAgICBfdm0uX3QoXCJkZWZhdWx0XCIpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5tZEZpeGVkXG4gICAgICAgID8gX2MoXCJtZC1vdmVybGF5XCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IFwibWQtYWN0aXZlXCI6IF92bS5tZEFjdGl2ZSB9LFxuICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jbG9zZURyYXdlciB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfYyhcIm1kLW92ZXJsYXlcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgXCJtZC1hY3RpdmVcIjogX3ZtLm1kQWN0aXZlLCBcIm1kLWF0dGFjaC10by1wYXJlbnRcIjogXCJcIiB9LFxuICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5jbG9zZURyYXdlciB9XG4gICAgICAgICAgfSlcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZERyYXdlcl9NZERyYXdlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtODAxY2FhNjJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kRHJhd2VyL01kRHJhd2VyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMjM0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREcmF3ZXJfZGVmYXVsdC5hLFxuICBNZERyYXdlcl9NZERyYXdlcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRHJhd2VyL01kRHJhd2VyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTgwMWNhYTYyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtODAxY2FhNjJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWREcmF3ZXJfTWREcmF3ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZE92ZXJsYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIF9NZE92ZXJsYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRPdmVybGF5KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb3BWYWxpZGF0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kRHJhd2VyJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kT3ZlcmxheTogX01kT3ZlcmxheTIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kTGVmdDogQm9vbGVhbixcbiAgICBtZFJpZ2h0OiBCb29sZWFuLFxuICAgIG1kUGVybWFuZW50OiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLXBlcm1hbmVudCcsIFsnZnVsbCcsICdjbGlwcGVkJywgJ2NhcmQnXSkpLFxuICAgIG1kUGVyc2lzdGVudDogX2V4dGVuZHMoe1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1wZXJzaXN0ZW50JywgWydtaW5pJywgJ2Z1bGwnXSkpLFxuICAgIG1kQWN0aXZlOiBCb29sZWFuLFxuICAgIG1kRml4ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZEFjdGl2ZTogZnVuY3Rpb24gbWRBY3RpdmUodmlzaWJsZSkge1xuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnbWQtb3BlbmVkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbWl0KCdtZC1jbG9zZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZHJhd2VyQ2xhc3NlczogZnVuY3Rpb24gZHJhd2VyQ2xhc3NlcygpIHtcbiAgICAgIHZhciBjbGFzc2VzID0ge1xuICAgICAgICAnbWQtbGVmdCc6IHRoaXMubWRMZWZ0LFxuICAgICAgICAnbWQtcmlnaHQnOiB0aGlzLm1kUmlnaHQsXG4gICAgICAgICdtZC10ZW1wb3JhcnknOiB0aGlzLmlzVGVtcG9yYXJ5LFxuICAgICAgICAnbWQtcGVyc2lzdGVudCc6IHRoaXMubWRQZXJzaXN0ZW50LFxuICAgICAgICAnbWQtcGVybWFuZW50JzogdGhpcy5tZFBlcm1hbmVudCxcbiAgICAgICAgJ21kLWFjdGl2ZSc6IHRoaXMubWRBY3RpdmUsXG4gICAgICAgICdtZC1maXhlZCc6IHRoaXMubWRGaXhlZFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWRQZXJtYW5lbnQpIHtcbiAgICAgICAgY2xhc3Nlc1snbWQtcGVybWFuZW50LScgKyB0aGlzLm1kUGVybWFuZW50XSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1kUGVyc2lzdGVudCkge1xuICAgICAgICBjbGFzc2VzWydtZC1wZXJzaXN0ZW50LScgKyB0aGlzLm1kUGVyc2lzdGVudF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3NlcztcbiAgICB9LFxuICAgIGlzVGVtcG9yYXJ5OiBmdW5jdGlvbiBpc1RlbXBvcmFyeSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5tZFBlcm1hbmVudCAmJiAhdGhpcy5tZFBlcnNpc3RlbnQ7XG4gICAgfSxcbiAgICBtb2RlOiBmdW5jdGlvbiBtb2RlKCkge1xuICAgICAgaWYgKHRoaXMubWRQZXJzaXN0ZW50KSB7XG4gICAgICAgIHJldHVybiAncGVyc2lzdGVudCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1kUGVybWFuZW50KSB7XG4gICAgICAgIHJldHVybiAncGVybWFuZW50JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd0ZW1wb3JhcnknO1xuICAgIH0sXG4gICAgc3VibW9kZTogZnVuY3Rpb24gc3VibW9kZSgpIHtcbiAgICAgIGlmICh0aGlzLm1kUGVyc2lzdGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZFBlcnNpc3RlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1kUGVybWFuZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1kUGVybWFuZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNsb3NlRHJhd2VyOiBmdW5jdGlvbiBjbG9zZURyYXdlcigpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptZEFjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDIzNyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHt9O1xuXG4vKioqLyB9KSxcbi8qIDIzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDIzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRFbXB0eVN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbnZhciBfTWRFbXB0eVN0YXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRW1wdHlTdGF0ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRFbXB0eVN0YXRlMi5kZWZhdWx0Lm5hbWUsIF9NZEVtcHR5U3RhdGUyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kRW1wdHlTdGF0ZVByb3BzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbnZhciBfTWRFbXB0eVN0YXRlUHJvcHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRFbXB0eVN0YXRlUHJvcHMpO1xuXG52YXIgX01kQXNzZXRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfTWRBc3NldEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRBc3NldEljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kRW1wdHlTdGF0ZScsXG4gIG1peGluczogW19NZEFzc2V0SWNvbjIuZGVmYXVsdF0sXG4gIHByb3BzOiBfTWRFbXB0eVN0YXRlUHJvcHMyLmRlZmF1bHQsXG4gIGNvbXB1dGVkOiB7XG4gICAgZW1wdHlTdGF0ZUNsYXNzZXM6IGZ1bmN0aW9uIGVtcHR5U3RhdGVDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLXJvdW5kZWQnOiB0aGlzLm1kUm91bmRlZFxuICAgICAgfTtcbiAgICB9LFxuICAgIGVtcHR5U3RhdGVTdHlsZXM6IGZ1bmN0aW9uIGVtcHR5U3RhdGVTdHlsZXMoKSB7XG4gICAgICBpZiAodGhpcy5tZFJvdW5kZWQpIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLm1kU2l6ZSArICdweCc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgICBoZWlnaHQ6IHNpemVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAyNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG52YXIgX01kU2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDIpO1xuXG52YXIgX01kU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kU2VsZWN0KTtcblxudmFyIF9NZEZpZWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBfTWRGaWVsZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEZpZWxkKTtcblxudmFyIF9NZEZpbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MSk7XG5cbnZhciBfTWRGaWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRmlsZSk7XG5cbnZhciBfTWRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01kSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJbnB1dCk7XG5cbnZhciBfTWRUZXh0YXJlYSA9IF9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcblxudmFyIF9NZFRleHRhcmVhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGV4dGFyZWEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS51c2UoX01kSWNvbjIuZGVmYXVsdCk7XG4gIFZ1ZS51c2UoX01kU2VsZWN0Mi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRGaWVsZDIuZGVmYXVsdC5uYW1lLCBfTWRGaWVsZDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kRmlsZTIuZGVmYXVsdC5uYW1lLCBfTWRGaWxlMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRJbnB1dDIuZGVmYXVsdC5uYW1lLCBfTWRJbnB1dDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVGV4dGFyZWEyLmRlZmF1bHQubmFtZSwgX01kVGV4dGFyZWEyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kU2VsZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDMpO1xuXG52YXIgX01kU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kU2VsZWN0KTtcblxudmFyIF9NZE9wdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjU1KTtcblxudmFyIF9NZE9wdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZE9wdGlvbik7XG5cbnZhciBfTWRPcHRncm91cCA9IF9fd2VicGFja19yZXF1aXJlX18oMjU4KTtcblxudmFyIF9NZE9wdGdyb3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kT3B0Z3JvdXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU2VsZWN0Mi5kZWZhdWx0Lm5hbWUsIF9NZFNlbGVjdDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kT3B0aW9uMi5kZWZhdWx0Lm5hbWUsIF9NZE9wdGlvbjIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kT3B0Z3JvdXAyLmRlZmF1bHQubmFtZSwgX01kT3B0Z3JvdXAyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRTZWxlY3QvTWRTZWxlY3QudnVlXG52YXIgTWRTZWxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NSk7XG52YXIgTWRTZWxlY3RfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRTZWxlY3QpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdlMzVkZmEzXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRTZWxlY3QvTWRTZWxlY3QudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibWQtbWVudVwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXNlbGVjdFwiLFxuICAgICAgY2xhc3M6IHsgXCJtZC1kaXNhYmxlZFwiOiBfdm0uZGlzYWJsZWQgfSxcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwibWQtY2xvc2Utb24tc2VsZWN0XCI6IGZhbHNlLFxuICAgICAgICBcIm1kLWFjdGl2ZVwiOiBfdm0uc2hvd1NlbGVjdCxcbiAgICAgICAgXCJtZC1vZmZzZXQteFwiOiBfdm0ub2Zmc2V0LngsXG4gICAgICAgIFwibWQtb2Zmc2V0LXlcIjogX3ZtLm9mZnNldC55LFxuICAgICAgICBcIm1kLWRlbnNlXCI6IF92bS5tZERlbnNlXG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgXCJ1cGRhdGU6bWRBY3RpdmVcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLnNob3dTZWxlY3QgPSAkZXZlbnRcbiAgICAgICAgfSxcbiAgICAgICAgXCJtZC1jbG9zZWRcIjogX3ZtLm9uQ2xvc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWlucHV0XCIsXG4gICAgICAgIF92bS5fZyhcbiAgICAgICAgICBfdm0uX2IoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlZjogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1pbnB1dCBtZC1zZWxlY3QtdmFsdWVcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICByZWFkb25seTogXCJcIixcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogX3ZtLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBfdm0ucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICBfdm0ub25Gb2N1cygkZXZlbnQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibHVyOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICBfdm0ucmVtb3ZlSGlnaGxpZ2h0KCRldmVudClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNsaWNrOiBfdm0ub3BlblNlbGVjdCxcbiAgICAgICAgICAgICAgICBrZXlkb3duOiBbXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICEoXCJidXR0b25cIiBpbiAkZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcImRvd25cIiwgNDAsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3ZtLm9wZW5TZWxlY3QoJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwiZW50ZXJcIiwgMTMsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3ZtLm9wZW5TZWxlY3QoJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIShcImJ1dHRvblwiIGluICRldmVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX2soJGV2ZW50LmtleUNvZGUsIFwic3BhY2VcIiwgMzIsICRldmVudC5rZXkpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3ZtLm9wZW5TZWxlY3QoJGV2ZW50KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLk1kU2VsZWN0LmxhYmVsLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigkJHYpIHtcbiAgICAgICAgICAgICAgICAgIF92bS4kc2V0KF92bS5NZFNlbGVjdCwgXCJsYWJlbFwiLCAkJHYpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcIk1kU2VsZWN0LmxhYmVsXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwibWQtaW5wdXRcIixcbiAgICAgICAgICAgIF92bS4kYXR0cnMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLmlucHV0TGlzdGVuZXJzXG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJtZC1kcm9wLWRvd24taWNvblwiLCB7XG4gICAgICAgIG5hdGl2ZU9uOiB7XG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgX3ZtLm9wZW5TZWxlY3QoJGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcIm1kLW1lbnUtY29udGVudFwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZWY6IFwibWVudVwiLFxuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1zZWxlY3QtbWVudVwiLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLm1lbnVTdHlsZXMsXG4gICAgICAgICAgICAgIGF0dHJzOiB7IFwibWQtY29udGVudC1jbGFzc1wiOiBfdm0ubWRDbGFzcyB9LFxuICAgICAgICAgICAgICBvbjogeyBlbnRlcjogX3ZtLm9uTWVudUVudGVyIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLnNob3dTZWxlY3QgPyBfdm0uX3QoXCJkZWZhdWx0XCIpIDogX3ZtLl9lKCldLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAhX3ZtLnNob3dTZWxlY3RcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1zaG93XCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImZhbHNlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLm1vZGVsLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJtb2RlbFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1pbnB1dC1mYWtlXCIsXG4gICAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsIHJlYWRvbmx5OiBcIlwiLCB0YWJpbmRleDogXCItMVwiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubW9kZWwgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0ubW9kZWwgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLm1vZGVsLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibW9kZWxcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYXR0cnM6IHsgcmVhZG9ubHk6IFwiXCIsIHRhYmluZGV4OiBcIi0xXCIgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyICQkc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gICAgICAgICAgICAgICAgICAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF92bS5tb2RlbCA9ICRldmVudC50YXJnZXQubXVsdGlwbGVcbiAgICAgICAgICAgICAgICAgID8gJCRzZWxlY3RlZFZhbFxuICAgICAgICAgICAgICAgICAgOiAkJHNlbGVjdGVkVmFsWzBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgX3ZtLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kU2VsZWN0X01kU2VsZWN0ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03ZTM1ZGZhM1wiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZFNlbGVjdC9NZFNlbGVjdC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kU2VsZWN0X2RlZmF1bHQuYSxcbiAgTWRTZWxlY3RfTWRTZWxlY3QsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEZpZWxkL01kU2VsZWN0L01kU2VsZWN0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTdlMzVkZmEzXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtN2UzNWRmYTNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRmllbGRfTWRTZWxlY3RfTWRTZWxlY3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX3JhZiA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBfcmFmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JhZik7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZERyb3BEb3duSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ2KTtcblxudmFyIF9NZERyb3BEb3duSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZERyb3BEb3duSWNvbik7XG5cbnZhciBfTWRNZW51ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XG5cbnZhciBfTWRNZW51MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTWVudSk7XG5cbnZhciBfTWRNZW51Q29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuXG52YXIgX01kTWVudUNvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRNZW51Q29udGVudCk7XG5cbnZhciBfTWRJbnB1dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG52YXIgX01kSW5wdXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJbnB1dCk7XG5cbnZhciBfTWRGaWVsZE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfTWRGaWVsZE1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRmllbGRNaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbnZhciBkZWZhdWx0T2Zmc2V0ID0ge1xuICB4OiAtMTUsXG4gIHk6IC00OFxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTZWxlY3QnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJbnB1dDogX01kSW5wdXQyLmRlZmF1bHQsXG4gICAgTWRNZW51OiBfTWRNZW51Mi5kZWZhdWx0LFxuICAgIE1kTWVudUNvbnRlbnQ6IF9NZE1lbnVDb250ZW50Mi5kZWZhdWx0LFxuICAgIE1kRHJvcERvd25JY29uOiBfTWREcm9wRG93bkljb24yLmRlZmF1bHRcbiAgfSxcbiAgbWl4aW5zOiBbX01kRmllbGRNaXhpbjIuZGVmYXVsdF0sXG4gIHByb3BzOiB7XG4gICAgbWREZW5zZTogQm9vbGVhbixcbiAgICBtZENsYXNzOiBTdHJpbmcsXG4gICAgbXVsdGlwbGU6IEJvb2xlYW4sXG4gICAgaWQ6IFN0cmluZyxcbiAgICBuYW1lOiBTdHJpbmdcbiAgfSxcbiAgaW5qZWN0OiBbJ01kRmllbGQnXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVudVN0eWxlczoge30sXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgeDogZGVmYXVsdE9mZnNldC54LFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgc2hvd1NlbGVjdDogdHJ1ZSxcbiAgICAgIGRpZE1vdW50OiBmYWxzZSxcbiAgICAgIE1kU2VsZWN0OiB7XG4gICAgICAgIGl0ZW1zOiB7fSxcbiAgICAgICAgbGFiZWw6IG51bGwsXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSxcbiAgICAgICAgbW9kZWxWYWx1ZTogdGhpcy5sb2NhbFZhbHVlLFxuICAgICAgICBzZXRWYWx1ZTogdGhpcy5zZXRWYWx1ZSxcbiAgICAgICAgc2V0Q29udGVudDogdGhpcy5zZXRDb250ZW50LFxuICAgICAgICBzZXRNdWx0aXBsZVZhbHVlOiB0aGlzLnNldE11bHRpcGxlVmFsdWUsXG4gICAgICAgIHNldE11bHRpcGxlQ29udGVudDogdGhpcy5zZXRNdWx0aXBsZUNvbnRlbnRcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHZhciBNZFNlbGVjdCA9IHRoaXMuTWRTZWxlY3Q7XG5cbiAgICByZXR1cm4geyBNZFNlbGVjdDogTWRTZWxlY3QgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGlucHV0TGlzdGVuZXJzOiBmdW5jdGlvbiBpbnB1dExpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdGhpcy4kbGlzdGVuZXJzLCB7XG4gICAgICAgIGlucHV0OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBsb2NhbFZhbHVlOiB7XG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbCkge1xuICAgICAgICB0aGlzLnNldEZpZWxkQ29udGVudCgpO1xuICAgICAgICB0aGlzLk1kU2VsZWN0Lm1vZGVsVmFsdWUgPSB0aGlzLmxvY2FsVmFsdWU7XG4gICAgICAgIHRoaXMuZW1pdFNlbGVjdGVkKHZhbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBtdWx0aXBsZToge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihpc011bHRpcGxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5NZFNlbGVjdC5tdWx0aXBsZSA9IGlzTXVsdGlwbGU7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaW5pdGlhbExvY2FsVmFsdWVCeURlZmF1bHQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZWxIYXNTY3JvbGw6IGZ1bmN0aW9uIGVsSGFzU2Nyb2xsKGVsKSB7XG4gICAgICByZXR1cm4gZWwuc2Nyb2xsSGVpZ2h0ID4gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIH0sXG4gICAgc2Nyb2xsVG9TZWxlY3RlZE9wdGlvbjogZnVuY3Rpb24gc2Nyb2xsVG9TZWxlY3RlZE9wdGlvbihlbCwgbWVudSkge1xuICAgICAgdmFyIHRvcCA9IGVsLm9mZnNldFRvcDtcbiAgICAgIHZhciBlbEhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICAgIHZhciBtZW51SGVpZ2h0ID0gbWVudS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIG1lbnUuc2Nyb2xsVG9wID0gdG9wIC0gKG1lbnVIZWlnaHQgLSBlbEhlaWdodCkgLyAyO1xuICAgIH0sXG4gICAgc2V0T2Zmc2V0czogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodGFyZ2V0KSB7XG4gICAgICAgIHZhciBtZW51LCBzZWxlY3RlZDtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgIG1lbnUgPSB0aGlzLiRyZWZzLm1lbnUuJHJlZnMuY29udGFpbmVyO1xuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdGFyZ2V0IHx8IG1lbnUucXVlcnlTZWxlY3RvcignLm1kLXNlbGVjdGVkJyk7XG5cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQsIG1lbnUpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0LnkgPSBkZWZhdWx0T2Zmc2V0LnkgLSBzZWxlY3RlZC5vZmZzZXRUb3AgKyBtZW51LnNjcm9sbFRvcCArIDg7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51U3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybS1vcmlnaW4nOiAnMCAnICsgTWF0aC5hYnModGhpcy5vZmZzZXQueSkgKyAncHgnXG4gICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldC55ID0gZGVmYXVsdE9mZnNldC55ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVTdHlsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRPZmZzZXRzKF94KSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRPZmZzZXRzO1xuICAgIH0oKSxcbiAgICBvbk1lbnVFbnRlcjogZnVuY3Rpb24gb25NZW51RW50ZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuZGlkTW91bnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE9mZnNldHMoKTtcbiAgICAgIHRoaXMuTWRGaWVsZC5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLW9wZW5lZCcpO1xuICAgIH0sXG4gICAgYXBwbHlIaWdobGlnaHQ6IGZ1bmN0aW9uIGFwcGx5SGlnaGxpZ2h0KCkge1xuICAgICAgdGhpcy5NZEZpZWxkLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuTWRGaWVsZC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0LiRlbC5mb2N1cygpO1xuICAgIH0sXG4gICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLWNsb3NlZCcpO1xuICAgICAgaWYgKHRoaXMuZGlkTW91bnQpIHtcbiAgICAgICAgdGhpcy5hcHBseUhpZ2hsaWdodCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cygpIHtcbiAgICAgIGlmICh0aGlzLmRpZE1vdW50KSB7XG4gICAgICAgIHRoaXMuYXBwbHlIaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUhpZ2hsaWdodDogZnVuY3Rpb24gcmVtb3ZlSGlnaGxpZ2h0KCkge1xuICAgICAgdGhpcy5NZEZpZWxkLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgfSxcbiAgICBvcGVuU2VsZWN0OiBmdW5jdGlvbiBvcGVuU2VsZWN0KCkge1xuICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc2hvd1NlbGVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhcnJheUFjY2Vzc29yUmVtb3ZlOiBmdW5jdGlvbiBhcnJheUFjY2Vzc29yUmVtb3ZlKGFyciwgaW5kZXgpIHtcbiAgICAgIHZhciBiZWZvcmUgPSBhcnIuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgdmFyIGFmdGVyID0gYXJyLnNsaWNlKGluZGV4ICsgMSwgYXJyLmxlbmd0aCk7XG4gICAgICByZXR1cm4gYmVmb3JlLmNvbmNhdChhZnRlcik7XG4gICAgfSxcbiAgICB0b2dnbGVBcnJheVZhbHVlOiBmdW5jdGlvbiB0b2dnbGVBcnJheVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmxvY2FsVmFsdWUuaW5kZXhPZih2YWx1ZSk7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBpbmRleCA+IC0xO1xuICAgICAgaWYgKCFpbmNsdWRlcykge1xuICAgICAgICB0aGlzLmxvY2FsVmFsdWUgPSB0aGlzLmxvY2FsVmFsdWUuY29uY2F0KFt2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2NhbFZhbHVlID0gdGhpcy5hcnJheUFjY2Vzc29yUmVtb3ZlKHRoaXMubG9jYWxWYWx1ZSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgICB0aGlzLm1vZGVsID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLnNldEZpZWxkVmFsdWUoKTtcbiAgICAgIHRoaXMuc2hvd1NlbGVjdCA9IGZhbHNlO1xuICAgIH0sXG4gICAgc2V0Q29udGVudDogZnVuY3Rpb24gc2V0Q29udGVudChuZXdMYWJlbCkge1xuICAgICAgdGhpcy5NZFNlbGVjdC5sYWJlbCA9IG5ld0xhYmVsO1xuICAgIH0sXG4gICAgc2V0Q29udGVudEJ5VmFsdWU6IGZ1bmN0aW9uIHNldENvbnRlbnRCeVZhbHVlKCkge1xuICAgICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy5NZFNlbGVjdC5pdGVtc1t0aGlzLmxvY2FsVmFsdWVdO1xuXG4gICAgICBpZiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KHRleHRDb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGVudCgnJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRNdWx0aXBsZVZhbHVlOiBmdW5jdGlvbiBzZXRNdWx0aXBsZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMudG9nZ2xlQXJyYXlWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB0aGlzLnNldEZpZWxkVmFsdWUoKTtcbiAgICB9LFxuICAgIHNldE11bHRpcGxlQ29udGVudEJ5VmFsdWU6IGZ1bmN0aW9uIHNldE11bHRpcGxlQ29udGVudEJ5VmFsdWUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmxvY2FsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsTG9jYWxWYWx1ZUJ5RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnQgPSBbXTtcblxuICAgICAgdGhpcy5sb2NhbFZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gX3RoaXMyLk1kU2VsZWN0Lml0ZW1zW2l0ZW1dO1xuXG4gICAgICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgIGNvbnRlbnQucHVzaCh0ZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldENvbnRlbnQoY29udGVudC5qb2luKCcsICcpKTtcbiAgICB9LFxuICAgIHNldEZpZWxkQ29udGVudDogZnVuY3Rpb24gc2V0RmllbGRDb250ZW50KCkge1xuICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5zZXRNdWx0aXBsZUNvbnRlbnRCeVZhbHVlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldENvbnRlbnRCeVZhbHVlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0aWFsTG9jYWxWYWx1ZUJ5RGVmYXVsdDogZnVuY3Rpb24gaW5pdGlhbExvY2FsVmFsdWVCeURlZmF1bHQoKSB7XG4gICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGhpcy5sb2NhbFZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgIHZhciBpc1NldCA9IHRoaXMubG9jYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMubG9jYWxWYWx1ZSAhPT0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2NhbFZhbHVlID0gaXNTZXQgPyBbdGhpcy5sb2NhbFZhbHVlXSA6IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICB0aGlzLmxvY2FsVmFsdWUgPSB0aGlzLmxvY2FsVmFsdWUubGVuZ3RoID4gMCA/IHRoaXMubG9jYWxWYWx1ZVswXSA6IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0U2VsZWN0ZWQ6IGZ1bmN0aW9uIGVtaXRTZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnbWQtc2VsZWN0ZWQnLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuc2hvd1NlbGVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLnNldEZpZWxkQ29udGVudCgpO1xuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdGhpcy5kaWRNb3VudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpXG59O1xuXG4vKioqLyB9KSxcbi8qIDI0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWREcm9wRG93bkljb24udnVlXG52YXIgTWREcm9wRG93bkljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Nyk7XG52YXIgTWREcm9wRG93bkljb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWREcm9wRG93bkljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQ0ZGIwMzFkXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kRHJvcERvd25JY29uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMCwgZmFsc2UsIHRydWUpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1pY29uLWltYWdlXCIgfSwgW1xuICAgICAgX2MoXG4gICAgICAgIFwic3ZnXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInBhdGhcIiwgeyBhdHRyczogeyBkOiBcIk03IDEwbDUgNSA1LTV6XCIgfSB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAgMGgyNHYyNEgwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpY29uc19NZERyb3BEb3duSWNvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDRkYjAzMWRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2ljb25zL01kRHJvcERvd25JY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWREcm9wRG93bkljb25fZGVmYXVsdC5hLFxuICBpY29uc19NZERyb3BEb3duSWNvbixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb3JlL2ljb25zL01kRHJvcERvd25JY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ0ZGIwMzFkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDRkYjAzMWRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWREcm9wRG93bkljb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZERyb3BEb3duSWNvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEljb246IF9NZEljb24yLmRlZmF1bHRcbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDI0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDI0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRNZW51JyxcbiAgcHJvcHM6IHtcbiAgICBtZEFjdGl2ZTogQm9vbGVhbixcbiAgICBtZEFsaWduVHJpZ2dlcjogQm9vbGVhbixcbiAgICBtZE9mZnNldFg6IE51bWJlcixcbiAgICBtZE9mZnNldFk6IE51bWJlcixcbiAgICBtZEZ1bGxXaWR0aDogQm9vbGVhbixcbiAgICBtZERlbnNlOiBCb29sZWFuLFxuICAgIG1kRGlyZWN0aW9uOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYm90dG9tLXN0YXJ0J1xuICAgIH0sICgwLCBfTWRQcm9wVmFsaWRhdG9yMi5kZWZhdWx0KSgnbWQtZGlyZWN0aW9uJywgWyd0b3AtZW5kJywgJ3RvcC1zdGFydCcsICdib3R0b20tZW5kJywgJ2JvdHRvbS1zdGFydCddKSksXG4gICAgbWRDbG9zZU9uU2VsZWN0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgbWRTaXplOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnc21hbGwnXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1zaXplJywgWydhdXRvJywgJ3NtYWxsJywgJ21lZGl1bScsICdiaWcnLCAnaHVnZSddKSlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpZ2dlckVsOiBudWxsLFxuICAgICAgTWRNZW51OiB7XG4gICAgICAgIGluc3RhbmNlOiB0aGlzLFxuICAgICAgICBhY3RpdmU6IHRoaXMubWRBY3RpdmUsXG4gICAgICAgIGRpcmVjdGlvbjogdGhpcy5tZERpcmVjdGlvbixcbiAgICAgICAgc2l6ZTogdGhpcy5tZFNpemUsXG4gICAgICAgIGFsaWduVHJpZ2dlcjogdGhpcy5tZEFsaWduVHJpZ2dlcixcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5tZE9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRoaXMubWRPZmZzZXRZLFxuICAgICAgICBmdWxsV2lkdGg6IHRoaXMubWRGdWxsV2lkdGgsXG4gICAgICAgIGRlbnNlOiB0aGlzLm1kRGVuc2UsXG4gICAgICAgIGNsb3NlT25TZWxlY3Q6IHRoaXMubWRDbG9zZU9uU2VsZWN0LFxuICAgICAgICBib2R5Q2xpY2tPYnNlcnZlcjogbnVsbCxcbiAgICAgICAgd2luZG93UmVzaXplT2JzZXJ2ZXI6IG51bGwsXG4gICAgICAgICRlbDogdGhpcy4kZWxcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBNZE1lbnU6IHRoaXMuTWRNZW51XG4gICAgfTtcbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kTWVudS5hY3RpdmU7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG1kQWN0aXZlOiB7XG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuTWRNZW51LmFjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWREaXJlY3Rpb246IGZ1bmN0aW9uIG1kRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgdGhpcy5NZE1lbnUuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH0sXG4gICAgbWRTaXplOiBmdW5jdGlvbiBtZFNpemUoc2l6ZSkge1xuICAgICAgdGhpcy5NZE1lbnUuc2l6ZSA9IHNpemU7XG4gICAgfSxcbiAgICBtZEFsaWduVHJpZ2dlcjogZnVuY3Rpb24gbWRBbGlnblRyaWdnZXIoYWxpZ25lZCkge1xuICAgICAgdGhpcy5NZE1lbnUuYWxpZ25UcmlnZ2VyID0gYWxpZ25lZDtcbiAgICB9LFxuICAgIG1kT2Zmc2V0WDogZnVuY3Rpb24gbWRPZmZzZXRYKG9mZnNldCkge1xuICAgICAgdGhpcy5NZE1lbnUub2Zmc2V0WCA9IG9mZnNldDtcbiAgICB9LFxuICAgIG1kT2Zmc2V0WTogZnVuY3Rpb24gbWRPZmZzZXRZKG9mZnNldCkge1xuICAgICAgdGhpcy5NZE1lbnUub2Zmc2V0WSA9IG9mZnNldDtcbiAgICB9LFxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZShfaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptZEFjdGl2ZScsIF9pc0FjdGl2ZSk7XG5cbiAgICAgIGlmICghX2lzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ21kLWNsb3NlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnbWQtb3BlbmVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlQ29udGVudDogZnVuY3Rpb24gdG9nZ2xlQ29udGVudCgkZXZlbnQpIHtcbiAgICAgIHRoaXMuTWRNZW51LmFjdGl2ZSA9ICF0aGlzLk1kTWVudS5hY3RpdmU7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuTWRNZW51LiRlbCA9IHRoaXMuJGVsO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcblxuICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJ1ttZC1tZW51LXRyaWdnZXJdJyk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlckVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUNvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRyaWdnZXJFbCkge1xuICAgICAgdGhpcy50cmlnZ2VyRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZUNvbnRlbnQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbnZhciBfTWRPYnNlcnZlRXZlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxudmFyIF9NZE9ic2VydmVFdmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZE9ic2VydmVFdmVudCk7XG5cbnZhciBfTWRSZXNpemVPYnNlcnZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUyKTtcblxudmFyIF9NZFJlc2l6ZU9ic2VydmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUmVzaXplT2JzZXJ2ZXIpO1xuXG52YXIgX01kUG9wb3ZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgX01kUG9wb3ZlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFBvcG92ZXIpO1xuXG52YXIgX01kRm9jdXNUcmFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XG5cbnZhciBfTWRGb2N1c1RyYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRGb2N1c1RyYXApO1xuXG52YXIgX01kTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG52YXIgX01kTGlzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExpc3QpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfSAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRNZW51Q29udGVudCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZFBvcG92ZXI6IF9NZFBvcG92ZXIyLmRlZmF1bHQsXG4gICAgTWRGb2N1c1RyYXA6IF9NZEZvY3VzVHJhcDIuZGVmYXVsdCxcbiAgICBNZExpc3Q6IF9NZExpc3QyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZExpc3RDbGFzczogW1N0cmluZywgQm9vbGVhbl0sXG4gICAgbWRDb250ZW50Q2xhc3M6IFtTdHJpbmcsIEJvb2xlYW5dXG4gIH0sXG4gIGluamVjdDogWydNZE1lbnUnXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGlnaGxpZ2h0SW5kZXg6IC0xLFxuICAgICAgZGlkTW91bnQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0SXRlbXM6IFtdLFxuICAgICAgcG9wcGVyU2V0dGluZ3M6IG51bGwsXG4gICAgICBtZW51U3R5bGVzOiAnJ1xuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZmlsdGVyZWRBdHRyczogZnVuY3Rpb24gZmlsdGVyZWRBdHRycygpIHtcbiAgICAgIHZhciBhdHRycyA9IHRoaXMuJGF0dHJzO1xuICAgICAgZGVsZXRlIGF0dHJzLmlkO1xuICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH0sXG4gICAgaGlnaGxpZ2h0ZWRJdGVtOiBmdW5jdGlvbiBoaWdobGlnaHRlZEl0ZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdobGlnaHRJdGVtc1t0aGlzLmhpZ2hsaWdodEluZGV4XTtcbiAgICB9LFxuICAgIHNob3VsZFJlbmRlcjogZnVuY3Rpb24gc2hvdWxkUmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRNZW51LmFjdGl2ZTtcbiAgICB9LFxuICAgIG1lbnVDbGFzc2VzOiBmdW5jdGlvbiBtZW51Q2xhc3NlcygpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICB2YXIgcHJlZml4ID0gJ21kLW1lbnUtY29udGVudC0nO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgcHJlZml4ICsgdGhpcy5NZE1lbnUuZGlyZWN0aW9uLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsIHByZWZpeCArIHRoaXMuTWRNZW51LnNpemUsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ21kLW1lbnUtY29udGVudCcsIHRoaXMuZGlkTW91bnQpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ21kLXNoYWxsb3cnLCAhdGhpcy5kaWRNb3VudCksIF9yZWY7XG4gICAgfSxcbiAgICBsaXN0Q2xhc3NlczogZnVuY3Rpb24gbGlzdENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICAnbWQtZGVuc2UnOiB0aGlzLk1kTWVudS5kZW5zZVxuICAgICAgfSwgdGhpcy5tZExpc3RDbGFzcyk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHNob3VsZFJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9zaG91bGRSZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghX3Nob3VsZFJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvcHBlclNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbEhpZ2hsaWdodEluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVDbGlja0V2ZW50T2JzZXJ2ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVJlc2l6ZU9ic2VydmVyKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2hvdWxkUmVuZGVyKF94KSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2hvdWxkUmVuZGVyO1xuICAgIH0oKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0UG9wcGVyU2V0dGluZ3M6IGZ1bmN0aW9uIHNldFBvcHBlclNldHRpbmdzKCkge1xuICAgICAgdmFyIF9NZE1lbnUgPSB0aGlzLk1kTWVudSxcbiAgICAgICAgICBkaXJlY3Rpb24gPSBfTWRNZW51LmRpcmVjdGlvbixcbiAgICAgICAgICBhbGlnblRyaWdnZXIgPSBfTWRNZW51LmFsaWduVHJpZ2dlcjtcblxuICAgICAgdmFyIF9nZXRPZmZzZXRzID0gdGhpcy5nZXRPZmZzZXRzKCksXG4gICAgICAgICAgb2Zmc2V0WCA9IF9nZXRPZmZzZXRzLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WSA9IF9nZXRPZmZzZXRzLm9mZnNldFk7XG5cbiAgICAgIGlmICghdGhpcy5oYXNDdXN0b21PZmZzZXRzKCkpIHtcbiAgICAgICAgaWYgKHRoaXMuTWRNZW51Lmluc3RhbmNlLiRlbCAmJiB0aGlzLk1kTWVudS5pbnN0YW5jZS4kZWwub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICAgICAgb2Zmc2V0WSA9IC10aGlzLk1kTWVudS5pbnN0YW5jZS4kZWwub2Zmc2V0SGVpZ2h0IC0gMTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlyZWN0aW9uLmluY2x1ZGVzKCdzdGFydCcpKSB7XG4gICAgICAgICAgb2Zmc2V0WCA9IC04O1xuICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbi5pbmNsdWRlcygnZW5kJykpIHtcbiAgICAgICAgICBvZmZzZXRYID0gODtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcHBlclNldHRpbmdzID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IGRpcmVjdGlvbixcbiAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAga2VlcFRvZ2V0aGVyOiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFggKyAnLCAnICsgb2Zmc2V0WVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldEluaXRpYWxIaWdobGlnaHRJbmRleDogZnVuY3Rpb24gc2V0SW5pdGlhbEhpZ2hsaWdodEluZGV4KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5zZXRIaWdobGlnaHRJdGVtcygpO1xuICAgICAgdGhpcy5oaWdobGlnaHRJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ21kLXNlbGVjdGVkJykpIHtcbiAgICAgICAgICBfdGhpcy5oaWdobGlnaHRJbmRleCA9IGluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRIaWdobGlnaHRJdGVtczogZnVuY3Rpb24gc2V0SGlnaGxpZ2h0SXRlbXMoKSB7XG4gICAgICBpZiAodGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKCcubWQtbGlzdC1pdGVtLWNvbnRhaW5lcjpub3QoLm1kLWxpc3QtaXRlbS1kZWZhdWx0KTpub3QoW2Rpc2FibGVkXSknKTtcblxuICAgICAgICB0aGlzLmhpZ2hsaWdodEl0ZW1zID0gQXJyYXkuZnJvbShpdGVtcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRIaWdobGlnaHQ6IGZ1bmN0aW9uIHNldEhpZ2hsaWdodChkaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMuc2V0SGlnaGxpZ2h0SXRlbXMoKTtcblxuICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodEluZGV4ID09PSB0aGlzLmhpZ2hsaWdodEl0ZW1zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0SW5kZXggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEluZGV4ID0gdGhpcy5oaWdobGlnaHRJdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodEluZGV4LS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jbGVhckFsbEhpZ2hsaWdodHMoKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtSGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhckFsbEhpZ2hsaWdodHM6IGZ1bmN0aW9uIGNsZWFyQWxsSGlnaGxpZ2h0cygpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0SXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpdGVtLnBhcmVudE5vZGUuX192dWVfXy5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRJdGVtSGlnaGxpZ2h0OiBmdW5jdGlvbiBzZXRJdGVtSGlnaGxpZ2h0KCkge1xuICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtLnBhcmVudE5vZGUuX192dWVfXy5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLiRwYXJlbnQuJHBhcmVudC5zZXRPZmZzZXRzKSB7XG4gICAgICAgICAgdGhpcy4kcGFyZW50LiRwYXJlbnQuc2V0T2Zmc2V0cyh0aGlzLmhpZ2hsaWdodGVkSXRlbS5wYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5oaWdobGlnaHRlZEl0ZW0pIHtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0ucGFyZW50Tm9kZS5jbGljaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Fc2M6IGZ1bmN0aW9uIG9uRXNjKCkge1xuICAgICAgdGhpcy5NZE1lbnUuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRzOiBmdW5jdGlvbiBnZXRPZmZzZXRzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0WDogdGhpcy5NZE1lbnUub2Zmc2V0WCB8fCAwLFxuICAgICAgICBvZmZzZXRZOiB0aGlzLk1kTWVudS5vZmZzZXRZIHx8IDBcbiAgICAgIH07XG4gICAgfSxcbiAgICBoYXNDdXN0b21PZmZzZXRzOiBmdW5jdGlvbiBoYXNDdXN0b21PZmZzZXRzKCkge1xuICAgICAgdmFyIF9NZE1lbnUyID0gdGhpcy5NZE1lbnUsXG4gICAgICAgICAgb2Zmc2V0WCA9IF9NZE1lbnUyLm9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WSA9IF9NZE1lbnUyLm9mZnNldFksXG4gICAgICAgICAgYWxpZ25UcmlnZ2VyID0gX01kTWVudTIuYWxpZ25UcmlnZ2VyO1xuXG5cbiAgICAgIHJldHVybiBCb29sZWFuKGFsaWduVHJpZ2dlciB8fCBvZmZzZXRZIHx8IG9mZnNldFgpO1xuICAgIH0sXG4gICAgY3JlYXRlQ2xpY2tFdmVudE9ic2VydmVyOiBmdW5jdGlvbiBjcmVhdGVDbGlja0V2ZW50T2JzZXJ2ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuTWRNZW51LmJvZHlDbGlja09ic2VydmVyID0gbmV3IF9NZE9ic2VydmVFdmVudDIuZGVmYXVsdChkb2N1bWVudC5ib2R5LCAnY2xpY2snLCBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHZhciBpc01kTWVudSA9IF90aGlzMi5NZE1lbnUuJGVsID8gX3RoaXMyLk1kTWVudS4kZWwuY29udGFpbnMoJGV2ZW50LnRhcmdldCkgOiBmYWxzZTtcbiAgICAgICAgICB2YXIgaXNNZW51Q29udGVudEVsID0gX3RoaXMyLiRyZWZzLm1lbnUgPyBfdGhpczIuJHJlZnMubWVudS5jb250YWlucygkZXZlbnQudGFyZ2V0KSA6IGZhbHNlO1xuICAgICAgICAgIGlmICghX3RoaXMyLiRlbC5jb250YWlucygkZXZlbnQudGFyZ2V0KSAmJiAhaXNNZE1lbnUgJiYgIWlzTWVudUNvbnRlbnRFbCkge1xuICAgICAgICAgICAgX3RoaXMyLk1kTWVudS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzMi5NZE1lbnUuYm9keUNsaWNrT2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgX3RoaXMyLk1kTWVudS53aW5kb3dSZXNpemVPYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVJlc2l6ZU9ic2VydmVyOiBmdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcbiAgICAgIHRoaXMuTWRNZW51LndpbmRvd1Jlc2l6ZU9ic2VydmVyID0gbmV3IF9NZFJlc2l6ZU9ic2VydmVyMi5kZWZhdWx0KHdpbmRvdywgdGhpcy5zZXRTdHlsZXMpO1xuICAgIH0sXG4gICAgc2V0dXBXYXRjaGVyczogZnVuY3Rpb24gc2V0dXBXYXRjaGVycygpIHtcbiAgICAgIHRoaXMuJHdhdGNoKCdNZE1lbnUuZGlyZWN0aW9uJywgdGhpcy5zZXRQb3BwZXJTZXR0aW5ncyk7XG4gICAgICB0aGlzLiR3YXRjaCgnTWRNZW51LmFsaWduVHJpZ2dlcicsIHRoaXMuc2V0UG9wcGVyU2V0dGluZ3MpO1xuICAgICAgdGhpcy4kd2F0Y2goJ01kTWVudS5vZmZzZXRYJywgdGhpcy5zZXRQb3BwZXJTZXR0aW5ncyk7XG4gICAgICB0aGlzLiR3YXRjaCgnTWRNZW51Lm9mZnNldFknLCB0aGlzLnNldFBvcHBlclNldHRpbmdzKTtcbiAgICB9LFxuICAgIHNldFN0eWxlczogZnVuY3Rpb24gc2V0U3R5bGVzKCkge1xuICAgICAgaWYgKHRoaXMuTWRNZW51LmZ1bGxXaWR0aCkge1xuICAgICAgICB0aGlzLm1lbnVTdHlsZXMgPSAnXFxuICAgICAgICAgIHdpZHRoOiAnICsgdGhpcy5NZE1lbnUuaW5zdGFuY2UuJGVsLm9mZnNldFdpZHRoICsgJ3B4O1xcbiAgICAgICAgICBtYXgtd2lkdGg6ICcgKyB0aGlzLk1kTWVudS5pbnN0YW5jZS4kZWwub2Zmc2V0V2lkdGggKyAncHhcXG4gICAgICAgICc7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdGhpcy5zZXRIaWdobGlnaHRJdGVtcygpO1xuICAgICAgICAgICAgICB0aGlzLnNldHVwV2F0Y2hlcnMoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTdHlsZXMoKTtcbiAgICAgICAgICAgICAgdGhpcy5kaWRNb3VudCA9IHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLk1kTWVudS5ib2R5Q2xpY2tPYnNlcnZlcikge1xuICAgICAgdGhpcy5NZE1lbnUuYm9keUNsaWNrT2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLk1kTWVudS53aW5kb3dSZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5NZE1lbnUud2luZG93UmVzaXplT2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMjUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9yYWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFmKTtcblxudmFyIF9NZE9ic2VydmVFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNDYpO1xuXG52YXIgX01kT2JzZXJ2ZUV2ZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kT2JzZXJ2ZUV2ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdztcbiAgdmFyIG9ic2VydmVyRm4gPSBhcmd1bWVudHNbMV07XG5cbiAgdmFyIG9ic2VydmVyID0gKDAsIF9NZE9ic2VydmVFdmVudDIuZGVmYXVsdCkoZWwsICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgKDAsIF9yYWYyLmRlZmF1bHQpKG9ic2VydmVyRm4pO1xuICB9LCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmV0dXJuIG9ic2VydmVyLmRlc3Ryb3k7XG4gICAgfVxuICB9O1xufTtcblxuLyoqKi8gfSksXG4vKiAyNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kTGlzdCdcbn0pOyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kU2VsZWN0L01kT3B0aW9uLnZ1ZVxudmFyIE1kT3B0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTcpO1xudmFyIE1kT3B0aW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kT3B0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0zMmM4Y2U5Y1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kU2VsZWN0L01kT3B0aW9uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLW1lbnUtaXRlbVwiLFxuICAgIHtcbiAgICAgIGNsYXNzOiBfdm0ub3B0aW9uQ2xhc3NlcyxcbiAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0uaXNEaXNhYmxlZCB9LFxuICAgICAgb246IHsgY2xpY2s6IF92bS5zZXRTZWxlY3Rpb24gfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLk1kU2VsZWN0Lm11bHRpcGxlXG4gICAgICAgID8gX2MoXCJtZC1jaGVja2JveFwiLCB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1wcmltYXJ5XCIsXG4gICAgICAgICAgICBhdHRyczogeyBkaXNhYmxlZDogX3ZtLmlzRGlzYWJsZWQgfSxcbiAgICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0uaXNDaGVja2VkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICAgICAgX3ZtLmlzQ2hlY2tlZCA9ICQkdlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImlzQ2hlY2tlZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzcGFuXCIsXG4gICAgICAgIHsgcmVmOiBcInRleHRcIiwgc3RhdGljQ2xhc3M6IFwibWQtbGlzdC1pdGVtLXRleHRcIiB9LFxuICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgIDJcbiAgICAgIClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFNlbGVjdF9NZE9wdGlvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzJjOGNlOWNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRTZWxlY3QvTWRPcHRpb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNTYpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZE9wdGlvbl9kZWZhdWx0LmEsXG4gIE1kU2VsZWN0X01kT3B0aW9uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZFNlbGVjdC9NZE9wdGlvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zMmM4Y2U5Y1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTMyYzhjZTljXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEZpZWxkX01kU2VsZWN0X01kT3B0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRVdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9NZFV1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRVdWlkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRPcHRpb24nLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbU3RyaW5nLCBOdW1iZXIsIEJvb2xlYW5dLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDoge1xuICAgIE1kU2VsZWN0OiB7fSxcbiAgICBNZE9wdGdyb3VwOiB7XG4gICAgICBkZWZhdWx0OiB7fVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pcXVlSWQ6ICdtZC1vcHRpb24tJyArICgwLCBfTWRVdWlkMi5kZWZhdWx0KSgpLFxuICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICBpc0NoZWNrZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzZWxlY3RWYWx1ZTogZnVuY3Rpb24gc2VsZWN0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZFNlbGVjdC5tb2RlbFZhbHVlO1xuICAgIH0sXG4gICAgaXNNdWx0aXBsZTogZnVuY3Rpb24gaXNNdWx0aXBsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kU2VsZWN0Lm11bHRpcGxlO1xuICAgIH0sXG4gICAgaXNEaXNhYmxlZDogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kT3B0Z3JvdXAuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZDtcbiAgICB9LFxuICAgIGtleTogZnVuY3Rpb24ga2V5KCkge1xuICAgICAgdmFyIGlzU2V0ID0gdGhpcy52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSAwO1xuICAgICAgcmV0dXJuIGlzU2V0ID8gdGhpcy52YWx1ZSA6IHRoaXMudW5pcXVlSWQ7XG4gICAgfSxcbiAgICBpbnB1dExhYmVsOiBmdW5jdGlvbiBpbnB1dExhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRTZWxlY3QubGFiZWw7XG4gICAgfSxcbiAgICBvcHRpb25DbGFzc2VzOiBmdW5jdGlvbiBvcHRpb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLXNlbGVjdGVkJzogdGhpcy5pc1NlbGVjdGVkIHx8IHRoaXMuaXNDaGVja2VkXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBzZWxlY3RWYWx1ZTogZnVuY3Rpb24gc2VsZWN0VmFsdWUoKSB7XG4gICAgICB0aGlzLnNldElzU2VsZWN0ZWQoKTtcbiAgICB9LFxuICAgIGlzQ2hlY2tlZDogZnVuY3Rpb24gaXNDaGVja2VkKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PT0gdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKCk7XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiBpc1NlbGVjdGVkKHZhbCkge1xuICAgICAgdGhpcy5pc0NoZWNrZWQgPSB2YWw7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIGdldFRleHRDb250ZW50KCkge1xuICAgICAgaWYgKHRoaXMuJGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC50ZXh0Q29udGVudC50cmltKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcblxuICAgICAgcmV0dXJuIHNsb3QgPyBzbG90WzBdLnRleHQudHJpbSgpIDogJyc7XG4gICAgfSxcbiAgICBzZXRJc1NlbGVjdGVkOiBmdW5jdGlvbiBzZXRJc1NlbGVjdGVkKCkge1xuICAgICAgaWYgKCF0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdGhpcy5zZWxlY3RWYWx1ZSA9PT0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdGhpcy5zZWxlY3RWYWx1ZS5pbmNsdWRlcyh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIHNldFNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2luZ2xlU2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy5NZFNlbGVjdC5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIHNldE11bHRpcGxlU2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRNdWx0aXBsZVNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMuTWRTZWxlY3Quc2V0TXVsdGlwbGVWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aXBsZSkge1xuICAgICAgICAgIHRoaXMuc2V0TXVsdGlwbGVTZWxlY3Rpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldFNpbmdsZVNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRJdGVtOiBmdW5jdGlvbiBzZXRJdGVtKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuTWRTZWxlY3QuaXRlbXMsIHRoaXMua2V5LCB0aGlzLmdldFRleHRDb250ZW50KCkpO1xuICAgIH1cbiAgfSxcbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCgpIHtcbiAgICB0aGlzLnNldEl0ZW0oKTtcbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLnNldEl0ZW0oKTtcbiAgICB0aGlzLnNldElzU2VsZWN0ZWQoKTtcbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAyNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRTZWxlY3QvTWRPcHRncm91cC52dWVcbnZhciBNZE9wdGdyb3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjApO1xudmFyIE1kT3B0Z3JvdXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRPcHRncm91cCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNjA4NDBhOTNcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZFNlbGVjdC9NZE9wdGdyb3VwLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtb3B0Z3JvdXBcIiB9LFxuICAgIFtcbiAgICAgIF9jKFwibWQtc3ViaGVhZGVyXCIsIFtfdm0uX3YoX3ZtLl9zKF92bS5sYWJlbCkpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLl90KFwiZGVmYXVsdFwiKVxuICAgIF0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kU2VsZWN0X01kT3B0Z3JvdXAgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTYwODQwYTkzXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kU2VsZWN0L01kT3B0Z3JvdXAudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNTkpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZE9wdGdyb3VwX2RlZmF1bHQuYSxcbiAgTWRTZWxlY3RfTWRPcHRncm91cCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRmllbGQvTWRTZWxlY3QvTWRPcHRncm91cC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02MDg0MGE5M1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTYwODQwYTkzXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEZpZWxkX01kU2VsZWN0X01kT3B0Z3JvdXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAyNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kT3B0Z3JvdXAnLFxuICBwcm9wczoge1xuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTWRPcHRncm91cDoge1xuICAgICAgICBkaXNhYmxlZDogdGhpcy5kaXNhYmxlZFxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kRmlsZS9NZEZpbGUudnVlXG52YXIgTWRGaWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjMpO1xudmFyIE1kRmlsZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZEZpbGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTE2ZmFjNGEzXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRGaWxlL01kRmlsZS52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWZpbGVcIiB9LFxuICAgIFtcbiAgICAgIF9jKFwibWQtZmlsZS1pY29uXCIsIHtcbiAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBfdm0ub3BlblBpY2tlcigkZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICBfdm0uX2IoXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0ubW9kZWwsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJtb2RlbFwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1pbnB1dFwiLFxuICAgICAgICAgICAgYXR0cnM6IHsgcmVhZG9ubHk6IFwiXCIgfSxcbiAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubW9kZWwgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGZvY3VzOiBfdm0ub3BlblBpY2tlcixcbiAgICAgICAgICAgICAgYmx1cjogX3ZtLm9uQmx1cixcbiAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF92bS5tb2RlbCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsXG4gICAgICAgICAgICByZXF1aXJlZDogX3ZtLnJlcXVpcmVkLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IF92bS5wbGFjZWhvbGRlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICBfdm0uX2coXG4gICAgICAgICAgX3ZtLl9iKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZWY6IFwiaW5wdXRGaWxlXCIsXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiZmlsZVwiIH0sXG4gICAgICAgICAgICAgIG9uOiB7IGNoYW5nZTogX3ZtLm9uQ2hhbmdlIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgICBfdm0uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICAgICApXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRGaWxlX01kRmlsZSA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMTZmYWM0YTNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRGaWxlL01kRmlsZS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Milcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kRmlsZV9kZWZhdWx0LmEsXG4gIE1kRmlsZV9NZEZpbGUsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZEZpZWxkL01kRmlsZS9NZEZpbGUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMTZmYWM0YTNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xNmZhYzRhM1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRGaWVsZF9NZEZpbGVfTWRGaWxlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRVdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9NZFV1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRVdWlkKTtcblxudmFyIF9NZEZpbGVJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjQpO1xuXG52YXIgX01kRmlsZUljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRGaWxlSWNvbik7XG5cbnZhciBfTWRGaWVsZE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfTWRGaWVsZE1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRmllbGRNaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfSAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEZpbGUnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRGaWxlSWNvbjogX01kRmlsZUljb24yLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAnbWQtZmlsZS0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBTdHJpbmdcbiAgfSxcbiAgbWl4aW5zOiBbX01kRmllbGRNaXhpbjIuZGVmYXVsdF0sXG4gIGluamVjdDogWydNZEZpZWxkJ10sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRNdWx0aXBsZU5hbWU6IGZ1bmN0aW9uIGdldE11bHRpcGxlTmFtZShmaWxlcykge1xuICAgICAgdmFyIG5hbWVzID0gW107XG5cbiAgICAgIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZmlsZXMpKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICByZXR1cm4gbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmFtZXMuam9pbignLCAnKTtcbiAgICB9LFxuICAgIGdldEZpbGVOYW1lOiBmdW5jdGlvbiBnZXRGaWxlTmFtZShmaWxlcywgdGFyZ2V0KSB7XG4gICAgICBpZiAoIWZpbGVzKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQudmFsdWUuc3BsaXQoJ1xcXFwnKS5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TXVsdGlwbGVOYW1lKGZpbGVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmlsZXNbMF0ubmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBvcGVuUGlja2VyOiBmdW5jdGlvbiBvcGVuUGlja2VyKCkge1xuICAgICAgdGhpcy5vbkZvY3VzKCk7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0RmlsZS5jbGljaygpO1xuICAgIH0sXG4gICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKCRldmVudCkge1xuICAgICAgdGhpcy5vbkZpbGVTZWxlY3RlZCgkZXZlbnQpO1xuICAgIH0sXG4gICAgb25GaWxlU2VsZWN0ZWQ6IGZ1bmN0aW9uIG9uRmlsZVNlbGVjdGVkKF9yZWYyKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgICAgIGRhdGFUcmFuc2ZlciA9IF9yZWYyLmRhdGFUcmFuc2ZlcjtcblxuICAgICAgdmFyIGZpbGVzID0gdGFyZ2V0LmZpbGVzIHx8IGRhdGFUcmFuc2Zlci5maWxlcztcblxuICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuZ2V0RmlsZU5hbWUoZmlsZXMsIHRhcmdldCk7XG4gICAgICB0aGlzLiRlbWl0KCdtZC1jaGFuZ2UnLCBmaWxlcyB8fCB0YXJnZXQudmFsdWUpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLk1kRmllbGQuZmlsZSA9IHRydWU7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5NZEZpZWxkLmZpbGUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kRmlsZUljb24udnVlXG52YXIgTWRGaWxlSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjY1KTtcbnZhciBNZEZpbGVJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kRmlsZUljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNiZDBjYTMwXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kRmlsZUljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICBkOlxuICAgICAgICAgICAgICAgIFwiTTE2LjUgNnYxMS41YzAgMi4yMS0xLjc5IDQtNCA0cy00LTEuNzktNC00VjVjMC0xLjM4IDEuMTItMi41IDIuNS0yLjVzMi41IDEuMTIgMi41IDIuNXYxMC41YzAgLjU1LS40NSAxLTEgMXMtMS0uNDUtMS0xVjZIMTB2OS41YzAgMS4zOCAxLjEyIDIuNSAyLjUgMi41czIuNS0xLjEyIDIuNS0yLjVWNWMwLTIuMjEtMS43OS00LTQtNFM3IDIuNzkgNyA1djEyLjVjMCAzLjA0IDIuNDYgNS41IDUuNSA1LjVzNS41LTIuNDYgNS41LTUuNVY2aC0xLjV6XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAgMGgyNHYyNEgwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpY29uc19NZEZpbGVJY29uID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0zYmQwY2EzMFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaWNvbnMvTWRGaWxlSWNvbi52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kRmlsZUljb25fZGVmYXVsdC5hLFxuICBpY29uc19NZEZpbGVJY29uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvcmUvaWNvbnMvTWRGaWxlSWNvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zYmQwY2EzMFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTNiZDBjYTMwXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb3JlX2ljb25zX01kRmlsZUljb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZEZpbGVJY29uJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kSWNvbjogX01kSWNvbjIuZGVmYXVsdFxuICB9XG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZEZpZWxkL01kVGV4dGFyZWEvTWRUZXh0YXJlYS52dWVcbnZhciBNZFRleHRhcmVhID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjcpO1xudmFyIE1kVGV4dGFyZWFfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUZXh0YXJlYSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDQ1ZDEwM2FcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRGaWVsZC9NZFRleHRhcmVhL01kVGV4dGFyZWEudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwidGV4dGFyZWFcIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHtcbiAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdm0ubW9kZWwsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb246IFwibW9kZWxcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtdGV4dGFyZWFcIixcbiAgICAgICAgICBzdHlsZTogX3ZtLnRleHRhcmVhU3R5bGVzLFxuICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubW9kZWwgfSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgZm9jdXM6IF92bS5vbkZvY3VzLFxuICAgICAgICAgICAgYmx1cjogX3ZtLm9uQmx1cixcbiAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3ZtLm1vZGVsID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgICBfdm0uYXR0cmlidXRlcyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0ubGlzdGVuZXJzXG4gICAgKVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGV4dGFyZWFfTWRUZXh0YXJlYSA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDQ1ZDEwM2FcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kRmllbGQvTWRUZXh0YXJlYS9NZFRleHRhcmVhLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUZXh0YXJlYV9kZWZhdWx0LmEsXG4gIE1kVGV4dGFyZWFfTWRUZXh0YXJlYSxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kRmllbGQvTWRUZXh0YXJlYS9NZFRleHRhcmVhLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ0NWQxMDNhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDQ1ZDEwM2FcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kRmllbGRfTWRUZXh0YXJlYV9NZFRleHRhcmVhID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kVXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfTWRVdWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVXVpZCk7XG5cbnZhciBfTWRGaWVsZE1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciBfTWRGaWVsZE1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRmllbGRNaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRlbnRIZWlnaHQoZWwsIGxpbmVIZWlnaHQpIHtcbiAgdmFyIG9yaWdIZWlnaHQgPSBlbC5zdHlsZS5oZWlnaHQ7XG4gIHZhciBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG4gIHZhciBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQ7XG5cbiAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICBpZiAoaGVpZ2h0ID49IHNjcm9sbEhlaWdodCkge1xuICAgIGVsLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIGxpbmVIZWlnaHQgKyAncHgnO1xuXG4gICAgaWYgKHNjcm9sbEhlaWdodCA8IGVsLnNjcm9sbEhlaWdodCkge1xuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gb3JpZ0hlaWdodDtcblxuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2Nyb2xsSGVpZ2h0O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kVGV4dGFyZWEnLFxuICBtaXhpbnM6IFtfTWRGaWVsZE1peGluMi5kZWZhdWx0XSxcbiAgaW5qZWN0OiBbJ01kRmllbGQnXSxcbiAgcHJvcHM6IHtcbiAgICBpZDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAnbWQtdGV4dGFyZWEtJyArICgwLCBfTWRVdWlkMi5kZWZhdWx0KSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWRBdXRvZ3JvdzogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpc3RlbmVyczogZnVuY3Rpb24gbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCB0aGlzLiRsaXN0ZW5lcnMsIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMub25JbnB1dFxuICAgICAgfSk7XG4gICAgfSxcbiAgICB0ZXh0YXJlYVN0eWxlczogZnVuY3Rpb24gdGV4dGFyZWFTdHlsZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IHRoaXMudGV4dGFyZWFIZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZ2V0VGV4dEFyZWFMaW5lU2l6ZTogZnVuY3Rpb24gZ2V0VGV4dEFyZWFMaW5lU2l6ZSgpIHtcbiAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKTtcblxuICAgICAgcmV0dXJuIHBhcnNlSW50KHN0eWxlLmxpbmVIZWlnaHQsIDEwKTtcbiAgICB9LFxuICAgIHNldFRleHRBcmVhU2l6ZTogZnVuY3Rpb24gc2V0VGV4dEFyZWFTaXplKGhlaWdodCkge1xuICAgICAgdmFyIG5ld0hlaWdodCA9IGhlaWdodDtcblxuICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFRleHRBcmVhTGluZVNpemUoKTtcblxuICAgICAgICBuZXdIZWlnaHQgPSBjYWxjdWxhdGVDb250ZW50SGVpZ2h0KHRoaXMuJGVsLCBzaXplKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0YXJlYUhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG4gICAgfSxcbiAgICBhcHBseVN0eWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tZEF1dG9ncm93KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dEFyZWFTaXplKDMyKTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUZXh0QXJlYVNpemUoKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy4kZWwuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgfSwgMTApO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHlTdHlsZXM7XG4gICAgfSgpLFxuICAgIHNldFRleHRhcmVhOiBmdW5jdGlvbiBzZXRUZXh0YXJlYSgpIHtcbiAgICAgIHRoaXMuTWRGaWVsZC50ZXh0YXJlYSA9IHRydWU7XG4gICAgfSxcbiAgICBzZXRBdXRvZ3JvdzogZnVuY3Rpb24gc2V0QXV0b2dyb3coKSB7XG4gICAgICB0aGlzLk1kRmllbGQuYXV0b2dyb3cgPSB0aGlzLm1kQXV0b2dyb3c7XG4gICAgfSxcbiAgICBvbklucHV0OiBmdW5jdGlvbiBvbklucHV0KCkge1xuICAgICAgdGhpcy5zZXRGaWVsZFZhbHVlKCk7XG4gICAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuc2V0VGV4dGFyZWEoKTtcbiAgICB0aGlzLnNldEF1dG9ncm93KCk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuc2V0VGV4dGFyZWEoZmFsc2UpO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAyNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kSGlnaGxpZ2h0VGV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oMjY5KTtcblxudmFyIF9NZEhpZ2hsaWdodFRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRIaWdobGlnaHRUZXh0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZEhpZ2hsaWdodFRleHQyLmRlZmF1bHQubmFtZSwgX01kSGlnaGxpZ2h0VGV4dDIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRIaWdobGlnaHRUZXh0X3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEhpZ2hsaWdodFRleHRfdnVlX19fZGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18ubihfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRIaWdobGlnaHRUZXh0X3Z1ZV9fKTtcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZEhpZ2hsaWdodFRleHRfdnVlX19fZGVmYXVsdC5hLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRIaWdobGlnaHRUZXh0L01kSGlnaGxpZ2h0VGV4dC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi00MWViMzZhNVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTQxZWIzNmE1XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDI3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDI3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3Z1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gZ2V0SFRNTE91dHB1dChzdHIpIHtcbiAgdmFyIHRleHQgPSBzdHI7XG5cbiAgaWYgKCF0ZXh0KSB7XG4gICAgdGV4dCA9ICckJic7XG4gIH1cblxuICByZXR1cm4gJzxzcGFuIGNsYXNzPVwibWQtaGlnaGxpZ2h0LXRleHQtbWF0Y2hcIj4nICsgdGV4dCArICc8L3NwYW4+Jztcbn1cblxuZnVuY3Rpb24gZnV6enlIaWdobGlnaHQodGV4dCwgdGVybSkge1xuICBpZiAodGVybS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSB0ZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0ZXJtWzBdLnRvTG93ZXJDYXNlKCkpO1xuXG4gIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGxhc3QgPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHRlcm0ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGV4dFtvZmZzZXQgKyBpXSAhPT0gdGVybVtpXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGFzdCA9IGk7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gdGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuICB2YXIgbWF0Y2ggPSBnZXRIVE1MT3V0cHV0KHRleHQuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsYXN0ICsgMSkpO1xuICB2YXIgYWZ0ZXIgPSBmdXp6eUhpZ2hsaWdodCh0ZXh0LnNsaWNlKG9mZnNldCArIGxhc3QgKyAxKSwgdGVybS5zbGljZShsYXN0ICsgMSkpO1xuXG4gIHJldHVybiBiZWZvcmUgKyBtYXRjaCArIGFmdGVyO1xufVxuXG5mdW5jdGlvbiBub3JtYWxIaWdobGlnaHQodGV4dCwgdGVybSkge1xuICB2YXIgbWF0Y2hlcyA9IG5ldyBSZWdFeHAodGVybSArICcoPyEoW148XSspPzwpJywgJ2dpJyk7XG5cbiAgcmV0dXJuIHRleHQucmVwbGFjZShtYXRjaGVzLCBnZXRIVE1MT3V0cHV0KCkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUhpZ2hsaWdodChfcmVmLCB0ZXJtLCBpc0Z1enp5KSB7XG4gIHZhciB0ZXh0ID0gX3JlZi50ZXh0O1xuXG4gIGlmICh0ZXh0ICYmIHRlcm0gJiYgdGVybVswXSkge1xuICAgIGlmIChpc0Z1enp5KSB7XG4gICAgICByZXR1cm4gZnV6enlIaWdobGlnaHQodGV4dCwgdGVybSkgfHwgdGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsSGlnaGxpZ2h0KHRleHQsIHRlcm0pO1xuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRIaWdobGlnaHRUZXh0JyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbWRUZXJtOiBTdHJpbmcsXG4gICAgbWRGdXp6eVNlYXJjaDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGRlZmF1bHRTbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcblxuICAgICAgaWYgKCFkZWZhdWx0U2xvdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRTbG90Lmxlbmd0aCA+IDEgfHwgZGVmYXVsdFNsb3RbMF0udGFnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgSFRNTENvbnRlbnQgPSBnZW5lcmF0ZUhpZ2hsaWdodChkZWZhdWx0U2xvdFswXSwgdGhpcy5tZFRlcm0sIHRoaXMubWRGdXp6eVNlYXJjaCk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiAnbWQtaGlnaGxpZ2h0LXRleHQnLFxuICAgICAgICBjbGFzczogdGhpcy4kbWRBY3RpdmVUaGVtZSxcbiAgICAgICAgZG9tUHJvcHM6IHtcbiAgICAgICAgICBpbm5lckhUTUw6IEhUTUxDb250ZW50XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF92dWUyLmRlZmF1bHQudXRpbC53YXJuKCdNZEhpZ2hsaWdodFRleHQgY2FuIG9ubHkgcmVuZGVyIHRleHQgbm9kZXMuJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDI3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRJbWFnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjczKTtcblxudmFyIF9NZEltYWdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSW1hZ2UpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kSW1hZ2UyLmRlZmF1bHQubmFtZSwgX01kSW1hZ2UyLmRlZmF1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kSW1hZ2UvTWRJbWFnZS52dWVcbnZhciBNZEltYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzUpO1xudmFyIE1kSW1hZ2VfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRJbWFnZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDUxMWVhNTlcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRJbWFnZS9NZEltYWdlLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtaW1hZ2VcIiwgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWVdIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZEltYWdlX01kSW1hZ2UgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTQ1MTFlYTU5XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZEltYWdlL01kSW1hZ2UudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyNzQpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEltYWdlX2RlZmF1bHQuYSxcbiAgTWRJbWFnZV9NZEltYWdlLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRJbWFnZS9NZEltYWdlLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ1MTFlYTU5XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDUxMWVhNTlcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRJbWFnZV9NZEltYWdlID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjc0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZEltYWdlJyxcbiAgcHJvcHM6IHtcbiAgICBtZFNyYzogU3RyaW5nXG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDI3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI3Nyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHt9O1xuXG4vKioqLyB9KSxcbi8qIDI3NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDI3OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cbnZhciBfTWRMaXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTGlzdCk7XG5cbnZhciBfTWRMaXN0SXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG52YXIgX01kTGlzdEl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRMaXN0Mi5kZWZhdWx0Lm5hbWUsIF9NZExpc3QyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZExpc3RJdGVtMi5kZWZhdWx0Lm5hbWUsIF9NZExpc3RJdGVtMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfTWRJbnRlcmFjdGlvbkV2ZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG52YXIgX01kSW50ZXJhY3Rpb25FdmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJbnRlcmFjdGlvbkV2ZW50cyk7XG5cbnZhciBfTWRSb3V0ZXJMaW5rUHJvcHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIF9NZFJvdXRlckxpbmtQcm9wczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJvdXRlckxpbmtQcm9wcyk7XG5cbnZhciBfTWRMaXN0SXRlbURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4MSk7XG5cbnZhciBfTWRMaXN0SXRlbURlZmF1bHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbURlZmF1bHQpO1xuXG52YXIgX01kTGlzdEl0ZW1CdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NSk7XG5cbnZhciBfTWRMaXN0SXRlbUJ1dHRvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExpc3RJdGVtQnV0dG9uKTtcblxudmFyIF9NZExpc3RJdGVtTGluayA9IF9fd2VicGFja19yZXF1aXJlX18oMjg3KTtcblxudmFyIF9NZExpc3RJdGVtTGluazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExpc3RJdGVtTGluayk7XG5cbnZhciBfTWRMaXN0SXRlbVJvdXRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjg5KTtcblxudmFyIF9NZExpc3RJdGVtUm91dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTGlzdEl0ZW1Sb3V0ZXIpO1xuXG52YXIgX01kTGlzdEl0ZW1FeHBhbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MSk7XG5cbnZhciBfTWRMaXN0SXRlbUV4cGFuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZExpc3RJdGVtRXhwYW5kKTtcblxudmFyIF9NZEJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX01kQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQnV0dG9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaGFzRXhwYW5zaW9uKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnbWRFeHBhbmQnKSAmJiBwcm9wcy5tZEV4cGFuZCAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90KHByb3BzLCBjaGlsZHJlbikge1xuICBpZiAoaGFzRXhwYW5zaW9uKHByb3BzKSkge1xuICAgIHJldHVybiB7XG4gICAgICAnbWQtZXhwYW5kJzogZnVuY3Rpb24gbWRFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblsnbWQtZXhwYW5kJ11bMF07XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZExpc3RJdGVtJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgY29tcG9uZW50czoge1xuICAgIE1kQnV0dG9uOiBfTWRCdXR0b24yLmRlZmF1bHRcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCwgX3JlZikge1xuICAgIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudCxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBsaXN0ZW5lcnMgPSBfcmVmLmxpc3RlbmVycyxcbiAgICAgICAgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgc2xvdHMgPSBfcmVmLnNsb3RzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gc2xvdHMoKTtcbiAgICB2YXIgbGlzdENvbXBvbmVudCA9IF9NZExpc3RJdGVtRGVmYXVsdDIuZGVmYXVsdDtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSAnbWQtbGlzdC1pdGVtJztcblxuICAgIGlmIChoYXNFeHBhbnNpb24ocHJvcHMpKSB7XG4gICAgICBsaXN0Q29tcG9uZW50ID0gX01kTGlzdEl0ZW1FeHBhbmQyLmRlZmF1bHQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgcGFyZW50LiRyb3V0ZXIgJiYgcHJvcHMudG8pIHtcbiAgICAgIGxpc3RDb21wb25lbnQgPSBfTWRMaXN0SXRlbVJvdXRlcjIuZGVmYXVsdDtcbiAgICAgIGxpc3RDb21wb25lbnQucHJvcHMgPSAoMCwgX01kUm91dGVyTGlua1Byb3BzMi5kZWZhdWx0KShwYXJlbnQsIHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmdcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIGxpc3RDb21wb25lbnQucHJvcHMuaHJlZjtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhyZWYpIHtcbiAgICAgIGxpc3RDb21wb25lbnQgPSBfTWRMaXN0SXRlbUxpbmsyLmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsaXN0ZW5lck5hbWVzID0gT2JqZWN0LmtleXMobGlzdGVuZXJzKTtcblxuICAgICAgbGlzdGVuZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAoX01kSW50ZXJhY3Rpb25FdmVudHMyLmRlZmF1bHQuaW5jbHVkZXMobGlzdGVuZXIpKSB7XG4gICAgICAgICAgbGlzdENvbXBvbmVudCA9IF9NZExpc3RJdGVtQnV0dG9uMi5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5zdGF0aWNDbGFzcykge1xuICAgICAgc3RhdGljQ2xhc3MgKz0gJyAnICsgZGF0YS5zdGF0aWNDbGFzcztcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnbGknLCBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgc3RhdGljQ2xhc3M6IHN0YXRpY0NsYXNzLFxuICAgICAgb246IGxpc3RlbmVyc1xuICAgIH0pLCBbY3JlYXRlRWxlbWVudChsaXN0Q29tcG9uZW50LCB7XG4gICAgICBwcm9wczogcHJvcHMsXG4gICAgICBzY29wZWRTbG90czogcmVzb2x2ZVNjb3BlZFNsb3QocHJvcHMsIGNoaWxkcmVuKSxcbiAgICAgIHN0YXRpY0NsYXNzOiAnbWQtbGlzdC1pdGVtLWNvbnRhaW5lciBtZC1idXR0b24tY2xlYW4nLFxuICAgICAgb246IGxpc3RlbmVyc1xuICAgIH0sIGNoaWxkcmVuLmRlZmF1bHQpXSk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtRGVmYXVsdC52dWVcbnZhciBNZExpc3RJdGVtRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgyKTtcbnZhciBNZExpc3RJdGVtRGVmYXVsdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZExpc3RJdGVtRGVmYXVsdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYjRlYWM4NjhcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbURlZmF1bHQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1saXN0LWl0ZW0tZGVmYXVsdFwiLCBvbjogeyBjbGljazogX3ZtLnRvZ2dsZUNvbnRyb2wgfSB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWxpc3QtaXRlbS1jb250ZW50XCIsXG4gICAgICAgIHsgYXR0cnM6IHsgXCJtZC1kaXNhYmxlZFwiOiBcIlwiIH0gfSxcbiAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAyXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0SXRlbV9NZExpc3RJdGVtRGVmYXVsdCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYjRlYWM4NjhcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1EZWZhdWx0LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRMaXN0SXRlbURlZmF1bHRfZGVmYXVsdC5hLFxuICBNZExpc3RJdGVtX01kTGlzdEl0ZW1EZWZhdWx0LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbURlZmF1bHQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYjRlYWM4NjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1iNGVhYzg2OFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0X01kTGlzdEl0ZW1fTWRMaXN0SXRlbURlZmF1bHQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbU1peGluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRMaXN0SXRlbURlZmF1bHQnLFxuICBtaXhpbnM6IFtfTWRMaXN0SXRlbU1peGluMi5kZWZhdWx0XSxcbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZUNvbnRyb2w6IGZ1bmN0aW9uIHRvZ2dsZUNvbnRyb2woKSB7XG4gICAgICB2YXIgY29udHJvbCA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5tZC1jaGVja2JveC1jb250YWluZXIsIC5tZC1zd2l0Y2gtY29udGFpbmVyLCAubWQtcmFkaW8tY29udGFpbmVyJyk7XG5cbiAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wuY2xpY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDI4MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUNvbnRlbnQudnVlXG52YXIgTWRMaXN0SXRlbUNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NCk7XG52YXIgTWRMaXN0SXRlbUNvbnRlbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRMaXN0SXRlbUNvbnRlbnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWFmMzdjM2Y4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1Db250ZW50LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLXJpcHBsZVwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWxpc3QtaXRlbS1jb250ZW50XCIsXG4gICAgICBhdHRyczogeyBcIm1kLWRpc2FibGVkXCI6IF92bS5tZERpc2FibGVkIH1cbiAgICB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0SXRlbV9NZExpc3RJdGVtQ29udGVudCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYWYzN2MzZjhcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1Db250ZW50LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRMaXN0SXRlbUNvbnRlbnRfZGVmYXVsdC5hLFxuICBNZExpc3RJdGVtX01kTGlzdEl0ZW1Db250ZW50LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUNvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYWYzN2MzZjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1hZjM3YzNmOFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0X01kTGlzdEl0ZW1fTWRMaXN0SXRlbUNvbnRlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFJpcHBsZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBfTWRSaXBwbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSaXBwbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZExpc3RJdGVtQ29udGVudCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZFJpcHBsZTogX01kUmlwcGxlMi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWREaXNhYmxlZDogQm9vbGVhblxuICB9XG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjg1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtQnV0dG9uLnZ1ZVxudmFyIE1kTGlzdEl0ZW1CdXR0b24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4Nik7XG52YXIgTWRMaXN0SXRlbUJ1dHRvbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZExpc3RJdGVtQnV0dG9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZDI3Y2ExMlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtQnV0dG9uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImJ1dHRvblwiLFxuICAgIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLWxpc3QtaXRlbS1idXR0b25cIixcbiAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIsIGRpc2FibGVkOiBfdm0uZGlzYWJsZWQgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwibWQtbGlzdC1pdGVtLWNvbnRlbnRcIixcbiAgICAgICAgeyBhdHRyczogeyBcIm1kLWRpc2FibGVkXCI6IF92bS5pc0Rpc2FibGVkIH0gfSxcbiAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAyXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0SXRlbV9NZExpc3RJdGVtQnV0dG9uID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi00ZDI3Y2ExMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUJ1dHRvbi52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kTGlzdEl0ZW1CdXR0b25fZGVmYXVsdC5hLFxuICBNZExpc3RJdGVtX01kTGlzdEl0ZW1CdXR0b24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtQnV0dG9uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTRkMjdjYTEyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNGQyN2NhMTJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTGlzdF9NZExpc3RJdGVtX01kTGlzdEl0ZW1CdXR0b24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbU1peGluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRMaXN0SXRlbUJ1dHRvbicsXG4gIG1peGluczogW19NZExpc3RJdGVtTWl4aW4yLmRlZmF1bHRdXG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAyODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1MaW5rLnZ1ZVxudmFyIE1kTGlzdEl0ZW1MaW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODgpO1xudmFyIE1kTGlzdEl0ZW1MaW5rX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kTGlzdEl0ZW1MaW5rKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00OWFjYjIwMlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtTGluay52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJhXCIsXG4gICAgX3ZtLl9iKHsgc3RhdGljQ2xhc3M6IFwibWQtbGlzdC1pdGVtLWxpbmtcIiB9LCBcImFcIiwgX3ZtLiRwcm9wcywgZmFsc2UpLFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWxpc3QtaXRlbS1jb250ZW50XCIsXG4gICAgICAgIHsgYXR0cnM6IHsgXCJtZC1kaXNhYmxlZFwiOiBfdm0uaXNEaXNhYmxlZCB9IH0sXG4gICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTGlzdEl0ZW1fTWRMaXN0SXRlbUxpbmsgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTQ5YWNiMjAyXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtTGluay52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kTGlzdEl0ZW1MaW5rX2RlZmF1bHQuYSxcbiAgTWRMaXN0SXRlbV9NZExpc3RJdGVtTGluayxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1MaW5rLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ5YWNiMjAyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDlhY2IyMDJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTGlzdF9NZExpc3RJdGVtX01kTGlzdEl0ZW1MaW5rID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjg4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRMaXN0SXRlbU1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfTWRMaXN0SXRlbU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTGlzdEl0ZW1NaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kTGlzdEl0ZW1MaW5rJyxcbiAgbWl4aW5zOiBbX01kTGlzdEl0ZW1NaXhpbjIuZGVmYXVsdF0sXG4gIHByb3BzOiB7XG4gICAgZG93bmxvYWQ6IFN0cmluZyxcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgaHJlZmxhbmc6IFN0cmluZyxcbiAgICBwaW5nOiBTdHJpbmcsXG4gICAgcmVsOiBTdHJpbmcsXG4gICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgdHlwZTogU3RyaW5nXG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDI4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbVJvdXRlci52dWVcbnZhciBNZExpc3RJdGVtUm91dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTApO1xudmFyIE1kTGlzdEl0ZW1Sb3V0ZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRMaXN0SXRlbVJvdXRlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDkxY2IwZTRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbVJvdXRlci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJyb3V0ZXItbGlua1wiLFxuICAgIF92bS5fYihcbiAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtbGlzdC1pdGVtLXJvdXRlclwiIH0sXG4gICAgICBcInJvdXRlci1saW5rXCIsXG4gICAgICBfdm0ucm91dGVyUHJvcHMsXG4gICAgICBmYWxzZVxuICAgICksXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwibWQtbGlzdC1pdGVtLWNvbnRlbnRcIixcbiAgICAgICAgeyBhdHRyczogeyBcIm1kLWRpc2FibGVkXCI6IF92bS5pc0Rpc2FibGVkIH0gfSxcbiAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAyXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRMaXN0SXRlbV9NZExpc3RJdGVtUm91dGVyID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wOTFjYjBlNFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbVJvdXRlci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kTGlzdEl0ZW1Sb3V0ZXJfZGVmYXVsdC5hLFxuICBNZExpc3RJdGVtX01kTGlzdEl0ZW1Sb3V0ZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZExpc3QvTWRMaXN0SXRlbS9NZExpc3RJdGVtUm91dGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTA5MWNiMGU0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDkxY2IwZTRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTGlzdF9NZExpc3RJdGVtX01kTGlzdEl0ZW1Sb3V0ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIF9NZExpc3RJdGVtTWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRMaXN0SXRlbU1peGluKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRMaXN0SXRlbVJvdXRlcicsXG4gIG1peGluczogW19NZExpc3RJdGVtTWl4aW4yLmRlZmF1bHRdLFxuICBjb21wdXRlZDoge1xuICAgIHJvdXRlclByb3BzOiBmdW5jdGlvbiByb3V0ZXJQcm9wcygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwcm9wcztcbiAgICB9XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDI5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUV4cGFuZC52dWVcbnZhciBNZExpc3RJdGVtRXhwYW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTMpO1xudmFyIE1kTGlzdEl0ZW1FeHBhbmRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRMaXN0SXRlbUV4cGFuZCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMzc4ZTQzNDJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUV4cGFuZC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLWxpc3QtaXRlbS1leHBhbmRcIiwgY2xhc3M6IF92bS5leHBhbmRDbGFzc2VzIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwibWQtbGlzdC1pdGVtLWNvbnRlbnRcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7IFwibWQtZGlzYWJsZWRcIjogX3ZtLmlzRGlzYWJsZWQgfSxcbiAgICAgICAgICBuYXRpdmVPbjoge1xuICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICBfdm0udG9nZ2xlRXhwYW5kKCRldmVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0uX3QoXCJkZWZhdWx0XCIpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJtZC1hcnJvdy1kb3duLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1saXN0LWV4cGFuZC1pY29uXCIgfSlcbiAgICAgICAgXSxcbiAgICAgICAgMlxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHJlZjogXCJsaXN0RXhwYW5kXCIsXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtbGlzdC1leHBhbmRcIixcbiAgICAgICAgICBzdHlsZTogX3ZtLmV4cGFuZFN0eWxlc1xuICAgICAgICB9LFxuICAgICAgICBbX3ZtLl90KFwibWQtZXhwYW5kXCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kTGlzdEl0ZW1fTWRMaXN0SXRlbUV4cGFuZCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzc4ZTQzNDJcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kTGlzdC9NZExpc3RJdGVtL01kTGlzdEl0ZW1FeHBhbmQudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygyOTIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZExpc3RJdGVtRXhwYW5kX2RlZmF1bHQuYSxcbiAgTWRMaXN0SXRlbV9NZExpc3RJdGVtRXhwYW5kLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRMaXN0L01kTGlzdEl0ZW0vTWRMaXN0SXRlbUV4cGFuZC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zNzhlNDM0MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM3OGU0MzQyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZExpc3RfTWRMaXN0SXRlbV9NZExpc3RJdGVtRXhwYW5kID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjkyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMjkzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcmFmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9yYWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFmKTtcblxudmFyIF9NZEFycm93RG93bkljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5NCk7XG5cbnZhciBfTWRBcnJvd0Rvd25JY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQXJyb3dEb3duSWNvbik7XG5cbnZhciBfTWRMaXN0SXRlbU1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfTWRMaXN0SXRlbU1peGluMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTGlzdEl0ZW1NaXhpbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZExpc3RJdGVtRXhwYW5kJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kQXJyb3dEb3duSWNvbjogX01kQXJyb3dEb3duSWNvbjIuZGVmYXVsdFxuICB9LFxuICBtaXhpbnM6IFtfTWRMaXN0SXRlbU1peGluMi5kZWZhdWx0XSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwYW5kU3R5bGVzOiB7fSxcbiAgICAgIHNob3dDb250ZW50OiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWRFeHBhbmRlZDogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGV4cGFuZENsYXNzZXM6IGZ1bmN0aW9uIGV4cGFuZENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtYWN0aXZlJzogdGhpcy5zaG93Q29udGVudFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRDaGlsZHJlblNpemU6IGZ1bmN0aW9uIGdldENoaWxkcmVuU2l6ZSgpIHtcbiAgICAgIHZhciBleHBhbmRFbCA9IHRoaXMuJHJlZnMubGlzdEV4cGFuZDtcbiAgICAgIHZhciBzaXplID0gMDtcblxuICAgICAgQXJyYXkuZnJvbShleHBhbmRFbC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2l6ZSArPSBjaGlsZC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfSxcbiAgICBmZXRjaFN0eWxlOiBmdW5jdGlvbiBmZXRjaFN0eWxlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICgwLCBfcmFmMi5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGZ1bGxIZWlnaHQgPSAwO1xuXG4gICAgICAgICAgaWYgKCFfdGhpcy5zaG93Q29udGVudCkge1xuICAgICAgICAgICAgZnVsbEhlaWdodCA9ICdhdXRvJzsgLy8gdGhpcy5nZXRDaGlsZHJlblNpemUoKSArICdweCdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5leHBhbmRTdHlsZXMgPSB7IGhlaWdodDogZnVsbEhlaWdodCB9O1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHRvZ2dsZUV4cGFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFN0eWxlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSAhdGhpcy5zaG93Q29udGVudDtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB0b2dnbGVFeHBhbmQoKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2dnbGVFeHBhbmQ7XG4gICAgfSgpLFxuICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3dDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hTdHlsZSgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDb250ZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3BlbjtcbiAgICB9KCksXG4gICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaFN0eWxlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRlbnQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMywgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3NlO1xuICAgIH0oKVxuICB9LFxuICB3YXRjaDoge1xuICAgIG1kRXhwYW5kZWQ6IGZ1bmN0aW9uIG1kRXhwYW5kZWQoKSB7XG4gICAgICBpZiAodGhpcy5tZEV4cGFuZGVkKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd0NvbnRlbnQ6IGZ1bmN0aW9uIHNob3dDb250ZW50KCkge1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1kRXhwYW5kZWQnLCB0aGlzLnNob3dDb250ZW50KTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMubWRFeHBhbmRlZCkge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWRBcnJvd0Rvd25JY29uLnZ1ZVxudmFyIE1kQXJyb3dEb3duSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjk1KTtcbnZhciBNZEFycm93RG93bkljb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRBcnJvd0Rvd25JY29uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yNDQzZGUyMVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29yZS9pY29ucy9NZEFycm93RG93bkljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7XG4gICAgICAgICAgICBhdHRyczogeyBkOiBcIk03LjQxIDcuODRMMTIgMTIuNDJsNC41OS00LjU4TDE4IDkuMjVsLTYgNi02LTZ6XCIgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHsgYXR0cnM6IHsgZDogXCJNMC0uNzVoMjR2MjRIMHpcIiwgZmlsbDogXCJub25lXCIgfSB9KVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaWNvbnNfTWRBcnJvd0Rvd25JY29uID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0yNDQzZGUyMVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaWNvbnMvTWRBcnJvd0Rvd25JY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRBcnJvd0Rvd25JY29uX2RlZmF1bHQuYSxcbiAgaWNvbnNfTWRBcnJvd0Rvd25JY29uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvcmUvaWNvbnMvTWRBcnJvd0Rvd25JY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTI0NDNkZTIxXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMjQ0M2RlMjFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRBcnJvd0Rvd25JY29uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMjk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9NZEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRBcnJvd0Rvd25JY29uJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kSWNvbjogX01kSWNvbjIuZGVmYXVsdFxuICB9XG59OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMjk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZE1lbnUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblxudmFyIF9NZE1lbnUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRNZW51KTtcblxudmFyIF9NZE1lbnVDb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cbnZhciBfTWRNZW51Q29udGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZE1lbnVDb250ZW50KTtcblxudmFyIF9NZE1lbnVJdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOTcpO1xuXG52YXIgX01kTWVudUl0ZW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRNZW51SXRlbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRNZW51Mi5kZWZhdWx0Lm5hbWUsIF9NZE1lbnUyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZE1lbnVDb250ZW50Mi5kZWZhdWx0Lm5hbWUsIF9NZE1lbnVDb250ZW50Mi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRNZW51SXRlbTIuZGVmYXVsdC5uYW1lLCBfTWRNZW51SXRlbTIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRNZW51L01kTWVudUl0ZW0udnVlXG52YXIgTWRNZW51SXRlbSA9IF9fd2VicGFja19yZXF1aXJlX18oMjk4KTtcbnZhciBNZE1lbnVJdGVtX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kTWVudUl0ZW0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTI2NzYyNzAyXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kTWVudS9NZE1lbnVJdGVtLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLWxpc3QtaXRlbVwiLFxuICAgIF92bS5fZyhcbiAgICAgIF92bS5fYihcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLW1lbnUtaXRlbVwiLFxuICAgICAgICAgIGNsYXNzOiBbX3ZtLml0ZW1DbGFzc2VzLCBfdm0uJG1kQWN0aXZlVGhlbWVdLFxuICAgICAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsIHRhYmluZGV4OiBfdm0uaGlnaGxpZ2h0ZWQgJiYgLTEgfVxuICAgICAgICB9LFxuICAgICAgICBcIm1kLWxpc3QtaXRlbVwiLFxuICAgICAgICBfdm0uJGF0dHJzLFxuICAgICAgICBmYWxzZVxuICAgICAgKSxcbiAgICAgIF92bS5saXN0ZW5lcnNcbiAgICApLFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRNZW51X01kTWVudUl0ZW0gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTI2NzYyNzAyXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZE1lbnUvTWRNZW51SXRlbS52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBudWxsXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kTWVudUl0ZW1fZGVmYXVsdC5hLFxuICBNZE1lbnVfTWRNZW51SXRlbSxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kTWVudS9NZE1lbnVJdGVtLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTI2NzYyNzAyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMjY3NjI3MDJcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRNZW51X01kTWVudUl0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAyOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kSW50ZXJhY3Rpb25FdmVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcblxudmFyIF9NZEludGVyYWN0aW9uRXZlbnRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSW50ZXJhY3Rpb25FdmVudHMpO1xuXG52YXIgX01kTGlzdEl0ZW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KTtcblxudmFyIF9NZExpc3RJdGVtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kTGlzdEl0ZW0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kTWVudUl0ZW0nLFxuICBwcm9wczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDogWydNZE1lbnUnXSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlzdGVuZXJzOiB7fSxcbiAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbUNsYXNzZXM6IGZ1bmN0aW9uIGl0ZW1DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLWhpZ2hsaWdodCc6IHRoaXMuaGlnaGxpZ2h0ZWRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5NZE1lbnUuY2xvc2VPblNlbGVjdCkge1xuICAgICAgdmFyIGxpc3RlbmVyTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLiRsaXN0ZW5lcnMpO1xuICAgICAgdmFyIGhhc0ludGVyYWN0aW9uID0gZmFsc2U7XG5cbiAgICAgIGxpc3RlbmVyTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKF9NZEludGVyYWN0aW9uRXZlbnRzMi5kZWZhdWx0LmluY2x1ZGVzKGxpc3RlbmVyKSkge1xuICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1tsaXN0ZW5lcl0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzLiRsaXN0ZW5lcnNbbGlzdGVuZXJdKCRldmVudCk7XG4gICAgICAgICAgICAgIF90aGlzLk1kTWVudS5hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXMuTWRNZW51LmV2ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5NZE1lbnUuZXZlbnRPYnNlcnZlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1tsaXN0ZW5lcl0gPSBfdGhpcy4kbGlzdGVuZXJzW2xpc3RlbmVyXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gdGhpcy4kbGlzdGVuZXJzO1xuICAgIH1cbiAgfVxufSk7IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAyOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kUHJvZ3Jlc3NCYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMCk7XG5cbnZhciBfTWRQcm9ncmVzc0JhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb2dyZXNzQmFyKTtcblxudmFyIF9NZFByb2dyZXNzU3Bpbm5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMzAzKTtcblxudmFyIF9NZFByb2dyZXNzU3Bpbm5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb2dyZXNzU3Bpbm5lcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRQcm9ncmVzc0JhcjIuZGVmYXVsdC5uYW1lLCBfTWRQcm9ncmVzc0JhcjIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kUHJvZ3Jlc3NTcGlubmVyMi5kZWZhdWx0Lm5hbWUsIF9NZFByb2dyZXNzU3Bpbm5lcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRQcm9ncmVzcy9NZFByb2dyZXNzQmFyL01kUHJvZ3Jlc3NCYXIudnVlXG52YXIgTWRQcm9ncmVzc0JhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzAyKTtcbnZhciBNZFByb2dyZXNzQmFyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kUHJvZ3Jlc3NCYXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWVjODJlNzU4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kUHJvZ3Jlc3MvTWRQcm9ncmVzc0Jhci9NZFByb2dyZXNzQmFyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcInRyYW5zaXRpb25cIiwgeyBhdHRyczogeyBuYW1lOiBcIm1kLXByb2dyZXNzLWJhclwiLCBhcHBlYXI6IFwiXCIgfSB9LCBbXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1wcm9ncmVzcy1iYXJcIixcbiAgICAgICAgY2xhc3M6IFtfdm0ucHJvZ3Jlc3NDbGFzc2VzLCBfdm0uJG1kQWN0aXZlVGhlbWVdXG4gICAgICB9LFxuICAgICAgW1xuICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtcHJvZ3Jlc3MtYmFyLXRyYWNrXCIsXG4gICAgICAgICAgc3R5bGU6IF92bS5wcm9ncmVzc1RyYWNrU3R5bGVcbiAgICAgICAgfSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1wcm9ncmVzcy1iYXItZmlsbFwiLFxuICAgICAgICAgIHN0eWxlOiBfdm0ucHJvZ3Jlc3NWYWx1ZVN0eWxlXG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlclwiLFxuICAgICAgICAgIGF0dHJzOiB7IFN0eWxlOiBfdm0ucHJvZ3Jlc3NCdWZmZXJTdHlsZSB9XG4gICAgICAgIH0pXG4gICAgICBdXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFByb2dyZXNzQmFyX01kUHJvZ3Jlc3NCYXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWVjODJlNzU4XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFByb2dyZXNzL01kUHJvZ3Jlc3NCYXIvTWRQcm9ncmVzc0Jhci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kUHJvZ3Jlc3NCYXJfZGVmYXVsdC5hLFxuICBNZFByb2dyZXNzQmFyX01kUHJvZ3Jlc3NCYXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFByb2dyZXNzL01kUHJvZ3Jlc3NCYXIvTWRQcm9ncmVzc0Jhci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1lYzgyZTc1OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWVjODJlNzU4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFByb2dyZXNzX01kUHJvZ3Jlc3NCYXJfTWRQcm9ncmVzc0JhciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDMwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDMwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFByb2dyZXNzQmFyJyxcbiAgcHJvcHM6IHtcbiAgICBtZFZhbHVlOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBtZEJ1ZmZlcjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH0sXG4gICAgbWRNb2RlOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGV0ZXJtaW5hdGUnXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1tb2RlJywgWydkZXRlcm1pbmF0ZScsICdpbmRldGVybWluYXRlJywgJ3F1ZXJ5JywgJ2J1ZmZlciddKSlcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc0RldGVybWluYXRlOiBmdW5jdGlvbiBpc0RldGVybWluYXRlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRNb2RlID09PSAnZGV0ZXJtaW5hdGUnO1xuICAgIH0sXG4gICAgaXNCdWZmZXI6IGZ1bmN0aW9uIGlzQnVmZmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRNb2RlID09PSAnYnVmZmVyJztcbiAgICB9LFxuICAgIGhhc0Ftb3VudEZpbGw6IGZ1bmN0aW9uIGhhc0Ftb3VudEZpbGwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0J1ZmZlciB8fCB0aGlzLmlzRGV0ZXJtaW5hdGU7XG4gICAgfSxcbiAgICBwcm9ncmVzc0NsYXNzZXM6IGZ1bmN0aW9uIHByb2dyZXNzQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiAnbWQtJyArIHRoaXMubWRNb2RlO1xuICAgIH0sXG4gICAgcHJvZ3Jlc3NWYWx1ZVN0eWxlOiBmdW5jdGlvbiBwcm9ncmVzc1ZhbHVlU3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5oYXNBbW91bnRGaWxsKSB7XG4gICAgICAgIHJldHVybiAnd2lkdGg6ICcgKyB0aGlzLm1kVmFsdWUgKyAnJSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9ncmVzc1RyYWNrU3R5bGU6IGZ1bmN0aW9uIHByb2dyZXNzVHJhY2tTdHlsZSgpIHtcbiAgICAgIGlmICh0aGlzLmhhc0Ftb3VudEZpbGwpIHtcbiAgICAgICAgcmV0dXJuICd3aWR0aDogJyArIHRoaXMubWRCdWZmZXIgKyAnJSc7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9ncmVzc0J1ZmZlclN0eWxlOiBmdW5jdGlvbiBwcm9ncmVzc0J1ZmZlclN0eWxlKCkge1xuICAgICAgaWYgKHRoaXMuaGFzQW1vdW50RmlsbCkge1xuICAgICAgICByZXR1cm4gJ2xlZnQ6IGNhbGMoJyArIHRoaXMubWRCdWZmZXIgKyAnJSArIDhweCknO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMzAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFByb2dyZXNzL01kUHJvZ3Jlc3NTcGlubmVyL01kUHJvZ3Jlc3NTcGlubmVyLnZ1ZVxudmFyIE1kUHJvZ3Jlc3NTcGlubmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDUpO1xudmFyIE1kUHJvZ3Jlc3NTcGlubmVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kUHJvZ3Jlc3NTcGlubmVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wYWJmMTNlMFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFByb2dyZXNzL01kUHJvZ3Jlc3NTcGlubmVyL01kUHJvZ3Jlc3NTcGlubmVyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInRyYW5zaXRpb25cIixcbiAgICB7IGF0dHJzOiB7IG5hbWU6IFwibWQtcHJvZ3Jlc3Mtc3Bpbm5lclwiLCBhcHBlYXI6IFwiXCIgfSB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtcHJvZ3Jlc3Mtc3Bpbm5lclwiLFxuICAgICAgICAgIGNsYXNzOiBbX3ZtLnByb2dyZXNzQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcInN2Z1wiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1wcm9ncmVzcy1zcGlubmVyLWRyYXdcIixcbiAgICAgICAgICAgICAgc3R5bGU6IF92bS5zdmdTdHlsZXMsXG4gICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZCBtZWV0XCIsXG4gICAgICAgICAgICAgICAgZm9jdXNhYmxlOiBcImZhbHNlXCIsXG4gICAgICAgICAgICAgICAgdmlld0JveDogXCIwIDAgXCIgKyBfdm0ubWREaWFtZXRlciArIFwiIFwiICsgX3ZtLm1kRGlhbWV0ZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJjaXJjbGVcIiwge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXByb2dyZXNzLXNwaW5uZXItY2lyY2xlXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IF92bS5jaXJjbGVTdHlsZXMsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgY3g6IFwiNTAlXCIsIGN5OiBcIjUwJVwiLCByOiBfdm0uY2lyY2xlUmFkaXVzIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRQcm9ncmVzc1NwaW5uZXJfTWRQcm9ncmVzc1NwaW5uZXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTBhYmYxM2UwXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFByb2dyZXNzL01kUHJvZ3Jlc3NTcGlubmVyL01kUHJvZ3Jlc3NTcGlubmVyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzA0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRQcm9ncmVzc1NwaW5uZXJfZGVmYXVsdC5hLFxuICBNZFByb2dyZXNzU3Bpbm5lcl9NZFByb2dyZXNzU3Bpbm5lcixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kUHJvZ3Jlc3MvTWRQcm9ncmVzc1NwaW5uZXIvTWRQcm9ncmVzc1NwaW5uZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMGFiZjEzZTBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0wYWJmMTNlMFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRQcm9ncmVzc19NZFByb2dyZXNzU3Bpbm5lcl9NZFByb2dyZXNzU3Bpbm5lciA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDMwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDMwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb3BWYWxpZGF0b3IpO1xuXG52YXIgX01kUHJvZ3Jlc3NTcGlubmVyQW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDYpO1xuXG52YXIgX01kUHJvZ3Jlc3NTcGlubmVyQW5pbWF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvZ3Jlc3NTcGlubmVyQW5pbWF0aW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIE1kUHJvZ3Jlc3NTcGlubmVyID0ge1xuICBzdHlsZVRhZzogbnVsbCxcbiAgZGlhbWV0ZXJzOiBuZXcgU2V0KClcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBfTWRDb21wb25lbnQyLmRlZmF1bHQoe1xuICBuYW1lOiAnTWRQcm9ncmVzc1NwaW5uZXInLFxuICBwcm9wczoge1xuICAgIG1kVmFsdWU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG1kRGlhbWV0ZXI6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDYwXG4gICAgfSxcbiAgICBtZFN0cm9rZToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH0sXG4gICAgbWRNb2RlOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGV0ZXJtaW5hdGUnXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1tb2RlJywgWydkZXRlcm1pbmF0ZScsICdpbmRldGVybWluYXRlJ10pKVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRGV0ZXJtaW5hdGU6IGZ1bmN0aW9uIGlzRGV0ZXJtaW5hdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZE1vZGUgPT09ICdkZXRlcm1pbmF0ZSc7XG4gICAgfSxcbiAgICBpc0luZGV0ZXJtaW5hdGU6IGZ1bmN0aW9uIGlzSW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kTW9kZSA9PT0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgIH0sXG4gICAgaXNJRTogZnVuY3Rpb24gaXNJRSgpIHtcbiAgICAgIGlmICghdGhpcy4kaXNTZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygndHJpZGVudCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcHJvZ3Jlc3NDbGFzc2VzOiBmdW5jdGlvbiBwcm9ncmVzc0NsYXNzZXMoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgdmFyIGFuaW1hdGlvbkNsYXNzID0gJ21kLXByb2dyZXNzLXNwaW5uZXItaW5kZXRlcm1pbmF0ZSc7XG5cbiAgICAgIGlmICh0aGlzLmlzSUUpIHtcbiAgICAgICAgYW5pbWF0aW9uQ2xhc3MgKz0gJy1mYWxsYmFjayc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCBhbmltYXRpb25DbGFzcywgdHJ1ZSksIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnbWQtJyArIHRoaXMubWRNb2RlLCB0cnVlKSwgX3JlZjtcbiAgICB9LFxuICAgIHN2Z1N0eWxlczogZnVuY3Rpb24gc3ZnU3R5bGVzKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLm1kRGlhbWV0ZXIgKyAncHgnO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2lyY2xlU3R5bGVzOiBmdW5jdGlvbiBjaXJjbGVTdHlsZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiB0aGlzLmNpcmNsZVN0cm9rZURhc2hPZmZzZXQsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogdGhpcy5jaXJjbGVTdHJva2VEYXNoQXJyYXksXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiB0aGlzLmNpcmNsZVN0cm9rZVdpZHRoLFxuICAgICAgICAnYW5pbWF0aW9uLW5hbWUnOiAnbWQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHJva2Utcm90YXRlLScgKyB0aGlzLm1kRGlhbWV0ZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBjaXJjbGVSYWRpdXM6IGZ1bmN0aW9uIGNpcmNsZVJhZGl1cygpIHtcbiAgICAgIHJldHVybiAodGhpcy5tZERpYW1ldGVyIC0gdGhpcy5tZFN0cm9rZSkgLyAyO1xuICAgIH0sXG4gICAgY2lyY2xlU3Ryb2tlV2lkdGg6IGZ1bmN0aW9uIGNpcmNsZVN0cm9rZVdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRTdHJva2UgKyAncHgnO1xuICAgIH0sXG4gICAgY2lyY2xlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24gY2lyY2xlQ2lyY3VtZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiAyICogTWF0aC5QSSAqIHRoaXMuY2lyY2xlUmFkaXVzO1xuICAgIH0sXG4gICAgY2lyY2xlU3Ryb2tlRGFzaEFycmF5OiBmdW5jdGlvbiBjaXJjbGVTdHJva2VEYXNoQXJyYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaXJjbGVDaXJjdW1mZXJlbmNlICsgJ3B4JztcbiAgICB9LFxuICAgIGNpcmNsZVN0cm9rZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIGNpcmNsZVN0cm9rZURhc2hPZmZzZXQoKSB7XG4gICAgICBpZiAodGhpcy5pc0RldGVybWluYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNpcmNsZUNpcmN1bWZlcmVuY2UgKiAoMTAwIC0gdGhpcy5tZFZhbHVlKSAvIDEwMCArICdweCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzSW5kZXRlcm1pbmF0ZSAmJiB0aGlzLmlzSUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2lyY2xlQ2lyY3VtZmVyZW5jZSAqIDAuMiArICdweCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZERpYW1ldGVyOiBmdW5jdGlvbiBtZERpYW1ldGVyKCkge1xuICAgICAgdGhpcy5hdHRhY2hTdHlsZVRhZygpO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldEFuaW1hdGlvbkNTUzogZnVuY3Rpb24gZ2V0QW5pbWF0aW9uQ1NTKCkge1xuICAgICAgcmV0dXJuIF9NZFByb2dyZXNzU3Bpbm5lckFuaW1hdGlvbjIuZGVmYXVsdC5yZXBsYWNlKC9TVEFSVF9WQUxVRS9nLCAnJyArIDAuOTUgKiB0aGlzLmNpcmNsZUNpcmN1bWZlcmVuY2UpLnJlcGxhY2UoL0VORF9WQUxVRS9nLCAnJyArIDAuMiAqIHRoaXMuY2lyY2xlQ2lyY3VtZmVyZW5jZSkucmVwbGFjZSgvRElBTUVURVIvZywgJycgKyB0aGlzLm1kRGlhbWV0ZXIpO1xuICAgIH0sXG4gICAgYXR0YWNoU3R5bGVUYWc6IGZ1bmN0aW9uIGF0dGFjaFN0eWxlVGFnKCkge1xuICAgICAgdmFyIHN0eWxlVGFnID0gTWRQcm9ncmVzc1NwaW5uZXIuc3R5bGVUYWc7XG5cbiAgICAgIGlmICghc3R5bGVUYWcpIHtcbiAgICAgICAgc3R5bGVUYWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHlsZXMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHlsZVRhZykge1xuICAgICAgICBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgc3R5bGVUYWcuaWQgPSAnbWQtcHJvZ3Jlc3Mtc3Bpbm5lci1zdHlsZXMnO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcbiAgICAgICAgTWRQcm9ncmVzc1NwaW5uZXIuc3R5bGVUYWcgPSBzdHlsZVRhZztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlVGFnICYmIHN0eWxlVGFnLnNoZWV0KSB7XG4gICAgICAgIHN0eWxlVGFnLnNoZWV0Lmluc2VydFJ1bGUodGhpcy5nZXRBbmltYXRpb25DU1MoKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIE1kUHJvZ3Jlc3NTcGlubmVyLmRpYW1ldGVycy5hZGQodGhpcy5tZERpYW1ldGVyKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5hdHRhY2hTdHlsZVRhZygpO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFwiXFxuICBAa2V5ZnJhbWVzIG1kLXByb2dyZXNzLXNwaW5uZXItc3Ryb2tlLXJvdGF0ZS1ESUFNRVRFUiB7XFxuICAgIDAlIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMCk7XFxuICAgIH1cXG5cXG4gICAgMTIuNSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMCk7XFxuICAgIH1cXG5cXG4gICAgMTIuNTElIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFO1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSg3Mi41ZGVnKTtcXG4gICAgfVxcblxcbiAgICAyNSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoNzIuNWRlZyk7XFxuICAgIH1cXG5cXG4gICAgMjUuMSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpO1xcbiAgICB9XFxuXFxuICAgIDM3LjUlIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFO1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDI3MGRlZyk7XFxuICAgIH1cXG5cXG4gICAgMzcuNTElIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFO1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgxNjEuNWRlZyk7XFxuICAgIH1cXG5cXG4gICAgNTAlIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDE2MS41ZGVnKTtcXG4gICAgfVxcblxcbiAgICA1MC4wMSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSgxODBkZWcpO1xcbiAgICB9XFxuXFxuICAgIDYyLjUlIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFO1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlKDE4MGRlZyk7XFxuICAgIH1cXG5cXG4gICAgNjIuNTElIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogRU5EX1ZBTFVFO1xcbiAgICAgIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpIHJvdGF0ZSgyNTEuNWRlZyk7XFxuICAgIH1cXG5cXG4gICAgNzUlIHtcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogU1RBUlRfVkFMVUU7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZykgcm90YXRlKDI1MS41ZGVnKTtcXG4gICAgfVxcblxcbiAgICA3NS4wMSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZSg5MGRlZyk7XFxuICAgIH1cXG5cXG4gICAgODcuNSUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBFTkRfVkFMVUU7XFxuICAgICAgdHJhbnNmb3JtOiByb3RhdGUoOTBkZWcpO1xcbiAgICB9XFxuXFxuICAgIDg3LjUxJSB7XFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6IEVORF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpO1xcbiAgICB9XFxuXFxuICAgIDEwMCUge1xcbiAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiBTVEFSVF9WQUxVRTtcXG4gICAgICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKSByb3RhdGUoMzQxLjVkZWcpO1xcbiAgICB9XFxuICB9XFxuXCI7XG5cbi8qKiovIH0pLFxuLyogMzA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFJhZGlvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDgpO1xuXG52YXIgX01kUmFkaW8yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRSYWRpbyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRSYWRpbzIuZGVmYXVsdC5uYW1lLCBfTWRSYWRpbzIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRSYWRpby9NZFJhZGlvLnZ1ZVxudmFyIE1kUmFkaW8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMCk7XG52YXIgTWRSYWRpb19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFJhZGlvKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1iNWI5MDBjZVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFJhZGlvL01kUmFkaW8udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1yYWRpb1wiLCBjbGFzczogW192bS4kbWRBY3RpdmVUaGVtZSwgX3ZtLnJhZGlvQ2xhc3Nlc10gfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXJhZGlvLWNvbnRhaW5lclwiLFxuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICBfdm0udG9nZ2xlQ2hlY2soJGV2ZW50KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJtZC1yaXBwbGVcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICBcIm1kLWNlbnRlcmVkXCI6IFwiXCIsXG4gICAgICAgICAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnJpcHBsZUFjdGl2ZSxcbiAgICAgICAgICAgICAgICBcIm1kLWRpc2FibGVkXCI6IF92bS5kaXNhYmxlZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIFwidXBkYXRlOm1kQWN0aXZlXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLnJpcHBsZUFjdGl2ZSA9ICRldmVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAgICAgIHsgYXR0cnM6IHsgdHlwZTogXCJyYWRpb1wiIH0gfSxcbiAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IF92bS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX3ZtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBfdm0ucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0udmFsdWVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgIClcbiAgICAgICAgXSxcbiAgICAgICAgMVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uJHNsb3RzLmRlZmF1bHRcbiAgICAgICAgPyBfYyhcbiAgICAgICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtcmFkaW8tbGFiZWxcIixcbiAgICAgICAgICAgICAgYXR0cnM6IHsgZm9yOiBfdm0uaWQgfSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgX3ZtLnRvZ2dsZUNoZWNrKCRldmVudClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kUmFkaW9fTWRSYWRpbyA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtYjViOTAwY2VcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kUmFkaW8vTWRSYWRpby52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwOSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kUmFkaW9fZGVmYXVsdC5hLFxuICBNZFJhZGlvX01kUmFkaW8sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFJhZGlvL01kUmFkaW8udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYjViOTAwY2VcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1iNWI5MDBjZVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZFJhZGlvX01kUmFkaW8gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kVXVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBfTWRVdWlkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVXVpZCk7XG5cbnZhciBfTWRSaXBwbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgX01kUmlwcGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUmlwcGxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFJhZGlvJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kUmlwcGxlOiBfTWRSaXBwbGUyLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtb2RlbDogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuXSxcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyLCBCb29sZWFuXSxcbiAgICAgIGRlZmF1bHQ6ICdvbidcbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdtZC1yYWRpby0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ21vZGVsJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmlwcGxlQWN0aXZlOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNTZWxlY3RlZDogZnVuY3Rpb24gaXNTZWxlY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsID09PSB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgcmFkaW9DbGFzc2VzOiBmdW5jdGlvbiByYWRpb0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtY2hlY2tlZCc6IHRoaXMuaXNTZWxlY3RlZCxcbiAgICAgICAgJ21kLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgJ21kLXJlcXVpcmVkJzogdGhpcy5yZXF1aXJlZFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICB0b2dnbGVDaGVjazogZnVuY3Rpb24gdG9nZ2xlQ2hlY2soKSB7XG4gICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yaXBwbGVBY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kUmlwcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIF9NZFJpcHBsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFJpcHBsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRSaXBwbGUyLmRlZmF1bHQubmFtZSwgX01kUmlwcGxlMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFNuYWNrYmFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTMpO1xuXG52YXIgX01kU25hY2tiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTbmFja2Jhcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRTbmFja2JhcjIuZGVmYXVsdC5uYW1lLCBfTWRTbmFja2JhcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTbmFja2Jhci9NZFNuYWNrYmFyLnZ1ZVxudmFyIE1kU25hY2tiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNSk7XG52YXIgTWRTbmFja2Jhcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFNuYWNrYmFyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03MDYzYmM4ZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFNuYWNrYmFyL01kU25hY2tiYXIudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5tZFBlcnNpc3RlbnQgJiYgX3ZtLm1kRHVyYXRpb24gIT09IEluZmluaXR5XG4gICAgPyBfYyhcbiAgICAgICAgXCJtZC1wb3J0YWxcIixcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJrZWVwLWFsaXZlXCIsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF92bS5tZEFjdGl2ZVxuICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgIFwibWQtc25hY2tiYXItY29udGVudFwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtY2xhc3Nlc1wiOiBbX3ZtLnNuYWNrYmFyQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApXG4gICAgICAgIF0sXG4gICAgICAgIDFcbiAgICAgIClcbiAgICA6IF9jKFxuICAgICAgICBcIm1kLXBvcnRhbFwiLFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLm1kQWN0aXZlXG4gICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgIFwibWQtc25hY2tiYXItY29udGVudFwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWQtY2xhc3Nlc1wiOiBbX3ZtLnNuYWNrYmFyQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kU25hY2tiYXJfTWRTbmFja2JhciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNzA2M2JjOGZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kU25hY2tiYXIvTWRTbmFja2Jhci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kU25hY2tiYXJfZGVmYXVsdC5hLFxuICBNZFNuYWNrYmFyX01kU25hY2tiYXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFNuYWNrYmFyL01kU25hY2tiYXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNzA2M2JjOGZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03MDYzYmM4ZlwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZFNuYWNrYmFyX01kU25hY2tiYXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbnZhciBfTWRQb3J0YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9NZFBvcnRhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFBvcnRhbCk7XG5cbnZhciBfTWRTbmFja2JhckNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNik7XG5cbnZhciBfTWRTbmFja2JhckNvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTbmFja2JhckNvbnRlbnQpO1xuXG52YXIgX01kU25hY2tiYXJRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzE4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFNuYWNrYmFyJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kUG9ydGFsOiBfTWRQb3J0YWwyLmRlZmF1bHQsXG4gICAgTWRTbmFja2JhckNvbnRlbnQ6IF9NZFNuYWNrYmFyQ29udGVudDIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kQWN0aXZlOiBCb29sZWFuLFxuICAgIG1kUGVyc2lzdGVudDogQm9vbGVhbixcbiAgICBtZER1cmF0aW9uOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiA0MDAwXG4gICAgfSxcbiAgICBtZFBvc2l0aW9uOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnY2VudGVyJ1xuICAgIH0sICgwLCBfTWRQcm9wVmFsaWRhdG9yMi5kZWZhdWx0KSgnbWQtcG9zaXRpb24nLCBbJ2NlbnRlcicsICdsZWZ0J10pKVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNuYWNrYmFyQ2xhc3NlczogZnVuY3Rpb24gc25hY2tiYXJDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgJ21kLXBvc2l0aW9uLScgKyB0aGlzLm1kUG9zaXRpb24sIHRydWUpO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZEFjdGl2ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX01kU25hY2tiYXJRdWV1ZS5jcmVhdGVTbmFja2JhcikodGhpcy5tZER1cmF0aW9uLCB0aGlzKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWRBY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnbWQtb3BlbmVkJyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICgwLCBfTWRTbmFja2JhclF1ZXVlLmRlc3Ryb3lTbmFja2JhcikoKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdtZC1jbG9zZWQnKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBtZEFjdGl2ZShfeCkge1xuICAgICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1kQWN0aXZlO1xuICAgIH0oKVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kU25hY2tiYXIvTWRTbmFja2JhckNvbnRlbnQudnVlXG52YXIgTWRTbmFja2JhckNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxNyk7XG52YXIgTWRTbmFja2JhckNvbnRlbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRTbmFja2JhckNvbnRlbnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWZmZTA2NmNjXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOntcInN0cmlwV2l0aEZ1bmN0aW9uYWxcIjp0cnVlfX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFNuYWNrYmFyL01kU25hY2tiYXJDb250ZW50LnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKF9oLCBfdm0pIHtcbiAgdmFyIF9jID0gX3ZtLl9jXG4gIHJldHVybiBfYyhcInRyYW5zaXRpb25cIiwgeyBhdHRyczogeyBuYW1lOiBcIm1kLXNuYWNrYmFyXCIsIGFwcGVhcjogXCJcIiB9IH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLXNuYWNrYmFyXCIsIGNsYXNzOiBfdm0ucHJvcHMubWRDbGFzc2VzIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtc25hY2tiYXItY29udGVudFwiIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbiAgICBdKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFNuYWNrYmFyX01kU25hY2tiYXJDb250ZW50ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1mZmUwNjZjY1wiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRTbmFja2Jhci9NZFNuYWNrYmFyQ29udGVudC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSB0cnVlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTbmFja2JhckNvbnRlbnRfZGVmYXVsdC5hLFxuICBNZFNuYWNrYmFyX01kU25hY2tiYXJDb250ZW50LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRTbmFja2Jhci9NZFNuYWNrYmFyQ29udGVudC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1mZmUwNjZjY1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVyZW5kZXIoXCJkYXRhLXYtZmZlMDY2Y2NcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTbmFja2Jhcl9NZFNuYWNrYmFyQ29udGVudCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDMxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTbmFja2JhckNvbnRlbnQnLFxuICBwcm9wczoge1xuICAgIG1kQ2xhc3NlczogQXJyYXlcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxudmFyIGN1cnJlbnRTbmFja2JhciA9IG51bGw7XG52YXIgdGltZW91dCA9IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb21pc2UoZHVyYXRpb24sIGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgY3VycmVudFNuYWNrYmFyID0ge1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY3VycmVudFNuYWNrYmFyID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZHVyYXRpb24gIT09IEluZmluaXR5KSB7XG4gICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkZXN0cm95U25hY2tiYXIoKTtcbiAgICAgICAgY29udGV4dC5fdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuaW5pdERlc3Ryb3kodHJ1ZSk7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRlc3Ryb3lTbmFja2JhciA9IGV4cG9ydHMuZGVzdHJveVNuYWNrYmFyID0gZnVuY3Rpb24gZGVzdHJveVNuYWNrYmFyKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc29sdmUpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTbmFja2Jhcikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFNuYWNrYmFyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCA0MDApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB1bmRlZmluZWQpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoX3gpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpKTtcbn07XG5cbnZhciBjcmVhdGVTbmFja2JhciA9IGV4cG9ydHMuY3JlYXRlU25hY2tiYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoZHVyYXRpb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U25hY2tiYXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3lTbmFja2JhcigpO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgY3JlYXRlUHJvbWlzZShkdXJhdGlvbiwgY29udGV4dCkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgY3JlYXRlUHJvbWlzZShkdXJhdGlvbiwgY29udGV4dCkpO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIsIHVuZGVmaW5lZCk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU25hY2tiYXIoX3gyLCBfeDMpIHtcbiAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAzMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kU3BlZWREaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjApO1xuXG52YXIgX01kU3BlZWREaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kU3BlZWREaWFsKTtcblxudmFyIF9NZFNwZWVkRGlhbFRhcmdldCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIzKTtcblxudmFyIF9NZFNwZWVkRGlhbFRhcmdldDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFNwZWVkRGlhbFRhcmdldCk7XG5cbnZhciBfTWRTcGVlZERpYWxDb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjYpO1xuXG52YXIgX01kU3BlZWREaWFsQ29udGVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFNwZWVkRGlhbENvbnRlbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU3BlZWREaWFsMi5kZWZhdWx0Lm5hbWUsIF9NZFNwZWVkRGlhbDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU3BlZWREaWFsVGFyZ2V0Mi5kZWZhdWx0Lm5hbWUsIF9NZFNwZWVkRGlhbFRhcmdldDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU3BlZWREaWFsQ29udGVudDIuZGVmYXVsdC5uYW1lLCBfTWRTcGVlZERpYWxDb250ZW50Mi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFNwZWVkRGlhbC9NZFNwZWVkRGlhbC52dWVcbnZhciBNZFNwZWVkRGlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIyKTtcbnZhciBNZFNwZWVkRGlhbF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFNwZWVkRGlhbCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDcwZjc2ZDFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTcGVlZERpYWwvTWRTcGVlZERpYWwudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWQtc3BlZWQtZGlhbFwiLFxuICAgICAgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWUsIF92bS5zcGVlZERpYWxDbGFzc2VzXVxuICAgIH0sXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFNwZWVkRGlhbF9NZFNwZWVkRGlhbCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDcwZjc2ZDFcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kU3BlZWREaWFsL01kU3BlZWREaWFsLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzIxKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTcGVlZERpYWxfZGVmYXVsdC5hLFxuICBNZFNwZWVkRGlhbF9NZFNwZWVkRGlhbCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kU3BlZWREaWFsL01kU3BlZWREaWFsLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ3MGY3NmQxXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDcwZjc2ZDFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTcGVlZERpYWxfTWRTcGVlZERpYWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFNwZWVkRGlhbCcsXG4gIHByb3BzOiB7XG4gICAgbWRFdmVudDogX2V4dGVuZHMoe1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2hvdmVyJ1xuICAgIH0sICgwLCBfTWRQcm9wVmFsaWRhdG9yMi5kZWZhdWx0KSgnbWQtZXZlbnQnLCBbJ2NsaWNrJywgJ2hvdmVyJ10pKSxcbiAgICBtZERpcmVjdGlvbjogX2V4dGVuZHMoe1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3RvcCdcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLWRpcmVjdGlvbicsIFsndG9wJywgJ2JvdHRvbSddKSksXG4gICAgbWRFZmZlY3Q6IF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdmbGluZydcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLWVmZmVjdCcsIFsnZmxpbmcnLCAnc2NhbGUnLCAnb3BhY2l0eSddKSlcbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTWRTcGVlZERpYWw6IHtcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgZXZlbnQ6IHRoaXMubWRFdmVudCxcbiAgICAgICAgZGlyZWN0aW9uOiB0aGlzLm1kRGlyZWN0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcHJvdmlkZTogZnVuY3Rpb24gcHJvdmlkZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgTWRTcGVlZERpYWw6IHRoaXMuTWRTcGVlZERpYWxcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgc3BlZWREaWFsQ2xhc3NlczogZnVuY3Rpb24gc3BlZWREaWFsQ2xhc3NlcygpIHtcbiAgICAgIHZhciBfcmVmO1xuXG4gICAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgICAgJ21kLWFjdGl2ZSc6IHRoaXMuTWRTcGVlZERpYWwuYWN0aXZlLFxuICAgICAgICAnbWQtd2l0aC1ob3Zlcic6IHRoaXMubWRFdmVudCA9PT0gJ2hvdmVyJ1xuICAgICAgfSwgX2RlZmluZVByb3BlcnR5KF9yZWYsICdtZC1kaXJlY3Rpb24tJyArIHRoaXMubWREaXJlY3Rpb24sIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ21kLWVmZmVjdC0nICsgdGhpcy5tZEVmZmVjdCwgdHJ1ZSksIF9yZWY7XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kU3BlZWREaWFsL01kU3BlZWREaWFsVGFyZ2V0LnZ1ZVxudmFyIE1kU3BlZWREaWFsVGFyZ2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjUpO1xudmFyIE1kU3BlZWREaWFsVGFyZ2V0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kU3BlZWREaWFsVGFyZ2V0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02NTRhNzU3Y1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFNwZWVkRGlhbC9NZFNwZWVkRGlhbFRhcmdldC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC1idXR0b25cIixcbiAgICBfdm0uX2coXG4gICAgICBfdm0uX2IoXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1zcGVlZC1kaWFsLXRhcmdldCBtZC1mYWJcIixcbiAgICAgICAgICBvbjogeyBjbGljazogX3ZtLmhhbmRsZUNsaWNrIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtZC1idXR0b25cIixcbiAgICAgICAgX3ZtLiRhdHRycyxcbiAgICAgICAgZmFsc2VcbiAgICAgICksXG4gICAgICBfdm0uJGxpc3RlbmVyc1xuICAgICksXG4gICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFNwZWVkRGlhbF9NZFNwZWVkRGlhbFRhcmdldCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNjU0YTc1N2NcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kU3BlZWREaWFsL01kU3BlZWREaWFsVGFyZ2V0LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzI0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTcGVlZERpYWxUYXJnZXRfZGVmYXVsdC5hLFxuICBNZFNwZWVkRGlhbF9NZFNwZWVkRGlhbFRhcmdldCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kU3BlZWREaWFsL01kU3BlZWREaWFsVGFyZ2V0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTY1NGE3NTdjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNjU0YTc1N2NcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTcGVlZERpYWxfTWRTcGVlZERpYWxUYXJnZXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEJ1dHRvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgX01kQnV0dG9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQnV0dG9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTcGVlZERpYWxUYXJnZXQnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRCdXR0b246IF9NZEJ1dHRvbjIuZGVmYXVsdFxuICB9LFxuICBpbmplY3Q6IFsnTWRTcGVlZERpYWwnXSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVDbGljaygpIHtcbiAgICAgIGlmICh0aGlzLk1kU3BlZWREaWFsLmV2ZW50ID09PSAnY2xpY2snKSB7XG4gICAgICAgIHRoaXMuTWRTcGVlZERpYWwuYWN0aXZlID0gIXRoaXMuTWRTcGVlZERpYWwuYWN0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDMyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTcGVlZERpYWwvTWRTcGVlZERpYWxDb250ZW50LnZ1ZVxudmFyIE1kU3BlZWREaWFsQ29udGVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMzI4KTtcbnZhciBNZFNwZWVkRGlhbENvbnRlbnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRTcGVlZERpYWxDb250ZW50KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00NWFjNjQxOFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFNwZWVkRGlhbC9NZFNwZWVkRGlhbENvbnRlbnQudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1zcGVlZC1kaWFsLWNvbnRlbnRcIiB9LFxuICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRTcGVlZERpYWxfTWRTcGVlZERpYWxDb250ZW50ID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi00NWFjNjQxOFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRTcGVlZERpYWwvTWRTcGVlZERpYWxDb250ZW50LnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzI3KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTcGVlZERpYWxDb250ZW50X2RlZmF1bHQuYSxcbiAgTWRTcGVlZERpYWxfTWRTcGVlZERpYWxDb250ZW50LFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRTcGVlZERpYWwvTWRTcGVlZERpYWxDb250ZW50LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQ1YWM2NDE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDVhYzY0MThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTcGVlZERpYWxfTWRTcGVlZERpYWxDb250ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9XG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuZnVuY3Rpb24gZ2V0Q2hpbGRJbmRleChkaXJlY3Rpb24sIGluZGV4LCBjb3VudCkge1xuICBpZiAoZGlyZWN0aW9uID09PSAndG9wJykge1xuICAgIHJldHVybiBjb3VudCAtIGluZGV4IC0gMTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTcGVlZERpYWxDb250ZW50JyxcbiAgaW5qZWN0OiBbJ01kU3BlZWREaWFsJ10sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRDaGlsZHJlbkluZGV4ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjb3VudENoaWxkO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNvdW50Q2hpbGQgPSB0aGlzLiRjaGlsZHJlbi5sZW5ndGg7XG5cblxuICAgICAgICAgICAgICAgIHRoaXMuJGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLl92bm9kZS50YWcgPT09ICdidXR0b24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEluZGV4ID0gZ2V0Q2hpbGRJbmRleChfdGhpcy5NZFNwZWVkRGlhbC5kaXJlY3Rpb24sIGluZGV4LCBjb3VudENoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBjaGlsZC4kZWwuc2V0QXR0cmlidXRlKCdtZC1idXR0b24taW5kZXgnLCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuJGVsLmNsYXNzTGlzdC5hZGQoJ21kLXJhaXNlZCcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldENoaWxkcmVuSW5kZXhlcygpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldENoaWxkcmVuSW5kZXhlcztcbiAgICB9KClcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLnNldENoaWxkcmVuSW5kZXhlcygpO1xuICB9LFxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgIHRoaXMuc2V0Q2hpbGRyZW5JbmRleGVzKCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFN0ZXBwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzApO1xuXG52YXIgX01kU3RlcHBlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTdGVwcGVycyk7XG5cbnZhciBfTWRTdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDApO1xuXG52YXIgX01kU3RlcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN0ZXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU3RlcHBlcnMyLmRlZmF1bHQubmFtZSwgX01kU3RlcHBlcnMyLmRlZmF1bHQpO1xuICBWdWUuY29tcG9uZW50KF9NZFN0ZXAyLmRlZmF1bHQubmFtZSwgX01kU3RlcDIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTdGVwcGVycy9NZFN0ZXBwZXJzLnZ1ZVxudmFyIE1kU3RlcHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzMik7XG52YXIgTWRTdGVwcGVyc19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFN0ZXBwZXJzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi05NWFjYjcyMlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFN0ZXBwZXJzL01kU3RlcHBlcnMudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWQtc3RlcHBlcnNcIixcbiAgICAgIGNsYXNzOiBbX3ZtLnN0ZXBwZXJzQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXVxuICAgIH0sXG4gICAgW1xuICAgICAgIV92bS5tZFZlcnRpY2FsXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1zdGVwcGVycy1uYXZpZ2F0aW9uXCIgfSxcbiAgICAgICAgICAgIF92bS5fbChfdm0uTWRTdGVwcGVycy5pdGVtcywgZnVuY3Rpb24oXywgaW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jKFwibWQtc3RlcC1oZWFkZXJcIiwge1xuICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHsgaW5kZXg6IGluZGV4IH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXN0ZXBwZXJzLXdyYXBwZXJcIiwgc3R5bGU6IF92bS5jb250ZW50U3R5bGVzIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXN0ZXBwZXJzLWNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLmNvbnRhaW5lclN0eWxlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRTdGVwcGVyc19NZFN0ZXBwZXJzID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi05NWFjYjcyMlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRTdGVwcGVycy9NZFN0ZXBwZXJzLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzMxKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRTdGVwcGVyc19kZWZhdWx0LmEsXG4gIE1kU3RlcHBlcnNfTWRTdGVwcGVycyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kU3RlcHBlcnMvTWRTdGVwcGVycy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi05NWFjYjcyMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTk1YWNiNzIyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kU3RlcHBlcnNfTWRTdGVwcGVycyA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDMzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDMzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRPYnNlcnZlRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgX01kT2JzZXJ2ZUVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRPYnNlcnZlRWxlbWVudCk7XG5cbnZhciBfTWRTdGVwSGVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cbnZhciBfTWRTdGVwSGVhZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kU3RlcEhlYWRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kU3RlcHBlcnMnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRTdGVwSGVhZGVyOiBfTWRTdGVwSGVhZGVyMi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWRTeW5jUm91dGU6IEJvb2xlYW4sXG4gICAgbWREeW5hbWljSGVpZ2h0OiBCb29sZWFuLFxuICAgIG1kVmVydGljYWw6IEJvb2xlYW4sXG4gICAgbWRMaW5lYXI6IEJvb2xlYW4sXG4gICAgbWRBbHRlcm5hdGl2ZTogQm9vbGVhbixcbiAgICBtZEFjdGl2ZVN0ZXA6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlU3RlcEluZGV4OiAwLFxuICAgICAgbm9UcmFuc2l0aW9uOiB0cnVlLFxuICAgICAgY29udGFpbmVyU3R5bGVzOiB7fSxcbiAgICAgIGNvbnRlbnRTdHlsZXM6IHt9LFxuICAgICAgTWRTdGVwcGVyczoge1xuICAgICAgICBhY3RpdmVTdGVwOiAwLFxuICAgICAgICBpc0xpbmVhcjogZmFsc2UsXG4gICAgICAgIGlzVmVydGljYWw6IGZhbHNlLFxuICAgICAgICBpdGVtczoge31cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHZhciBNZFN0ZXBwZXJzID0gdGhpcy5NZFN0ZXBwZXJzO1xuXG4gICAgTWRTdGVwcGVycy5nZXRTdGVwcGVyTnVtYmVyID0gdGhpcy5nZXRTdGVwcGVyTnVtYmVyO1xuICAgIE1kU3RlcHBlcnMuc2V0QWN0aXZlU3RlcCA9IHRoaXMuc2V0QWN0aXZlU3RlcDtcbiAgICBNZFN0ZXBwZXJzLmlzUHJldmlvdXNTdGVwcGVyRG9uZSA9IHRoaXMuaXNQcmV2aW91c1N0ZXBwZXJEb25lO1xuXG4gICAgcmV0dXJuIHsgTWRTdGVwcGVyczogTWRTdGVwcGVycyB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgc3RlcHBlcnNDbGFzc2VzOiBmdW5jdGlvbiBzdGVwcGVyc0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtbm8tdHJhbnNpdGlvbic6IHRoaXMubm9UcmFuc2l0aW9uLFxuICAgICAgICAnbWQtYWx0ZXJuYXRpdmUnOiB0aGlzLm1kQWx0ZXJuYXRpdmUsXG4gICAgICAgICdtZC1ob3Jpem9udGFsJzogIXRoaXMubWRWZXJ0aWNhbCxcbiAgICAgICAgJ21kLXZlcnRpY2FsJzogdGhpcy5tZFZlcnRpY2FsLFxuICAgICAgICAnbWQtZHluYW1pYy1oZWlnaHQnOiB0aGlzLm1kRHluYW1pY0hlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIGFjdGl2ZUluZGV4OiBmdW5jdGlvbiBhY3RpdmVJbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kU3RlcHBlcnMuYWN0aXZlU3RlcDtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRBY3RpdmVTdGVwOiBmdW5jdGlvbiBtZEFjdGl2ZVN0ZXAoc3RlcHBlcikge1xuICAgICAgdGhpcy5NZFN0ZXBwZXJzLmFjdGl2ZVN0ZXAgPSBzdGVwcGVyO1xuICAgICAgdGhpcy4kZW1pdCgnbWQtY2hhbmdlZCcsIHN0ZXBwZXIpO1xuICAgIH0sXG4gICAgbWRMaW5lYXI6IGZ1bmN0aW9uIG1kTGluZWFyKGlzTGluZWFyKSB7XG4gICAgICB0aGlzLk1kU3RlcHBlcnMuaXNMaW5lYXIgPSBpc0xpbmVhcjtcbiAgICB9LFxuICAgIG1kVmVydGljYWw6IGZ1bmN0aW9uIG1kVmVydGljYWwoaXNWZXJ0aWNhbCkge1xuICAgICAgdGhpcy5NZFN0ZXBwZXJzLmlzVmVydGljYWwgPSBpc1ZlcnRpY2FsO1xuICAgIH0sXG4gICAgYWN0aXZlSW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlU3RlcEluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVTdGVwcGVyUG9zKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gYWN0aXZlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY3RpdmVJbmRleDtcbiAgICB9KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhc0FjdGl2ZVN0ZXA6IGZ1bmN0aW9uIGhhc0FjdGl2ZVN0ZXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZFN0ZXBwZXJzLmFjdGl2ZVN0ZXAgfHwgdGhpcy5tZEFjdGl2ZVN0ZXA7XG4gICAgfSxcbiAgICBnZXRJdGVtc0FuZEtleXM6IGZ1bmN0aW9uIGdldEl0ZW1zQW5kS2V5cygpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuTWRTdGVwcGVycy5pdGVtcztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICBrZXlzOiBPYmplY3Qua2V5cyhpdGVtcylcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTdGVwcGVyTnVtYmVyOiBmdW5jdGlvbiBnZXRTdGVwcGVyTnVtYmVyKGlkKSB7XG4gICAgICB2YXIgc3RlcHBlck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5NZFN0ZXBwZXJzLml0ZW1zKTtcblxuICAgICAgcmV0dXJuIHN0ZXBwZXJOYW1lcy5pbmRleE9mKGlkKSArIDE7XG4gICAgfSxcbiAgICBpc1N0ZXBwZXJEb25lOiBmdW5jdGlvbiBpc1N0ZXBwZXJEb25lKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZFN0ZXBwZXJzLml0ZW1zW2lkXS5kb25lO1xuICAgIH0sXG4gICAgaXNQcmV2aW91c1N0ZXBwZXJEb25lOiBmdW5jdGlvbiBpc1ByZXZpb3VzU3RlcHBlckRvbmUoaWQpIHtcbiAgICAgIHZhciBpdGVtcyA9IHRoaXMuTWRTdGVwcGVycy5pdGVtcztcblxuICAgICAgdmFyIHN0ZXBwZXJOYW1lcyA9IE9iamVjdC5rZXlzKGl0ZW1zKTtcbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0U3RlcHBlck51bWJlcihpZCkgLSAyO1xuICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSBzdGVwcGVyTmFtZXNbYWN0aXZlSW5kZXhdO1xuXG4gICAgICBpZiAoIXByZXZpb3VzSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtc1twcmV2aW91c0luZGV4XS5kb25lO1xuICAgIH0sXG4gICAgaXNTdGVwcGVyRWRpdGFibGU6IGZ1bmN0aW9uIGlzU3RlcHBlckVkaXRhYmxlKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZFN0ZXBwZXJzLml0ZW1zW2lkXS5lZGl0YWJsZTtcbiAgICB9LFxuICAgIHNldFN0ZXBwZXJBc0RvbmU6IGZ1bmN0aW9uIHNldFN0ZXBwZXJBc0RvbmUoaWQpIHtcbiAgICAgIHRoaXMuTWRTdGVwcGVycy5pdGVtc1tpZF0uZG9uZSA9IHRydWU7XG4gICAgfSxcbiAgICBzZXRQcmV2aW91c1N0ZXBwZXJBc0RvbmU6IGZ1bmN0aW9uIHNldFByZXZpb3VzU3RlcHBlckFzRG9uZShuZXdJZCkge1xuICAgICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5nZXRTdGVwcGVyTnVtYmVyKHRoaXMuTWRTdGVwcGVycy5hY3RpdmVTdGVwKTtcbiAgICAgIHZhciBuZXdJbmRleCA9IHRoaXMuZ2V0U3RlcHBlck51bWJlcihuZXdJZCk7XG5cbiAgICAgIGlmIChuZXdJbmRleCA+IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIHRoaXMuc2V0U3RlcHBlckFzRG9uZSh0aGlzLk1kU3RlcHBlcnMuYWN0aXZlU3RlcCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBY3RpdmVTdGVwOiBmdW5jdGlvbiBzZXRBY3RpdmVTdGVwKGlkKSB7XG4gICAgICBpZiAodGhpcy5tZExpbmVhciAmJiAhdGhpcy5pc1ByZXZpb3VzU3RlcHBlckRvbmUoaWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkICE9PSB0aGlzLk1kU3RlcHBlcnMuYWN0aXZlU3RlcCAmJiAodGhpcy5pc1N0ZXBwZXJFZGl0YWJsZShpZCkgfHwgIXRoaXMuaXNTdGVwcGVyRG9uZShpZCkpKSB7XG4gICAgICAgIHRoaXMuc2V0UHJldmlvdXNTdGVwcGVyQXNEb25lKGlkKTtcbiAgICAgICAgdGhpcy5NZFN0ZXBwZXJzLmFjdGl2ZVN0ZXAgPSBpZDtcbiAgICAgICAgdGhpcy4kZW1pdCgnbWQtY2hhbmdlZCcsIGlkKTtcbiAgICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1kQWN0aXZlU3RlcCcsIGlkKTtcbiAgICAgICAgdGhpcy5NZFN0ZXBwZXJzLml0ZW1zW2lkXS5lcnJvciA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBY3RpdmVTdGVwSW5kZXg6IGZ1bmN0aW9uIHNldEFjdGl2ZVN0ZXBJbmRleCgpIHtcbiAgICAgIHZhciBhY3RpdmVCdXR0b24gPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcubWQtYnV0dG9uLm1kLWFjdGl2ZScpO1xuXG4gICAgICBpZiAoYWN0aXZlQnV0dG9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlU3RlcEluZGV4ID0gW10uaW5kZXhPZi5jYWxsKGFjdGl2ZUJ1dHRvbi5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIGFjdGl2ZUJ1dHRvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBY3RpdmVTdGVwQnlJbmRleDogZnVuY3Rpb24gc2V0QWN0aXZlU3RlcEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgIHZhciBfZ2V0SXRlbXNBbmRLZXlzID0gdGhpcy5nZXRJdGVtc0FuZEtleXMoKSxcbiAgICAgICAgICBrZXlzID0gX2dldEl0ZW1zQW5kS2V5cy5rZXlzO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlU3RlcCgpKSB7XG4gICAgICAgIHRoaXMuTWRTdGVwcGVycy5hY3RpdmVTdGVwID0ga2V5c1tpbmRleF07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBY3RpdmVTdGVwQnlSb3V0ZTogZnVuY3Rpb24gc2V0QWN0aXZlU3RlcEJ5Um91dGUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgX2dldEl0ZW1zQW5kS2V5czIgPSB0aGlzLmdldEl0ZW1zQW5kS2V5cygpLFxuICAgICAgICAgIGl0ZW1zID0gX2dldEl0ZW1zQW5kS2V5czIuaXRlbXMsXG4gICAgICAgICAga2V5cyA9IF9nZXRJdGVtc0FuZEtleXMyLmtleXM7XG5cbiAgICAgIHZhciBzdGVwcGVySW5kZXggPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy4kcm91dGVyKSB7XG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNba2V5XTtcbiAgICAgICAgICB2YXIgdG9Qcm9wID0gaXRlbS5wcm9wcy50bztcblxuICAgICAgICAgIGlmICh0b1Byb3AgJiYgdG9Qcm9wID09PSBfdGhpcy4kcm91dGUucGF0aCkge1xuICAgICAgICAgICAgc3RlcHBlckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhhc0FjdGl2ZVN0ZXAoKSAmJiAhc3RlcHBlckluZGV4KSB7XG4gICAgICAgIHRoaXMuTWRTdGVwcGVycy5hY3RpdmVTdGVwID0ga2V5c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuTWRTdGVwcGVycy5hY3RpdmVTdGVwID0ga2V5c1tzdGVwcGVySW5kZXhdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcHBlckluZGV4OyBpKyspIHtcbiAgICAgICAgICB0aGlzLnNldFN0ZXBwZXJBc0RvbmUoa2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwT2JzZXJ2ZXJzOiBmdW5jdGlvbiBzZXR1cE9ic2VydmVycygpIHtcbiAgICAgIHZhciBzdGVwcGVyc0NvbnRlbnQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKCcubWQtc3RlcHBlcnMtd3JhcHBlcicpO1xuXG4gICAgICBpZiAoJ1Jlc2l6ZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5jYWxjdWxhdGVTdGVwcGVyUG9zKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmNhbGN1bGF0ZVN0ZXBwZXJQb3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcHBlcnNDb250ZW50KSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSAoMCwgX01kT2JzZXJ2ZUVsZW1lbnQyLmRlZmF1bHQpKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5tZC1zdGVwcGVycy13cmFwcGVyJyksIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0sIHRoaXMuY2FsY3VsYXRlU3RlcHBlclBvcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxjdWxhdGVTdGVwcGVyUG9zOiBmdW5jdGlvbiBjYWxjdWxhdGVTdGVwcGVyUG9zKCkge1xuICAgICAgaWYgKCF0aGlzLm1kVmVydGljYWwpIHtcbiAgICAgICAgdmFyIHN0ZXBwZXJFbGVtZW50ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLm1kLXN0ZXBwZXI6bnRoLWNoaWxkKCcgKyAodGhpcy5hY3RpdmVTdGVwSW5kZXggKyAxKSArICcpJyk7XG5cbiAgICAgICAgdGhpcy5jb250ZW50U3R5bGVzID0ge1xuICAgICAgICAgIGhlaWdodDogc3RlcHBlckVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyU3R5bGVzID0ge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAtdGhpcy5hY3RpdmVTdGVwSW5kZXggKiAxMDAgKyAnJSwgMCwgMCknXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXR1cFdhdGNoZXJzOiBmdW5jdGlvbiBzZXR1cFdhdGNoZXJzKCkge1xuICAgICAgaWYgKHRoaXMubWRTeW5jUm91dGUpIHtcbiAgICAgICAgdGhpcy4kd2F0Y2goJyRyb3V0ZScsIHtcbiAgICAgICAgICBkZWVwOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVN0ZXBCeVJvdXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5NZFN0ZXBwZXJzLmFjdGl2ZVN0ZXAgPSB0aGlzLm1kQWN0aXZlU3RlcDtcbiAgICB0aGlzLk1kU3RlcHBlcnMuaXNMaW5lYXIgPSB0aGlzLm1kTGluZWFyO1xuICAgIHRoaXMuTWRTdGVwcGVycy5pc1ZlcnRpY2FsID0gdGhpcy5tZFZlcnRpY2FsO1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWRTeW5jUm91dGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVN0ZXBCeVJvdXRlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVTdGVwQnlJbmRleCgwKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcblxuICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVN0ZXBJbmRleCgpO1xuICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVN0ZXBwZXJQb3MoKTtcblxuICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLm5vVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzMi5zZXR1cE9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIF90aGlzMi5zZXR1cFdhdGNoZXJzKCk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICghKCdSZXNpemVPYnNlcnZlcicgaW4gd2luZG93KSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuY2FsY3VsYXRlU3RlcHBlclBvcyk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFdhcm5pbmdJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzQpO1xuXG52YXIgX01kV2FybmluZ0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRXYXJuaW5nSWNvbik7XG5cbnZhciBfTWRDaGVja0ljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzNik7XG5cbnZhciBfTWRDaGVja0ljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDaGVja0ljb24pO1xuXG52YXIgX01kRWRpdEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzOCk7XG5cbnZhciBfTWRFZGl0SWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEVkaXRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRTdGVwcGVySGVhZGVyJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kV2FybmluZ0ljb246IF9NZFdhcm5pbmdJY29uMi5kZWZhdWx0LFxuICAgIE1kQ2hlY2tJY29uOiBfTWRDaGVja0ljb24yLmRlZmF1bHQsXG4gICAgTWRFZGl0SWNvbjogX01kRWRpdEljb24yLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBpbmRleDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGluamVjdDogWydNZFN0ZXBwZXJzJ10sXG4gIGNvbXB1dGVkOiB7XG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kU3RlcHBlcnMuaXRlbXNbdGhpcy5pbmRleF07XG4gICAgfSxcbiAgICBzaG91bGREaXNhYmxlOiBmdW5jdGlvbiBzaG91bGREaXNhYmxlKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4LFxuICAgICAgICAgIE1kU3RlcHBlcnMgPSB0aGlzLk1kU3RlcHBlcnM7XG5cblxuICAgICAgaWYgKGRhdGEuZG9uZSAmJiAhZGF0YS5lZGl0YWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1kU3RlcHBlcnMuaXNMaW5lYXIgJiYgIU1kU3RlcHBlcnMuaXNQcmV2aW91c1N0ZXBwZXJEb25lKGluZGV4KTtcbiAgICB9LFxuICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtYWN0aXZlJzogdGhpcy5pbmRleCA9PT0gdGhpcy5NZFN0ZXBwZXJzLmFjdGl2ZVN0ZXAsXG4gICAgICAgICdtZC1lcnJvcic6IHRoaXMuZGF0YS5lcnJvcixcbiAgICAgICAgJ21kLWRvbmUnOiB0aGlzLmRhdGEuZG9uZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kV2FybmluZ0ljb24udnVlXG52YXIgTWRXYXJuaW5nSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzM1KTtcbnZhciBNZFdhcm5pbmdJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kV2FybmluZ0ljb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTg5OTNkYzljXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kV2FybmluZ0ljb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwLCBmYWxzZSwgdHJ1ZSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwibWQtaWNvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLWljb24taW1hZ2VcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzdmdcIixcbiAgICAgICAge1xuICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjRcIixcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gICAgICAgICAgICB3aWR0aDogXCIyNFwiLFxuICAgICAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwicGF0aFwiLCB7IGF0dHJzOiB7IGQ6IFwiTTAgMGgyNHYyNEgwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IGQ6IFwiTTEgMjFoMjJMMTIgMiAxIDIxem0xMi0zaC0ydi0yaDJ2MnptMC00aC0ydi00aDJ2NHpcIiB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXVxuICAgICAgKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGljb25zX01kV2FybmluZ0ljb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTg5OTNkYzljXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9pY29ucy9NZFdhcm5pbmdJY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRXYXJuaW5nSWNvbl9kZWZhdWx0LmEsXG4gIGljb25zX01kV2FybmluZ0ljb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29yZS9pY29ucy9NZFdhcm5pbmdJY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTg5OTNkYzljXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtODk5M2RjOWNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRXYXJuaW5nSWNvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDMzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX01kSWNvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBfTWRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kV2FybmluZ0ljb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJY29uOiBfTWRJY29uMi5kZWZhdWx0XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kQ2hlY2tJY29uLnZ1ZVxudmFyIE1kQ2hlY2tJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzcpO1xudmFyIE1kQ2hlY2tJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kQ2hlY2tJY29uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00MTU0YjA1ZVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29yZS9pY29ucy9NZENoZWNrSWNvbi52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDAsIGZhbHNlLCB0cnVlKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJtZC1pY29uXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtaWNvbi1pbWFnZVwiIH0sIFtcbiAgICAgIF9jKFxuICAgICAgICBcInN2Z1wiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyNFwiLFxuICAgICAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHsgYXR0cnM6IHsgZDogXCJNMCAwaDI0djI0SDB6XCIsIGZpbGw6IFwibm9uZVwiIH0gfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInBhdGhcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgZDogXCJNOSAxNi4xN0w0LjgzIDEybC0xLjQyIDEuNDFMOSAxOSAyMSA3bC0xLjQxLTEuNDF6XCIgfVxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpY29uc19NZENoZWNrSWNvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDE1NGIwNWVcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2ljb25zL01kQ2hlY2tJY29uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRDaGVja0ljb25fZGVmYXVsdC5hLFxuICBpY29uc19NZENoZWNrSWNvbixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb3JlL2ljb25zL01kQ2hlY2tJY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQxNTRiMDVlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDE1NGIwNWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvcmVfaWNvbnNfTWRDaGVja0ljb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZENoZWNrSWNvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEljb246IF9NZEljb24yLmRlZmF1bHRcbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDMzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWRFZGl0SWNvbi52dWVcbnZhciBNZEVkaXRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzkpO1xudmFyIE1kRWRpdEljb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRFZGl0SWNvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzVkNmI1MTRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWRFZGl0SWNvbi52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDAsIGZhbHNlLCB0cnVlKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJtZC1pY29uXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtaWNvbi1pbWFnZVwiIH0sIFtcbiAgICAgIF9jKFxuICAgICAgICBcInN2Z1wiLFxuICAgICAgICB7XG4gICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogXCIyNFwiLFxuICAgICAgICAgICAgdmlld0JveDogXCIwIDAgMjQgMjRcIixcbiAgICAgICAgICAgIHdpZHRoOiBcIjI0XCIsXG4gICAgICAgICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6XG4gICAgICAgICAgICAgICAgXCJNMyAxNy4yNVYyMWgzLjc1TDE3LjgxIDkuOTRsLTMuNzUtMy43NUwzIDE3LjI1ek0yMC43MSA3LjA0Yy4zOS0uMzkuMzktMS4wMiAwLTEuNDFsLTIuMzQtMi4zNGMtLjM5LS4zOS0xLjAyLS4zOS0xLjQxIDBsLTEuODMgMS44MyAzLjc1IDMuNzUgMS44My0xLjgzelwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInBhdGhcIiwgeyBhdHRyczogeyBkOiBcIk0wIDBoMjR2MjRIMHpcIiwgZmlsbDogXCJub25lXCIgfSB9KVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaWNvbnNfTWRFZGl0SWNvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNzVkNmI1MTRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2ljb25zL01kRWRpdEljb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZEVkaXRJY29uX2RlZmF1bHQuYSxcbiAgaWNvbnNfTWRFZGl0SWNvbixcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb3JlL2ljb25zL01kRWRpdEljb24udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNzVkNmI1MTRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03NWQ2YjUxNFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9pY29uc19NZEVkaXRJY29uID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRJY29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIF9NZEljb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRJY29uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRFZGl0SWNvbicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZEljb246IF9NZEljb24yLmRlZmF1bHRcbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDM0MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTdGVwcGVycy9NZFN0ZXAudnVlXG52YXIgTWRTdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDIpO1xudmFyIE1kU3RlcF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFN0ZXApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTg2MjQ5NjBlXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kU3RlcHBlcnMvTWRTdGVwLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtc3RlcHBlclwiIH0sXG4gICAgW1xuICAgICAgX3ZtLk1kU3RlcHBlcnMuaXNWZXJ0aWNhbFxuICAgICAgICA/IF9jKFwibWQtc3RlcC1oZWFkZXJcIiwgeyBhdHRyczogeyBpbmRleDogX3ZtLmlkIH0gfSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXN0ZXBwZXItY29udGVudFwiLFxuICAgICAgICAgIGNsYXNzOiB7IFwibWQtYWN0aXZlXCI6IF92bS5pZCA9PT0gX3ZtLk1kU3RlcHBlcnMuYWN0aXZlU3RlcCB9XG4gICAgICAgIH0sXG4gICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIF0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kU3RlcHBlcnNfTWRTdGVwID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi04NjI0OTYwZVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRTdGVwcGVycy9NZFN0ZXAudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzNDEpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFN0ZXBfZGVmYXVsdC5hLFxuICBNZFN0ZXBwZXJzX01kU3RlcCxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kU3RlcHBlcnMvTWRTdGVwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTg2MjQ5NjBlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtODYyNDk2MGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRTdGVwcGVyc19NZFN0ZXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxudmFyIF9NZFV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX01kVXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFV1aWQpO1xuXG52YXIgX01kU3RlcEhlYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xuXG52YXIgX01kU3RlcEhlYWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN0ZXBIZWFkZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFN0ZXAnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRTdGVwSGVhZGVyOiBfTWRTdGVwSGVhZGVyMi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ21kLXN0ZXBwZXItJyArICgwLCBfTWRVdWlkMi5kZWZhdWx0KSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaHJlZjogW1N0cmluZywgTnVtYmVyXSxcbiAgICB0bzogbnVsbCxcbiAgICBtZExhYmVsOiBTdHJpbmcsXG4gICAgbWREZXNjcmlwdGlvbjogU3RyaW5nLFxuICAgIG1kRXJyb3I6IFN0cmluZyxcbiAgICBtZERvbmU6IEJvb2xlYW4sXG4gICAgbWRFZGl0YWJsZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGluamVjdDogWydNZFN0ZXBwZXJzJ10sXG4gIHdhdGNoOiB7XG4gICAgJHByb3BzOiB7XG4gICAgICBkZWVwOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5zZXRTdGVwcGVyRGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGdldFByb3BWYWx1ZXM6IGZ1bmN0aW9uIGdldFByb3BWYWx1ZXMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXModGhpcy4kb3B0aW9ucy5wcm9wcyk7XG4gICAgICB2YXIgaWdub3JlZFByb3BzID0gWydpZCcsICdtZExhYmVsJywgJ21kRGVzY3JpcHRpb24nLCAnbWRFcnJvcicsICdtZEVkaXRhYmxlJ107XG4gICAgICB2YXIgdmFsdWVzID0ge307XG5cbiAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghaWdub3JlZFByb3BzLmluY2x1ZGVzKHByb3ApKSB7XG4gICAgICAgICAgaWYgKF90aGlzW3Byb3BdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbcHJvcF0gPSBfdGhpc1twcm9wXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLiRhdHRycy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICAgICAgdmFsdWVzW3Byb3BdID0gX3RoaXMuJGF0dHJzW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWVzW3Byb3BdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0sXG4gICAgc2V0U3RlcHBlckRhdGE6IGZ1bmN0aW9uIHNldFN0ZXBwZXJEYXRhKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuTWRTdGVwcGVycy5pdGVtcywgdGhpcy5pZCwge1xuICAgICAgICBsYWJlbDogdGhpcy5tZExhYmVsLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5tZERlc2NyaXB0aW9uLFxuICAgICAgICBlcnJvcjogdGhpcy5tZEVycm9yLFxuICAgICAgICBkb25lOiB0aGlzLm1kRG9uZSxcbiAgICAgICAgZWRpdGFibGU6IHRoaXMubWRFZGl0YWJsZSxcbiAgICAgICAgcHJvcHM6IHRoaXMuZ2V0UHJvcFZhbHVlcygpLFxuICAgICAgICBldmVudHM6IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXR1cFdhdGNoZXJzOiBmdW5jdGlvbiBzZXR1cFdhdGNoZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBnZXRQcm9wID0gZnVuY3Rpb24gZ2V0UHJvcChwcm9wKSB7XG4gICAgICAgIGlmIChfdGhpczIuTWRTdGVwcGVycy5pdGVtc1tfdGhpczIuaWRdKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5NZFN0ZXBwZXJzLml0ZW1zW190aGlzMi5pZF1bcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuJHdhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFByb3AoJ2Vycm9yJyk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuJGVtaXQoJ3VwZGF0ZTptZEVycm9yJywgZ2V0UHJvcCgnZXJyb3InKSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy4kd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0UHJvcCgnZG9uZScpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLiRlbWl0KCd1cGRhdGU6bWREb25lJywgZ2V0UHJvcCgnZG9uZScpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLnNldFN0ZXBwZXJEYXRhKCk7XG4gICAgdGhpcy5zZXR1cFdhdGNoZXJzKCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy4kZGVsZXRlKHRoaXMuTWRTdGVwcGVycy5pdGVtcywgdGhpcy5pZCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICB2YXIgc3RlcHBlckF0dHJzID0ge1xuICAgICAgc3RhdGljQ2xhc3M6ICdtZC1zdGVwcGVyJyxcbiAgICAgIGF0dHJzOiBfZXh0ZW5kcyh7fSwgdGhpcy4kYXR0cnMsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgIH0pLFxuICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5ocmVmKSB7XG4gICAgICB0aGlzLmJ1dHRvblByb3BzID0gdGhpcy4kb3B0aW9ucy5wcm9wcztcbiAgICB9IGVsc2UgaWYgKHRoaXMuJHJvdXRlciAmJiB0aGlzLnRvKSB7XG4gICAgICB0aGlzLiRvcHRpb25zLnByb3BzID0gTWRSb3V0ZXJMaW5rUHJvcHModGhpcywgdGhpcy4kb3B0aW9ucy5wcm9wcyk7XG5cbiAgICAgIHN0ZXBwZXJBdHRycy5wcm9wcyA9IHRoaXMuJHByb3BzO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCBzdGVwcGVyQXR0cnMsIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRTdWJoZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NCk7XG5cbnZhciBfTWRTdWJoZWFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRTdWJoZWFkZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kU3ViaGVhZGVyMi5kZWZhdWx0Lm5hbWUsIF9NZFN1YmhlYWRlcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTdWJoZWFkZXIvTWRTdWJoZWFkZXIudnVlXG52YXIgTWRTdWJoZWFkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0Nik7XG52YXIgTWRTdWJoZWFkZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRTdWJoZWFkZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdmZjMwZTg2XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kU3ViaGVhZGVyL01kU3ViaGVhZGVyLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uaW5zaWRlTGlzdFxuICAgID8gX2MoXG4gICAgICAgIFwibGlcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1zdWJoZWFkZXJcIiwgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWVdIH0sXG4gICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgMlxuICAgICAgKVxuICAgIDogX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtc3ViaGVhZGVyXCIsIGNsYXNzOiBbX3ZtLiRtZEFjdGl2ZVRoZW1lXSB9LFxuICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgIDJcbiAgICAgIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRTdWJoZWFkZXJfTWRTdWJoZWFkZXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTdmZjMwZTg2XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFN1YmhlYWRlci9NZFN1YmhlYWRlci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kU3ViaGVhZGVyX2RlZmF1bHQuYSxcbiAgTWRTdWJoZWFkZXJfTWRTdWJoZWFkZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFN1YmhlYWRlci9NZFN1YmhlYWRlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03ZmYzMGU4NlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTdmZjMwZTg2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kU3ViaGVhZGVyX01kU3ViaGVhZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzQ1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFN1YmhlYWRlcicsXG4gIGNvbXB1dGVkOiB7XG4gICAgaW5zaWRlTGlzdDogZnVuY3Rpb24gaW5zaWRlTGlzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQuJG9wdGlvbnMuX2NvbXBvbmVudFRhZyA9PT0gJ21kLWxpc3QnO1xuICAgIH1cbiAgfVxufSk7IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMzQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFN3aXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ4KTtcblxudmFyIF9NZFN3aXRjaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFN3aXRjaCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudChfTWRTd2l0Y2gyLmRlZmF1bHQubmFtZSwgX01kU3dpdGNoMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFN3aXRjaC9NZFN3aXRjaC52dWVcbnZhciBNZFN3aXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUwKTtcbnZhciBNZFN3aXRjaF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFN3aXRjaCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNWZmOTUzYTJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRTd2l0Y2gvTWRTd2l0Y2gudnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJtZC1zd2l0Y2hcIiwgY2xhc3M6IFtfdm0uJG1kQWN0aXZlVGhlbWUsIF92bS5jaGVja0NsYXNzZXNdIH0sXG4gICAgW1xuICAgICAgX2MoXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC1zd2l0Y2gtY29udGFpbmVyXCIsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgIF92bS50b2dnbGVDaGVjaygkZXZlbnQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC1zd2l0Y2gtdGh1bWJcIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcIm1kLXJpcHBsZVwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwibWQtY2VudGVyZWRcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnJpcHBsZUFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgXCJtZC1kaXNhYmxlZFwiOiBfdm0uZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBcInVwZGF0ZTptZEFjdGl2ZVwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0ucmlwcGxlQWN0aXZlID0gJGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAgICAgICAgICB7IGF0dHJzOiB7IHR5cGU6IFwiY2hlY2tib3hcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBfdm0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfdm0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogX3ZtLnJlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApXG4gICAgICAgIF1cbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLiRzbG90cy5kZWZhdWx0XG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXN3aXRjaC1sYWJlbFwiLFxuICAgICAgICAgICAgICBhdHRyczogeyBmb3I6IF92bS5pZCB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICBfdm0udG9nZ2xlQ2hlY2soJGV2ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRTd2l0Y2hfTWRTd2l0Y2ggPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTVmZjk1M2EyXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFN3aXRjaC9NZFN3aXRjaC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0OSlcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kU3dpdGNoX2RlZmF1bHQuYSxcbiAgTWRTd2l0Y2hfTWRTd2l0Y2gsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFN3aXRjaC9NZFN3aXRjaC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi01ZmY5NTNhMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTVmZjk1M2EyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kU3dpdGNoX01kU3dpdGNoID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cbi8qKiovIH0pLFxuLyogMzUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX01kQ29tcG9uZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kQ29tcG9uZW50KTtcblxudmFyIF9NZENoZWNrYm94TWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcblxudmFyIF9NZENoZWNrYm94TWl4aW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDaGVja2JveE1peGluKTtcblxudmFyIF9NZFV1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG52YXIgX01kVXVpZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFV1aWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kU3dpdGNoJyxcbiAgbWl4aW5zOiBbX01kQ2hlY2tib3hNaXhpbjIuZGVmYXVsdF0sXG4gIHByb3BzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ21kLXN3aXRjaC0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tYXRlcmlhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfbWF0ZXJpYWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0ZXJpYWwpO1xuXG52YXIgX01kVGFibGVDb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1Mik7XG5cbnZhciBfTWRUYWJsZUNvbnRhaW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlQ29udGFpbmVyKTtcblxudmFyIF9NZFRhYmxlVG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzc1KTtcblxudmFyIF9NZFRhYmxlVG9vbGJhcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlVG9vbGJhcik7XG5cbnZhciBfTWRUYWJsZUVtcHR5U3RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MCk7XG5cbnZhciBfTWRUYWJsZUVtcHR5U3RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZUVtcHR5U3RhdGUpO1xuXG52YXIgX01kVGFibGVSb3cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcblxudmFyIF9NZFRhYmxlUm93MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGFibGVSb3cpO1xuXG52YXIgX01kVGFibGVIZWFkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbnZhciBfTWRUYWJsZUhlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZUhlYWQpO1xuXG52YXIgX01kVGFibGVDZWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODMpO1xuXG52YXIgX01kVGFibGVDZWxsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGFibGVDZWxsKTtcblxudmFyIF9NZFRhYmxlUGFnaW5hdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzg2KTtcblxudmFyIF9NZFRhYmxlUGFnaW5hdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlUGFnaW5hdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgKDAsIF9tYXRlcmlhbDIuZGVmYXVsdCkoVnVlKTtcbiAgVnVlLmNvbXBvbmVudCgnTWRUYWJsZScsIF9NZFRhYmxlQ29udGFpbmVyMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRUYWJsZVRvb2xiYXIyLmRlZmF1bHQubmFtZSwgX01kVGFibGVUb29sYmFyMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRUYWJsZUVtcHR5U3RhdGUyLmRlZmF1bHQubmFtZSwgX01kVGFibGVFbXB0eVN0YXRlMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRUYWJsZVJvdzIuZGVmYXVsdC5uYW1lLCBfTWRUYWJsZVJvdzIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVGFibGVIZWFkMi5kZWZhdWx0Lm5hbWUsIF9NZFRhYmxlSGVhZDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVGFibGVDZWxsMi5kZWZhdWx0Lm5hbWUsIF9NZFRhYmxlQ2VsbDIuZGVmYXVsdCk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVGFibGVQYWdpbmF0aW9uMi5kZWZhdWx0Lm5hbWUsIF9NZFRhYmxlUGFnaW5hdGlvbjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX01kVGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1Myk7XG5cbnZhciBfTWRUYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuKGNoaWxkcmVuLCBjcmVhdGVFbGVtZW50KSB7XG4gIHZhciBzbG90TmFtZXMgPSBbJ21kLXRhYmxlLXRvb2xiYXInLCAnbWQtdGFibGUtZW1wdHktc3RhdGUnLCAnbWQtdGFibGUtcGFnaW5hdGlvbiddO1xuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcbiAgdmFyIG5hbWVkU2xvdHMgPSB7fTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgIGlmIChub2RlICYmIG5vZGUudGFnKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS5jb21wb25lbnRPcHRpb25zICYmIG5vZGUuY29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgICAgIGlmICh0YWcgJiYgc2xvdE5hbWVzLmluY2x1ZGVzKHRhZykpIHtcbiAgICAgICAgbm9kZS5kYXRhLnNsb3QgPSB0YWc7XG4gICAgICAgIG5vZGUuZGF0YS5hdHRycyA9IG5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgICAgbmFtZWRTbG90c1t0YWddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9O1xuICAgICAgICBub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZE5vZGVzOiBub2RlcyxcbiAgICBzbG90czogbmFtZWRTbG90c1xuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlQ29udGFpbmVyJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCwgX3JlZikge1xuICAgIHZhciBkYXRhID0gX3JlZi5kYXRhLFxuICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcblxuICAgIHZhciBzbG90Q2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgX3Byb2Nlc3NDaGlsZHJlbiA9IHByb2Nlc3NDaGlsZHJlbihjaGlsZHJlbiwgY3JlYXRlRWxlbWVudCksXG4gICAgICAgICAgY2hpbGROb2RlcyA9IF9wcm9jZXNzQ2hpbGRyZW4uY2hpbGROb2RlcyxcbiAgICAgICAgICBzbG90cyA9IF9wcm9jZXNzQ2hpbGRyZW4uc2xvdHM7XG5cbiAgICAgIHNsb3RDaGlsZHJlbiA9IGNoaWxkTm9kZXM7XG4gICAgICBzY29wZWRTbG90cyA9IF9leHRlbmRzKHt9LCBzY29wZWRTbG90cywgc2xvdHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KF9NZFRhYmxlMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgZGF0YSwge1xuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgc2NvcGVkU2xvdHM6IHNjb3BlZFNsb3RzXG4gICAgfSksIFtzbG90Q2hpbGRyZW5dKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZS52dWVcbnZhciBNZFRhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTUpO1xudmFyIE1kVGFibGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJsZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWFlY2VkODJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLXRhZy1zd2l0Y2hlclwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGVcIiwgYXR0cnM6IHsgXCJtZC10YWdcIjogX3ZtLmNvbnRlbnRUYWcgfSB9LFxuICAgIFtcbiAgICAgIF92bS5fdChcIm1kLXRhYmxlLXRvb2xiYXJcIiksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgICAgICBbXG4gICAgICAgICAgX3ZtLiRzY29wZWRTbG90c1tcIm1kLXRhYmxlLWFsdGVybmF0ZS1oZWFkZXJcIl0gJiYgX3ZtLnNlbGVjdGVkQ291bnRcbiAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgXCJtZC10YWJsZS1hbHRlcm5hdGUtaGVhZGVyXCIsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX3ZtLl90KFwibWQtdGFibGUtYWx0ZXJuYXRlLWhlYWRlclwiLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBfdm0uc2VsZWN0ZWRDb3VudFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5tZEZpeGVkSGVhZGVyXG4gICAgICAgID8gX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1maXhlZC1oZWFkZXJcIixcbiAgICAgICAgICAgICAgY2xhc3M6IF92bS5oZWFkZXJDbGFzc2VzLFxuICAgICAgICAgICAgICBzdHlsZTogX3ZtLmhlYWRlclN0eWxlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtfYyhcInRhYmxlXCIsIFtfYyhcIm1kLXRhYmxlLXRoZWFkXCIpXSwgMSldXG4gICAgICAgICAgKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWNvbnRlbnRcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm1kLXRhYmxlLWNvbnRlbnQgbWQtc2Nyb2xsYmFyXCIsXG4gICAgICAgICAgY2xhc3M6IF92bS5jb250ZW50Q2xhc3NlcyxcbiAgICAgICAgICBzdHlsZTogX3ZtLmNvbnRlbnRTdHlsZXMsXG4gICAgICAgICAgb246IHsgc2Nyb2xsOiBfdm0uc2V0U2Nyb2xsIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAhX3ZtLm1kRml4ZWRIZWFkZXIgJiYgX3ZtLiRzY29wZWRTbG90c1tcIm1kLXRhYmxlLXJvd1wiXVxuICAgICAgICAgICAgICAgID8gX2MoXCJtZC10YWJsZS10aGVhZFwiLCB7IGNsYXNzOiBfdm0uaGVhZGVyQ2xhc3NlcyB9KVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICFfdm0uJHNjb3BlZFNsb3RzW1wibWQtdGFibGUtcm93XCJdXG4gICAgICAgICAgICAgICAgPyBfYyhcInRib2R5XCIsIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcbiAgICAgICAgICAgICAgICA6IF92bS52YWx1ZS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0Ym9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0udmFsdWUsIGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwibWQtdGFibGUtcm93LWdob3N0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IF92bS5nZXRSb3dJZChpdGVtW192bS5tZE1vZGVsSWRdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1pZFwiOiBfdm0uZ2V0Um93SWQoaXRlbVtfdm0ubWRNb2RlbElkXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1kLWluZGV4XCI6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtZC1pdGVtXCI6IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtfdm0uX3QoXCJtZC10YWJsZS1yb3dcIiwgbnVsbCwgeyBpdGVtOiBpdGVtIH0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIDogX3ZtLiRzY29wZWRTbG90c1tcIm1kLXRhYmxlLWVtcHR5LXN0YXRlXCJdXG4gICAgICAgICAgICAgICAgICAgID8gX2MoXCJ0Ym9keVwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXR0cnM6IHsgY29sc3BhbjogX3ZtLmhlYWRlckNvdW50IH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl90KFwibWQtdGFibGUtZW1wdHktc3RhdGVcIildLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0uX3QoXCJtZC10YWJsZS1wYWdpbmF0aW9uXCIpXG4gICAgICAgIF0sXG4gICAgICAgIDJcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLnZhbHVlID8gX3ZtLl90KFwiZGVmYXVsdFwiKSA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUYWJsZV9NZFRhYmxlID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1hYWVjZWQ4MlwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzU0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZV9kZWZhdWx0LmEsXG4gIE1kVGFibGVfTWRUYWJsZSxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1hYWVjZWQ4MlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWFhZWNlZDgyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDM1NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDM1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbnZhciBfcmFmID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIF9yYWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmFmKTtcblxudmFyIF9NZFRhZ1N3aXRjaGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTYpO1xuXG52YXIgX01kVGFnU3dpdGNoZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWdTd2l0Y2hlcik7XG5cbnZhciBfTWRVdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9NZFV1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRVdWlkKTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgX01kUHJvcFZhbGlkYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFByb3BWYWxpZGF0b3IpO1xuXG52YXIgX01kVGFibGVUaGVhZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzU4KTtcblxudmFyIF9NZFRhYmxlVGhlYWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZVRoZWFkKTtcblxudmFyIF9NZFRhYmxlQWx0ZXJuYXRlSGVhZGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNjYpO1xuXG52YXIgX01kVGFibGVBbHRlcm5hdGVIZWFkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZUFsdGVybmF0ZUhlYWRlcik7XG5cbnZhciBfTWRUYWJsZVJvdyA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xuXG52YXIgX01kVGFibGVSb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZVJvdyk7XG5cbnZhciBfTWRUYWJsZVJvd0dob3N0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzMpO1xuXG52YXIgX01kVGFibGVSb3dHaG9zdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlUm93R2hvc3QpO1xuXG52YXIgX01kVGFibGVDZWxsU2VsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mik7XG5cbnZhciBfTWRUYWJsZUNlbGxTZWxlY3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZUNlbGxTZWxlY3Rpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgc3RlcChcInRocm93XCIsIGVycik7IH0pOyB9IH0gcmV0dXJuIHN0ZXAoXCJuZXh0XCIpOyB9KTsgfTsgfVxuXG52YXIgZ2V0T2JqZWN0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0T2JqZWN0QXR0cmlidXRlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9iamVjdDtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBrZXkuc3BsaXQoJy4nKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgdmFsdWUgPSB2YWx1ZVthdHRyaWJ1dGVdO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlJyxcbiAgY29tcG9uZW50czoge1xuICAgIE1kVGFnU3dpdGNoZXI6IF9NZFRhZ1N3aXRjaGVyMi5kZWZhdWx0LFxuICAgIE1kVGFibGVBbHRlcm5hdGVIZWFkZXI6IF9NZFRhYmxlQWx0ZXJuYXRlSGVhZGVyMi5kZWZhdWx0LFxuICAgIE1kVGFibGVUaGVhZDogX01kVGFibGVUaGVhZDIuZGVmYXVsdCxcbiAgICBNZFRhYmxlUm93OiBfTWRUYWJsZVJvdzIuZGVmYXVsdCxcbiAgICBNZFRhYmxlUm93R2hvc3Q6IF9NZFRhYmxlUm93R2hvc3QyLmRlZmF1bHQsXG4gICAgTWRUYWJsZUNlbGxTZWxlY3Rpb246IF9NZFRhYmxlQ2VsbFNlbGVjdGlvbjIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbQXJyYXksIE9iamVjdF0sXG4gICAgbWRNb2RlbElkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnaWQnXG4gICAgfSxcbiAgICBtZENhcmQ6IEJvb2xlYW4sXG4gICAgbWRGaXhlZEhlYWRlcjogQm9vbGVhbixcbiAgICBtZEhlaWdodDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogNDAwXG4gICAgfSxcbiAgICBtZFNvcnQ6IFN0cmluZyxcbiAgICBtZFNvcnRPcmRlcjogX2V4dGVuZHMoe1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2FzYydcbiAgICB9LCAoMCwgX01kUHJvcFZhbGlkYXRvcjIuZGVmYXVsdCkoJ21kLXNvcnQtb3JkZXInLCBbJ2FzYycsICdkZXNjJ10pKSxcbiAgICBtZFNvcnRGbjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIHNvcnRCeSA9IF90aGlzLk1kVGFibGUuc29ydDtcbiAgICAgICAgICB2YXIgYUF0dHIgPSBnZXRPYmplY3RBdHRyaWJ1dGUoYSwgc29ydEJ5KTtcbiAgICAgICAgICB2YXIgYkF0dHIgPSBnZXRPYmplY3RBdHRyaWJ1dGUoYiwgc29ydEJ5KTtcbiAgICAgICAgICB2YXIgaXNBc2MgPSBfdGhpcy5NZFRhYmxlLnNvcnRPcmRlciA9PT0gJ2FzYyc7XG4gICAgICAgICAgdmFyIGlzTnVtYmVyID0gdHlwZW9mIGFBdHRyID09PSAnbnVtYmVyJztcblxuICAgICAgICAgIGlmIChpc051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXNjID8gYkF0dHIgLSBhQXR0ciA6IGFBdHRyIC0gYkF0dHI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gYkF0dHIubG9jYWxlQ29tcGFyZShhQXR0cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGFBdHRyLmxvY2FsZUNvbXBhcmUoYkF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1kU2VsZWN0ZWRWYWx1ZToge1xuICAgICAgdHlwZTogW0FycmF5LCBPYmplY3RdXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaXhlZEhlYWRlclBhZGRpbmc6IDAsXG4gICAgICBoYXNDb250ZW50U2Nyb2xsOiBmYWxzZSxcbiAgICAgIE1kVGFibGU6IHtcbiAgICAgICAgaXRlbXM6IHt9LFxuICAgICAgICBzb3J0OiBudWxsLFxuICAgICAgICBzb3J0T3JkZXI6IG51bGwsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRJdGVtczogW10sXG4gICAgICAgIHNlbGVjdGFibGU6IFtdLFxuICAgICAgICBmaXhlZEhlYWRlcjogbnVsbCxcbiAgICAgICAgY29udGVudFBhZGRpbmc6IG51bGwsXG4gICAgICAgIGNvbnRlbnRFbDogbnVsbCxcbiAgICAgICAgLy8gY29tcHV0ZWRcbiAgICAgICAgaGFzVmFsdWU6IHRoaXMuaGFzVmFsdWUsXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgZW1pdEV2ZW50OiB0aGlzLmVtaXRFdmVudCxcbiAgICAgICAgc29ydFRhYmxlOiB0aGlzLnNvcnRUYWJsZSxcbiAgICAgICAgbWFuYWdlSXRlbVNlbGVjdGlvbjogdGhpcy5tYW5hZ2VJdGVtU2VsZWN0aW9uLFxuICAgICAgICBnZXRNb2RlbDogdGhpcy5nZXRNb2RlbCxcbiAgICAgICAgZ2V0TW9kZWxJdGVtOiB0aGlzLmdldE1vZGVsSXRlbSxcbiAgICAgICAgc2VsZWN0aW5nTW9kZTogbnVsbFxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgY29tcHV0ZWQ6IHtcbiAgICBjb250ZW50VGFnOiBmdW5jdGlvbiBjb250ZW50VGFnKCkge1xuICAgICAgaWYgKHRoaXMubWRDYXJkKSB7XG4gICAgICAgIHJldHVybiAnbWQtY2FyZCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnbWQtY29udGVudCc7XG4gICAgfSxcbiAgICBoZWFkZXJDb3VudDogZnVuY3Rpb24gaGVhZGVyQ291bnQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5NZFRhYmxlLml0ZW1zKS5sZW5ndGg7XG4gICAgfSxcbiAgICBzZWxlY3RlZENvdW50OiBmdW5jdGlvbiBzZWxlY3RlZENvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zLmxlbmd0aDtcbiAgICB9LFxuICAgIGhlYWRlclN0eWxlczogZnVuY3Rpb24gaGVhZGVyU3R5bGVzKCkge1xuICAgICAgaWYgKHRoaXMubWRGaXhlZEhlYWRlcikge1xuICAgICAgICByZXR1cm4gJ3BhZGRpbmctcmlnaHQ6ICcgKyB0aGlzLmZpeGVkSGVhZGVyUGFkZGluZyArICdweCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNWYWx1ZTogZnVuY3Rpb24gaGFzVmFsdWUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmxlbmd0aCAhPT0gMDtcbiAgICB9LFxuICAgIGhlYWRlckNsYXNzZXM6IGZ1bmN0aW9uIGhlYWRlckNsYXNzZXMoKSB7XG4gICAgICBpZiAodGhpcy5tZEZpeGVkSGVhZGVyICYmIHRoaXMuaGFzQ29udGVudFNjcm9sbCB8fCAhdGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICByZXR1cm4gJ21kLXRhYmxlLWZpeGVkLWhlYWRlci1hY3RpdmUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGVudFN0eWxlczogZnVuY3Rpb24gY29udGVudFN0eWxlcygpIHtcbiAgICAgIGlmICh0aGlzLm1kRml4ZWRIZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuICdoZWlnaHQ6ICcgKyB0aGlzLm1kSGVpZ2h0ICsgJ3B4O21heC1oZWlnaHQ6ICcgKyB0aGlzLm1kSGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRlbnRDbGFzc2VzOiBmdW5jdGlvbiBjb250ZW50Q2xhc3NlcygpIHtcbiAgICAgIGlmICh0aGlzLm1kRml4ZWRIZWFkZXIgJiYgdGhpcy52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICdtZC10YWJsZS1lbXB0eSc7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHZhciBNZFRhYmxlID0gdGhpcy5NZFRhYmxlO1xuXG4gICAgcmV0dXJuIHsgTWRUYWJsZTogTWRUYWJsZSB9O1xuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgbWRTb3J0OiB7XG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLk1kVGFibGUuc29ydCA9IHRoaXMubWRTb3J0O1xuICAgICAgfVxuICAgIH0sXG4gICAgbWRTb3J0T3JkZXI6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zb3J0T3JkZXIgPSB0aGlzLm1kU29ydE9yZGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWRGaXhlZEhlYWRlcjoge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5NZFRhYmxlLmZpeGVkSGVhZGVyID0gdGhpcy5tZEZpeGVkSGVhZGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzVmFsdWU6IHtcbiAgICAgIGltbWVkaWF0ZTogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5oYXNWYWx1ZSA9IHRoaXMuaGFzVmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICAnTWRUYWJsZS5zZWxlY3RlZEl0ZW1zJzogZnVuY3Rpb24gTWRUYWJsZVNlbGVjdGVkSXRlbXModmFsKSB7XG4gICAgICB0aGlzLnNlbGVjdCh2YWwpO1xuICAgIH0sXG4gICAgJ01kVGFibGUuc2luZ2xlU2VsZWN0aW9uJzogZnVuY3Rpb24gTWRUYWJsZVNpbmdsZVNlbGVjdGlvbih2YWwpIHtcbiAgICAgIHRoaXMuc2VsZWN0KHZhbCk7XG4gICAgfSxcbiAgICBtZFNlbGVjdGVkVmFsdWU6IGZ1bmN0aW9uIG1kU2VsZWN0ZWRWYWx1ZSgpIHtcbiAgICAgIHRoaXMuc3luY1NlbGVjdGVkVmFsdWUoKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBlbWl0RXZlbnQ6IGZ1bmN0aW9uIGVtaXRFdmVudChldmVudE5hbWUsIHZhbHVlKSB7XG4gICAgICB0aGlzLiRlbWl0KGV2ZW50TmFtZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgZ2V0Um93SWQ6IGZ1bmN0aW9uIGdldFJvd0lkKGlkKSB7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ21kLXJvdy0nICsgKDAsIF9NZFV1aWQyLmRlZmF1bHQpKCk7XG4gICAgfSxcbiAgICBzZXRTY3JvbGw6IGZ1bmN0aW9uIHNldFNjcm9sbCgkZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAoMCwgX3JhZjIuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuaGFzQ29udGVudFNjcm9sbCA9ICRldmVudC50YXJnZXQuc2Nyb2xsVG9wID4gMDtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0Q29udGVudEVsOiBmdW5jdGlvbiBnZXRDb250ZW50RWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLm1kLXRhYmxlLWNvbnRlbnQnKTtcbiAgICB9LFxuICAgIHNldENvbnRlbnRFbDogZnVuY3Rpb24gc2V0Q29udGVudEVsKCkge1xuICAgICAgdGhpcy5NZFRhYmxlLmNvbnRlbnRFbCA9IHRoaXMuZ2V0Q29udGVudEVsKCk7XG4gICAgfSxcbiAgICBzZXRIZWFkZXJQYWRkaW5nOiBmdW5jdGlvbiBzZXRIZWFkZXJQYWRkaW5nKCkge1xuICAgICAgdGhpcy5zZXRDb250ZW50RWwoKTtcblxuICAgICAgdmFyIGNvbnRlbnRFbCA9IHRoaXMuTWRUYWJsZS5jb250ZW50RWw7XG5cbiAgICAgIHZhciB0YWJsZUVsID0gY29udGVudEVsLmNoaWxkTm9kZXNbMF07XG5cbiAgICAgIHRoaXMuZml4ZWRIZWFkZXJQYWRkaW5nID0gY29udGVudEVsLm9mZnNldFdpZHRoIC0gdGFibGVFbC5vZmZzZXRXaWR0aDtcbiAgICB9LFxuICAgIGdldE1vZGVsOiBmdW5jdGlvbiBnZXRNb2RlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgZ2V0TW9kZWxJdGVtOiBmdW5jdGlvbiBnZXRNb2RlbEl0ZW0oaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlW2luZGV4XTtcbiAgICB9LFxuICAgIG1hbmFnZUl0ZW1TZWxlY3Rpb246IGZ1bmN0aW9uIG1hbmFnZUl0ZW1TZWxlY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zID0gdGhpcy5NZFRhYmxlLnNlbGVjdGVkSXRlbXMuZmlsdGVyKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ICE9PSBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzb3J0VGFibGU6IGZ1bmN0aW9uIHNvcnRUYWJsZSgpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5tZFNvcnRGbih0aGlzLnZhbHVlKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Q6IGZ1bmN0aW9uIHNlbGVjdCh2YWwpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTptZFNlbGVjdGVkVmFsdWUnLCB2YWwpO1xuICAgICAgdGhpcy4kZW1pdCgnbWQtc2VsZWN0ZWQnLCB2YWwpO1xuICAgIH0sXG4gICAgc3luY1NlbGVjdGVkVmFsdWU6IGZ1bmN0aW9uIHN5bmNTZWxlY3RlZFZhbHVlKCkge1xuICAgICAgc3dpdGNoICh0aGlzLk1kVGFibGUuc2VsZWN0aW5nTW9kZSkge1xuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgIHRoaXMuTWRUYWJsZS5zaW5nbGVTZWxlY3Rpb24gPSB0aGlzLm1kU2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbXVsdGlwbGUnOlxuICAgICAgICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zID0gdGhpcy5tZFNlbGVjdGVkVmFsdWUgfHwgW107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB0aGlzLnN5bmNTZWxlY3RlZFZhbHVlKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSgpLFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHRoaXMuc2V0Q29udGVudEVsKCk7XG5cbiAgICBpZiAodGhpcy5tZEZpeGVkSGVhZGVyKSB7XG4gICAgICB0aGlzLnNldEhlYWRlclBhZGRpbmcoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhZ1N3aXRjaGVyX3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNTcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhZ1N3aXRjaGVyX3Z1ZV9fX2RlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLm4oX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kVGFnU3dpdGNoZXJfdnVlX18pO1xudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kVGFnU3dpdGNoZXJfdnVlX19fZGVmYXVsdC5hLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWdTd2l0Y2hlci9NZFRhZ1N3aXRjaGVyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTZmMDdhMzk5XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNmYwN2EzOTlcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBtZFRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RpdidcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQsIF9yZWYpIHtcbiAgICB2YXIgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIGxpc3RlbmVycyA9IF9yZWYubGlzdGVuZXJzO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQocHJvcHMubWRUYWcsIF9leHRlbmRzKHt9LCBkYXRhLCB7XG4gICAgICBvbjogbGlzdGVuZXJzXG4gICAgfSksIGNoaWxkcmVuKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZVRoZWFkLnZ1ZVxudmFyIE1kVGFibGVUaGVhZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzU5KTtcbnZhciBNZFRhYmxlVGhlYWRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJsZVRoZWFkKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04YTgzOTJmNlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVUaGVhZC52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJ0aGVhZFwiLCBbXG4gICAgX2MoXG4gICAgICBcInRyXCIsXG4gICAgICBbXG4gICAgICAgIF9jKFwibWQtdGFibGUtaGVhZC1zZWxlY3Rpb25cIiksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF92bS5fbChfdm0uTWRUYWJsZS5pdGVtcywgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICBcIm1kLXRhYmxlLWhlYWRcIixcbiAgICAgICAgICAgIF92bS5fYih7IGtleTogaW5kZXggfSwgXCJtZC10YWJsZS1oZWFkXCIsIGl0ZW0sIGZhbHNlKVxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICAyXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFRhYmxlX01kVGFibGVUaGVhZCA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtOGE4MzkyZjZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZVRoZWFkLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZVRoZWFkX2RlZmF1bHQuYSxcbiAgTWRUYWJsZV9NZFRhYmxlVGhlYWQsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVUaGVhZC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi04YTgzOTJmNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LThhODM5MmY2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZVRoZWFkID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfTWRUYWJsZUhlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIF9NZFRhYmxlSGVhZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlSGVhZCk7XG5cbnZhciBfTWRUYWJsZUhlYWRTZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2NCk7XG5cbnZhciBfTWRUYWJsZUhlYWRTZWxlY3Rpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWJsZUhlYWRTZWxlY3Rpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kVGFibGVUaGVhZCcsXG4gIGluamVjdDogWydNZFRhYmxlJ10sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZFRhYmxlSGVhZDogX01kVGFibGVIZWFkMi5kZWZhdWx0LFxuICAgIE1kVGFibGVIZWFkU2VsZWN0aW9uOiBfTWRUYWJsZUhlYWRTZWxlY3Rpb24yLmRlZmF1bHRcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFVwd2FyZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Mik7XG5cbnZhciBfTWRVcHdhcmRJY29uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVXB3YXJkSWNvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBnZW4gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IHN0ZXAoXCJuZXh0XCIsIHZhbHVlKTsgfSwgZnVuY3Rpb24gKGVycikgeyBzdGVwKFwidGhyb3dcIiwgZXJyKTsgfSk7IH0gfSByZXR1cm4gc3RlcChcIm5leHRcIik7IH0pOyB9OyB9IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlSGVhZCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNZFVwd2FyZEljb246IF9NZFVwd2FyZEljb24yLmRlZmF1bHRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtZE51bWVyaWM6IEJvb2xlYW4sXG4gICAgbnVtZXJpYzogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIHRvb2x0aXA6IFN0cmluZyxcbiAgICBzb3J0Qnk6IFN0cmluZ1xuICB9LFxuICBpbmplY3Q6IFsnTWRUYWJsZSddLFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogbnVsbFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzU29ydDogZnVuY3Rpb24gaGFzU29ydCgpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kVGFibGUuc29ydCAmJiB0aGlzLnNvcnRCeTtcbiAgICB9LFxuICAgIGlzU29ydGVkOiBmdW5jdGlvbiBpc1NvcnRlZCgpIHtcbiAgICAgIGlmICh0aGlzLk1kVGFibGUuc29ydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5NZFRhYmxlLnNvcnQgPT09IHRoaXMuc29ydEJ5O1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNEZXNjU29ydGVkOiBmdW5jdGlvbiBpc0Rlc2NTb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1NvcnRlZCAmJiB0aGlzLk1kVGFibGUuc29ydE9yZGVyID09PSAnZGVzYyc7XG4gICAgfSxcbiAgICBpc0FzY1NvcnRlZDogZnVuY3Rpb24gaXNBc2NTb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1NvcnRlZCAmJiB0aGlzLk1kVGFibGUuc29ydE9yZGVyID09PSAnYXNjJztcbiAgICB9LFxuICAgIGhlYWRTdHlsZXM6IGZ1bmN0aW9uIGhlYWRTdHlsZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCArICdweCdcbiAgICAgIH07XG4gICAgfSxcbiAgICBoZWFkQ2xhc3NlczogZnVuY3Rpb24gaGVhZENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWQtbnVtZXJpYyc6IHRoaXMubnVtZXJpYyB8fCB0aGlzLm1kTnVtZXJpYyxcbiAgICAgICAgJ21kLXNvcnRhYmxlJzogdGhpcy5oYXNTb3J0LFxuICAgICAgICAnbWQtc29ydGVkJzogdGhpcy5pc1NvcnRlZCxcbiAgICAgICAgJ21kLXNvcnRlZC1kZXNjJzogdGhpcy5pc0Rlc2NTb3J0ZWRcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgY2hhbmdlU29ydDogZnVuY3Rpb24gY2hhbmdlU29ydCgpIHtcbiAgICAgIGlmICh0aGlzLmhhc1NvcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBc2NTb3J0ZWQpIHtcbiAgICAgICAgICB0aGlzLk1kVGFibGUuc29ydE9yZGVyID0gJ2Rlc2MnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuTWRUYWJsZS5zb3J0T3JkZXIgPSAnYXNjJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuTWRUYWJsZS5zb3J0ID0gdGhpcy5zb3J0Qnk7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5lbWl0RXZlbnQoJ21kLXNvcnRlZCcsIHRoaXMuTWRUYWJsZS5zb3J0KTtcbiAgICAgICAgdGhpcy5NZFRhYmxlLmVtaXRFdmVudCgndXBkYXRlOm1kU29ydCcsIHRoaXMuTWRUYWJsZS5zb3J0KTtcbiAgICAgICAgdGhpcy5NZFRhYmxlLmVtaXRFdmVudCgndXBkYXRlOm1kU29ydE9yZGVyJywgdGhpcy5NZFRhYmxlLnNvcnRPcmRlcik7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zb3J0VGFibGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldENoaWxkTm9kZXNCeVNlbGVjdG9yOiBmdW5jdGlvbiBnZXRDaGlsZE5vZGVzQnlTZWxlY3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgY2xhc3NMaXN0ID0gX3JlZi5jbGFzc0xpc3Q7XG4gICAgICAgIHJldHVybiBjbGFzc0xpc3QgJiYgY2xhc3NMaXN0LmNvbnRhaW5zKHNlbGVjdG9yKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0Tm9kZUluZGV4OiBmdW5jdGlvbiBnZXROb2RlSW5kZXgobm9kZXMsIGVsKSB7XG4gICAgICByZXR1cm4gW10uaW5kZXhPZi5jYWxsKG5vZGVzLCBlbCk7XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gc2V0V2lkdGgoKSB7XG4gICAgICBpZiAodGhpcy5NZFRhYmxlLmZpeGVkSGVhZGVyKSB7XG4gICAgICAgIHZhciBjZWxsU2VsZWN0b3IgPSAnbWQtdGFibGUtY2VsbCc7XG4gICAgICAgIHZhciB0aEVscyA9IHRoaXMuZ2V0Q2hpbGROb2Rlc0J5U2VsZWN0b3IodGhpcy4kZWwucGFyZW50Tm9kZSwgJ21kLXRhYmxlLWhlYWQnKTtcbiAgICAgICAgdmFyIHRkRWxzID0gdGhpcy5NZFRhYmxlLmNvbnRlbnRFbC5xdWVyeVNlbGVjdG9yQWxsKCd0cjpmaXJzdC1jaGlsZCAuJyArIGNlbGxTZWxlY3Rvcik7XG4gICAgICAgIHZhciBub2RlSW5kZXggPSB0aGlzLmdldE5vZGVJbmRleCh0aEVscywgdGhpcy4kZWwpO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSB0ZEVsc1tub2RlSW5kZXhdLm9mZnNldFdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdXBkYXRlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgoKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfSgpLFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdGhpcy5zZXRXaWR0aCgpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH0oKVxufTtcblxuLyoqKi8gfSksXG4vKiAzNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb3JlL2ljb25zL01kVXB3YXJkSWNvbi52dWVcbnZhciBNZFVwd2FyZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Myk7XG52YXIgTWRVcHdhcmRJY29uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kVXB3YXJkSWNvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMjM1ZjE5N2FcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvcmUvaWNvbnMvTWRVcHdhcmRJY29uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMCwgZmFsc2UsIHRydWUpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC1pY29uLWltYWdlXCIgfSwgW1xuICAgICAgX2MoXG4gICAgICAgIFwic3ZnXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBcIjI0XCIsXG4gICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiMjRcIixcbiAgICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcInBhdGhcIiwgeyBhdHRyczogeyBkOiBcIk0wIDBoMjR2MjRIMFYwelwiLCBmaWxsOiBcIm5vbmVcIiB9IH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgIGQ6IFwiTTQgMTJsMS40MSAxLjQxTDExIDcuODNWMjBoMlY3LjgzbDUuNTggNS41OUwyMCAxMmwtOC04LTggOHpcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICAgIClcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpY29uc19NZFVwd2FyZEljb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTIzNWYxOTdhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9pY29ucy9NZFVwd2FyZEljb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFVwd2FyZEljb25fZGVmYXVsdC5hLFxuICBpY29uc19NZFVwd2FyZEljb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29yZS9pY29ucy9NZFVwd2FyZEljb24udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMjM1ZjE5N2FcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0yMzVmMTk3YVwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9pY29uc19NZFVwd2FyZEljb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgX01kSWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEljb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFVwd2FyZEljb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRJY29uOiBfTWRJY29uMi5kZWZhdWx0XG4gIH1cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUhlYWRTZWxlY3Rpb24udnVlXG52YXIgTWRUYWJsZUhlYWRTZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2NSk7XG52YXIgTWRUYWJsZUhlYWRTZWxlY3Rpb25fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJsZUhlYWRTZWxlY3Rpb24pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTdmYTMxY2JkXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUhlYWRTZWxlY3Rpb24udnVlXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5zZWxlY3RhYmxlQ291bnRcbiAgICA/IF9jKFwibWQtdGFibGUtaGVhZFwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLXRhYmxlLWNlbGwtc2VsZWN0aW9uXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtY2VsbC1jb250YWluZXJcIiB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwibWQtY2hlY2tib3hcIiwge1xuICAgICAgICAgICAgICBhdHRyczogeyBtb2RlbDogX3ZtLmFsbFNlbGVjdGVkLCBkaXNhYmxlZDogX3ZtLmlzRGlzYWJsZWQgfSxcbiAgICAgICAgICAgICAgb246IHsgY2hhbmdlOiBfdm0ub25DaGFuZ2UgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgXSlcbiAgICA6IF92bS5fZSgpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGFibGVfTWRUYWJsZUhlYWRTZWxlY3Rpb24gPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTdmYTMxY2JkXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVIZWFkU2VsZWN0aW9uLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZUhlYWRTZWxlY3Rpb25fZGVmYXVsdC5hLFxuICBNZFRhYmxlX01kVGFibGVIZWFkU2VsZWN0aW9uLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlSGVhZFNlbGVjdGlvbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03ZmEzMWNiZFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTdmYTMxY2JkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZUhlYWRTZWxlY3Rpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFRhYmxlSGVhZCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgX01kVGFibGVIZWFkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGFibGVIZWFkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRUYWJsZUhlYWRTZWxlY3Rpb24nLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRUYWJsZUhlYWQ6IF9NZFRhYmxlSGVhZDIuZGVmYXVsdFxuICB9LFxuICBpbmplY3Q6IFsnTWRUYWJsZSddLFxuICBjb21wdXRlZDoge1xuICAgIHNlbGVjdGFibGVDb3VudDogZnVuY3Rpb24gc2VsZWN0YWJsZUNvdW50KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2VsZWN0YWJsZSkubGVuZ3RoO1xuICAgIH0sXG4gICAgaXNEaXNhYmxlZDogZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5zZWxlY3RhYmxlQ291bnQ7XG4gICAgfSxcbiAgICBzZWxlY3RhYmxlOiBmdW5jdGlvbiBzZWxlY3RhYmxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRUYWJsZS5zZWxlY3RhYmxlO1xuICAgIH0sXG4gICAgc2VsZWN0ZWRJdGVtczogZnVuY3Rpb24gc2VsZWN0ZWRJdGVtcygpIHtcbiAgICAgIHJldHVybiB0aGlzLk1kVGFibGUuc2VsZWN0ZWRJdGVtcztcbiAgICB9LFxuICAgIGFsbFNlbGVjdGVkOiBmdW5jdGlvbiBhbGxTZWxlY3RlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnNlbGVjdGFibGVDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGFibGUuZXZlcnkoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmFsKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLk1kVGFibGUuc2VsZWN0ZWRJdGVtcyA9IHRoaXMuc2VsZWN0ZWRJdGVtcy5jb25jYXQodGhpcy5zZWxlY3RhYmxlLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAhX3RoaXMyLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RlZEl0ZW1zID0gdGhpcy5zZWxlY3RlZEl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAhX3RoaXMyLnNlbGVjdGFibGUuaW5jbHVkZXMoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbi8qKiovIH0pLFxuLyogMzY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVBbHRlcm5hdGVIZWFkZXIudnVlXG52YXIgTWRUYWJsZUFsdGVybmF0ZUhlYWRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzY4KTtcbnZhciBNZFRhYmxlQWx0ZXJuYXRlSGVhZGVyX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kVGFibGVBbHRlcm5hdGVIZWFkZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQyNDFjMTE4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUFsdGVybmF0ZUhlYWRlci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJ0cmFuc2l0aW9uXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJtZC10YWJsZS1hbHRlcm5hdGUtaGVhZGVyXCIgfSB9LCBbXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdGF0aWNDbGFzczogXCJtZC10YWJsZS1hbHRlcm5hdGUtaGVhZGVyXCIgfSxcbiAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgIDJcbiAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGFibGVfTWRUYWJsZUFsdGVybmF0ZUhlYWRlciA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDI0MWMxMThcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZUFsdGVybmF0ZUhlYWRlci52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2Nylcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kVGFibGVBbHRlcm5hdGVIZWFkZXJfZGVmYXVsdC5hLFxuICBNZFRhYmxlX01kVGFibGVBbHRlcm5hdGVIZWFkZXIsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVBbHRlcm5hdGVIZWFkZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChmYWxzZSkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDI0MWMxMThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00MjQxYzExOFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19NZFRhYmxlX01kVGFibGVBbHRlcm5hdGVIZWFkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlQWx0ZXJuYXRlSGVhZGVyJ1xufTtcblxuLyoqKi8gfSksXG4vKiAzNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kUHJvcFZhbGlkYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUHJvcFZhbGlkYXRvcik7XG5cbnZhciBfTWRUYWJsZUNlbGxTZWxlY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcblxudmFyIF9NZFRhYmxlQ2VsbFNlbGVjdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRhYmxlQ2VsbFNlbGVjdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kVGFibGVSb3cnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRUYWJsZUNlbGxTZWxlY3Rpb246IF9NZFRhYmxlQ2VsbFNlbGVjdGlvbjIuZGVmYXVsdFxuICB9LFxuICBwcm9wczoge1xuICAgIG1kSW5kZXg6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgbWRJZDogW051bWJlciwgU3RyaW5nXSxcbiAgICBtZFNlbGVjdGFibGU6IF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IFtTdHJpbmddXG4gICAgfSwgKDAsIF9NZFByb3BWYWxpZGF0b3IyLmRlZmF1bHQpKCdtZC1zZWxlY3RhYmxlJywgWydtdWx0aXBsZScsICdzaW5nbGUnXSkpLFxuICAgIG1kRGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbWRBdXRvU2VsZWN0OiBCb29sZWFuLFxuICAgIG1kSXRlbTogT2JqZWN0XG4gIH0sXG4gIGluamVjdDogWydNZFRhYmxlJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBudWxsLFxuICAgICAgaXNTZWxlY3RlZDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNlbGVjdGFibGVDb3VudDogZnVuY3Rpb24gc2VsZWN0YWJsZUNvdW50KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuTWRUYWJsZS5zZWxlY3RhYmxlKS5sZW5ndGg7XG4gICAgfSxcbiAgICBpc1NpbmdsZVNlbGVjdGVkOiBmdW5jdGlvbiBpc1NpbmdsZVNlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRUYWJsZS5zaW5nbGVTZWxlY3Rpb24gPT09IHRoaXMubWRJdGVtO1xuICAgIH0sXG4gICAgaGFzTXVsdGlwbGVTZWxlY3Rpb246IGZ1bmN0aW9uIGhhc011bHRpcGxlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRUYWJsZS5oYXNWYWx1ZSAmJiB0aGlzLm1kU2VsZWN0YWJsZSA9PT0gJ211bHRpcGxlJztcbiAgICB9LFxuICAgIGhhc1NpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gaGFzU2luZ2xlU2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuTWRUYWJsZS5oYXNWYWx1ZSAmJiB0aGlzLm1kU2VsZWN0YWJsZSA9PT0gJ3NpbmdsZSc7XG4gICAgfSxcbiAgICByb3dDbGFzc2VzOiBmdW5jdGlvbiByb3dDbGFzc2VzKCkge1xuICAgICAgaWYgKHRoaXMuTWRUYWJsZS5oYXNWYWx1ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdtZC1oYXMtc2VsZWN0aW9uJzogIXRoaXMubWREaXNhYmxlZCAmJiAodGhpcy5tZEF1dG9TZWxlY3QgfHwgdGhpcy5oYXNTaW5nbGVTZWxlY3Rpb24pLFxuICAgICAgICAgICdtZC1zZWxlY3RlZCc6IHRoaXMuaXNTZWxlY3RlZCxcbiAgICAgICAgICAnbWQtc2VsZWN0ZWQtc2luZ2xlJzogdGhpcy5pc1NpbmdsZVNlbGVjdGVkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0luU2VsZWN0ZWRJdGVtczogZnVuY3Rpb24gaXNJblNlbGVjdGVkSXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5NZFRhYmxlLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXModGhpcy5tZEl0ZW0pO1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZERpc2FibGVkOiBmdW5jdGlvbiBtZERpc2FibGVkKCkge1xuICAgICAgaWYgKHRoaXMubWREaXNhYmxlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGFibGVJdGVtKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFNlbGVjdGFibGVJdGVtKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbiBpc1NlbGVjdGVkKHZhbCkge1xuICAgICAgdmFyIG5vQ2hhbmdlID0gdmFsICYmIHRoaXMuaXNJblNlbGVjdGVkSXRlbXMgfHwgIXZhbCAmJiAhdGhpcy5pc0luU2VsZWN0ZWRJdGVtcztcblxuICAgICAgaWYgKG5vQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5NZFRhYmxlLm1hbmFnZUl0ZW1TZWxlY3Rpb24odGhpcy5tZEl0ZW0pO1xuICAgIH0sXG4gICAgaXNJblNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uIGlzSW5TZWxlY3RlZEl0ZW1zKHZhbCkge1xuICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdmFsO1xuICAgIH0sXG4gICAgbWRTZWxlY3RhYmxlOiBmdW5jdGlvbiBtZFNlbGVjdGFibGUoKSB7XG4gICAgICB0aGlzLk1kVGFibGUuc2VsZWN0aW5nTW9kZSA9IHRoaXMubWRTZWxlY3RhYmxlO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICBpZiAodGhpcy5NZFRhYmxlLmhhc1ZhbHVlICYmICF0aGlzLm1kRGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTXVsdGlwbGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdFJvd0lmTXVsdGlwbGUoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1NpbmdsZVNlbGVjdGlvbikge1xuICAgICAgICAgIHRoaXMuc2VsZWN0Um93SWZTaW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdG9nZ2xlU2VsZWN0aW9uOiBmdW5jdGlvbiB0b2dnbGVTZWxlY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSAhdGhpcy5pc1NlbGVjdGVkO1xuICAgIH0sXG4gICAgc2VsZWN0Um93SWZTaW5nbGU6IGZ1bmN0aW9uIHNlbGVjdFJvd0lmU2luZ2xlKCkge1xuICAgICAgaWYgKHRoaXMuTWRUYWJsZS5zaW5nbGVTZWxlY3Rpb24gPT09IHRoaXMubWRJdGVtKSB7XG4gICAgICAgIHRoaXMuTWRUYWJsZS5zaW5nbGVTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5NZFRhYmxlLnNpbmdsZVNlbGVjdGlvbiA9IHRoaXMubWRJdGVtO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0Um93SWZNdWx0aXBsZTogZnVuY3Rpb24gc2VsZWN0Um93SWZNdWx0aXBsZSgpIHtcbiAgICAgIGlmICh0aGlzLm1kQXV0b1NlbGVjdCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkU2VsZWN0YWJsZUl0ZW06IGZ1bmN0aW9uIGFkZFNlbGVjdGFibGVJdGVtKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc011bHRpcGxlU2VsZWN0aW9uIHx8IHRoaXMubWREaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLk1kVGFibGUuc2VsZWN0YWJsZS5pbmNsdWRlcyh0aGlzLm1kSXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLk1kVGFibGUuc2VsZWN0YWJsZS5wdXNoKHRoaXMubWRJdGVtKTtcbiAgICB9LFxuICAgIHJlbW92ZVNlbGVjdGFibGVJdGVtOiBmdW5jdGlvbiByZW1vdmVTZWxlY3RhYmxlSXRlbSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5oYXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RhYmxlID0gdGhpcy5NZFRhYmxlLnNlbGVjdGFibGUuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBfdGhpcy5tZEl0ZW07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5hZGRTZWxlY3RhYmxlSXRlbSgpO1xuICAgIHRoaXMuTWRUYWJsZS5zZWxlY3RpbmdNb2RlID0gdGhpcy5tZFNlbGVjdGFibGU7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVTZWxlY3RhYmxlSXRlbSgpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDM3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgbmFtZTogJ01kVGFibGVDZWxsU2VsZWN0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogQm9vbGVhbixcbiAgICBtZFJvd0lkOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIG1kU2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBtZERpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDogWydNZFRhYmxlJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICB0aGlzLmlzU2VsZWN0ZWQgPSB0aGlzLnZhbHVlO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy5pc1NlbGVjdGVkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhYmxlUm93R2hvc3RfdnVlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3NCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kVGFibGVSb3dHaG9zdF92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhYmxlUm93R2hvc3RfdnVlX18pO1xudmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gbnVsbFxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kVGFibGVSb3dHaG9zdF92dWVfX19kZWZhdWx0LmEsXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVSb3dHaG9zdC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1iMWQ2YTY5OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWIxZDZhNjk4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDM3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRUYWJsZVJvd0dob3N0JyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbWRJbmRleDogW1N0cmluZywgTnVtYmVyXSxcbiAgICBtZElkOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgIG1kSXRlbTogT2JqZWN0XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRbMF0uY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEubWRJbmRleCA9IHRoaXMubWRJbmRleDtcbiAgICB0aGlzLiRzbG90cy5kZWZhdWx0WzBdLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLm1kSWQgPSB0aGlzLm1kSWQ7XG4gICAgdGhpcy4kc2xvdHMuZGVmYXVsdFswXS5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YS5tZEl0ZW0gPSB0aGlzLm1kSXRlbTtcblxuICAgIHJldHVybiB0aGlzLiRzbG90cy5kZWZhdWx0WzBdO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlVG9vbGJhci52dWVcbnZhciBNZFRhYmxlVG9vbGJhciA9IF9fd2VicGFja19yZXF1aXJlX18oMzc3KTtcbnZhciBNZFRhYmxlVG9vbGJhcl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFRhYmxlVG9vbGJhcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtM2Y2ZjQwMjhcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlVG9vbGJhci52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC10b29sYmFyXCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtdG9vbGJhciBtZC10cmFuc3BhcmVudFwiLFxuICAgICAgYXR0cnM6IHsgXCJtZC1lbGV2YXRpb25cIjogMCB9XG4gICAgfSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGFibGVfTWRUYWJsZVRvb2xiYXIgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTNmNmY0MDI4XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVUb29sYmFyLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzc2KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZVRvb2xiYXJfZGVmYXVsdC5hLFxuICBNZFRhYmxlX01kVGFibGVUb29sYmFyLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlVG9vbGJhci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zZjZmNDAyOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTNmNmY0MDI4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZVRvb2xiYXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZFRvb2xiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIF9NZFRvb2xiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUb29sYmFyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRUYWJsZVRvb2xiYXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRUb29sYmFyOiBfTWRUb29sYmFyMi5kZWZhdWx0XG4gIH0sXG4gIGluamVjdDogWydNZFRhYmxlJ11cbn07IC8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuLyoqKi8gfSksXG4vKiAzNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzNzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZENvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfTWRDb21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgX01kQ29tcG9uZW50Mi5kZWZhdWx0KHtcbiAgbmFtZTogJ01kVG9vbGJhcicsXG4gIHByb3BzOiB7XG4gICAgbWRFbGV2YXRpb246IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiA0XG4gICAgfVxuICB9XG59KTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG4vKioqLyB9KSxcbi8qIDM4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlRW1wdHlTdGF0ZS52dWVcbnZhciBNZFRhYmxlRW1wdHlTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgyKTtcbnZhciBNZFRhYmxlRW1wdHlTdGF0ZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihNZFRhYmxlRW1wdHlTdGF0ZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNmY4NDc0M2FcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vc3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlRW1wdHlTdGF0ZS52dWVcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJtZC1lbXB0eS1zdGF0ZVwiLFxuICAgIF92bS5fYihcbiAgICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtZW1wdHktc3RhdGVcIiB9LFxuICAgICAgXCJtZC1lbXB0eS1zdGF0ZVwiLFxuICAgICAgX3ZtLiRwcm9wcyxcbiAgICAgIGZhbHNlXG4gICAgKSxcbiAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgMlxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGFibGVfTWRUYWJsZUVtcHR5U3RhdGUgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTZmODQ3NDNhXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVFbXB0eVN0YXRlLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzgxKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZUVtcHR5U3RhdGVfZGVmYXVsdC5hLFxuICBNZFRhYmxlX01kVGFibGVFbXB0eVN0YXRlLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlRW1wdHlTdGF0ZS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02Zjg0NzQzYVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTZmODQ3NDNhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZUVtcHR5U3RhdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9NZEVtcHR5U3RhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIF9NZEVtcHR5U3RhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRFbXB0eVN0YXRlKTtcblxudmFyIF9NZEVtcHR5U3RhdGVQcm9wcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG52YXIgX01kRW1wdHlTdGF0ZVByb3BzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kRW1wdHlTdGF0ZVByb3BzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlRW1wdHlTdGF0ZScsXG4gIHByb3BzOiBfTWRFbXB0eVN0YXRlUHJvcHMyLmRlZmF1bHQsXG4gIGluamVjdDogWydNZFRhYmxlJ11cbn07XG5cbi8qKiovIH0pLFxuLyogMzgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsLnZ1ZVxudmFyIE1kVGFibGVDZWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODUpO1xudmFyIE1kVGFibGVDZWxsX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kVGFibGVDZWxsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi04MTNkNmI3ZVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcInRkXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtY2VsbFwiLCBjbGFzczogX3ZtLmNlbGxDbGFzc2VzIH0sIFtcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXRhYmxlLWNlbGwtY29udGFpbmVyXCIgfSxcbiAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgIDJcbiAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1kVGFibGVfTWRUYWJsZUNlbGwgPSAoZXNFeHBvcnRzKTtcbmlmIChmYWxzZSkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTgxM2Q2YjdlXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVDZWxsLnZ1ZVxudmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMzg0KVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xuXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgTWRUYWJsZUNlbGxfZGVmYXVsdC5hLFxuICBNZFRhYmxlX01kVGFibGVDZWxsLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJsZS9NZFRhYmxlQ2VsbC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi04MTNkNmI3ZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTgxM2Q2YjdlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFibGVfTWRUYWJsZUNlbGwgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlQ2VsbCcsXG4gIHByb3BzOiB7XG4gICAgbWRMYWJlbDogU3RyaW5nLFxuICAgIG1kTnVtZXJpYzogQm9vbGVhbixcbiAgICBtZFRvb2x0aXA6IFN0cmluZyxcbiAgICBtZFNvcnRCeTogU3RyaW5nXG4gIH0sXG4gIGluamVjdDogWydNZFRhYmxlJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBudWxsLFxuICAgICAgcGFyZW50Tm9kZTogbnVsbFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2VsbENsYXNzZXM6IGZ1bmN0aW9uIGNlbGxDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kLW51bWVyaWMnOiB0aGlzLm1kTnVtZXJpY1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRTb3J0Qnk6IGZ1bmN0aW9uIG1kU29ydEJ5KCkge1xuICAgICAgdGhpcy5zZXRDZWxsRGF0YSgpO1xuICAgIH0sXG4gICAgbWROdW1lcmljOiBmdW5jdGlvbiBtZE51bWVyaWMoKSB7XG4gICAgICB0aGlzLnNldENlbGxEYXRhKCk7XG4gICAgfSxcbiAgICBtZExhYmVsOiBmdW5jdGlvbiBtZExhYmVsKCkge1xuICAgICAgdGhpcy5zZXRDZWxsRGF0YSgpO1xuICAgIH0sXG4gICAgbWRUb29sdGlwOiBmdW5jdGlvbiBtZFRvb2x0aXAoKSB7XG4gICAgICB0aGlzLnNldENlbGxEYXRhKCk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0Q2VsbERhdGE6IGZ1bmN0aW9uIHNldENlbGxEYXRhKCkge1xuICAgICAgdmFyICR2bSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcztcblxuICAgICAgdGhpcy4kc2V0KHRoaXMuTWRUYWJsZS5pdGVtcywgJHZtLmluZGV4LCB7XG4gICAgICAgIGxhYmVsOiAkdm0ubWRMYWJlbCxcbiAgICAgICAgbnVtZXJpYzogJHZtLm1kTnVtZXJpYyxcbiAgICAgICAgdG9vbHRpcDogJHZtLm1kVG9vbHRpcCxcbiAgICAgICAgc29ydEJ5OiAkdm0ubWRTb3J0QnlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlQWxsQ2VsbERhdGE6IGZ1bmN0aW9uIHVwZGF0ZUFsbENlbGxEYXRhKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5NZFRhYmxlLml0ZW1zID0ge307XG5cbiAgICAgIHZhciBjZWxscyA9IEFycmF5LmZyb20odGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdGFnTmFtZSA9IF9yZWYudGFnTmFtZSxcbiAgICAgICAgICAgIGNsYXNzTGlzdCA9IF9yZWYuY2xhc3NMaXN0O1xuXG4gICAgICAgIHZhciBpc1NlbGVjdGlvbiA9IGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29udGFpbnMoJ21kLXRhYmxlLWNlbGwtc2VsZWN0aW9uJyk7XG4gICAgICAgIHZhciBpc1RkID0gdGFnTmFtZSAmJiB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZCc7XG5cbiAgICAgICAgcmV0dXJuIGlzVGQgJiYgIWlzU2VsZWN0aW9uO1xuICAgICAgfSk7XG5cbiAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwsIGluZGV4KSB7XG4gICAgICAgIHZhciAkdm0gPSBjZWxsLl9fdnVlX187XG5cbiAgICAgICAgJHZtLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgX3RoaXMuc2V0Q2VsbERhdGEoJHZtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUgPSB0aGlzLiRlbC5wYXJlbnROb2RlO1xuICAgIHRoaXMudXBkYXRlQWxsQ2VsbERhdGEoKTtcbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgdmFyIHJvd1JlbW92ZWQgPSB0aGlzLiRlbC5wYXJlbnROb2RlICE9PSBudWxsO1xuXG4gICAgaWYgKHJvd1JlbW92ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFsbENlbGxEYXRhKCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVQYWdpbmF0aW9uLnZ1ZVxudmFyIE1kVGFibGVQYWdpbmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODgpO1xudmFyIE1kVGFibGVQYWdpbmF0aW9uX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKE1kVGFibGVQYWdpbmF0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00MTY1Njk4ZVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVQYWdpbmF0aW9uLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtcGFnaW5hdGlvblwiIH0sXG4gICAgW1xuICAgICAgX3ZtLm1kUGFnZU9wdGlvbnMgIT09IGZhbHNlXG4gICAgICAgID8gW1xuICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFibGUtcGFnaW5hdGlvbi1sYWJlbFwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ubWRMYWJlbCkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgXCJtZC1maWVsZFwiLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcIm1kLXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwibWQtZGVuc2VcIjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICBcIm1kLWNsYXNzXCI6IFwibWQtcGFnaW5hdGlvbi1zZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbjogeyBjaGFuZ2VkOiBfdm0uc2V0UGFnZVNpemUgfSxcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmN1cnJlbnRQYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uY3VycmVudFBhZ2VTaXplID0gJCR2XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImN1cnJlbnRQYWdlU2l6ZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLm1kUGFnZU9wdGlvbnMsIGZ1bmN0aW9uKGFtb3VudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJtZC1vcHRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGtleTogYW1vdW50LCBhdHRyczogeyB2YWx1ZTogYW1vdW50IH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KF92bS5fcyhhbW91bnQpKV1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJzcGFuXCIsIFtcbiAgICAgICAgX3ZtLl92KFxuICAgICAgICAgIF92bS5fcyhfdm0uY3VycmVudEl0ZW1Db3VudCkgK1xuICAgICAgICAgICAgXCItXCIgK1xuICAgICAgICAgICAgX3ZtLl9zKF92bS5jdXJyZW50UGFnZUNvdW50KSArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBfdm0uX3MoX3ZtLm1kU2VwYXJhdG9yKSArXG4gICAgICAgICAgICBcIiBcIiArXG4gICAgICAgICAgICBfdm0uX3MoX3ZtLm1kVG90YWwpXG4gICAgICAgIClcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtaWNvbi1idXR0b24gbWQtdGFibGUtcGFnaW5hdGlvbi1wcmV2aW91c1wiLFxuICAgICAgICAgIGF0dHJzOiB7IGRpc2FibGVkOiBfdm0ubWRQYWdlID09PSAxIH0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLmdvVG9QcmV2aW91cygpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbX2MoXCJtZC1pY29uXCIsIFtfdm0uX3YoXCJrZXlib2FyZF9hcnJvd19sZWZ0XCIpXSldLFxuICAgICAgICAxXG4gICAgICApLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcIm1kLWJ1dHRvblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtaWNvbi1idXR0b24gbWQtdGFibGUtcGFnaW5hdGlvbi1uZXh0XCIsXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgX3ZtLmdvVG9OZXh0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFtfYyhcIm1kLWljb25cIiwgW192bS5fdihcImtleWJvYXJkX2Fycm93X3JpZ2h0XCIpXSldLFxuICAgICAgICAxXG4gICAgICApXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUYWJsZV9NZFRhYmxlUGFnaW5hdGlvbiA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNDE2NTY5OGVcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVGFibGUvTWRUYWJsZVBhZ2luYXRpb24udnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzODcpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFRhYmxlUGFnaW5hdGlvbl9kZWZhdWx0LmEsXG4gIE1kVGFibGVfTWRUYWJsZVBhZ2luYXRpb24sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRhYmxlL01kVGFibGVQYWdpbmF0aW9uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTQxNjU2OThlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNDE2NTY5OGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRUYWJsZV9NZFRhYmxlUGFnaW5hdGlvbiA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDM4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDM4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdNZFRhYmxlUGFnaW5hdGlvbicsXG4gIGluamVjdDogWydNZFRhYmxlJ10sXG4gIHByb3BzOiB7XG4gICAgbWRQYWdlU2l6ZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICBtZFBhZ2VPcHRpb25zOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gWzEwLCAyNSwgNTAsIDEwMF07XG4gICAgICB9XG4gICAgfSxcbiAgICBtZFBhZ2U6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9LFxuICAgIG1kVG90YWw6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiAnTWFueSdcbiAgICB9LFxuICAgIG1kTGFiZWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdSb3dzIHBlciBwYWdlOidcbiAgICB9LFxuICAgIG1kU2VwYXJhdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnb2YnXG4gICAgfVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50UGFnZVNpemU6IDBcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGN1cnJlbnRJdGVtQ291bnQ6IGZ1bmN0aW9uIGN1cnJlbnRJdGVtQ291bnQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWRQYWdlIC0gMSkgKiB0aGlzLm1kUGFnZVNpemUgKyAxO1xuICAgIH0sXG4gICAgY3VycmVudFBhZ2VDb3VudDogZnVuY3Rpb24gY3VycmVudFBhZ2VDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kUGFnZSAqIHRoaXMubWRQYWdlU2l6ZTtcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgbWRQYWdlU2l6ZToge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihwYWdlU2l6ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlU2l6ZSA9IHRoaXMucGFnZVNpemU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0UGFnZVNpemU6IGZ1bmN0aW9uIHNldFBhZ2VTaXplKCkge1xuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm1kUGFnZVNpemUnLCB0aGlzLmN1cnJlbnRQYWdlU2l6ZSk7XG4gICAgfSxcbiAgICBnb1RvUHJldmlvdXM6IGZ1bmN0aW9uIGdvVG9QcmV2aW91cygpIHt9LFxuICAgIGdvVG9OZXh0OiBmdW5jdGlvbiBnb1RvTmV4dCgpIHt9XG4gIH0sXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZVNpemUgPSB0aGlzLm1kUGFnZVNpemU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFRhYnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5MCk7XG5cbnZhciBfTWRUYWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kVGFicyk7XG5cbnZhciBfTWRUYWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5Myk7XG5cbnZhciBfTWRUYWIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUYWIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVGFiczIuZGVmYXVsdC5uYW1lLCBfTWRUYWJzMi5kZWZhdWx0KTtcbiAgVnVlLmNvbXBvbmVudChfTWRUYWIyLmRlZmF1bHQubmFtZSwgX01kVGFiMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYnMvTWRUYWJzLnZ1ZVxudmFyIE1kVGFicyA9IF9fd2VicGFja19yZXF1aXJlX18oMzkyKTtcbnZhciBNZFRhYnNfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUYWJzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03MzNjMWJlZlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRhYnMvTWRUYWJzLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIHsgc3RhdGljQ2xhc3M6IFwibWQtdGFic1wiLCBjbGFzczogW192bS50YWJzQ2xhc3NlcywgX3ZtLiRtZEFjdGl2ZVRoZW1lXSB9LFxuICAgIFtcbiAgICAgIF9jKFxuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgcmVmOiBcIm5hdmlnYXRpb25cIixcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC10YWJzLW5hdmlnYXRpb25cIixcbiAgICAgICAgICBjbGFzczogX3ZtLm5hdmlnYXRpb25DbGFzc2VzXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfdm0uX2woX3ZtLk1kVGFicy5pdGVtcywgZnVuY3Rpb24ocmVmLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gcmVmLmxhYmVsXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSByZWYucHJvcHNcbiAgICAgICAgICAgIHZhciBpY29uID0gcmVmLmljb25cbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IHJlZi5kaXNhYmxlZFxuICAgICAgICAgICAgdmFyIGRhdGEgPSByZWYuZGF0YVxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHJlZi5ldmVudHNcbiAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgXCJtZC1idXR0b25cIixcbiAgICAgICAgICAgICAgX3ZtLl9nKFxuICAgICAgICAgICAgICAgIF92bS5fYihcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcIm1kLWFjdGl2ZVwiOiBpbmRleCA9PT0gX3ZtLmFjdGl2ZVRhYixcbiAgICAgICAgICAgICAgICAgICAgICBcIm1kLWljb24tbGFiZWxcIjogaWNvbiAmJiBsYWJlbFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBkaXNhYmxlZDogZGlzYWJsZWQgfSxcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlT246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2V0QWN0aXZlVGFiKGluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwibWQtYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBldmVudHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIF92bS4kc2NvcGVkU2xvdHNbXCJtZC10YWJcIl1cbiAgICAgICAgICAgICAgICAgID8gX3ZtLl90KFwibWQtdGFiXCIsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0YWI6IHsgbGFiZWw6IGxhYmVsLCBpY29uOiBpY29uLCBkYXRhOiBkYXRhIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICAgICFpY29uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtfdm0uX3YoX3ZtLl9zKGxhYmVsKSldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uaXNBc3NldEljb24oaWNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJtZC1pY29uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC10YWItaWNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IFwibWQtc3JjXCI6IGljb24gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfYyhcIm1kLWljb25cIiwgeyBzdGF0aWNDbGFzczogXCJtZC10YWItaWNvblwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKGljb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1kLXRhYi1sYWJlbFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MobGFiZWwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcInNwYW5cIiwge1xuICAgICAgICAgICAgcmVmOiBcImluZGljYXRvclwiLFxuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtdGFicy1pbmRpY2F0b3JcIixcbiAgICAgICAgICAgIGNsYXNzOiBfdm0uaW5kaWNhdG9yQ2xhc3MsXG4gICAgICAgICAgICBzdHlsZTogX3ZtLmluZGljYXRvclN0eWxlc1xuICAgICAgICAgIH0pXG4gICAgICAgIF0sXG4gICAgICAgIDJcbiAgICAgICksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwibWQtY29udGVudFwiLFxuICAgICAgICB7XG4gICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5oYXNDb250ZW50LFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImhhc0NvbnRlbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwibWQtdGFicy1jb250ZW50XCIsXG4gICAgICAgICAgc3R5bGU6IF92bS5jb250ZW50U3R5bGVzXG4gICAgICAgIH0sXG4gICAgICAgIFtcbiAgICAgICAgICBfYyhcbiAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm1kLXRhYnMtY29udGFpbmVyXCIsIHN0eWxlOiBfdm0uY29udGFpbmVyU3R5bGVzIH0sXG4gICAgICAgICAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICApXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgTWRUYWJzX01kVGFicyA9IChlc0V4cG9ydHMpO1xuaWYgKGZhbHNlKSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNzMzYzFiZWZcIiwgZXNFeHBvcnRzKVxuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb21wb25lbnRzL01kVGFicy9NZFRhYnMudnVlXG52YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXygzOTEpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKVxuLyogc2NyaXB0ICovXG5cbi8qIHRlbXBsYXRlICovXG5cbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBNZFRhYnNfZGVmYXVsdC5hLFxuICBNZFRhYnNfTWRUYWJzLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJzL01kVGFicy52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkgeyAgcmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHsgIGNvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03MzNjMWJlZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTczM2MxYmVmXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX01kVGFic19NZFRhYnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChDb21wb25lbnQuZXhwb3J0cyk7XG5cblxuLyoqKi8gfSksXG4vKiAzOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuLyoqKi8gfSksXG4vKiAzOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRBc3NldEljb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIF9NZEFzc2V0SWNvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZEFzc2V0SWNvbik7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxudmFyIF9NZE9ic2VydmVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnZhciBfTWRPYnNlcnZlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZE9ic2VydmVFbGVtZW50KTtcblxudmFyIF9NZENvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcblxudmFyIF9NZENvbnRlbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRDb250ZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFRhYnMnLFxuICBtaXhpbnM6IFtfTWRBc3NldEljb24yLmRlZmF1bHRdLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRDb250ZW50OiBfTWRDb250ZW50Mi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWRBbGlnbm1lbnQ6IF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdsZWZ0J1xuICAgIH0sICgwLCBfTWRQcm9wVmFsaWRhdG9yMi5kZWZhdWx0KSgnbWQtYWxpZ25tZW50JywgWydsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcmVkJywgJ2ZpeGVkJ10pKSxcbiAgICBtZEVsZXZhdGlvbjoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG1kU3luY1JvdXRlOiBCb29sZWFuLFxuICAgIG1kRHluYW1pY0hlaWdodDogQm9vbGVhbixcbiAgICBtZEFjdGl2ZVRhYjogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXNpemVPYnNlcnZlcjogbnVsbCxcbiAgICAgIGFjdGl2ZVRhYjogMCxcbiAgICAgIGFjdGl2ZVRhYkluZGV4OiAwLFxuICAgICAgaW5kaWNhdG9yU3R5bGVzOiB7fSxcbiAgICAgIGluZGljYXRvckNsYXNzOiBudWxsLFxuICAgICAgbm9UcmFuc2l0aW9uOiB0cnVlLFxuICAgICAgY29udGFpbmVyU3R5bGVzOiB7fSxcbiAgICAgIGNvbnRlbnRTdHlsZXM6IHtcbiAgICAgICAgaGVpZ2h0OiAnMHB4J1xuICAgICAgfSxcbiAgICAgIGhhc0NvbnRlbnQ6IGZhbHNlLFxuICAgICAgTWRUYWJzOiB7XG4gICAgICAgIGl0ZW1zOiB7fVxuICAgICAgfSxcbiAgICAgIGFsaWdubWVudENoYW5naW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIE1kVGFiczogdGhpcy5NZFRhYnNcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgdGFic0NsYXNzZXM6IGZ1bmN0aW9uIHRhYnNDbGFzc2VzKCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfcmVmLCAnbWQtYWxpZ25tZW50LScgKyB0aGlzLm1kQWxpZ25tZW50LCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yZWYsICdtZC1uby10cmFuc2l0aW9uJywgdGhpcy5ub1RyYW5zaXRpb24pLCBfZGVmaW5lUHJvcGVydHkoX3JlZiwgJ21kLWR5bmFtaWMtaGVpZ2h0JywgdGhpcy5tZER5bmFtaWNIZWlnaHQpLCBfcmVmO1xuICAgIH0sXG4gICAgbmF2aWdhdGlvbkNsYXNzZXM6IGZ1bmN0aW9uIG5hdmlnYXRpb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuICdtZC1lbGV2YXRpb24tJyArIHRoaXMubWRFbGV2YXRpb247XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIE1kVGFiczoge1xuICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuc2V0SGFzQ29udGVudCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWN0aXZlVGFiOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbmRpY2F0b3JTdHlsZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVUYWJQb3MoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBhY3RpdmVUYWIoKSB7XG4gICAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWN0aXZlVGFiO1xuICAgIH0oKSxcbiAgICBtZEFjdGl2ZVRhYjogZnVuY3Rpb24gbWRBY3RpdmVUYWIodGFiKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRhYjtcbiAgICAgIHRoaXMuJGVtaXQoJ21kLWNoYW5nZWQnLCB0YWIpO1xuICAgIH0sXG4gICAgbWRBbGlnbm1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGNiO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbGlnbm1lbnRDaGFuZ2luZykge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFsaWdubWVudENoYW5naW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG5leHRUaWNrKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNiID0gZnVuY3Rpb24gY2IoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgIT09ICdtaW4td2lkdGgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgX3RoaXMuJHJlZnMubmF2aWdhdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgY2IpO1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5kaWNhdG9yU3R5bGVzKCk7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5hbGlnbm1lbnRDaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLm5hdmlnYXRpb24uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIG1kQWxpZ25tZW50KCkge1xuICAgICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1kQWxpZ25tZW50O1xuICAgIH0oKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFzQWN0aXZlVGFiOiBmdW5jdGlvbiBoYXNBY3RpdmVUYWIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVUYWIgfHwgdGhpcy5tZEFjdGl2ZVRhYjtcbiAgICB9LFxuICAgIGdldEl0ZW1zQW5kS2V5czogZnVuY3Rpb24gZ2V0SXRlbXNBbmRLZXlzKCkge1xuICAgICAgdmFyIGl0ZW1zID0gdGhpcy5NZFRhYnMuaXRlbXM7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMoaXRlbXMpXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0QWN0aXZlVGFiOiBmdW5jdGlvbiBzZXRBY3RpdmVUYWIoaW5kZXgpIHtcbiAgICAgIHRoaXMuYWN0aXZlVGFiID0gaW5kZXg7XG4gICAgICB0aGlzLiRlbWl0KCdtZC1jaGFuZ2VkJywgaW5kZXgpO1xuICAgIH0sXG4gICAgc2V0QWN0aXZlVGFiSW5kZXg6IGZ1bmN0aW9uIHNldEFjdGl2ZVRhYkluZGV4KCkge1xuICAgICAgdmFyIGFjdGl2ZUJ1dHRvbiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5tZC1idXR0b24ubWQtYWN0aXZlJyk7XG5cbiAgICAgIGlmIChhY3RpdmVCdXR0b24pIHtcbiAgICAgICAgdGhpcy5hY3RpdmVUYWJJbmRleCA9IFtdLmluZGV4T2YuY2FsbChhY3RpdmVCdXR0b24ucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCBhY3RpdmVCdXR0b24pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QWN0aXZlVGFiQnlJbmRleDogZnVuY3Rpb24gc2V0QWN0aXZlVGFiQnlJbmRleChpbmRleCkge1xuICAgICAgdmFyIF9nZXRJdGVtc0FuZEtleXMgPSB0aGlzLmdldEl0ZW1zQW5kS2V5cygpLFxuICAgICAgICAgIGtleXMgPSBfZ2V0SXRlbXNBbmRLZXlzLmtleXM7XG5cbiAgICAgIGlmICghdGhpcy5oYXNBY3RpdmVUYWIoKSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IGtleXNbaW5kZXhdO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QWN0aXZlVGFiQnlSb3V0ZTogZnVuY3Rpb24gc2V0QWN0aXZlVGFiQnlSb3V0ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX2dldEl0ZW1zQW5kS2V5czIgPSB0aGlzLmdldEl0ZW1zQW5kS2V5cygpLFxuICAgICAgICAgIGl0ZW1zID0gX2dldEl0ZW1zQW5kS2V5czIuaXRlbXMsXG4gICAgICAgICAga2V5cyA9IF9nZXRJdGVtc0FuZEtleXMyLmtleXM7XG5cbiAgICAgIHZhciB0YWJJbmRleCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLiRyb3V0ZXIpIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1trZXldO1xuICAgICAgICAgIHZhciB0b1Byb3AgPSBpdGVtLnByb3BzLnRvO1xuXG4gICAgICAgICAgaWYgKHRvUHJvcCAmJiB0b1Byb3AgPT09IF90aGlzMi4kcm91dGUucGF0aCkge1xuICAgICAgICAgICAgdGFiSW5kZXggPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlVGFiKCkgJiYgIXRhYkluZGV4KSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0ga2V5c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVGFiID0ga2V5c1t0YWJJbmRleF07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRIYXNDb250ZW50OiBmdW5jdGlvbiBzZXRIYXNDb250ZW50KCkge1xuICAgICAgdmFyIF9nZXRJdGVtc0FuZEtleXMzID0gdGhpcy5nZXRJdGVtc0FuZEtleXMoKSxcbiAgICAgICAgICBpdGVtcyA9IF9nZXRJdGVtc0FuZEtleXMzLml0ZW1zLFxuICAgICAgICAgIGtleXMgPSBfZ2V0SXRlbXNBbmRLZXlzMy5rZXlzO1xuXG4gICAgICB0aGlzLmhhc0NvbnRlbnQgPSBrZXlzLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gaXRlbXNba2V5XS5oYXNDb250ZW50O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXRJbmRpY2F0b3JTdHlsZXM6IGZ1bmN0aW9uIHNldEluZGljYXRvclN0eWxlcygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XG4gICAgICAgIHZhciBhY3RpdmVCdXR0b24sIGJ1dHRvbldpZHRoLCBidXR0b25MZWZ0LCBpbmRpY2F0b3JMZWZ0O1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLiRuZXh0VGljaygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhY3RpdmVCdXR0b24gPSBfdGhpczMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5tZC1idXR0b24ubWQtYWN0aXZlJyk7XG5cblxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVCdXR0b24gJiYgX3RoaXMzLiRyZWZzLmluZGljYXRvcikge1xuICAgICAgICAgICAgICAgICAgYnV0dG9uV2lkdGggPSBhY3RpdmVCdXR0b24ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBidXR0b25MZWZ0ID0gYWN0aXZlQnV0dG9uLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICBpbmRpY2F0b3JMZWZ0ID0gX3RoaXMzLiRyZWZzLmluZGljYXRvci5vZmZzZXRMZWZ0O1xuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3JMZWZ0IDwgYnV0dG9uTGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpczMuaW5kaWNhdG9yQ2xhc3MgPSAnbWQtdGFicy1pbmRpY2F0b3ItcmlnaHQnO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMzLmluZGljYXRvckNsYXNzID0gJ21kLXRhYnMtaW5kaWNhdG9yLWxlZnQnO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpczMuaW5kaWNhdG9yU3R5bGVzID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBidXR0b25MZWZ0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGJ1dHRvbldpZHRoICsgJ3B4J1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIF90aGlzMyk7XG4gICAgICB9KSkpO1xuICAgIH0sXG4gICAgY2FsY3VsYXRlVGFiUG9zOiBmdW5jdGlvbiBjYWxjdWxhdGVUYWJQb3MoKSB7XG4gICAgICBpZiAodGhpcy5oYXNDb250ZW50KSB7XG4gICAgICAgIHZhciB0YWJFbGVtZW50ID0gdGhpcy4kZWwucXVlcnlTZWxlY3RvcignLm1kLXRhYjpudGgtY2hpbGQoJyArICh0aGlzLmFjdGl2ZVRhYkluZGV4ICsgMSkgKyAnKScpO1xuXG4gICAgICAgIHRoaXMuY29udGVudFN0eWxlcyA9IHtcbiAgICAgICAgICBoZWlnaHQ6IHRhYkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY29udGFpbmVyU3R5bGVzID0ge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKCcgKyAtdGhpcy5hY3RpdmVUYWJJbmRleCAqIDEwMCArICclLCAwLCAwKSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwT2JzZXJ2ZXJzOiBmdW5jdGlvbiBzZXR1cE9ic2VydmVycygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAoJ1Jlc2l6ZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIodGhpcy5zZXRJbmRpY2F0b3JTdHlsZXMpO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9ICgwLCBfTWRPYnNlcnZlRWxlbWVudDIuZGVmYXVsdCkodGhpcy4kZWwucXVlcnlTZWxlY3RvcignLm1kLXRhYnMtY29udGVudCcpLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LnNldEluZGljYXRvclN0eWxlcygpO1xuICAgICAgICAgIF90aGlzNC5jYWxjdWxhdGVUYWJQb3MoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc2V0SW5kaWNhdG9yU3R5bGVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldHVwV2F0Y2hlcnM6IGZ1bmN0aW9uIHNldHVwV2F0Y2hlcnMoKSB7XG4gICAgICBpZiAodGhpcy5tZFN5bmNSb3V0ZSkge1xuICAgICAgICB0aGlzLiR3YXRjaCgnJHJvdXRlJywge1xuICAgICAgICAgIGRlZXA6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1kU3luY1JvdXRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiQnlSb3V0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuc2V0SGFzQ29udGVudCgpO1xuICAgIHRoaXMuYWN0aXZlVGFiID0gdGhpcy5tZEFjdGl2ZVRhYjtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm1kU3luY1JvdXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVUYWJCeVJvdXRlKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVUYWJCeUluZGV4KDApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuXG4gICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVUYWJQb3MoKTtcblxuICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM1Lm5vVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzNS5zZXR1cE9ic2VydmVycygpO1xuICAgICAgICAgICAgICAgIF90aGlzNS5zZXR1cFdhdGNoZXJzKCk7XG4gICAgICAgICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRlZDtcbiAgfSgpLFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5zZXRJbmRpY2F0b3JTdHlsZXMpO1xuICB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAzOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19iYWJlbF9sb2FkZXJfbm9kZV9tb2R1bGVzX3Z1ZV9sb2FkZXJfbGliX3NlbGVjdG9yX3R5cGVfc2NyaXB0X2luZGV4XzBfYnVzdENhY2hlX01kVGFiX3Z1ZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhYl92dWVfX19kZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYmFiZWxfbG9hZGVyX25vZGVfbW9kdWxlc192dWVfbG9hZGVyX2xpYl9zZWxlY3Rvcl90eXBlX3NjcmlwdF9pbmRleF8wX2J1c3RDYWNoZV9NZFRhYl92dWVfXyk7XG52YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMClcbi8qIHNjcmlwdCAqL1xuXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSBudWxsXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2JhYmVsX2xvYWRlcl9ub2RlX21vZHVsZXNfdnVlX2xvYWRlcl9saWJfc2VsZWN0b3JfdHlwZV9zY3JpcHRfaW5kZXhfMF9idXN0Q2FjaGVfTWRUYWJfdnVlX19fZGVmYXVsdC5hLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwic3JjL2NvbXBvbmVudHMvTWRUYWJzL01kVGFiLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTRiNjIwODk4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNGI2MjA4OThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoQ29tcG9uZW50LmV4cG9ydHMpO1xuXG5cbi8qKiovIH0pLFxuLyogMzk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfTWRVdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIF9NZFV1aWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRVdWlkKTtcblxudmFyIF9NZE9ic2VydmVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbnZhciBfTWRPYnNlcnZlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZE9ic2VydmVFbGVtZW50KTtcblxudmFyIF9NZFJvdXRlckxpbmtQcm9wcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgX01kUm91dGVyTGlua1Byb3BzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX01kUm91dGVyTGlua1Byb3BzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBuYW1lOiAnTWRUYWInLFxuICBwcm9wczoge1xuICAgIGlkOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuICdtZC10YWItJyArICgwLCBfTWRVdWlkMi5kZWZhdWx0KSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaHJlZjogW1N0cmluZywgTnVtYmVyXSxcbiAgICB0bzogbnVsbCxcbiAgICBtZERpc2FibGVkOiBCb29sZWFuLFxuICAgIG1kTGFiZWw6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgbWRJY29uOiBTdHJpbmcsXG4gICAgbWRUZW1wbGF0ZURhdGE6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpbmplY3Q6IFsnTWRUYWJzJ10sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9ic2VydmVyOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAkcHJvcHM6IHtcbiAgICAgIGRlZXA6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnNldFRhYkRhdGEoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICRhdHRyczoge1xuICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuc2V0VGFiRGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNldFRhYkNvbnRlbnQ6IGZ1bmN0aW9uIHNldFRhYkNvbnRlbnQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5NZFRhYnMuaXRlbXNbdGhpcy5pZF0sICdoYXNDb250ZW50JywgISF0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB9LFxuICAgIHNldHVwT2JzZXJ2ZXI6IGZ1bmN0aW9uIHNldHVwT2JzZXJ2ZXIoKSB7XG4gICAgICB0aGlzLm9ic2VydmVyID0gKDAsIF9NZE9ic2VydmVFbGVtZW50Mi5kZWZhdWx0KSh0aGlzLiRlbCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgIH0sIHRoaXMuc2V0VGFiQ29udGVudCk7XG4gICAgfSxcbiAgICBzZXRUYWJEYXRhOiBmdW5jdGlvbiBzZXRUYWJEYXRhKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuTWRUYWJzLml0ZW1zLCB0aGlzLmlkLCB7XG4gICAgICAgIGhhc0NvbnRlbnQ6ICEhdGhpcy4kc2xvdHMuZGVmYXVsdCxcbiAgICAgICAgbGFiZWw6IHRoaXMubWRMYWJlbCxcbiAgICAgICAgaWNvbjogdGhpcy5tZEljb24sXG4gICAgICAgIGRpc2FibGVkOiB0aGlzLm1kRGlzYWJsZWQsXG4gICAgICAgIGRhdGE6IHRoaXMubWRUZW1wbGF0ZURhdGEsXG4gICAgICAgIHByb3BzOiB0aGlzLmdldFByb3BWYWx1ZXMoKSxcbiAgICAgICAgZXZlbnRzOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0UHJvcFZhbHVlczogZnVuY3Rpb24gZ2V0UHJvcFZhbHVlcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLiRvcHRpb25zLnByb3BzKTtcbiAgICAgIHZhciBpZ25vcmVkUHJvcHMgPSBbJ2lkJywgJ21kTGFiZWwnLCAnbWREaXNhYmxlZCcsICdtZFRlbXBsYXRlRGF0YSddO1xuICAgICAgdmFyIHZhbHVlcyA9IHt9O1xuXG4gICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAoIWlnbm9yZWRQcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgIGlmIChfdGhpc1twcm9wXSkge1xuICAgICAgICAgICAgdmFsdWVzW3Byb3BdID0gX3RoaXNbcHJvcF07XG4gICAgICAgICAgfSBlbHNlIGlmIChfdGhpcy4kYXR0cnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgICAgICAgIHZhbHVlc1twcm9wXSA9IF90aGlzLiRhdHRyc1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlc1twcm9wXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5zZXR1cE9ic2VydmVyKCk7XG4gICAgdGhpcy5zZXRUYWJEYXRhKCk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIHRoaXMuJGRlbGV0ZSh0aGlzLk1kVGFicy5pdGVtcywgdGhpcy5pZCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICB2YXIgdGFiQXR0cnMgPSB7XG4gICAgICBzdGF0aWNDbGFzczogJ21kLXRhYicsXG4gICAgICBhdHRyczogX2V4dGVuZHMoe30sIHRoaXMuJGF0dHJzLCB7XG4gICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICB9KSxcbiAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuaHJlZikge1xuICAgICAgdGhpcy5idXR0b25Qcm9wcyA9IHRoaXMuJG9wdGlvbnMucHJvcHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLiRyb3V0ZXIgJiYgdGhpcy50bykge1xuICAgICAgdGhpcy4kb3B0aW9ucy5wcm9wcyA9ICgwLCBfTWRSb3V0ZXJMaW5rUHJvcHMyLmRlZmF1bHQpKHRoaXMsIHRoaXMuJG9wdGlvbnMucHJvcHMpO1xuXG4gICAgICB0YWJBdHRycy5wcm9wcyA9IHRoaXMuJHByb3BzO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB0YWJBdHRycywgdGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWF0ZXJpYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX21hdGVyaWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGVyaWFsKTtcblxudmFyIF9NZFRvb2xiYXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzKTtcblxudmFyIF9NZFRvb2xiYXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRUb29sYmFyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKFZ1ZSkge1xuICAoMCwgX21hdGVyaWFsMi5kZWZhdWx0KShWdWUpO1xuICBWdWUuY29tcG9uZW50KF9NZFRvb2xiYXIyLmRlZmF1bHQubmFtZSwgX01kVG9vbGJhcjIuZGVmYXVsdCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hdGVyaWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9tYXRlcmlhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXRlcmlhbCk7XG5cbnZhciBfTWRUb29sdGlwID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOTcpO1xuXG52YXIgX01kVG9vbHRpcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZFRvb2x0aXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoVnVlKSB7XG4gICgwLCBfbWF0ZXJpYWwyLmRlZmF1bHQpKFZ1ZSk7XG4gIFZ1ZS5jb21wb25lbnQoX01kVG9vbHRpcDIuZGVmYXVsdC5uYW1lLCBfTWRUb29sdGlwMi5kZWZhdWx0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KF9fd2VicGFja19leHBvcnRzX18sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRvb2x0aXAvTWRUb29sdGlwLnZ1ZVxudmFyIE1kVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMzk5KTtcbnZhciBNZFRvb2x0aXBfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oTWRUb29sdGlwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0wMzI1MmJlOVwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9zcmMvY29tcG9uZW50cy9NZFRvb2x0aXAvTWRUb29sdGlwLnZ1ZVxudmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcIm1kLXBvcG92ZXJcIixcbiAgICB7XG4gICAgICBhdHRyczoge1xuICAgICAgICBcIm1kLXNldHRpbmdzXCI6IF92bS5wb3BwZXJTZXR0aW5ncyxcbiAgICAgICAgXCJtZC1hY3RpdmVcIjogX3ZtLnNob3VsZFJlbmRlclxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX3ZtLnNob3VsZFJlbmRlclxuICAgICAgICA/IF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwibWQtdG9vbHRpcFwiIH0gfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJtZC10b29sdGlwXCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IFtfdm0udG9vbHRpcENsYXNzZXMsIF92bS4kbWRBY3RpdmVUaGVtZV0sXG4gICAgICAgICAgICAgICAgc3R5bGU6IF92bS50b29sdGlwU3R5bGVzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pXG4gICAgICAgIDogX3ZtLl9lKClcbiAgICBdLFxuICAgIDFcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNZFRvb2x0aXBfTWRUb29sdGlwID0gKGVzRXhwb3J0cyk7XG5pZiAoZmFsc2UpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wMzI1MmJlOVwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvbXBvbmVudHMvTWRUb29sdGlwL01kVG9vbHRpcC52dWVcbnZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5OClcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApXG4vKiBzY3JpcHQgKi9cblxuLyogdGVtcGxhdGUgKi9cblxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIE1kVG9vbHRpcF9kZWZhdWx0LmEsXG4gIE1kVG9vbHRpcF9NZFRvb2x0aXAsXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9NZFRvb2x0aXAvTWRUb29sdGlwLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTAzMjUyYmU5XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMDMyNTJiZTlcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4nICsgJyAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTWRUb29sdGlwX01kVG9vbHRpcCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENvbXBvbmVudC5leHBvcnRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDM5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG4vKioqLyB9KSxcbi8qIDM5OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyAvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG52YXIgX01kQ29tcG9uZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9NZENvbXBvbmVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9NZENvbXBvbmVudCk7XG5cbnZhciBfTWRQcm9wVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIF9NZFByb3BWYWxpZGF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQcm9wVmFsaWRhdG9yKTtcblxudmFyIF9NZFBvcG92ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIF9NZFBvcG92ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTWRQb3BvdmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgc3RlcChcIm5leHRcIiwgdmFsdWUpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHN0ZXAoXCJ0aHJvd1wiLCBlcnIpOyB9KTsgfSB9IHJldHVybiBzdGVwKFwibmV4dFwiKTsgfSk7IH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IF9NZENvbXBvbmVudDIuZGVmYXVsdCh7XG4gIG5hbWU6ICdNZFRvb2x0aXAnLFxuICBjb21wb25lbnRzOiB7XG4gICAgTWRQb3BvdmVyOiBfTWRQb3BvdmVyMi5kZWZhdWx0XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbWRBY3RpdmU6IEJvb2xlYW4sXG4gICAgbWREZWxheToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG1kRGlyZWN0aW9uOiBfZXh0ZW5kcyh7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYm90dG9tJ1xuICAgIH0sICgwLCBfTWRQcm9wVmFsaWRhdG9yMi5kZWZhdWx0KSgnbWQtZGlyZWN0aW9uJywgWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSkpXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNob3VsZFJlbmRlcjogZmFsc2UsXG4gICAgICB0YXJnZXRFbDogbnVsbFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9vbHRpcENsYXNzZXM6IGZ1bmN0aW9uIHRvb2x0aXBDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuICdtZC10b29sdGlwLScgKyB0aGlzLm1kRGlyZWN0aW9uO1xuICAgIH0sXG4gICAgdG9vbHRpcFN0eWxlczogZnVuY3Rpb24gdG9vbHRpcFN0eWxlcygpIHtcbiAgICAgIHJldHVybiAndHJhbnNpdGlvbi1kZWxheTogJyArIHRoaXMubWREZWxheSArICdtcyc7XG4gICAgfSxcbiAgICBwb3BwZXJTZXR0aW5nczogZnVuY3Rpb24gcG9wcGVyU2V0dGluZ3MoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMubWREaXJlY3Rpb24sXG4gICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgb2Zmc2V0OiAnMCwgMTYnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBtZEFjdGl2ZTogZnVuY3Rpb24gbWRBY3RpdmUoKSB7XG4gICAgICB0aGlzLnNob3VsZFJlbmRlciA9IHRoaXMubWRBY3RpdmU7XG4gICAgfSxcbiAgICBzaG91bGRSZW5kZXI6IGZ1bmN0aW9uIHNob3VsZFJlbmRlcihfc2hvdWxkUmVuZGVyKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6bWRBY3RpdmUnLCBfc2hvdWxkUmVuZGVyKTtcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5zaG91bGRSZW5kZXIgPSB0cnVlO1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuc2hvdWxkUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kbmV4dFRpY2soKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVuZGVyID0gdGhpcy5tZEFjdGl2ZTtcbiAgICAgICAgICAgICAgdGhpcy50YXJnZXRFbCA9IHRoaXMuX3Zub2RlLmNvbXBvbmVudEluc3RhbmNlLm9yaWdpbmFsUGFyZW50RWw7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0RWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnNob3csIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmhpZGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50ZWQ7XG4gIH0oKSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy50YXJnZXRFbCkge1xuICAgICAgdGhpcy50YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5zaG93KTtcbiAgICAgIHRoaXMudGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuaGlkZSk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7IiwiLyoqXG4gICogdnVlLXJvdXRlciB2My4wLjFcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChfLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBjb21wb25lbnRzIHJlbmRlcmVkIGJ5IHJvdXRlci12aWV3IGNhbiByZXNvbHZlIG5hbWVkIHNsb3RzXG4gICAgdmFyIGggPSBwYXJlbnQuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX3JvdXRlclJvb3QgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzdGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcbiAgICAvLyBpbiBjYXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgYWNyb3NzIGRpZmZlcmVudCByb3V0ZXNcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gcmVzb2x2ZSBwcm9wc1xuICAgIHZhciBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSByZXNvbHZlUHJvcHMocm91dGUsIG1hdGNoZWQucHJvcHMgJiYgbWF0Y2hlZC5wcm9wc1tuYW1lXSk7XG4gICAgaWYgKHByb3BzVG9QYXNzKSB7XG4gICAgICAvLyBjbG9uZSB0byBwcmV2ZW50IG11dGF0aW9uXG4gICAgICBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSBleHRlbmQoe30sIHByb3BzVG9QYXNzKTtcbiAgICAgIC8vIHBhc3Mgbm9uLWRlY2xhcmVkIHByb3BzIGFzIGF0dHJzXG4gICAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzID0gZGF0YS5hdHRycyB8fCB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvUGFzcykge1xuICAgICAgICBpZiAoIWNvbXBvbmVudC5wcm9wcyB8fCAhKGtleSBpbiBjb21wb25lbnQucHJvcHMpKSB7XG4gICAgICAgICAgYXR0cnNba2V5XSA9IHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgICAgZGVsZXRlIHByb3BzVG9QYXNzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaChjb21wb25lbnQsIGRhdGEsIGNoaWxkcmVuKVxuICB9XG59O1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHMgKHJvdXRlLCBjb25maWcpIHtcbiAgc3dpdGNoICh0eXBlb2YgY29uZmlnKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVyblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gY29uZmlnXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGNvbmZpZyhyb3V0ZSlcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjb25maWcgPyByb3V0ZS5wYXJhbXMgOiB1bmRlZmluZWRcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbmZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeSxcbiAgX3BhcnNlUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xuICB2YXIgcGFyc2VkUXVlcnk7XG4gIHRyeSB7XG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIGUubWVzc2FnZSk7XG4gICAgcGFyc2VkUXVlcnkgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gZXh0cmFRdWVyeSkge1xuICAgIHBhcnNlZFF1ZXJ5W2tleV0gPSBleHRyYVF1ZXJ5W2tleV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZFF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkgKHF1ZXJ5KSB7XG4gIHZhciByZXMgPSB7fTtcblxuICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG4gIGlmICghcXVlcnkpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBxdWVyeS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRzLnNoaWZ0KCkpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwXG4gICAgICA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpXG4gICAgICA6IG51bGw7XG5cbiAgICBpZiAocmVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc1trZXldKSkge1xuICAgICAgcmVzW2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNba2V5XSA9IFtyZXNba2V5XSwgdmFsXTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UXVlcnkgKG9iaikge1xuICB2YXIgcmVzID0gb2JqID8gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24gKHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHZhbDIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyYnKVxuICAgIH1cblxuICAgIHJldHVybiBlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwpXG4gIH0pLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5sZW5ndGggPiAwOyB9KS5qb2luKCcmJykgOiBudWxsO1xuICByZXR1cm4gcmVzID8gKFwiP1wiICsgcmVzKSA6ICcnXG59XG5cbi8qICAqL1xuXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tLFxuICByb3V0ZXJcbikge1xuICB2YXIgc3RyaW5naWZ5UXVlcnkkJDEgPSByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgfHwge307XG4gIHRyeSB7XG4gICAgcXVlcnkgPSBjbG9uZShxdWVyeSk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSQkMSksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5JCQxKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoY2xvbmUpXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHJlc1trZXldID0gY2xvbmUodmFsdWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgLy8gaGFuZGxlIG51bGwgdmFsdWUgIzE1NjZcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID09PSBiIH1cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIC8vIGNoZWNrIG5lc3RlZCBlcXVhbGl0eVxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RFcXVhbChhVmFsLCBiVmFsKVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAncm91dGVyLWxpbmsnLFxuICBwcm9wczoge1xuICAgIHRvOiB7XG4gICAgICB0eXBlOiB0b1R5cGVzLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2EnXG4gICAgfSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG5cbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcztcbiAgICB2YXIgZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGVtcHR5IGFjdGl2ZSBjbGFzc1xuICAgIHZhciBhY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsQWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxBY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzcyA9IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSBsb2NhdGlvbi5wYXRoXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpXG4gICAgICA6IHJvdXRlO1xuXG4gICAgY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXSA9IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxuICAgICAgPyBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHsgb25bZV0gPSBoYW5kbGVyOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGFnID09PSAnYScpIHtcbiAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXh0ZW5kID0gX1Z1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQgJiYgX1Z1ZSA9PT0gVnVlKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmJlZm9yZVJvdXRlVXBkYXRlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxudmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIHBhdGhUb1JlZ2V4cF8xID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5wYXRoVG9SZWdleHBfMS5wYXJzZSA9IHBhcnNlXzE7XG5wYXRoVG9SZWdleHBfMS5jb21waWxlID0gY29tcGlsZV8xO1xucGF0aFRvUmVnZXhwXzEudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbi8vICRmbG93LWRpc2FibGUtbGluZVxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IHBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUocGF0aCkpO1xuICAgIHJldHVybiBmaWxsZXIocGFyYW1zIHx8IHt9LCB7IHByZXR0eTogdHJ1ZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHdpbGRjYXJkIHJvdXRlcyBhcmUgYWx3YXlzIGF0IHRoZSBlbmRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocGF0aExpc3RbaV0gPT09ICcqJykge1xuICAgICAgcGF0aExpc3QucHVzaChwYXRoTGlzdC5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgbC0tO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aExpc3QsXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQocGF0aCAhPSBudWxsLCBcIlxcXCJwYXRoXFxcIiBpcyByZXF1aXJlZCBpbiBhIHJvdXRlIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIGFzc2VydChcbiAgICAgIHR5cGVvZiByb3V0ZS5jb21wb25lbnQgIT09ICdzdHJpbmcnLFxuICAgICAgXCJyb3V0ZSBjb25maWcgXFxcImNvbXBvbmVudFxcXCIgZm9yIHBhdGg6IFwiICsgKFN0cmluZyhwYXRoIHx8IG5hbWUpKSArIFwiIGNhbm5vdCBiZSBhIFwiICtcbiAgICAgIFwic3RyaW5nIGlkLiBVc2UgYW4gYWN0dWFsIGNvbXBvbmVudCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID0gcm91dGUucGF0aFRvUmVnZXhwT3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChcbiAgICBwYXRoLFxuICAgIHBhcmVudCxcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnN0cmljdFxuICApO1xuXG4gIGlmICh0eXBlb2Ygcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zZW5zaXRpdmUgPSByb3V0ZS5jYXNlU2Vuc2l0aXZlO1xuICB9XG5cbiAgdmFyIHJlY29yZCA9IHtcbiAgICBwYXRoOiBub3JtYWxpemVkUGF0aCxcbiAgICByZWdleDogY29tcGlsZVJvdXRlUmVnZXgobm9ybWFsaXplZFBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6IHJvdXRlLnByb3BzID09IG51bGxcbiAgICAgID8ge31cbiAgICAgIDogcm91dGUuY29tcG9uZW50c1xuICAgICAgICA/IHJvdXRlLnByb3BzXG4gICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCwgZG9lcyBub3QgcmVkaXJlY3QgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXG4gICAgLy8gSWYgdXNlcnMgbmF2aWdhdGUgdG8gdGhpcyByb3V0ZSBieSBuYW1lLCB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocm91dGUubmFtZSAmJiAhcm91dGUucmVkaXJlY3QgJiYgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgIFwidGhpcyByb3V0ZSBhbmQgdXNlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIGZvciBuYW1lZCBcIiArXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKVxuICAgICAgPyByb3V0ZS5hbGlhc1xuICAgICAgOiBbcm91dGUuYWxpYXNdO1xuXG4gICAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgdmFyIGFsaWFzUm91dGUgPSB7XG4gICAgICAgIHBhdGg6IGFsaWFzLFxuICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgIH07XG4gICAgICBhZGRSb3V0ZVJlY29yZChcbiAgICAgICAgcGF0aExpc3QsXG4gICAgICAgIHBhdGhNYXAsXG4gICAgICAgIG5hbWVNYXAsXG4gICAgICAgIGFsaWFzUm91dGUsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgcmVjb3JkLnBhdGggfHwgJy8nIC8vIG1hdGNoQXNcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIXBhdGhNYXBbcmVjb3JkLnBhdGhdKSB7XG4gICAgcGF0aExpc3QucHVzaChyZWNvcmQucGF0aCk7XG4gICAgcGF0aE1hcFtyZWNvcmQucGF0aF0gPSByZWNvcmQ7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICBcInsgbmFtZTogXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgcGF0aDogXFxcIlwiICsgKHJlY29yZC5wYXRoKSArIFwiXFxcIiB9XCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVSb3V0ZVJlZ2V4IChwYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSB7XG4gIHZhciByZWdleCA9IHBhdGhUb1JlZ2V4cF8xKHBhdGgsIFtdLCBwYXRoVG9SZWdleHBPcHRpb25zKTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmVnZXgua2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHdhcm4oIWtleXNba2V5Lm5hbWVdLCAoXCJEdXBsaWNhdGUgcGFyYW0ga2V5cyBpbiByb3V0ZSB3aXRoIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIikpO1xuICAgICAga2V5c1trZXkubmFtZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWdleFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoIChwYXRoLCBwYXJlbnQsIHN0cmljdCkge1xuICBpZiAoIXN0cmljdCkgeyBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpOyB9XG4gIGlmIChwYXRoWzBdID09PSAnLycpIHsgcmV0dXJuIHBhdGggfVxuICBpZiAocGFyZW50ID09IG51bGwpIHsgcmV0dXJuIHBhdGggfVxuICByZXR1cm4gY2xlYW5QYXRoKCgocGFyZW50LnBhdGgpICsgXCIvXCIgKyBwYXRoKSlcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24gKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIGFwcGVuZCxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIG5leHQgPSB0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyA/IHsgcGF0aDogcmF3IH0gOiByYXc7XG4gIC8vIG5hbWVkIHRhcmdldFxuICBpZiAobmV4dC5uYW1lIHx8IG5leHQuX25vcm1hbGl6ZWQpIHtcbiAgICByZXR1cm4gbmV4dFxuICB9XG5cbiAgLy8gcmVsYXRpdmUgcGFyYW1zXG4gIGlmICghbmV4dC5wYXRoICYmIG5leHQucGFyYW1zICYmIGN1cnJlbnQpIHtcbiAgICBuZXh0ID0gYXNzaWduKHt9LCBuZXh0KTtcbiAgICBuZXh0Ll9ub3JtYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgcGFyYW1zID0gYXNzaWduKGFzc2lnbih7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50Lm1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY29yZCkgeyByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKSB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHJlY29yZC5yZWdleC5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xuICAgICAgICB2YXIgcmVjb3JkJDEgPSBwYXRoTWFwW3BhdGhdO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3JpZ2luYWxSZWRpcmVjdChjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpKVxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICAvLyBGaXggZm9yICMxNTg1IGZvciBGaXJlZm94XG4gIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogZ2V0U3RhdGVLZXkoKSB9LCAnJyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICAgIHNldFN0YXRlS2V5KGUuc3RhdGUua2V5KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvcih0bywgZnJvbSwgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGwpO1xuXG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkU2Nyb2xsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3VsZFNjcm9sbC50aGVuKGZ1bmN0aW9uIChzaG91bGRTY3JvbGwpIHtcbiAgICAgICAgc2Nyb2xsVG9Qb3NpdGlvbigoc2hvdWxkU2Nyb2xsKSwgcG9zaXRpb24pO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9Qb3NpdGlvbihzaG91bGRTY3JvbGwsIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbiAoc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbikge1xuICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgIGlmIChlbCkge1xuICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xuICAgICAgb2Zmc2V0ID0gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCk7XG4gICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChpc0VTTW9kdWxlKHJlc29sdmVkRGVmKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlIChvYmopIHtcbiAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2Iocm91dGUpOyB9KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAob25BYm9ydCkge1xuICAgICAgb25BYm9ydChlcnIpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmICF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlFcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMkMS5lcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNFcnJvcih0bykpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgICBuZXh0KHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgdmFyIHF1ZXVlID0gZW50ZXJHdWFyZHMuY29uY2F0KHRoaXMkMS5yb3V0ZXIucmVzb2x2ZUhvb2tzKTtcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxuICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXlxcL10rLywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWQsXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlRW50ZXInLCBmdW5jdGlvbiAoZ3VhcmQsIF8sIG1hdGNoLCBrZXkpIHtcbiAgICByZXR1cm4gYmluZEVudGVyR3VhcmQoZ3VhcmQsIG1hdGNoLCBrZXksIGNicywgaXNWYWxpZClcbiAgfSlcbn1cblxuZnVuY3Rpb24gYmluZEVudGVyR3VhcmQgKFxuICBndWFyZCxcbiAgbWF0Y2gsXG4gIGtleSxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgbmV4dChjYik7XG4gICAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNicy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyAjNzUwXG4gICAgICAgICAgLy8gaWYgYSByb3V0ZXItdmlldyBpcyB3cmFwcGVkIHdpdGggYW4gb3V0LWluIHRyYW5zaXRpb24sXG4gICAgICAgICAgLy8gdGhlIGluc3RhbmNlIG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgYXQgdGhpcyB0aW1lLlxuICAgICAgICAgIC8vIHdlIHdpbGwgbmVlZCB0byBwb2xsIGZvciByZWdpc3RyYXRpb24gdW50aWwgY3VycmVudCByb3V0ZVxuICAgICAgICAgIC8vIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICBwb2xsKGNiLCBtYXRjaC5pbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gcG9sbCAoXG4gIGNiLCAvLyBzb21laG93IGZsb3cgY2Fubm90IGluZmVyIHRoaXMgaXMgYSBmdW5jdGlvblxuICBpbnN0YW5jZXMsXG4gIGtleSxcbiAgaXNWYWxpZFxuKSB7XG4gIGlmIChpbnN0YW5jZXNba2V5XSkge1xuICAgIGNiKGluc3RhbmNlc1trZXldKTtcbiAgfSBlbHNlIGlmIChpc1ZhbGlkKCkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHBvbGwoY2IsIGluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICB9LCAxNik7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEhUTUw1SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIVE1MNUhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG5cbiAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHZhciBpbml0TG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzLmJhc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMkMS5jdXJyZW50O1xuXG4gICAgICAvLyBBdm9pZGluZyBmaXJzdCBgcG9wc3RhdGVgIGV2ZW50IGRpc3BhdGNoZWQgaW4gc29tZSBicm93c2VycyBidXQgZmlyc3RcbiAgICAgIC8vIGhpc3Rvcnkgcm91dGUgbm90IHVwZGF0ZWQgc2luY2UgYXN5bmMgZ3VhcmQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKTtcbiAgICAgIGlmICh0aGlzJDEuY3VycmVudCA9PT0gU1RBUlQgJiYgbG9jYXRpb24gPT09IGluaXRMb2NhdGlvbikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICB2YXIgZXhwZWN0U2Nyb2xsID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gICAgdmFyIHN1cHBvcnRzU2Nyb2xsID0gc3VwcG9ydHNQdXNoU3RhdGUgJiYgZXhwZWN0U2Nyb2xsO1xuXG4gICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICBzZXR1cFNjcm9sbCgpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHN1cHBvcnRzUHVzaFN0YXRlID8gJ3BvcHN0YXRlJyA6ICdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoO1xuICAgIGlmIChnZXRIYXNoKCkgIT09IGN1cnJlbnQpIHtcbiAgICAgIHB1c2ggPyBwdXNoSGFzaChjdXJyZW50KSA6IHJlcGxhY2VIYXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ2V0Q3VycmVudExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0SGFzaCgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGNoZWNrRmFsbGJhY2sgKGJhc2UpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24oYmFzZSk7XG4gIGlmICghL15cXC8jLy50ZXN0KGxvY2F0aW9uKSkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgICAgY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaW5kZXggPT09IC0xID8gJycgOiBocmVmLnNsaWNlKGluZGV4ICsgMSlcbn1cblxuZnVuY3Rpb24gZ2V0VXJsIChwYXRoKSB7XG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHZhciBiYXNlID0gaSA+PSAwID8gaHJlZi5zbGljZSgwLCBpKSA6IGhyZWY7XG4gIHJldHVybiAoYmFzZSArIFwiI1wiICsgcGF0aClcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2ggKHBhdGgpIHtcbiAgaWYgKHN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgcHVzaFN0YXRlKGdldFVybChwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHJlcGxhY2VTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGdldFVybChwYXRoKSk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBcInByb2R1Y3Rpb25cIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydChcbiAgICBpbnN0YWxsLmluc3RhbGxlZCxcbiAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICBcImJlZm9yZSBjcmVhdGluZyByb290IGluc3RhbmNlLlwiXG4gICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBtYWluIGFwcCBhbHJlYWR5IGluaXRpYWxpemVkLlxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5KSB7XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH0gZWxzZSBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhhc2hIaXN0b3J5KSB7XG4gICAgdmFyIHNldHVwSGFzaExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgaGlzdG9yeS5zZXR1cExpc3RlbmVycygpO1xuICAgIH07XG4gICAgaGlzdG9yeS50cmFuc2l0aW9uVG8oXG4gICAgICBoaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXIsXG4gICAgICBzZXR1cEhhc2hMaXN0ZW5lclxuICAgICk7XG4gIH1cblxuICBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAocm91dGUpIHtcbiAgICB0aGlzJDEuYXBwcy5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgIGFwcC5fcm91dGUgPSByb3V0ZTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiBiZWZvcmVFYWNoIChmbikge1xuICByZXR1cm4gcmVnaXN0ZXJIb29rKHRoaXMuYmVmb3JlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVSZXNvbHZlID0gZnVuY3Rpb24gYmVmb3JlUmVzb2x2ZSAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLnJlc29sdmVIb29rcywgZm4pXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFmdGVyRWFjaCA9IGZ1bmN0aW9uIGFmdGVyRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmFmdGVySG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uUmVhZHkoY2IsIGVycm9yQ2IpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmhpc3Rvcnkub25FcnJvcihlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5wdXNoKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICB0aGlzLmhpc3RvcnkuZ28obik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmJhY2sgPSBmdW5jdGlvbiBiYWNrICgpIHtcbiAgdGhpcy5nbygtMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbiBmb3J3YXJkICgpIHtcbiAgdGhpcy5nbygxKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZ2V0TWF0Y2hlZENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRNYXRjaGVkQ29tcG9uZW50cyAodG8pIHtcbiAgdmFyIHJvdXRlID0gdG9cbiAgICA/IHRvLm1hdGNoZWRcbiAgICAgID8gdG9cbiAgICAgIDogdGhpcy5yZXNvbHZlKHRvKS5yb3V0ZVxuICAgIDogdGhpcy5jdXJyZW50Um91dGU7XG4gIGlmICghcm91dGUpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCByb3V0ZS5tYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbS5jb21wb25lbnRzW2tleV1cbiAgICB9KVxuICB9KSlcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUgKFxuICB0byxcbiAgY3VycmVudCxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24oXG4gICAgdG8sXG4gICAgY3VycmVudCB8fCB0aGlzLmhpc3RvcnkuY3VycmVudCxcbiAgICBhcHBlbmQsXG4gICAgdGhpc1xuICApO1xuICB2YXIgcm91dGUgPSB0aGlzLm1hdGNoKGxvY2F0aW9uLCBjdXJyZW50KTtcbiAgdmFyIGZ1bGxQYXRoID0gcm91dGUucmVkaXJlY3RlZEZyb20gfHwgcm91dGUuZnVsbFBhdGg7XG4gIHZhciBiYXNlID0gdGhpcy5oaXN0b3J5LmJhc2U7XG4gIHZhciBocmVmID0gY3JlYXRlSHJlZihiYXNlLCBmdWxsUGF0aCwgdGhpcy5tb2RlKTtcbiAgcmV0dXJuIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgcm91dGU6IHJvdXRlLFxuICAgIGhyZWY6IGhyZWYsXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBub3JtYWxpemVkVG86IGxvY2F0aW9uLFxuICAgIHJlc29sdmVkOiByb3V0ZVxuICB9XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlcyA9IGZ1bmN0aW9uIGFkZFJvdXRlcyAocm91dGVzKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZXMocm91dGVzKTtcbiAgaWYgKHRoaXMuaGlzdG9yeS5jdXJyZW50ICE9PSBTVEFSVCkge1xuICAgIHRoaXMuaGlzdG9yeS50cmFuc2l0aW9uVG8odGhpcy5oaXN0b3J5LmdldEN1cnJlbnRMb2NhdGlvbigpKTtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZ1ZVJvdXRlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZWdpc3Rlckhvb2sgKGxpc3QsIGZuKSB7XG4gIGxpc3QucHVzaChmbik7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBsaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHsgbGlzdC5zcGxpY2UoaSwgMSk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVIcmVmIChiYXNlLCBmdWxsUGF0aCwgbW9kZSkge1xuICB2YXIgcGF0aCA9IG1vZGUgPT09ICdoYXNoJyA/ICcjJyArIGZ1bGxQYXRoIDogZnVsbFBhdGg7XG4gIHJldHVybiBiYXNlID8gY2xlYW5QYXRoKGJhc2UgKyAnLycgKyBwYXRoKSA6IHBhdGhcbn1cblxuVnVlUm91dGVyLmluc3RhbGwgPSBpbnN0YWxsO1xuVnVlUm91dGVyLnZlcnNpb24gPSAnMy4wLjEnO1xuXG5pZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5WdWUpIHtcbiAgd2luZG93LlZ1ZS51c2UoVnVlUm91dGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWdWVSb3V0ZXI7XG4iLCJ2YXIgaW5zZXJ0ZWQgPSBleHBvcnRzLmNhY2hlID0ge31cblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5leHBvcnRzLmluc2VydCA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgaWYgKGluc2VydGVkW2Nzc10pIHJldHVybiBub29wXG4gIGluc2VydGVkW2Nzc10gPSB0cnVlXG5cbiAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIGVsZW0uc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJylcblxuICBpZiAoJ3RleHRDb250ZW50JyBpbiBlbGVtKSB7XG4gICAgZWxlbS50ZXh0Q29udGVudCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH1cblxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKGVsZW0pXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5yZW1vdmVDaGlsZChlbGVtKVxuICAgIGluc2VydGVkW2Nzc10gPSBmYWxzZVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFhNTEh0dHBSZXF1ZXN0O1xuIiwiPHRlbXBsYXRlPlxuICA8bWQtY29udGVudCBjbGFzcz1cImxlZnQtY29udGFpbmVyIG5vLXNjcm9sbFwiPlxuICAgIDxtZC10b29sYmFyIGNsYXNzPVwiYXBwLWhlYWRlclwiPlxuICAgICAgPGgzPkNhdGVnb3J5PC9oMz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZC10b29sYmFyLXNlY3Rpb24tZW5kIGNvbG9yX2JsYWNrXCI+XG5cbiAgICAgICAgPG1kLWJ1dHRvbiBjbGFzcz1cIm1kLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCIkZW1pdCgnY29kZUlPLWRhdGEnKVwiPlxuICAgICAgICAgIDxtZC10b29sdGlwPk9wZW4gSnNvbjwvbWQtdG9vbHRpcD5cbiAgICAgICAgICA8bWQtaWNvbj5hc3NpZ25tZW50X3R1cm5lZF9pbjwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG5cbiAgICAgICAgPG1kLWJ1dHRvbiBjbGFzcz1cIm1kLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCIkZW1pdCgncmVsb2FkLWRhdGEnKVwiPlxuICAgICAgICAgIDxtZC10b29sdGlwPlJlbG9hZCBmcm9tIG1vZGVsPC9tZC10b29sdGlwPlxuICAgICAgICAgIDxtZC1pY29uPnN5bmM8L21kLWljb24+XG4gICAgICAgIDwvbWQtYnV0dG9uPlxuXG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiJGVtaXQoJ3NhdmUtZGF0YScpXCI+XG4gICAgICAgICAgPG1kLXRvb2x0aXA+U2F2ZSBpbiBtb2RlbDwvbWQtdG9vbHRpcD5cbiAgICAgICAgICA8bWQtaWNvbj5zYXZlPC9tZC1pY29uPlxuICAgICAgICA8L21kLWJ1dHRvbj5cblxuICAgICAgICA8bWQtYnV0dG9uIGNsYXNzPVwibWQtaWNvbi1idXR0b25cIlxuICAgICAgICAgICAgICAgICAgIEBjbGljaz1cIiRlbWl0KCdhZG1pbi1jcmVhdGUtaXRlbScpXCI+XG4gICAgICAgICAgPG1kLXRvb2x0aXA+QWRkIENhdGVnb3J5PC9tZC10b29sdGlwPlxuICAgICAgICAgIDxtZC1pY29uPmFkZDwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L21kLXRvb2xiYXI+XG4gICAgPG1kLWNvbnRlbnQgY2xhc3M9XCJtZC1zY3JvbGxiYXIgYWRtaW4tbGVmdC1jb250ZW50IFwiPlxuICAgICAgPG1kLWVtcHR5LXN0YXRlIHYtaWY9XCJjdXJyZW50X2xpc3QubGVuZ3RoID09IDBcIlxuICAgICAgICAgICAgICAgICAgICAgIG1kLWljb249XCJjYW5jZWxcIlxuICAgICAgICAgICAgICAgICAgICAgIG1kLWxhYmVsPVwiTm90aGluZyBpbiBDYXRlZ29yeVwiPlxuICAgICAgICA8bWQtYnV0dG9uIGNsYXNzPVwibWQtcHJpbWFyeSBtZC1yYWlzZWRcIlxuICAgICAgICAgICAgICAgICAgIEBjbGljaz1cIiRlbWl0KCdhZG1pbi1jcmVhdGUtaXRlbScpXCI+Q3JlYXRlIGEgY2F0ZWdvcnk8L21kLWJ1dHRvbj5cbiAgICAgIDwvbWQtZW1wdHktc3RhdGU+XG4gICAgICA8dHJhbnNpdGlvbi1ncm91cCB2LWVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJmbGlwLWxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnPVwibWQtbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWxpc3Qtbm8tcGFkZGluZ1wiPlxuICAgICAgICA8bWQtbGlzdC1pdGVtIHYtZm9yPVwiKGl0ZW0saWQpIGluIGN1cnJlbnRfbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnYWRtaW4tc2VsZWN0ZWQnOiBpdGVtID09IHNlbGVjdGVkIH1cIlxuICAgICAgICAgICAgICAgICAgICAgIDprZXk9XCJpdGVtLmlkXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImFkbWluLWl0ZW0tbGlzdFwiPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8bWQtYnV0dG9uIGNsYXNzPVwibWQtaWNvbi1idXR0b24gbWQtZGVuc2Ugbm8tbWFyZ2luXCJcbiAgICAgICAgICAgICAgICAgICAgICAgOmRpc2FibGVkPVwiaWQgPT0gMFwiXG4gICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInVwSW5Mc3QoaWQsaXRlbSlcIj5cbiAgICAgICAgICAgICAgPG1kLWljb24+ZXhwYW5kX2xlc3M8L21kLWljb24+XG4gICAgICAgICAgICA8L21kLWJ1dHRvbj5cbiAgICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBtZC1kZW5zZSBuby1tYXJnaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJjdXJyZW50X2xpc3QubGVuZ3RoIC0gMSA9PSBpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgIEBjbGljaz1cImRvd25JbkxzdChpZCxpdGVtKVwiPlxuICAgICAgICAgICAgICA8bWQtaWNvbj5leHBhbmRfbW9yZTwvbWQtaWNvbj5cbiAgICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZC1saXN0LWl0ZW0tdGV4dFwiPlxuICAgICAgICAgICAgPHNwYW4+bGFiZWw6IHt7aXRlbS5sYWJlbH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4+dHlwZSA6IHt7aXRlbS50eXBlfX08L3NwYW4+XG4gICAgICAgICAgICA8cD50YXJnZXRfdXJsOiB7e2l0ZW0udGFyZ2V0X3VybH19XG4gICAgICAgICAgICAgIDxtZC10b29sdGlwIHYtaWY9XCJpdGVtLnRhcmdldF91cmwgJiYgaXRlbS50YXJnZXRfdXJsLmxlbmd0aCA+IDEwXCI+e3tpdGVtLnRhcmdldF91cmx9fTwvbWQtdG9vbHRpcD5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxtZC1idXR0b24gdi1pZj1cIml0ZW0udGFyZ2V0X3VybCAmJiBpdGVtLnRhcmdldF91cmwubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWljb24tYnV0dG9uIFwiXG4gICAgICAgICAgICAgICAgICAgICA6dG89XCJidG9hKGl0ZW0udGFyZ2V0X3VybClcIj5cbiAgICAgICAgICAgIDxtZC1pY29uPm9wZW5faW5fbmV3PC9tZC1pY29uPlxuICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBcIlxuICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiZGVsZXRlSXRlbShpdGVtLCBpZClcIj5cbiAgICAgICAgICAgIDxtZC1pY29uPmRlbGV0ZV9mb3JldmVyPC9tZC1pY29uPlxuICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBcIlxuICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwic2VsZWN0SXRlbShpdGVtKVwiPlxuICAgICAgICAgICAgPG1kLWljb24+a2V5Ym9hcmRfYXJyb3dfcmlnaHQ8L21kLWljb24+XG4gICAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICAgIDwvbWQtbGlzdC1pdGVtPlxuICAgICAgPC90cmFuc2l0aW9uLWdyb3VwPlxuICAgIDwvbWQtY29udGVudD5cblxuICA8L21kLWNvbnRlbnQ+XG5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBFdmVudEJ1cyB9IGZyb20gXCIuLi9ldmVudC1idXNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcIkFkbWluQ2F0ZWdvcnlcIixcbiAgY29tcG9uZW50czoge30sXG4gIHByb3BzOiBbXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudF9saXN0OiBbXSxcbiAgICAgIHNlbGVjdGVkOiB7fVxuICAgIH07XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBidG9hOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfSxcbiAgICBkZWxldGVJdGVtOiBmdW5jdGlvbihpdGVtLCBpZCkge1xuICAgICAgaWYgKGNvbmZpcm0oXCJjb25maW0gZGVsZXRlICFcIikgPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRfbGlzdC5zcGxpY2UoaWQsIDEpO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCA9PSBpdGVtKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50QnVzLiRlbWl0KFwiYWRtaW4tc2VsZWN0LWl0ZW1cIiwgdGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIEV2ZW50QnVzLiRlbWl0KFwidXBkYXRlLWxpc3RcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcImFkbWluLXNlbGVjdC1pdGVtXCIsIGl0ZW0pO1xuICAgIH0sXG4gICAgdXBJbkxzdDogZnVuY3Rpb24oaWQpIHtcbiAgICAgIGxldCBsaXN0ID0gdGhpcy5jdXJyZW50X2xpc3Q7XG4gICAgICBsZXQgYiA9IGxpc3RbaWRdO1xuICAgICAgbGlzdFtpZF0gPSBsaXN0W2lkIC0gMV07XG4gICAgICBsaXN0W2lkIC0gMV0gPSBiO1xuICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIEV2ZW50QnVzLiRlbWl0KFwidXBkYXRlLWxpc3RcIik7XG4gICAgfSxcbiAgICBkb3duSW5Mc3Q6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBsZXQgbGlzdCA9IHRoaXMuY3VycmVudF9saXN0O1xuICAgICAgbGV0IGIgPSBsaXN0W2lkXTtcbiAgICAgIGxpc3RbaWRdID0gbGlzdFtpZCArIDFdO1xuICAgICAgbGlzdFtpZCArIDFdID0gYjtcbiAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcInVwZGF0ZS1saXN0XCIpO1xuICAgIH0sXG4gICAgZ2V0TGlzdGVuOiBmdW5jdGlvbigpIHtcbiAgICAgIEV2ZW50QnVzLiRvbihcImFkbWluLXNlbGVjdC1pdGVtXCIsIGl0ZW0gPT4ge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gaXRlbTtcbiAgICAgIH0pO1xuICAgICAgRXZlbnRCdXMuJG9uKFwiYWRtaW4tc2VsZWN0LWxpc3RcIiwgbGlzdCA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudF9saXN0ID0gbGlzdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmdldExpc3RlbigpO1xuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG4ubm8tc2Nyb2xsIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi5tZC1sYXlvdXQge1xuICBoZWlnaHQ6IDEwMCU7XG59XG4ubGVmdC1jb250YWluZXIge1xuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA2NHB4KSAhaW1wb3J0YW50O1xufVxuLmFkbWluLWxlZnQtY29udGVudCB7XG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDEyOHB4KSAhaW1wb3J0YW50O1xuICBvdmVyZmxvdzogYXV0bztcbn1cbi5hZG1pbi1pdGVtLWxpc3Qge1xuICBib3JkZXI6IDFweCBzb2xpZCAjOWU5ZTllO1xuICBib3JkZXItcmFkaXVzOiAyMHB4O1xufVxuLmFkbWluLXNlbGVjdGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247XG59XG48L3N0eWxlPlxuXG48c3R5bGU+XG4uYWRtaW4taXRlbS1saXN0IC5tZC1saXN0LWl0ZW0tY29udGVudCB7XG4gIHBhZGRpbmctbGVmdDogNXB4O1xufVxuLmZsaXAtbGlzdC1tb3ZlIHtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnM7XG59XG4uZmxpcC1saXN0LWVudGVyLWFjdGl2ZSxcbi5mbGlwLWxpc3QtbGVhdmUtYWN0aXZlIHtcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzO1xufVxuLmZsaXAtbGlzdC1lbnRlcixcbi5mbGlwLWxpc3QtbGVhdmUtdG8ge1xuICBvcGFjaXR5OiAwO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPG1kLWNvbnRlbnQ+XG4gICAgPENyZWF0ZUNoaWxkTW9kYWwgOm9wZW5Nb2RhbEFkZD1cIm9wZW5Nb2RhbEFkZFwiXG4gICAgICAgICAgICAgICAgICAgICAgQGNsb3NlTW9kYWw9XCJvcGVuTW9kYWxBZGQgPSBmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwic2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIm9uTmV3Q2hpbGRcIj48L0NyZWF0ZUNoaWxkTW9kYWw+XG4gICAgPEVkaXRDaGlsZE1vZGFsIDpvcGVuTW9kYWxFZGl0PVwib3Blbk1vZGFsRWRpdFwiXG4gICAgICAgICAgICAgICAgICAgIEBjbG9zZU1vZGFsPVwib3Blbk1vZGFsRWRpdCA9IGZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgOnZhbHVlPVwiY2hpbGRTZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIm9uRWRpdENoaWxkXCI+PC9FZGl0Q2hpbGRNb2RhbD5cbiAgICA8bWQtdG9vbGJhciBjbGFzcz1cImFwcC1oZWFkZXJcIj5cbiAgICAgIDxoMz5DYXRlZ29yeSBDb250ZW50IENoaWxkcmVuPC9oMz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZC10b29sYmFyLXNlY3Rpb24tZW5kIGNvbG9yX2JsYWNrXCI+XG4gICAgICAgIDxtZC1idXR0b24gdi1pZj1cInNlbGVjdGVkLnR5cGUgPT09ICdpdGVtJ1wiXG4gICAgICAgICAgICAgICAgICAgY2xhc3M9XCJtZC1pY29uLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgQGNsaWNrPVwib3Blbk1vZGFsQWRkID0gdHJ1ZVwiPlxuICAgICAgICAgIDxtZC10b29sdGlwPkFkZCBDaGlsZDwvbWQtdG9vbHRpcD5cbiAgICAgICAgICA8bWQtaWNvbj5hZGQ8L21kLWljb24+XG4gICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9tZC10b29sYmFyPlxuXG4gICAgPG1kLWNvbnRlbnQgdi1pZj1cInNlbGVjdGVkLmNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm15X2NvbnRlbnRcIj5cbiAgICAgIDx0cmFuc2l0aW9uLWdyb3VwIG5hbWU9XCJmbGlwLWxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnPVwibWQtbGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWxpc3Qtbm8tcGFkZGluZ1wiPlxuICAgICAgICA8bWQtbGlzdC1pdGVtIHYtZm9yPVwiKGl0ZW0saWQpIGluIHNlbGVjdGVkLmNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICAgICAgICA6a2V5PVwiaXRlbS5sYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnYWRtaW4tc2VsZWN0ZWQnOiBpdGVtID09IHNlbGVjdGVkIH1cIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYWRtaW4taXRlbS1saXN0XCI+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBtZC1kZW5zZSBuby1tYXJnaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJpZCA9PSAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwidXBJbkxzdChpZClcIj5cbiAgICAgICAgICAgICAgPG1kLWljb24+ZXhwYW5kX2xlc3M8L21kLWljb24+XG4gICAgICAgICAgICA8L21kLWJ1dHRvbj5cbiAgICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBtZC1kZW5zZSBuby1tYXJnaW5cIlxuICAgICAgICAgICAgICAgICAgICAgICA6ZGlzYWJsZWQ9XCJzZWxlY3RlZC5jaGlsZHJlbi5sZW5ndGggLSAxID09IGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiZG93bkluTHN0KGlkKVwiPlxuICAgICAgICAgICAgICA8bWQtaWNvbj5leHBhbmRfbW9yZTwvbWQtaWNvbj5cbiAgICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZC1saXN0LWl0ZW0tdGV4dFwiPlxuICAgICAgICAgICAgPHNwYW4+bGFiZWw6IHt7aXRlbS5sYWJlbH19PC9zcGFuPlxuICAgICAgICAgICAgPHA+dGFyZ2V0X3VybDoge3tpdGVtLnRhcmdldF91cmx9fTwvcD5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIDxtZC1idXR0b24gdi1pZj1cIml0ZW0udGFyZ2V0X3VybCAmJiBpdGVtLnRhcmdldF91cmwubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWljb24tYnV0dG9uIFwiXG4gICAgICAgICAgICAgICAgICAgICA6dG89XCJidG9hKGl0ZW0udGFyZ2V0X3VybClcIj5cbiAgICAgICAgICAgIDxtZC1pY29uPm9wZW5faW5fbmV3PC9tZC1pY29uPlxuICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBcIlxuICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiZGVsZXRlSXRlbShpdGVtLCBpZClcIj5cbiAgICAgICAgICAgIDxtZC1pY29uPmRlbGV0ZV9mb3JldmVyPC9tZC1pY29uPlxuICAgICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvbiBcIlxuICAgICAgICAgICAgICAgICAgICAgQGNsaWNrPVwib3BlbkVkaXRDaGlsZChpdGVtKVwiPlxuICAgICAgICAgICAgPG1kLWljb24+ZWRpdDwvbWQtaWNvbj5cbiAgICAgICAgICA8L21kLWJ1dHRvbj5cbiAgICAgICAgPC9tZC1saXN0LWl0ZW0+XG4gICAgICA8L3RyYW5zaXRpb24tZ3JvdXA+XG4gICAgPC9tZC1jb250ZW50PlxuXG4gIDwvbWQtY29udGVudD5cblxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEV2ZW50QnVzIH0gZnJvbSBcIi4uL2V2ZW50LWJ1c1wiO1xuaW1wb3J0IENyZWF0ZUNoaWxkTW9kYWwgZnJvbSBcIi4vTW9kYWxzL0NyZWF0ZUNoaWxkLnZ1ZVwiO1xuaW1wb3J0IEVkaXRDaGlsZE1vZGFsIGZyb20gXCIuL01vZGFscy9FZGl0Q2hpbGQudnVlXCI7XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiQWRtaW5DYXRlZ29yeUNoaWxkcmVuXCIsXG4gIGNvbXBvbmVudHM6IHsgQ3JlYXRlQ2hpbGRNb2RhbCwgRWRpdENoaWxkTW9kYWwgfSxcbiAgcHJvcHM6IFtdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDoge30sXG4gICAgICBjaGlsZFNlbGVjdGVkOiB7fSxcbiAgICAgIG9wZW5Nb2RhbEFkZDogZmFsc2UsXG4gICAgICBvcGVuTW9kYWxFZGl0OiBmYWxzZVxuICAgIH07XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGRlbGV0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGlkKSB7XG4gICAgICBpZiAoY29uZmlybShcImNvbmZpbSBkZWxldGUgIVwiKSA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQuY2hpbGRyZW4uc3BsaWNlKGlkLCAxKTtcbiAgICAgICAgRXZlbnRCdXMuJGVtaXQoXCJ1cGRhdGUtY2hpbGRyZW5cIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBidG9hOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfSxcbiAgICBvbk5ld0NoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkLmNoaWxkcmVuKSB0aGlzLnNlbGVjdGVkLmNoaWxkcmVuID0gW107XG4gICAgICB0aGlzLnNlbGVjdGVkLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgdGhpcy5vcGVuTW9kYWxBZGQgPSBmYWxzZTtcbiAgICAgIEV2ZW50QnVzLiRlbWl0KFwidXBkYXRlLWNoaWxkcmVuXCIpO1xuICAgIH0sXG4gICAgb3BlbkVkaXRDaGlsZDogZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdGhpcy5jaGlsZFNlbGVjdGVkID0gaXRlbTtcbiAgICAgIHRoaXMub3Blbk1vZGFsRWRpdCA9IHRydWU7XG4gICAgfSxcbiAgICBvbkVkaXRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHRoaXMuY2hpbGRTZWxlY3RlZC5sYWJlbCA9IGNoaWxkLmxhYmVsO1xuICAgICAgdGhpcy5jaGlsZFNlbGVjdGVkLnRhcmdldF91cmwgPSBjaGlsZC50YXJnZXRfdXJsO1xuICAgICAgdGhpcy5vcGVuTW9kYWxFZGl0ID0gZmFsc2U7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcInVwZGF0ZS1jaGlsZHJlblwiKTtcbiAgICB9LFxuICAgIHVwSW5Mc3Q6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBsZXQgbGlzdCA9IHRoaXMuc2VsZWN0ZWQuY2hpbGRyZW47XG4gICAgICB2YXIgYiA9IGxpc3RbaWRdO1xuICAgICAgbGlzdFtpZF0gPSBsaXN0W2lkIC0gMV07XG4gICAgICBsaXN0W2lkIC0gMV0gPSBiO1xuICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIEV2ZW50QnVzLiRlbWl0KFwidXBkYXRlLWNoaWxkcmVuXCIpO1xuICAgIH0sXG4gICAgZG93bkluTHN0OiBmdW5jdGlvbihpZCkge1xuICAgICAgbGV0IGxpc3QgPSB0aGlzLnNlbGVjdGVkLmNoaWxkcmVuO1xuICAgICAgdmFyIGIgPSBsaXN0W2lkXTtcbiAgICAgIGxpc3RbaWRdID0gbGlzdFtpZCArIDFdO1xuICAgICAgbGlzdFtpZCArIDFdID0gYjtcbiAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcInVwZGF0ZS1jaGlsZHJlblwiKTtcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgRXZlbnRCdXMuJG9uKFwiYWRtaW4tc2VsZWN0LWl0ZW1cIiwgc2VsZWN0ZWQgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH0pO1xuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG4ubm8tbWFyZ2luIHtcbiAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG59XG4uYWRtaW4taXRlbS1saXN0IHtcbiAgYm9yZGVyOiAxcHggc29saWQgd2hpdGU7XG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XG59XG4uYWRtaW4tc2VsZWN0ZWQge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiBicm93bjtcbn1cbi5jYXRlZ29yeS1jb250ZW50LWVkaXQge1xuICBwYWRkaW5nLWJvdHRvbTogNXB4O1xuICBwYWRkaW5nLXRvcDogNXB4O1xufVxuLmNhdGVnb3J5LWNvbnRlbnQtZWRpdCAubWQtY2FyZC1jb250ZW50IHtcbiAgcGFkZGluZy1ib3R0b206IDBweDtcbiAgcGFkZGluZy10b3A6IDBweDtcbn1cbi5jYXRlZ29yeS1jb250ZW50LWVkaXQgLm1kLWZpZWxkIHtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxtZC1jb250ZW50IGNsYXNzPVwibWQtc2Nyb2xsYmFyIGNhdGVnb3J5LWNvbnRlbnQtY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgbWQtZHluYW1pYy1oZWlnaHQ+XG4gICAgPG1kLXRvb2xiYXIgY2xhc3M9XCJhcHAtaGVhZGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWQtbGlzdC1pdGVtLXRleHRcIj5cbiAgICAgICAgPHNwYW4+bGFiZWw6IHt7c2VsZWN0ZWQubGFiZWx9fTwvc3Bhbj5cbiAgICAgICAgPHNwYW4+dHlwZSA6IHt7c2VsZWN0ZWQudHlwZX19PC9zcGFuPlxuICAgICAgICA8cD50YXJnZXRfdXJsOiB7e3NlbGVjdGVkLnRhcmdldF91cmx9fVxuICAgICAgICAgIDxtZC10b29sdGlwIHYtaWY9XCJzZWxlY3RlZC50YXJnZXRfdXJsICYmIHNlbGVjdGVkLnRhcmdldF91cmwubGVuZ3RoID4gMTBcIj57e3NlbGVjdGVkLnRhcmdldF91cmx9fTwvbWQtdG9vbHRpcD5cbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibWQtdG9vbGJhci1zZWN0aW9uLWVuZCBjb2xvcl9ibGFja1wiPlxuICAgICAgICA8aDM+Q29udGVudDwvaDM+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1pY29uLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgQGNsaWNrPVwiZWRpdENvbnRlbnQgPSAhZWRpdENvbnRlbnRcIj5cbiAgICAgICAgICA8bWQtdG9vbHRpcD5BZGQgQ2hpbGQ8L21kLXRvb2x0aXA+XG4gICAgICAgICAgPG1kLWljb24+ZWRpdDwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICAgIDxtZC1idXR0b24gdi1pZj1cInNlbGVjdGVkLnRhcmdldF91cmwgJiYgc2VsZWN0ZWQudGFyZ2V0X3VybC5sZW5ndGggPiAwXCJcbiAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWljb24tYnV0dG9uIFwiXG4gICAgICAgICAgICAgICAgICAgOnRvPVwiYnRvYShzZWxlY3RlZC50YXJnZXRfdXJsKVwiPlxuICAgICAgICAgIDxtZC1pY29uPm9wZW5faW5fbmV3PC9tZC1pY29uPlxuICAgICAgICA8L21kLWJ1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbWQtdG9vbGJhcj5cbiAgICA8dHJhbnNpdGlvbiBuYW1lPVwic2xpZGUtZmFkZVwiPlxuXG4gICAgICA8bWQtY29udGVudCBtZC1lbGV2YXRpb249XCIxXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiY2F0ZWdvcnktY29udGVudC1lZGl0XCJcbiAgICAgICAgICAgICAgICAgIHYtaWY9XCJlZGl0Q29udGVudFwiPlxuICAgICAgICA8bWQtY2FyZC1jb250ZW50IHYtaWY9XCIhc2VsZWN0ZWQudHlwZVwiPlxuICAgICAgICAgIDxtZC1lbXB0eS1zdGF0ZSBtZC1pY29uPVwiY2FuY2VsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWQtbGFiZWw9XCJOb3RoaW5nIFNlbGVjdGVkXCI+XG4gICAgICAgICAgPC9tZC1lbXB0eS1zdGF0ZT5cbiAgICAgICAgPC9tZC1jYXJkLWNvbnRlbnQ+XG5cbiAgICAgICAgPG1kLWNhcmQtY29udGVudCB2LWVsc2U+XG4gICAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInR5cGVcIj5UeXBlPC9sYWJlbD5cbiAgICAgICAgICAgIDxtZC1zZWxlY3Qgdi1tb2RlbD1cInNlbGVjdGVkVHlwZVwiPlxuICAgICAgICAgICAgICA8bWQtb3B0aW9uIHZhbHVlPVwiaXRlbVwiPml0ZW08L21kLW9wdGlvbj5cbiAgICAgICAgICAgICAgPG1kLW9wdGlvbiB2YWx1ZT1cInN1YmhlYWRlclwiPnN1YmhlYWRlcjwvbWQtb3B0aW9uPlxuICAgICAgICAgICAgICA8bWQtb3B0aW9uIHZhbHVlPVwiZGl2aWRlclwiPmRpdmlkZXI8L21kLW9wdGlvbj5cbiAgICAgICAgICAgIDwvbWQtc2VsZWN0PlxuICAgICAgICAgIDwvbWQtZmllbGQ+XG5cbiAgICAgICAgICA8bWQtZmllbGQ+XG4gICAgICAgICAgICA8bGFiZWw+TGFiZWw8L2xhYmVsPlxuICAgICAgICAgICAgPG1kLWlucHV0IHYtbW9kZWw9XCJzZWxlY3RlZExhYmVsXCI+PC9tZC1pbnB1dD5cbiAgICAgICAgICA8L21kLWZpZWxkPlxuXG4gICAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgICAgPGxhYmVsPlRhcmdldCBVcmw8L2xhYmVsPlxuICAgICAgICAgICAgPG1kLWlucHV0IHYtbW9kZWw9XCJzZWxlY3RlZFRhcmdldF91cmxcIj48L21kLWlucHV0PlxuICAgICAgICAgIDwvbWQtZmllbGQ+XG4gICAgICAgIDwvbWQtY2FyZC1jb250ZW50PlxuICAgICAgPC9tZC1jb250ZW50PlxuICAgIDwvdHJhbnNpdGlvbj5cbiAgICA8QWRtaW5DYXRlZ29yeUNoaWxkcmVuIEB1cGRhdGUtY2hpbGRyZW49XCJvblVwZGF0ZUNoaWxkcmVuXCI+PC9BZG1pbkNhdGVnb3J5Q2hpbGRyZW4+XG4gIDwvbWQtY29udGVudD5cblxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgQWRtaW5DYXRlZ29yeUNoaWxkcmVuIGZyb20gXCIuL0FkbWluQ2F0ZWdvcnlDaGlsZHJlbi52dWVcIjtcbmltcG9ydCB7IEV2ZW50QnVzIH0gZnJvbSBcIi4uL2V2ZW50LWJ1c1wiO1xuY29uc3QgZGVib3VuY2UgPSByZXF1aXJlKFwibG9kYXNoLmRlYm91bmNlXCIpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiQWRtaW5DYXRlZ29yeUNvbnRlbnRcIixcbiAgY29tcG9uZW50czogeyBBZG1pbkNhdGVnb3J5Q2hpbGRyZW4gfSxcbiAgcHJvcHM6IFtdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDoge30sXG4gICAgICBlZGl0Q29udGVudDogZmFsc2VcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNlbGVjdGVkVHlwZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQudHlwZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkLnR5cGUgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMub25VcGRhdGVDaGlsZHJlbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0ZWRMYWJlbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQubGFiZWw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZC5sYWJlbCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5vblVwZGF0ZUNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3RlZFRhcmdldF91cmw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkLnRhcmdldF91cmw7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZC50YXJnZXRfdXJsID0gcmVzdWx0O1xuICAgICAgICB0aGlzLm9uVXBkYXRlQ2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBidG9hOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfSxcbiAgICB0b2dnbGVNb2RhbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbWl0KFwiYWRtaW4tY3JlYXRlLWl0ZW1cIik7XG4gICAgfSxcbiAgICBvblVwZGF0ZUNoaWxkcmVuOiBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgIEV2ZW50QnVzLiRlbWl0KFwidXBkYXRlLWNoaWxkcmVuXCIpO1xuICAgIH0sIDEwMDApXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgRXZlbnRCdXMuJG9uKFwiYWRtaW4tc2VsZWN0LWl0ZW1cIiwgc2VsZWN0ZWQgPT4ge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH0pO1xuICB9XG59O1xuPC9zY3JpcHQ+XG48c3R5bGU+XG4uc2xpZGUtZmFkZS1lbnRlci1hY3RpdmUge1xuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufVxuLnNsaWRlLWZhZGUtbGVhdmUtYWN0aXZlIHtcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgY3ViaWMtYmV6aWVyKDEsIDAuNSwgMC44LCAxKTtcbn1cbi5zbGlkZS1mYWRlLWVudGVyLFxuLnNsaWRlLWZhZGUtbGVhdmUtdG8ge1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjBweCk7XG4gIG9wYWNpdHk6IDA7XG59XG48L3N0eWxlPlxuXG5cbjxzdHlsZSBzY29wZWQ+XG4uY2F0ZWdvcnktY29udGVudC1jb250YWluZXIge1xuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA2NHB4KSAhaW1wb3J0YW50O1xuICBvdmVyZmxvdzogYXV0bztcbn1cbi5teV9jb250ZW50IHtcbiAgYm9yZGVyOiAxcHggc29saWQgcmVkO1xufVxuLmFkbWluLWl0ZW0tbGlzdCB7XG4gIGJvcmRlcjogMXB4IHNvbGlkIHdoaXRlO1xuICBib3JkZXItcmFkaXVzOiAyMHB4O1xufVxuLmFkbWluLXNlbGVjdGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247XG59XG4uY2F0ZWdvcnktY29udGVudC1lZGl0IHtcbiAgcGFkZGluZy1ib3R0b206IDVweDtcbiAgcGFkZGluZy10b3A6IDVweDtcbn1cbi5jYXRlZ29yeS1jb250ZW50LWVkaXQgLm1kLWNhcmQtY29udGVudCB7XG4gIHBhZGRpbmctYm90dG9tOiAwcHg7XG4gIHBhZGRpbmctdG9wOiAwcHg7XG59XG4uY2F0ZWdvcnktY29udGVudC1lZGl0IC5tZC1maWVsZCB7XG4gIG1hcmdpbi1ib3R0b206IDEwcHg7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWQtbGF5b3V0XCI+XG4gICAgPENyZWF0ZUNhdGVnb3J5TW9kYWwgOm9wZW5Nb2RhbEFkZD1cIm9wZW5DcmVhdGVDYXRlZ29yeU1vZGFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBAY2xvc2VNb2RhbD1cIm9wZW5DcmVhdGVDYXRlZ29yeU1vZGFsID0gZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWx1ZT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIm9uTmV3Q2F0ZWdvcnlcIj48L0NyZWF0ZUNhdGVnb3J5TW9kYWw+XG4gICAgPENvZGVJTyA6b3BlbkNvZGVJTz1cIm9wZW5Db2RlSU9cIlxuICAgICAgICAgICAgQGNsb3NlTW9kYWw9XCJvcGVuQ29kZUlPID0gZmFsc2VcIlxuICAgICAgICAgICAgOmxpc3Q9XCJsaXN0XCJcbiAgICAgICAgICAgIEB1cGRhdGVMaXN0PVwib25VcGRhdGVMaXN0XCI+PC9Db2RlSU8+XG5cbiAgICA8QWRtaW5DYXRlZ29yeSBAc2F2ZS1kYXRhPVwib25TYXZlXCJcbiAgICAgICAgICAgICAgICAgICBAcmVsb2FkLWRhdGE9XCJvblJlbG9hZFwiXG4gICAgICAgICAgICAgICAgICAgQGNvZGVJTy1kYXRhPVwib3BlbkNvZGVJTyA9IHRydWVcIlxuICAgICAgICAgICAgICAgICAgIEBhZG1pbi1jcmVhdGUtaXRlbT1cIm9wZW5DcmVhdGVDYXRlZ29yeU1vZGFsID0gIW9wZW5DcmVhdGVDYXRlZ29yeU1vZGFsXCJcbiAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWxheW91dC1pdGVtIG1kLXNpemUtMzMgbGF5b3V0LWl0ZW0tbm8tc2Nyb2xsXCI+PC9BZG1pbkNhdGVnb3J5PlxuICAgIDxBZG1pbkNhdGVnb3J5Q29udGVudCBjbGFzcz1cIm1kLWxheW91dC1pdGVtIG1kLXNpemUtMzMgbGF5b3V0LWl0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBAdXBkYXRlLWNoaWxkcmVuPVwib25VcGRhdGVDaGlsZHJlblwiPjwvQWRtaW5DYXRlZ29yeUNvbnRlbnQ+XG5cbiAgICA8TWFpbkNvbnRlbnQgY2xhc3M9XCJtZC1sYXlvdXQtaXRlbSBtZC1zaXplLTMzIGxheW91dC1pdGVtXCI+PC9NYWluQ29udGVudD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEFkbWluQ2F0ZWdvcnkgZnJvbSBcIi4vQWRtaW5DYXRlZ29yeS52dWVcIjtcbmltcG9ydCBBZG1pbkNhdGVnb3J5Q29udGVudCBmcm9tIFwiLi9BZG1pbkNhdGVnb3J5Q29udGVudC52dWVcIjtcbmltcG9ydCBNYWluQ29udGVudCBmcm9tIFwiLi4vTWFpbkNvbnRlbnQvTWFpbkNvbnRlbnQudnVlXCI7XG5pbXBvcnQgQ3JlYXRlQ2F0ZWdvcnlNb2RhbCBmcm9tIFwiLi9Nb2RhbHMvQ3JlYXRlQ2F0ZWdvcnkudnVlXCI7XG5pbXBvcnQgQ29kZUlPIGZyb20gXCIuL01vZGFscy9Db2RlSU8udnVlXCI7XG5pbXBvcnQgeyBFdmVudEJ1cyB9IGZyb20gXCIuLi9ldmVudC1idXNcIjtcbmxldCBpZCA9IDA7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJBZG1pbkNvbnRlbnRcIixcbiAgY29tcG9uZW50czoge1xuICAgIEFkbWluQ2F0ZWdvcnksXG4gICAgQWRtaW5DYXRlZ29yeUNvbnRlbnQsXG4gICAgTWFpbkNvbnRlbnQsXG4gICAgQ3JlYXRlQ2F0ZWdvcnlNb2RhbCxcbiAgICBDb2RlSU9cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGlzdDogW10sXG4gICAgICBzZWxlY3RlZEl0ZW06IHt9LFxuICAgICAgb3BlbkNyZWF0ZUNhdGVnb3J5TW9kYWw6IGZhbHNlLFxuICAgICAgb3BlbkNvZGVJTzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25JdGVtU2VsZWN0ZWQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICB9LFxuICAgIG9uVXBkYXRlTGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtID0ge307XG4gICAgICBFdmVudEJ1cy4kZW1pdChcImFkbWluLXNlbGVjdC1saXN0XCIsIHRoaXMubGlzdCk7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcImFkbWluLXNlbGVjdC1pdGVtXCIsIHRoaXMuc2VsZWN0ZWRJdGVtKTtcbiAgICB9LFxuICAgIG9uVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICB9LFxuICAgIG9uTmV3Q2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgICB0aGlzLmxpc3QucHVzaCh7XG4gICAgICAgIGxhYmVsOiBjYXRlZ29yeS5sYWJlbCxcbiAgICAgICAgdHlwZTogY2F0ZWdvcnkudHlwZSxcbiAgICAgICAgdGFyZ2V0X3VybDogY2F0ZWdvcnkudGFyZ2V0X3VybCxcbiAgICAgICAgaWQ6ICsraWRcbiAgICAgIH0pO1xuICAgICAgRXZlbnRCdXMuJGVtaXQoXCJ1cGRhdGUtbGlzdFwiKTtcbiAgICB9LFxuICAgIG9uU2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgd2luZG93LnNwaW5hbC5zcGluYWxTeXN0ZW0uZ2V0TW9kZWwoKS50aGVuKG1vZGVsID0+IHtcbiAgICAgICAgbW9kZWwuc2V0KHZtLmxpc3QpO1xuICAgICAgICBFdmVudEJ1cy4kZW1pdChcIlVQREFURS1NT0RFTFwiLCBtb2RlbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldE1heElkOiBmdW5jdGlvbihsc3QpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxzdFtpXS5pZCkgbWF4ID0gbHN0W2ldLmlkID4gbWF4ID8gbHN0W2ldLmlkIDogbWF4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuICAgIG9uUmVsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB3aW5kb3cuc3BpbmFsLnNwaW5hbFN5c3RlbS5nZXRNb2RlbCgpLnRoZW4obW9kZWwgPT4ge1xuICAgICAgICB2bS5saXN0ID0gbW9kZWwuZ2V0KCk7XG4gICAgICAgIGlkID0gdGhpcy5nZXRNYXhJZCh2bS5saXN0KTtcbiAgICAgICAgdm0uc2VsZWN0ZWRJdGVtID0ge307XG4gICAgICAgIEV2ZW50QnVzLiRlbWl0KFwiYWRtaW4tc2VsZWN0LWxpc3RcIiwgdm0ubGlzdCk7XG4gICAgICAgIEV2ZW50QnVzLiRlbWl0KFwiYWRtaW4tc2VsZWN0LWl0ZW1cIiwgdGhpcy5zZWxlY3RlZEl0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMub25SZWxvYWQoKTtcbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLmxheW91dC1pdGVtIHtcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNjRweCkgIWltcG9ydGFudDtcbiAgb3ZlcmZsb3c6IGF1dG87XG4gIGJvcmRlcjogMXB4IHNvbGlkICM5ZTllOWU7XG59XG4ubGF5b3V0LWl0ZW0tbm8tc2Nyb2xsIHtcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNjRweCkgIWltcG9ydGFudDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgYm9yZGVyOiAxcHggc29saWQgIzllOWU5ZTtcbn1cblxuLyogLm1kLWxheW91dCB7XG59ICovXG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuXG4gIDxtZC1kaWFsb2cgOm1kLWFjdGl2ZS5zeW5jPVwib3Blbk1vZGFsXCJcbiAgICAgICAgICAgICA6bWQtZnVsbHNjcmVlbj10cnVlPlxuICAgIDxtZC1kaWFsb2ctdGl0bGU+Q29kZSBJTzwvbWQtZGlhbG9nLXRpdGxlPlxuICAgIDxtZC1kaWFsb2ctY29udGVudD5cbiAgICAgIDwhLS0gPE1vbmFjb0VkaXRvciBzdHlsZT1cImhlaWdodDogY2FsYyg4MHZoIC0gMTUwcHgpXCJcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U9XCJqc29uXCJcbiAgICAgICAgICAgICAgICAgICAgOmNvZGU9XCJzdHJfY29kZVwiXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbj1cIm9wdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIEBjb2RlQ2hhbmdlPVwib25Db2RlQ2hhbmdlXCI+XG4gICAgICA8L01vbmFjb0VkaXRvcj5cbiAtLT5cbiAgICAgIDxNb25hY29FZGl0b3IgY2xhc3M9XCJlZGl0b3JcIlxuICAgICAgICAgICAgICAgICAgICB2LW1vZGVsPVwic3RyX2NvZGVcIlxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZT1cImpzb25cIj5cbiAgICAgIDwvTW9uYWNvRWRpdG9yPlxuXG4gICAgICA8IS0tIDxWbENvZGUgdi1tb2RlbD1cInN0cl9jb2RlXCIgLz4gLS0+XG4gICAgPC9tZC1kaWFsb2ctY29udGVudD5cbiAgICA8bWQtZGlhbG9nLWFjdGlvbnM+XG4gICAgICA8bWQtYnV0dG9uIGNsYXNzPVwibWQtcmFpc2VkIG1kLWFjY2VudFwiXG4gICAgICAgICAgICAgICAgIEBjbGljaz1cIm9uQ2FuY2VsXCI+XG4gICAgICAgIENhbmNlbFxuICAgICAgICA8bWQtaWNvbj5jYW5jZWw8L21kLWljb24+XG4gICAgICA8L21kLWJ1dHRvbj5cbiAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgIEBjbGljaz1cInNhdmVcIj5cbiAgICAgICAgU2F2ZVxuICAgICAgICA8bWQtaWNvbj5jaGVjazwvbWQtaWNvbj5cbiAgICAgIDwvbWQtYnV0dG9uPlxuICAgIDwvbWQtZGlhbG9nLWFjdGlvbnM+XG4gIDwvbWQtZGlhbG9nPlxuXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLy8gaW1wb3J0IFZsQ29kZSBmcm9tIFwiLi9Db2RlTWlycm9yLnZ1ZVwiO1xuaW1wb3J0IHsgRXZlbnRCdXMgfSBmcm9tIFwiLi4vLi4vZXZlbnQtYnVzXCI7XG5jb25zdCBkZWJvdW5jZSA9IHJlcXVpcmUoXCJsb2Rhc2guZGVib3VuY2VcIik7XG4vLyBpbXBvcnQgTW9uYWNvRWRpdG9yIGZyb20gXCJ2dWUtbW9uYWNvLWVkaXRvclwiO1xuaW1wb3J0IE1vbmFjb0VkaXRvciBmcm9tIFwiLi9Db2RlTW9uYWNvLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJDb2RlSU9cIixcbiAgLy8gY29tcG9uZW50czogeyBNb25hY29FZGl0b3IgfSxcbiAgY29tcG9uZW50czogeyBNb25hY29FZGl0b3IgfSxcbiAgLy8gY29tcG9uZW50czogeyBWbENvZGUgfSxcbiAgcHJvcHM6IFtcIm9wZW5Db2RlSU9cIiwgXCJsaXN0XCJdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJfY29kZTogXCJcIlxuICAgICAgLy8gb3B0aW9uOiB7XG4gICAgICAvLyAgIHNlbGVjdE9uTGluZU51bWJlcnM6IHRydWUsXG4gICAgICAvLyAgIHJvdW5kZWRTZWxlY3Rpb246IGZhbHNlLFxuICAgICAgLy8gICByZWFkT25seTogZmFsc2UsXG4gICAgICAvLyAgIGN1cnNvclN0eWxlOiBcImxpbmVcIixcbiAgICAgIC8vICAgYXV0b21hdGljTGF5b3V0OiB0cnVlLFxuICAgICAgLy8gICBnbHlwaE1hcmdpbjogdHJ1ZVxuICAgICAgLy8gfVxuICAgIH07XG4gIH0sXG4gIC8vIHdhdGNoOiB7XG4gIC8vICAgbGlzdDogZnVuY3Rpb24oKSB7XG4gIC8vICAgICAvLyBpZiAodGhpcy5saXN0KSB0aGlzLnN0cl9jb2RlID0gSlNPTi5zdHJpbmdpZnkodGhpcy5saXN0LCBudWxsLCAyKTtcbiAgLy8gICAgIC8vIGVsc2UgdGhpcy5zdHJfY29kZSA9IFwiXCI7XG4gIC8vICAgfVxuICAvLyB9LFxuICBjb21wdXRlZDoge1xuICAgIG9wZW5Nb2RhbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbkNvZGVJTztcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRlbWl0KFwiY2xvc2VNb2RhbFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNvZGVDaGFuZ2U6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgY29uc29sZS5sb2coZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZW1pdChcImNsb3NlTW9kYWxcIik7XG4gICAgfSxcbiAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKHRoaXMuc3RyX2NvZGUpO1xuICAgICAgICB0aGlzLiRlbWl0KFwidXBkYXRlTGlzdFwiLCBvYmopO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGV0IG1vZGVsTWFya2VycyA9IHdpbmRvdy5tb25hY28uZWRpdG9yXG4gICAgICAgICAgLmdldE1vZGVsTWFya2Vycyh7fSlcbiAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgbSA9PiBgRXJyb3I6ICgke20uc3RhcnRMaW5lTnVtYmVyfSwke20uc3RhcnRDb2x1bW59KSAke20ubWVzc2FnZX1gXG4gICAgICAgICAgKVxuICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhtb2RlbE1hcmtlcnMpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcblxuICAgICAgICAvL1xuICAgICAgICAvL1xuICAgICAgICAvLyApO1xuICAgICAgICBhbGVydChtb2RlbE1hcmtlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgRXZlbnRCdXMuJG9uKFxuICAgICAgW1wiYWRtaW4tc2VsZWN0LWl0ZW1cIiwgXCJ1cGRhdGUtY2hpbGRyZW5cIiwgXCJ1cGRhdGUtbGlzdFwiXSxcbiAgICAgIGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubGlzdCkgdGhpcy5zdHJfY29kZSA9IEpTT04uc3RyaW5naWZ5KHRoaXMubGlzdCwgbnVsbCwgMik7XG4gICAgICAgIGVsc2UgdGhpcy5zdHJfY29kZSA9IFwiXCI7XG4gICAgICB9LCA1MDApXG4gICAgKTtcbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLm1kLWRpYWxvZyB7XG4gIG1pbi13aWR0aDogODB2dztcbiAgbWluLWhlaWdodDogODB2aDtcbn1cbi5lZGl0b3Ige1xuICBoZWlnaHQ6IGNhbGMoODB2aCAtIDE1MHB4KTtcbn1cbjwvc3R5bGU+XG4iLCIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBhc3NpZ24gZnJvbSBcIm5hbm8tYXNzaWduXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJNb25hY29FZGl0b3JcIixcblxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgdGhlbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IFwidnMtZGFya1wiXG4gICAgfSxcbiAgICBsYW5ndWFnZTogU3RyaW5nLFxuICAgIG9wdGlvbnM6IE9iamVjdCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICByZXF1aXJlOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIGRlZmF1bHQ6IHdpbmRvdy5yZXF1aXJlXG4gICAgfVxuICB9LFxuXG4gIG1vZGVsOiB7XG4gICAgZXZlbnQ6IFwiY2hhbmdlXCJcbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JMb2FkZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcblxuICB3YXRjaDoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRlZXA6IHRydWUsXG4gICAgICBoYW5kbGVyKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICAgICAgdGhpcy5lZGl0b3IudXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWx1ZShuZXdWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBsYW5ndWFnZShuZXdWYWwpIHtcbiAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICB3aW5kb3cubW9uYWNvLmVkaXRvci5zZXRNb2RlbExhbmd1YWdlKHRoaXMuZWRpdG9yLmdldE1vZGVsKCksIG5ld1ZhbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRoZW1lKG5ld1ZhbCkge1xuICAgICAgaWYgKHRoaXMuZWRpdG9yKSB7XG4gICAgICAgIHdpbmRvdy5tb25hY28uZWRpdG9yLnNldFRoZW1lKG5ld1ZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgdGhlbWU6IHRoaXMudGhlbWUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgIH07XG4gICAgcmVxdWlyZShcIi4vLi4vLi4vLi4vd3d3L3ZzL2xhbmd1YWdlL2pzb24vbW9uYWNvLmNvbnRyaWJ1dGlvbi5qc1wiKTtcbiAgICB0aGlzLmVkaXRvckxvYWRlZCA9IHRydWU7XG4gICAgdGhpcy5lZGl0b3IgPSB3aW5kb3cubW9uYWNvLmVkaXRvci5jcmVhdGUodGhpcy4kZWwsIG9wdGlvbnMpO1xuICAgIHRoaXMuJGVtaXQoXCJlZGl0b3JNb3VudFwiLCB0aGlzLmVkaXRvcik7XG4gICAgdGhpcy5lZGl0b3Iub25Db250ZXh0TWVudShldmVudCA9PiB0aGlzLiRlbWl0KFwiY29udGV4dE1lbnVcIiwgZXZlbnQpKTtcbiAgICB0aGlzLmVkaXRvci5vbkRpZEJsdXJFZGl0b3IoKCkgPT4gdGhpcy4kZW1pdChcImJsdXJcIikpO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkQmx1ckVkaXRvclRleHQoKCkgPT4gdGhpcy4kZW1pdChcImJsdXJUZXh0XCIpKTtcbiAgICB0aGlzLmVkaXRvci5vbkRpZENoYW5nZUNvbmZpZ3VyYXRpb24oZXZlbnQgPT5cbiAgICAgIHRoaXMuJGVtaXQoXCJjb25maWd1cmF0aW9uXCIsIGV2ZW50KVxuICAgICk7XG4gICAgdGhpcy5lZGl0b3Iub25EaWRDaGFuZ2VDdXJzb3JQb3NpdGlvbihldmVudCA9PlxuICAgICAgdGhpcy4kZW1pdChcInBvc2l0aW9uXCIsIGV2ZW50KVxuICAgICk7XG4gICAgdGhpcy5lZGl0b3Iub25EaWRDaGFuZ2VDdXJzb3JTZWxlY3Rpb24oZXZlbnQgPT5cbiAgICAgIHRoaXMuJGVtaXQoXCJzZWxlY3Rpb25cIiwgZXZlbnQpXG4gICAgKTtcbiAgICB0aGlzLmVkaXRvci5vbkRpZENoYW5nZU1vZGVsKGV2ZW50ID0+IHRoaXMuJGVtaXQoXCJtb2RlbFwiLCBldmVudCkpO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkQ2hhbmdlTW9kZWxDb250ZW50KGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICB0aGlzLiRlbWl0KFwiY2hhbmdlXCIsIHZhbHVlLCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3Iub25EaWRDaGFuZ2VNb2RlbERlY29yYXRpb25zKGV2ZW50ID0+XG4gICAgICB0aGlzLiRlbWl0KFwibW9kZWxEZWNvcmF0aW9uc1wiLCBldmVudClcbiAgICApO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkQ2hhbmdlTW9kZWxMYW5ndWFnZShldmVudCA9PlxuICAgICAgdGhpcy4kZW1pdChcIm1vZGVsTGFuZ3VhZ2VcIiwgZXZlbnQpXG4gICAgKTtcbiAgICB0aGlzLmVkaXRvci5vbkRpZENoYW5nZU1vZGVsT3B0aW9ucyhldmVudCA9PlxuICAgICAgdGhpcy4kZW1pdChcIm1vZGVsT3B0aW9uc1wiLCBldmVudClcbiAgICApO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkRGlzcG9zZShldmVudCA9PiB0aGlzLiRlbWl0KFwiYWZ0ZXJEaXNwb3NlXCIsIGV2ZW50KSk7XG4gICAgdGhpcy5lZGl0b3Iub25EaWRGb2N1c0VkaXRvcigoKSA9PiB0aGlzLiRlbWl0KFwiZm9jdXNcIikpO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkRm9jdXNFZGl0b3JUZXh0KCgpID0+IHRoaXMuJGVtaXQoXCJmb2N1c1RleHRcIikpO1xuICAgIHRoaXMuZWRpdG9yLm9uRGlkTGF5b3V0Q2hhbmdlKGV2ZW50ID0+IHRoaXMuJGVtaXQoXCJsYXlvdXRcIiwgZXZlbnQpKTtcbiAgICB0aGlzLmVkaXRvci5vbkRpZFNjcm9sbENoYW5nZShldmVudCA9PiB0aGlzLiRlbWl0KFwic2Nyb2xsXCIsIGV2ZW50KSk7XG4gICAgdGhpcy5lZGl0b3Iub25LZXlEb3duKGV2ZW50ID0+IHRoaXMuJGVtaXQoXCJrZXlkb3duXCIsIGV2ZW50KSk7XG4gICAgdGhpcy5lZGl0b3Iub25LZXlVcChldmVudCA9PiB0aGlzLiRlbWl0KFwia2V5dXBcIiwgZXZlbnQpKTtcbiAgICB0aGlzLmVkaXRvci5vbk1vdXNlRG93bihldmVudCA9PiB0aGlzLiRlbWl0KFwibW91c2VEb3duXCIsIGV2ZW50KSk7XG4gICAgdGhpcy5lZGl0b3Iub25Nb3VzZUxlYXZlKGV2ZW50ID0+IHRoaXMuJGVtaXQoXCJtb3VzZUxlYXZlXCIsIGV2ZW50KSk7XG4gICAgdGhpcy5lZGl0b3Iub25Nb3VzZU1vdmUoZXZlbnQgPT4gdGhpcy4kZW1pdChcIm1vdXNlTW92ZVwiLCBldmVudCkpO1xuICAgIHRoaXMuZWRpdG9yLm9uTW91c2VVcChldmVudCA9PiB0aGlzLiRlbWl0KFwibW91c2VVcFwiLCBldmVudCkpO1xuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5lZGl0b3IgJiYgdGhpcy5lZGl0b3IuZGlzcG9zZSgpO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRNb25hY28oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3I7XG4gICAgfSxcblxuICAgIGZvY3VzKCkge1xuICAgICAgdGhpcy5lZGl0b3IuZm9jdXMoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyKGgpIHtcbiAgICByZXR1cm4gaChcImRpdlwiLCBudWxsLCBbdGhpcy5lZGl0b3JMb2FkZWQgPyBudWxsIDogdGhpcy5wbGFjZWhvbGRlcl0pO1xuICB9XG59O1xuIiwiPHRlbXBsYXRlPlxuICA8bWQtZGlhbG9nIDptZC1hY3RpdmUuc3luYz1cIm9wZW5Nb2RhbFwiPlxuICAgIDxtZC1kaWFsb2ctdGl0bGU+QWRkIENhdGVnb3J5PC9tZC1kaWFsb2ctdGl0bGU+XG4gICAgPGZvcm0gaWQ9XCJhcHBcIlxuICAgICAgICAgIEBzdWJtaXQucHJldmVudD1cImNoZWNrRm9ybVwiPlxuICAgICAgPG1kLWRpYWxvZy1jb250ZW50PlxuICAgICAgICA8cCB2LWlmPVwiZXJyb3JzLmxlbmd0aFwiPlxuICAgICAgICAgIDxiPlBsZWFzZSBjb3JyZWN0IHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6PC9iPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSB2LWZvcj1cImVycm9yIGluIGVycm9yc1wiXG4gICAgICAgICAgICAgICAgOmtleT1cImVycm9yXCI+e3sgZXJyb3IgfX08L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgIDxsYWJlbCBmb3I9XCJ0eXBlXCI+VHlwZTwvbGFiZWw+XG4gICAgICAgICAgPG1kLXNlbGVjdCB2LW1vZGVsPVwidHlwZVwiPlxuICAgICAgICAgICAgPG1kLW9wdGlvbiB2YWx1ZT1cIml0ZW1cIj5pdGVtPC9tZC1vcHRpb24+XG4gICAgICAgICAgICA8bWQtb3B0aW9uIHZhbHVlPVwic3ViaGVhZGVyXCI+c3ViaGVhZGVyPC9tZC1vcHRpb24+XG4gICAgICAgICAgICA8bWQtb3B0aW9uIHZhbHVlPVwiZGl2aWRlclwiPmRpdmlkZXI8L21kLW9wdGlvbj5cbiAgICAgICAgICA8L21kLXNlbGVjdD5cbiAgICAgICAgPC9tZC1maWVsZD5cblxuICAgICAgICA8bWQtZmllbGQ+XG4gICAgICAgICAgPGxhYmVsPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICA8bWQtaW5wdXQgdi1tb2RlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgOnJlcXVpcmVkPVwidHlwZSAhPT0gJ2RpdmlkZXInXCI+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgIDxsYWJlbD5VUkw8L2xhYmVsPlxuICAgICAgICAgIDxtZC1pbnB1dCB2LW1vZGVsPVwidXJsXCI+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgIDwvbWQtZGlhbG9nLWNvbnRlbnQ+XG4gICAgICA8bWQtZGlhbG9nLWFjdGlvbnM+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtYWNjZW50XCJcbiAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiPlxuICAgICAgICAgIENhbmNlbFxuICAgICAgICAgIDxtZC1pY29uPmNhbmNlbDwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgICAgdmFsdWU9XCJTdWJtaXRcIj5cbiAgICAgICAgICBTYXZlXG4gICAgICAgICAgPG1kLWljb24+Y2hlY2s8L21kLWljb24+XG4gICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgPC9tZC1kaWFsb2ctYWN0aW9ucz5cbiAgICA8L2Zvcm0+XG4gIDwvbWQtZGlhbG9nPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJDcmVhdGVDYXRlZ29yeU1vZGFsXCIsXG4gIHByb3BzOiBbXCJvcGVuTW9kYWxBZGRcIiwgXCJ2YWx1ZVwiXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBbXSxcbiAgICAgIHR5cGU6IFwiaXRlbVwiLFxuICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICB1cmw6IFwiXCJcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG9wZW5Nb2RhbDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbk1vZGFsQWRkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJjbG9zZU1vZGFsXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNoZWNrRm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoXG4gICAgICAgICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlID09PSBcImRpdmlkZXJcIikgfHxcbiAgICAgICAgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgPT09IFwic3ViaGVhZGVyXCIgJiYgdGhpcy5sYWJlbCkgfHxcbiAgICAgICAgKHRoaXMudHlwZSAmJiB0aGlzLnR5cGUgPT09IFwiaXRlbVwiICYmIHRoaXMubGFiZWwpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5jaGVjaygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICBpZiAoIXRoaXMudHlwZSkgdGhpcy5lcnJvcnMucHVzaChcIlR5cGUgcmVxdWlyZWQuXCIpO1xuICAgICAgaWYgKCF0aGlzLmxhYmVsKSB0aGlzLmVycm9ycy5wdXNoKFwiTGFiZWwgcmVxdWlyZWQuXCIpO1xuICAgIH0sXG4gICAgaXNMYWJlbFJlcXVpcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiaXRlbVwiO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5sYWJlbCA9IFwiXCI7XG4gICAgICB0aGlzLnVybCA9IFwiXCI7XG4gICAgICB0aGlzLm9wZW5Nb2RhbCA9IGZhbHNlO1xuICAgIH0sXG4gICAgY2hlY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZW1pdChcImlucHV0XCIsIHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBsYWJlbDogdGhpcy5sYWJlbCxcbiAgICAgICAgdGFyZ2V0X3VybDogdGhpcy51cmxcbiAgICAgIH0pO1xuICAgICAgdGhpcy50eXBlID0gXCJpdGVtXCI7XG4gICAgICB0aGlzLmxhYmVsID0gXCJcIjtcbiAgICAgIHRoaXMudXJsID0gXCJcIjtcbiAgICB9XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuLm1kLW1lbnUtY29udGVudCB7XG4gIHotaW5kZXg6IDIwO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPG1kLWRpYWxvZyA6bWQtYWN0aXZlLnN5bmM9XCJvcGVuTW9kYWxcIj5cbiAgICA8bWQtZGlhbG9nLXRpdGxlPkFkZCBDaGlsZHJlbjwvbWQtZGlhbG9nLXRpdGxlPlxuICAgIDxmb3JtIGlkPVwiYXBwXCJcbiAgICAgICAgICBAc3VibWl0LnByZXZlbnQ9XCJjaGVja0Zvcm1cIj5cblxuICAgICAgPG1kLWRpYWxvZy1jb250ZW50PlxuICAgICAgICA8cCB2LWlmPVwiZXJyb3JzLmxlbmd0aFwiPlxuICAgICAgICAgIDxiPlBsZWFzZSBjb3JyZWN0IHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6PC9iPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSB2LWZvcj1cImVycm9yIGluIGVycm9yc1wiXG4gICAgICAgICAgICAgICAgOmtleT1cImVycm9yXCI+e3sgZXJyb3IgfX08L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvcD5cblxuICAgICAgICA8bWQtZmllbGQ+XG4gICAgICAgICAgPGxhYmVsPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICA8bWQtaW5wdXQgdi1tb2RlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgIDxsYWJlbD5VUkw8L2xhYmVsPlxuICAgICAgICAgIDxtZC1pbnB1dCB2LW1vZGVsPVwidXJsXCJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgIDwvbWQtZGlhbG9nLWNvbnRlbnQ+XG4gICAgICA8bWQtZGlhbG9nLWFjdGlvbnM+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtYWNjZW50XCJcbiAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiPlxuICAgICAgICAgIENhbmNlbFxuICAgICAgICAgIDxtZC1pY29uPmNhbmNlbDwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgICAgdmFsdWU9XCJTdWJtaXRcIj5cbiAgICAgICAgICBTYXZlXG4gICAgICAgICAgPG1kLWljb24+Y2hlY2s8L21kLWljb24+XG4gICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgPC9tZC1kaWFsb2ctYWN0aW9ucz5cbiAgICA8L2Zvcm0+XG4gIDwvbWQtZGlhbG9nPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJDcmVhdGVDaGlsZE1vZGFsXCIsXG4gIHByb3BzOiBbXCJvcGVuTW9kYWxBZGRcIiwgXCJ2YWx1ZVwiXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBbXSxcbiAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgdXJsOiBcIlwiXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBvcGVuTW9kYWw6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5Nb2RhbEFkZDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRlbWl0KFwiY2xvc2VNb2RhbFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBjaGVja0Zvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMubGFiZWwgJiYgdGhpcy51cmwpIHtcbiAgICAgICAgdGhpcy5jaGVjaygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICBpZiAoIXRoaXMubGFiZWwpIHRoaXMuZXJyb3JzLnB1c2goXCJMYWJlbCByZXF1aXJlZC5cIik7XG4gICAgICBpZiAoIXRoaXMudXJsKSB0aGlzLmVycm9ycy5wdXNoKFwiVVJMIHJlcXVpcmVkLlwiKTtcbiAgICB9LFxuICAgIG9uQ2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubGFiZWwgPSBcIlwiO1xuICAgICAgdGhpcy51cmwgPSBcIlwiO1xuICAgICAgdGhpcy5vcGVuTW9kYWwgPSBmYWxzZTtcbiAgICB9LFxuICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuJGVtaXQoXCJpbnB1dFwiLCB7IGxhYmVsOiB0aGlzLmxhYmVsLCB0YXJnZXRfdXJsOiB0aGlzLnVybCB9KTtcbiAgICAgIHRoaXMubGFiZWwgPSBcIlwiO1xuICAgICAgdGhpcy51cmwgPSBcIlwiO1xuICAgIH1cbiAgfVxufTtcbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bWQtZGlhbG9nIDptZC1hY3RpdmUuc3luYz1cIm9wZW5Nb2RhbFwiPlxuICAgIDxtZC1kaWFsb2ctdGl0bGU+RWRpdCBDaGlsZDwvbWQtZGlhbG9nLXRpdGxlPlxuICAgIDxmb3JtIGlkPVwiYXBwXCJcbiAgICAgICAgICBAc3VibWl0LnByZXZlbnQ9XCJjaGVja0Zvcm1cIj5cblxuICAgICAgPG1kLWRpYWxvZy1jb250ZW50PlxuICAgICAgICA8cCB2LWlmPVwiZXJyb3JzLmxlbmd0aFwiPlxuICAgICAgICAgIDxiPlBsZWFzZSBjb3JyZWN0IHRoZSBmb2xsb3dpbmcgZXJyb3Iocyk6PC9iPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgIDxsaSB2LWZvcj1cImVycm9yIGluIGVycm9yc1wiXG4gICAgICAgICAgICAgICAgOmtleT1cImVycm9yXCI+e3sgZXJyb3IgfX08L2xpPlxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvcD5cblxuICAgICAgICA8bWQtZmllbGQ+XG4gICAgICAgICAgPGxhYmVsPkxhYmVsPC9sYWJlbD5cbiAgICAgICAgICA8bWQtaW5wdXQgdi1tb2RlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgICAgPG1kLWZpZWxkPlxuICAgICAgICAgIDxsYWJlbD5VUkw8L2xhYmVsPlxuICAgICAgICAgIDxtZC1pbnB1dCB2LW1vZGVsPVwidXJsXCJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ+PC9tZC1pbnB1dD5cbiAgICAgICAgPC9tZC1maWVsZD5cbiAgICAgIDwvbWQtZGlhbG9nLWNvbnRlbnQ+XG4gICAgICA8bWQtZGlhbG9nLWFjdGlvbnM+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtYWNjZW50XCJcbiAgICAgICAgICAgICAgICAgICBAY2xpY2s9XCJvbkNhbmNlbFwiPlxuICAgICAgICAgIENhbmNlbFxuICAgICAgICAgIDxtZC1pY29uPmNhbmNlbDwvbWQtaWNvbj5cbiAgICAgICAgPC9tZC1idXR0b24+XG4gICAgICAgIDxtZC1idXR0b24gY2xhc3M9XCJtZC1yYWlzZWQgbWQtcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgICAgdmFsdWU9XCJTdWJtaXRcIj5cbiAgICAgICAgICBTYXZlXG4gICAgICAgICAgPG1kLWljb24+Y2hlY2s8L21kLWljb24+XG4gICAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgPC9tZC1kaWFsb2ctYWN0aW9ucz5cbiAgICA8L2Zvcm0+XG4gIDwvbWQtZGlhbG9nPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJFZGl0Q2hpbGRNb2RhbFwiLFxuICBwcm9wczogW1wib3Blbk1vZGFsRWRpdFwiLCBcInZhbHVlXCJdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IFtdLFxuICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICB1cmw6IFwiXCJcbiAgICB9O1xuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgb3Blbk1vZGFsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuTW9kYWxFZGl0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoXCJjbG9zZU1vZGFsXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmxhYmVsID0gdGhpcy52YWx1ZS5sYWJlbDtcbiAgICAgIHRoaXMudXJsID0gdGhpcy52YWx1ZS50YXJnZXRfdXJsO1xuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGNoZWNrRm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5sYWJlbCAmJiB0aGlzLnVybCkge1xuICAgICAgICB0aGlzLmNoZWNrKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgIGlmICghdGhpcy5sYWJlbCkgdGhpcy5lcnJvcnMucHVzaChcIkxhYmVsIHJlcXVpcmVkLlwiKTtcbiAgICAgIGlmICghdGhpcy51cmwpIHRoaXMuZXJyb3JzLnB1c2goXCJVUkwgcmVxdWlyZWQuXCIpO1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5vcGVuTW9kYWwgPSBmYWxzZTtcbiAgICB9LFxuICAgIGNoZWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuJGVtaXQoXCJpbnB1dFwiLCB7IGxhYmVsOiB0aGlzLmxhYmVsLCB0YXJnZXRfdXJsOiB0aGlzLnVybCB9KTtcbiAgICB9XG4gIH1cbn07XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBpZD1cImFwcFwiXG4gICAgICAgdi1jbG9haz5cbiAgICA8bWQtYXBwIG1kLXdhdGVyZmFsbFxuICAgICAgICAgICAgbWQtbW9kZT1cImZpeGVkXCI+XG4gICAgICA8bWQtYXBwLXRvb2xiYXIgY2xhc3M9XCJhcHAtaGVhZGVyXCI+XG4gICAgICAgIDxzcGluYWxIZWFkZXIgdi1vbjpvcGVubWVudT1cIm1lbnVWaXNpYmxlID0gIW1lbnVWaXNpYmxlXCIgLz5cbiAgICAgIDwvbWQtYXBwLXRvb2xiYXI+XG5cbiAgICAgIDxtZC1hcHAtZHJhd2VyIGNsYXNzPVwic3BpbmFsTGVmdFNpZGVCYXItY29udGFpbmVyXCJcbiAgICAgICAgICAgICAgICAgICAgIDptZC1hY3RpdmUuc3luYz1cIm1lbnVWaXNpYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgIG1kLXBlcnNpc3RlbnQ9XCJmdWxsXCI+XG4gICAgICAgIDxzcGluYWxMZWZ0U2lkZUJhciB2LW9uOm9wZW5tZW51PVwibWVudVZpc2libGUgPSAhbWVudVZpc2libGVcIiAvPlxuICAgICAgPC9tZC1hcHAtZHJhd2VyPlxuXG4gICAgICA8bWQtYXBwLWNvbnRlbnQ+XG4gICAgICAgIDxyb3V0ZXItdmlldyBjbGFzcz1cInZpZXdcIj48L3JvdXRlci12aWV3PlxuICAgICAgICA8IS0tIDxNYWluQ29udGVudCAvPiAtLT5cbiAgICAgIDwvbWQtYXBwLWNvbnRlbnQ+XG4gICAgPC9tZC1hcHA+XG5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHNwaW5hbEhlYWRlciBmcm9tIFwiLi9oZWFkZXIvU3BpbmFsSGVhZGVyLnZ1ZVwiO1xuaW1wb3J0IHNwaW5hbExlZnRTaWRlQmFyIGZyb20gXCIuL0xlZnRTaWRlQmFyL1NwaW5hbExlZnRTaWRlQmFyLnZ1ZVwiO1xuLy8gaW1wb3J0IFNwaW5hbFJpZ2h0U2lkZUJhciBmcm9tIFwiLi9SaWdodFNpZGVCYXIvU3BpbmFsUmlnaHRTaWRlQmFyLnZ1ZVwiO1xuLy8gaW1wb3J0IE1haW5Db250ZW50IGZyb20gXCIuL01haW5Db250ZW50L01haW5Db250ZW50LnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwiYXBwXCIsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lbnVWaXNpYmxlOiB0cnVlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyBtZW51VmlzaWJsZToge1xuICAgIC8vICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMubWVudVZpc2libGVPYnM7XG4gICAgLy8gICB9LFxuICAgIC8vICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIC8vICAgICBIZWFkZXJDdHJsLnNldFZpZXdNZW51KG5ld1ZhbHVlKTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH0sXG4gIGNyZWF0ZWQoKSB7XG4gICAgLy8gdmFyIHZtID0gdGhpcztcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIHRoaXMuJHN1YnNjcmliZVRvKEhlYWRlckN0cmwuZ2V0T2JzZXJ2YWJsZSgpLCBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyAgIHZtLm1lbnVWaXNpYmxlT2JzID0gdmFsO1xuICAgIC8vIH0pO1xuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBzcGluYWxMZWZ0U2lkZUJhcixcbiAgICBzcGluYWxIZWFkZXJcbiAgICAvLyBTcGluYWxSaWdodFNpZGVCYXIsXG4gICAgLy8gTWFpbkNvbnRlbnRcbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuI2FwcCAubWQtYXBwIHtcbiAgaGVpZ2h0OiAxMDB2aDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi5hcHAtaGVhZGVyIHtcbiAgY29sb3I6IGJsYWNrO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xufVxuLm1kLWFwcC1jb250ZW50IHtcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNjRweCkgIWltcG9ydGFudDtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBwYWRkaW5nOiAwO1xufVxuLnNwaW5hbExlZnRTaWRlQmFyLWNvbnRhaW5lciB7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG48L3N0eWxlPlxuPHN0eWxlPlxuLm1kLWFwcC1jb250YWluZXIge1xuICBvdmVyZmxvdzogaGlkZGVuO1xufVxuPC9zdHlsZT5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cInNwaW5hbExlZnRTaWRlQmFyLWNvbnRhaW5lclwiPlxuICAgIDxtZC10b29sYmFyIGNsYXNzPVwiYXBwLWhlYWRlclwiXG4gICAgICAgICAgICAgICAgbWQtZWxldmF0aW9uPVwiMFwiPlxuICAgICAgPGgzPk5hdmlnYXRpb248L2gzPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWQtdG9vbGJhci1zZWN0aW9uLWVuZCBjb2xvcl9ibGFja1wiPlxuICAgICAgICA8bWQtYnV0dG9uIGNsYXNzPVwibWQtaWNvbi1idXR0b24gbWQtZGVuc2VcIlxuICAgICAgICAgICAgICAgICAgIEBjbGljaz1cInRvZ2dsZU1lbnVcIj5cbiAgICAgICAgICA8bWQtaWNvbj5rZXlib2FyZF9hcnJvd19sZWZ0PC9tZC1pY29uPlxuICAgICAgICA8L21kLWJ1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbWQtdG9vbGJhcj5cbiAgICA8bWQtY29udGVudCBjbGFzcz1cIm1kLXNjcm9sbGJhciBsZWZ0LWJhci1jb250ZW50XCI+XG4gICAgICA8c3BpbmFsQ2F0ZWdvcnlDb250YWluZXI+PC9zcGluYWxDYXRlZ29yeUNvbnRhaW5lcj5cblxuICAgIDwvbWQtY29udGVudD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuLy8gaW1wb3J0IFZ1ZSBmcm9tIFwidnVlXCI7XG5pbXBvcnQgc3BpbmFsQ2F0ZWdvcnlDb250YWluZXIgZnJvbSBcIi4vc3BpbmFsLWNhdGVnb3J5LWNvbnRhaW5lci52dWVcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJTcGluYWxMZWZ0U2lkZUJhclwiLFxuICBjb21wb25lbnRzOiB7XG4gICAgc3BpbmFsQ2F0ZWdvcnlDb250YWluZXJcbiAgfSxcblxuICBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgY3JlYXRlZCgpIHt9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlTWVudTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbWl0KFwib3Blbm1lbnVcIik7XG4gICAgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG4uc3BpbmFsTGVmdFNpZGVCYXItY29udGFpbmVyIHtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cbi5sZWZ0LWJhci1jb250ZW50IHtcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNjRweCkgIWltcG9ydGFudDtcbiAgb3ZlcmZsb3c6IGF1dG87XG59XG4ubWQtaWNvbiB7XG4gIGNvbG9yOiBibGFjaztcbn1cbi5hcHAtaGVhZGVyIHtcbiAgY29sb3I6IGJsYWNrO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xufVxuLmNvbG9yX2JsYWNrIC5tZC1idXR0b24sXG4uY29sb3JfYmxhY2sgLm1kLWljb24sXG4uY29sb3JfYmxhY2sgZGl2IHtcbiAgY29sb3I6IGJsYWNrICFpbXBvcnRhbnQ7XG59XG48L3N0eWxlPlxuIiwiPHRlbXBsYXRlPlxuICA8bWQtbGlzdCBpZD1cInNpZGUtYmFyLWxpc3RcIj5cbiAgICA8c3BpbmFsQ2F0ZWdvcnkgdi1mb3I9XCJpdGVtIGluIGxpc3RcIlxuICAgICAgICAgICAgICAgICAgICA6a2V5PVwiaXRlbS5sYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIDppdGVtPWl0ZW0+PC9zcGluYWxDYXRlZ29yeT5cblxuICA8L21kLWxpc3Q+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgc3BpbmFsQ2F0ZWdvcnkgZnJvbSBcIi4vc3BpbmFsLWNhdGVnb3J5LnZ1ZVwiO1xuaW1wb3J0IHsgRXZlbnRCdXMgfSBmcm9tIFwiLi4vZXZlbnQtYnVzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJzcGluYWxDYXRlZ29yeUNvbnRhaW5lclwiLFxuICBjb21wb25lbnRzOiB7IHNwaW5hbENhdGVnb3J5IH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpc3Q6IFtdXG4gICAgfTtcbiAgfSxcbiAgbWV0aG9kczoge30sXG4gIG1vdW50ZWQoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBFdmVudEJ1cy4kb24oXCJVUERBVEUtTU9ERUxcIiwgbW9kZWwgPT4ge1xuICAgICAgdm0ubGlzdCA9IG1vZGVsLmdldCgpO1xuICAgIH0pO1xuICAgIHdpbmRvdy5zcGluYWwuc3BpbmFsU3lzdGVtLmdldE1vZGVsKCkudGhlbihtb2RlbCA9PiB7XG4gICAgICBFdmVudEJ1cy4kZW1pdChcIlVQREFURS1NT0RFTFwiLCBtb2RlbCk7XG4gICAgfSk7XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuI3NpZGUtYmFyLWxpc3Qge1xuICBwYWRkaW5nLXRvcDogMDtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPG1kLWxpc3QtaXRlbSB2LWlmPVwidGhpcy5pdGVtLmNoaWxkcmVuICYmIHRoaXMuaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwibWQtZWxldmF0aW9uLTBcIlxuICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnbGVmdC1zZWxlY3RlZCc6IGJ0b2EoaXRlbS50YXJnZXRfdXJsKSA9PSAkcm91dGUucGFyYW1zLmlkIH1cIlxuICAgICAgICAgICAgICAgICAgbWQtZXhwYW5kPlxuICAgICAgPHJvdXRlci1saW5rIDp0bz1cImJ0b2EoaXRlbS50YXJnZXRfdXJsKVwiXG4gICAgICAgICAgICAgICAgICAgY2xhc3M9XCJtZC1saXN0LWl0ZW0tdGV4dFwiPlxuICAgICAgICA8c3Bhbj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cbiAgICAgIDwvcm91dGVyLWxpbms+XG5cbiAgICAgIDxtZC1saXN0IGNsYXNzPVwibWQtbGlzdC1uby1wYWRkaW5nXCJcbiAgICAgICAgICAgICAgIHNsb3Q9XCJtZC1leHBhbmRcIj5cbiAgICAgICAgPG1kLWxpc3QtaXRlbSB2LWZvcj1cIml0IGluIGl0ZW0uY2hpbGRyZW5cIlxuICAgICAgICAgICAgICAgICAgICAgIHYtYmluZDprZXk9XCJpdC5sYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwieyAnbGVmdC1zZWxlY3RlZCc6IGJ0b2EoaXQudGFyZ2V0X3VybCkgPT0gJHJvdXRlLnBhcmFtcy5pZCB9XCJcbiAgICAgICAgICAgICAgICAgICAgICA6dG89XCJidG9hKGl0LnRhcmdldF91cmwpXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm1kLWluc2V0IG1kLWVsZXZhdGlvbi0wXCI+XG4gICAgICAgICAge3tpdC5sYWJlbH19XG4gICAgICAgIDwvbWQtbGlzdC1pdGVtPlxuICAgICAgPC9tZC1saXN0PlxuICAgIDwvbWQtbGlzdC1pdGVtPlxuICAgIDxtZC1saXN0LWl0ZW0gdi1lbHNlXG4gICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7ICdsZWZ0LXNlbGVjdGVkJzogYnRvYShpdGVtLnRhcmdldF91cmwpID09ICRyb3V0ZS5wYXJhbXMuaWQgfVwiXG4gICAgICAgICAgICAgICAgICA6dG89XCJidG9hKGl0ZW0udGFyZ2V0X3VybClcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWQtbGlzdC1pdGVtLXRleHRcIj57e2l0ZW0ubGFiZWx9fTwvc3Bhbj5cbiAgICA8L21kLWxpc3QtaXRlbT5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogXCJzcGluYWxDYXRlZ29yeUV4cGFuZFwiLFxuICBwcm9wczogW1wiaXRlbVwiXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge307XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBidG9hOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBidG9hKHN0cik7XG4gICAgfVxuICB9XG59O1xuPC9zY3JpcHQ+XG5cblxuPHN0eWxlPlxuLm1kLWxpc3QtaXRlbS10ZXh0IHtcbiAgY29sb3I6IGluaGVyaXQgIWltcG9ydGFudDtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lICFpbXBvcnRhbnQ7XG59XG4ubWQtbGlzdC1uby1wYWRkaW5nIHtcbiAgcGFkZGluZzogMDtcbn1cbi5sZWZ0LXNlbGVjdGVkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzRkN2RiMztcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lICFpbXBvcnRhbnQ7XG59XG4ubGVmdC1zZWxlY3RlZCA+IGEgPiBkaXYge1xuICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcbn1cbjwvc3R5bGU+XG4iLCI8dGVtcGxhdGU+XG4gIDxtZC1zdWJoZWFkZXI+XG4gICAge3tpdGVtLmxhYmVsLnRvVXBwZXJDYXNlKCl9fVxuICA8L21kLXN1YmhlYWRlcj5cblxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcInNwaW5hbENhdGVnb3J5U3ViSGVhZGVyXCIsXG4gIHByb3BzOiBbXCJpdGVtXCJdLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgbWV0aG9kczoge31cbn07XG48L3NjcmlwdD4+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHNwaW5hbENhdGVnb3J5SXRlbSB2LWlmPVwiaXRlbS50eXBlID09ICdpdGVtJ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6aXRlbT1pdGVtPjwvc3BpbmFsQ2F0ZWdvcnlJdGVtPlxuICAgIDxzcGluYWxDYXRlZ29yeVN1YkhlYWRlciB2LWlmPVwiaXRlbS50eXBlID09ICdzdWJoZWFkZXInXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOml0ZW09aXRlbT48L3NwaW5hbENhdGVnb3J5U3ViSGVhZGVyPlxuICAgIDxtZC1kaXZpZGVyIGNsYXNzPVwibWQtaW5zZXRcIlxuICAgICAgICAgICAgICAgIHYtaWY9XCJpdGVtLnR5cGUgPT0gJ2RpdmlkZXInXCI+PC9tZC1kaXZpZGVyPlxuXG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuXG48c2NyaXB0PlxuaW1wb3J0IHNwaW5hbENhdGVnb3J5U3ViSGVhZGVyIGZyb20gXCIuL3NwaW5hbC1jYXRlZ29yeS10eXBlL3NwaW5hbC1jYXRlZ29yeS1zdWJoZWFkZXIudnVlXCI7XG5pbXBvcnQgc3BpbmFsQ2F0ZWdvcnlJdGVtIGZyb20gXCIuL3NwaW5hbC1jYXRlZ29yeS10eXBlL3NwaW5hbC1jYXRlZ29yeS1pdGVtLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwic3BpbmFsQ2F0ZWdvcnlDb250YWluZXJcIixcbiAgcHJvcHM6IFtcIml0ZW1cIl0sXG4gIGNvbXBvbmVudHM6IHsgc3BpbmFsQ2F0ZWdvcnlTdWJIZWFkZXIsIHNwaW5hbENhdGVnb3J5SXRlbSB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7fTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHRlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5sb2coXCJjbGljayB0ZXN0XCIpO1xuICAgIH1cbiAgfVxufTtcbjwvc2NyaXB0Pj5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGlmcmFtZSBpZD1cIm1haW4tY29udGVudC1pZnJhbWVcIlxuICAgICAgICAgIDpzcmM9XCJ0YXJnZXRfdXJsXCI+XG5cbiAgPC9pZnJhbWU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiBcImFwcFwiLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXRfdXJsOiBcIlwiXG4gICAgfTtcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAkcm91dGUoKSB7XG4gICAgICBpZiAodGhpcy4kcm91dGUucGFyYW1zLmlkKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0X3VybCA9IGF0b2IodGhpcy4kcm91dGUucGFyYW1zLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuJHJvdXRlLnBhcmFtcy5pZCkge1xuICAgICAgdGhpcy50YXJnZXRfdXJsID0gYXRvYih0aGlzLiRyb3V0ZS5wYXJhbXMuaWQpO1xuICAgIH1cbiAgfVxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4jbWFpbi1jb250ZW50LWlmcmFtZSB7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xufVxuPC9zdHlsZT5cbiIsImltcG9ydCB7fSBmcm9tIFwic3BpbmFsLWNvcmUtY29ubmVjdG9yanNcIjtcbmltcG9ydCAqIGFzIFEgZnJvbSBcInFcIjtcblxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUsIHVybCkge1xuICBpZiAoIXVybCkgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tbXFxdXS9nLCBcIlxcXFwkJlwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIls/Jl1cIiArIG5hbWUgKyBcIig9KFteJiNdKil8JnwjfCQpXCIpLFxuICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XG4gIGlmICghcmVzdWx0c1syXSkgcmV0dXJuIFwiXCI7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1syXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn1cblxuY2xhc3MgU3BpbmFsU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy51c2VyID0ge1xuICAgICAgdXNlcm5hbWU6IFwiYWRtaW5cIixcbiAgICAgIHBhc3N3b3JkOiBcIkpIR2djejQ1SktpbG16a256ZWxmNjVkZERhZGdnZnRJTzk4UFwiXG4gICAgfTtcbiAgICB0aGlzLnByb21pc2VNb2RlbCA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlaW5pdCA9IG51bGw7XG4gICAgdGhpcy5tb2RlbHNEaWN0aW9uYXJ5ID0ge307XG4gICAgdGhpcy5tb2RlbHNQYXRoRGljdGlvbmFyeSA9IHt9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlaW5pdCkgcmV0dXJuIHRoaXMucHJvbWlzZWluaXQucHJvbWlzZTtcbiAgICB0aGlzLnByb21pc2Vpbml0ID0gUS5kZWZlcigpO1xuICAgIHRoaXMuZ2V0VXNlcigpO1xuICAgIGlmICh0aGlzLnVzZXIudXNlcm5hbWUpIHtcbiAgICAgIHdpbmRvdy5TcGluYWxVc2VyTWFuYWdlci5nZXRfdXNlcl9pZChcbiAgICAgICAgXCJodHRwOi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCxcbiAgICAgICAgdGhpcy51c2VyLnVzZXJuYW1lLFxuICAgICAgICB0aGlzLnVzZXIucGFzc3dvcmQsXG4gICAgICAgIHJlc3BvbnNlID0+IHtcbiAgICAgICAgICBsZXQgaWQgPSBwYXJzZUludChyZXNwb25zZSk7XG4gICAgICAgICAgdGhpcy5jb25uID0gd2luZG93LnNwaW5hbENvcmUuY29ubmVjdChcbiAgICAgICAgICAgIGBodHRwOi8vJHtpZH06JHt0aGlzLnVzZXIucGFzc3dvcmR9QCR7d2luZG93LmxvY2F0aW9uLmhvc3R9L2BcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMucHJvbWlzZWluaXQucmVzb2x2ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9taXNlaW5pdC5yZWplY3QoKTtcbiAgICAgICAgICB0aGlzLnByb21pc2Vpbml0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9taXNlaW5pdC5yZWplY3QoKTtcbiAgICAgIHRoaXMucHJvbWlzZWluaXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9taXNlaW5pdC5wcm9taXNlO1xuICB9XG5cbiAgZ2V0UGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IGdldFBhcmFtZXRlckJ5TmFtZShcInBhdGhcIik7XG4gICAgaWYgKHBhdGgpIHJldHVybiBhdG9iKHBhdGgpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLnVzZXI7XG4gIH1cblxuICBnZXRNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlTW9kZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb21pc2VNb2RlbC5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2VNb2RlbCA9IFEuZGVmZXIoKTtcbiAgICB0aGlzLmluaXQoKS50aGVuKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RvYy9kb2NfZmlsZVwiO1xuICAgICAgICB3aW5kb3cuc3BpbmFsQ29yZS5sb2FkKFxuICAgICAgICAgIHRoaXMuY29ubixcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGRvY0ZpbGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGRvY0ZpbGU7XG4gICAgICAgICAgICB0aGlzLnByb21pc2VNb2RlbC5yZXNvbHZlKHRoaXMubW9kZWwpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IG5ldyB3aW5kb3cuTHN0KCk7XG4gICAgICAgICAgICB3aW5kb3cuc3BpbmFsQ29yZS5zdG9yZShcbiAgICAgICAgICAgICAgdGhpcy5jb25uLFxuICAgICAgICAgICAgICB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlTW9kZWwucmVzb2x2ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJJbXBvc2libGUgdG8gc3RvcmUgdGhlIGZpbGUsIGNoZWNrIHRoZSBjb25uZXRpb24gdG8gdGhlIGh1YlwiXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VNb2RlbC5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VNb2RlbCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5wcm9taXNlTW9kZWwucmVqZWN0KCk7XG4gICAgICAgIHRoaXMucHJvbWlzZU1vZGVsID0gbnVsbDtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLnByb21pc2VNb2RlbC5wcm9taXNlO1xuICB9XG5cbiAgX3dhaXRNb2RlbFJkeVJlYyhtb2RlbCwgcHJvbWlzZSkge1xuICAgIGlmICghbW9kZWwuX3NlcnZlcl9pZCB8fCB3aW5kb3cuRmlsZVN5c3RlbS5fdG1wX29iamVjdHNbbW9kZWwuX3NlcnZlcl9pZF0pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl93YWl0TW9kZWxSZHlSZWMobW9kZWwsIHByb21pc2UpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9IGVsc2UgcHJvbWlzZS5yZXNvbHZlKG1vZGVsKTtcbiAgfVxuICB3YWl0TW9kZWxSZHkobW9kZWwpIHtcbiAgICBsZXQgZGVmZXIgPSBRLmRlZmVyKCk7XG4gICAgdGhpcy5fd2FpdE1vZGVsUmR5UmVjKG1vZGVsLCBkZWZlcik7XG5cbiAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgfVxuICBsb2FkTW9kZWxQdHIobW9kZWwpIHtcbiAgICBpZiAodGhpcy5tb2RlbHNEaWN0aW9uYXJ5W21vZGVsLl9zZXJ2ZXJfaWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNEaWN0aW9uYXJ5W21vZGVsLl9zZXJ2ZXJfaWRdLnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMubW9kZWxzRGljdGlvbmFyeVttb2RlbC5fc2VydmVyX2lkXSA9IFEuZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgbW9kZWwubG9hZChtID0+IHtcbiAgICAgICAgdGhpcy5tb2RlbHNEaWN0aW9uYXJ5W21vZGVsLl9zZXJ2ZXJfaWRdLnJlc29sdmUobSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGV0IHByb21pc2UgPSB0aGlzLm1vZGVsc0RpY3Rpb25hcnlbbW9kZWwuX3NlcnZlcl9pZF07XG4gICAgICB0aGlzLm1vZGVsc0RpY3Rpb25hcnlbbW9kZWwuX3NlcnZlcl9pZF0gPSB1bmRlZmluZWQ7XG4gICAgICBwcm9taXNlLnJlamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb2RlbHNEaWN0aW9uYXJ5W21vZGVsLl9zZXJ2ZXJfaWRdLnByb21pc2U7XG4gIH1cbiAgc2lnbk91dCgpIHtcbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzcGluYWxob21lX2NmZ1wiLCBcIlwiKTtcbiAgfVxuICBsb2FkKHBhdGgpIHtcbiAgICBpZiAodGhpcy5tb2RlbHNQYXRoRGljdGlvbmFyeVtwYXRoXSkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzUGF0aERpY3Rpb25hcnlbcGF0aF0ucHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5tb2RlbHNQYXRoRGljdGlvbmFyeVtwYXRoXSA9IFEuZGVmZXIoKTtcblxuICAgIHdpbmRvdy5zcGluYWxDb3JlLmxvYWQoXG4gICAgICB0aGlzLmNvbm4sXG4gICAgICBwYXRoLFxuICAgICAgbSA9PiB7XG4gICAgICAgIHRoaXMubW9kZWxzUGF0aERpY3Rpb25hcnlbcGF0aF0ucmVzb2x2ZShtKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBtb2RlbCBpbiA6IFwiICsgcGF0aCk7XG4gICAgICAgIGxldCBwcm9taXNlID0gdGhpcy5tb2RlbHNQYXRoRGljdGlvbmFyeVtwYXRoXTtcbiAgICAgICAgdGhpcy5tb2RlbHNQYXRoRGljdGlvbmFyeVtwYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMubW9kZWxzUGF0aERpY3Rpb25hcnlbcGF0aF0ucHJvbWlzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTcGluYWxTeXN0ZW07XG4iLCJpbXBvcnQgU3BpbmFsU3lzdGVtIGZyb20gXCIuL1NwaW5hbFN5c3RlbVwiO1xuXG53aW5kb3cuc3BpbmFsID0ge307XG5cbndpbmRvdy5zcGluYWwuc3BpbmFsU3lzdGVtID0gbmV3IFNwaW5hbFN5c3RlbSgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluc3RhbGwoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS4kc3BpbmFsU3lzdGVtID0gd2luZG93LnNwaW5hbC5zcGluYWxTeXN0ZW07XG4gIH0sXG4gIHNwaW5hbFN5c3RlbTogd2luZG93LnNwaW5hbC5zcGluYWxTeXN0ZW1cbn07XG4iLCIiLCJpbXBvcnQgVnVlIGZyb20gXCJ2dWVcIjtcbmV4cG9ydCBjb25zdCBFdmVudEJ1cyA9IG5ldyBWdWUoKTtcbiIsIiA8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZC10b29sYmFyLXJvd1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kLXRvb2xiYXItc2VjdGlvbi1zdGFydFwiPlxuICAgICAgPG1kLWJ1dHRvbiBjbGFzcz1cIm1kLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgQGNsaWNrPVwidG9nZ2xlTWVudVwiXG4gICAgICAgICAgICAgICAgIHYtaWY9XCIhbWVudVZpc2libGVcIj5cbiAgICAgICAgPG1kLWljb24+bWVudTwvbWQtaWNvbj5cbiAgICAgIDwvbWQtYnV0dG9uPlxuICAgICAgPGltZyBzcmM9XCJkaXN0L2Fzc2V0cy9pbWcvU3BpbmFsQklNVmlld2VyTG9nby5wbmdcIlxuICAgICAgICAgICBhbHQ9XCJTcGluYWxCSU0gVmlld2VyXCJcbiAgICAgICAgICAgc3R5bGU9XCJoZWlnaHQ6IDQycHg7bWFyZ2luLXRvcDogNHB4O1wiPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZC10b29sYmFyLXNlY3Rpb24tZW5kXCI+XG4gICAgICA8IS0tIHt7dXNlcm5hbWV9fVxuICAgICAgPG1kLWJ1dHRvbiBjbGFzcz1cIm1kLWljb24tYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgdi1vbjpjbGljaz1cInRvZ2dsZU1lbnVcIj5cbiAgICAgICAgPG1kLWljb24+bWVudTwvbWQtaWNvbj5cbiAgICAgIDwvbWQtYnV0dG9uPiAtLT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHNwaW5hbCBmcm9tIFwiLi4vU3BpbmFsU3lzdGVtL3NwaW5hbFwiO1xuLy8gaW1wb3J0IEhlYWRlckN0cmwgZnJvbSBcIi4uL2hlYWRlci9IZWFkZXJDdHJsLnZ1ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6IFwic3BpbmFsSGVhZGVyXCIsXG4gIGRhdGEoKSB7XG4gICAgLy8gdmFyIHZtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgZnVsbFBhdGg6IFwiXCIsXG4gICAgICBwYXRoOiBcIlwiLFxuICAgICAgdXNlcm5hbWU6IFwiXCJcbiAgICB9O1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdG9nZ2xlTWVudTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbWl0KFwib3Blbm1lbnVcIik7XG5cbiAgICAgIC8vIEhlYWRlckN0cmwudG9nZ2xlTWVudSgpO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlZCgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIHZtLnVzZXJuYW1lID0gc3BpbmFsLnNwaW5hbFN5c3RlbS5nZXRVc2VyKCkudXNlcm5hbWU7XG4gICAgLy8gdm0uZnVsbFBhdGggPSBzcGluYWwuc3BpbmFsU3lzdGVtLmdldFBhdGgoKTtcbiAgICAvLyBsZXQgcGF0aCA9IHZtLmZ1bGxQYXRoLnNwbGl0KFwiL1wiKTtcblxuICAgIC8vIHZtLnBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIH1cbn07XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cbi5tZC1idXR0b24sXG4ubWQtaWNvbixcbmRpdiB7XG4gIGNvbG9yOiBibGFjayAhaW1wb3J0YW50O1xufVxuPC9zdHlsZT5cbiIsImltcG9ydCBWdWUgZnJvbSBcInZ1ZVwiO1xuaW1wb3J0IEFwcCBmcm9tIFwiLi9BcHAudnVlXCI7XG5pbXBvcnQgVnVlTWF0ZXJpYWwgZnJvbSBcInZ1ZS1tYXRlcmlhbFwiO1xuaW1wb3J0IHNwaW5hbCBmcm9tIFwiLi9TcGluYWxTeXN0ZW0vc3BpbmFsXCI7XG5pbXBvcnQgVnVlUm91dGVyIGZyb20gXCJ2dWUtcm91dGVyXCI7XG5pbXBvcnQgTWFpbkNvbnRlbnQgZnJvbSBcIi4vTWFpbkNvbnRlbnQvTWFpbkNvbnRlbnQudnVlXCI7XG5pbXBvcnQgQWRtaW5Db250ZW50IGZyb20gXCIuL0FkbWluQ29udGVudC9BZG1pbkNvbnRlbnQudnVlXCI7XG5WdWUudXNlKFZ1ZVJvdXRlcik7XG5cbmNvbnN0IHJvdXRlciA9IG5ldyBWdWVSb3V0ZXIoe1xuICByb3V0ZXM6IFtcbiAgICB7XG4gICAgICBwYXRoOiBcIi9wYWdlLzppZFwiLFxuICAgICAgY29tcG9uZW50OiBNYWluQ29udGVudFxuICAgIH0sXG4gICAge1xuICAgICAgcGF0aDogXCIvYWRtaW5cIixcbiAgICAgIGNvbXBvbmVudDogQWRtaW5Db250ZW50XG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiBcIi9hZG1pbi86aWRcIixcbiAgICAgIGNvbXBvbmVudDogQWRtaW5Db250ZW50XG4gICAgfSxcblxuICAgIHtcbiAgICAgIHBhdGg6IFwiKlwiLFxuICAgICAgcmVkaXJlY3Q6IFwiL3BhZ2UvNDA0XCJcbiAgICB9XG4gIF1cbn0pO1xuXG5WdWUudXNlKHNwaW5hbCk7XG5cbmltcG9ydCBcIi4vYXBwLmNzc1wiO1xuXG5WdWUudXNlKFZ1ZU1hdGVyaWFsKTtcbndpbmRvdy5zcGluYWxBcHAgPSBuZXcgVnVlKHtcbiAgcm91dGVyLFxuICBlbDogXCIjYXBwXCIsXG4gIHJlbmRlcjogaCA9PiBoKEFwcClcbn0pO1xuIiwiLyohLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogbW9uYWNvLWpzb24gdmVyc2lvbjogMi4xLjEoMGU2ZWE5NWY0ZjRlMDkzZGI5MjAxYzUwMmU4ZDQwMTM5MTgwMzIzMylcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9tb25hY28tanNvbi9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmRlZmluZShcInZzL2xhbmd1YWdlL2pzb24vbW9uYWNvLmNvbnRyaWJ1dGlvblwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIl0sZnVuY3Rpb24odCxlKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1tb25hY28uRW1pdHRlcixuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLG4pe3RoaXMuX29uRGlkQ2hhbmdlPW5ldyBvLHRoaXMuX2xhbmd1YWdlSWQ9ZSx0aGlzLnNldERpYWdub3N0aWNzT3B0aW9ucyhuKX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwib25EaWRDaGFuZ2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50fSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImxhbmd1YWdlSWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2xhbmd1YWdlSWR9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiZGlhZ25vc3RpY3NPcHRpb25zXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kaWFnbm9zdGljc09wdGlvbnN9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZS5wcm90b3R5cGUuc2V0RGlhZ25vc3RpY3NPcHRpb25zPWZ1bmN0aW9uKGUpe3RoaXMuX2RpYWdub3N0aWNzT3B0aW9ucz1lfHxPYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUodGhpcyl9LGV9KCksaT1uZXcoZS5MYW5ndWFnZVNlcnZpY2VEZWZhdWx0c0ltcGw9bikoXCJqc29uXCIse3ZhbGlkYXRlOiEwLGFsbG93Q29tbWVudHM6ITAsc2NoZW1hczpbXX0pO21vbmFjby5sYW5ndWFnZXMuanNvbj17anNvbkRlZmF1bHRzOml9LG1vbmFjby5sYW5ndWFnZXMucmVnaXN0ZXIoe2lkOlwianNvblwiLGV4dGVuc2lvbnM6W1wiLmpzb25cIixcIi5ib3dlcnJjXCIsXCIuanNoaW50cmNcIixcIi5qc2NzcmNcIixcIi5lc2xpbnRyY1wiLFwiLmJhYmVscmNcIl0sYWxpYXNlczpbXCJKU09OXCIsXCJqc29uXCJdLG1pbWV0eXBlczpbXCJhcHBsaWNhdGlvbi9qc29uXCJdfSksbW9uYWNvLmxhbmd1YWdlcy5vbkxhbmd1YWdlKFwianNvblwiLGZ1bmN0aW9uKCl7bW9uYWNvLlByb21pc2Uud3JhcChuZXcgUHJvbWlzZShmdW5jdGlvbihlLG4pe3QoW1wiLi9qc29uTW9kZVwiXSxlLG4pfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuc2V0dXBNb2RlKGkpfSl9KX0pOyJdfQ==
